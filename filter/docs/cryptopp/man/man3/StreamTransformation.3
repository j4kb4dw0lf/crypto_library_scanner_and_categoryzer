.TH "StreamTransformation" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StreamTransformation \- Interface for the data processing portion of stream ciphers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <cryptlib\&.h>\fP
.PP
Inherits \fBAlgorithm\fP\&.
.PP
Inherited by \fBAuthenticatedSymmetricCipher\fP, \fBPublicBlumBlumShub\fP, and \fBSymmetricCipher\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBStreamTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual unsigned int \fBMandatoryBlockSize\fP () const"
.br
.RI "Provides the mandatory block size of the cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBGetOptimalBlockSizeUsed\fP () const"
.br
.RI "Provides the number of bytes used in the current block when processing at optimal block size\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual void \fBProcessData\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)=0"
.br
.RI "Encrypt or decrypt an array of bytes\&. "
.ti -1c
.RI "virtual size_t \fBProcessLastBlock\fP (\fBbyte\fP *outString, size_t outLength, const \fBbyte\fP *inString, size_t inLength)"
.br
.RI "Encrypt or decrypt the last block of data\&. "
.ti -1c
.RI "virtual unsigned int \fBMinLastBlockSize\fP () const"
.br
.RI "Provides the size of the last block\&. "
.ti -1c
.RI "virtual bool \fBIsLastBlockSpecial\fP () const"
.br
.RI "Determines if the last block receives special processing\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *inoutString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "\fBbyte\fP \fBProcessByte\fP (\fBbyte\fP input)"
.br
.RI "Encrypt or decrypt a byte\&. "
.ti -1c
.RI "virtual bool \fBIsRandomAccess\fP () const =0"
.br
.RI "Determines whether the cipher supports random access\&. "
.ti -1c
.RI "virtual void \fBSeek\fP (\fBlword\fP pos)"
.br
.RI "Seek to an absolute position\&. "
.ti -1c
.RI "virtual bool \fBIsSelfInverting\fP () const =0"
.br
.RI "Determines whether the cipher is self-inverting\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SH "Detailed Description"
.PP 
Interface for the data processing portion of stream ciphers\&. 


.PP
\fBSee also\fP
.RS 4
\fBStreamTransformationFilter()\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "virtual unsigned int StreamTransformation::GetOptimalBlockSizeUsed () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the number of bytes used in the current block when processing at optimal block size\&. 
.PP
\fBReturns\fP
.RS 4
the number of bytes used in the current block when processing at the optimal block size 
.RE
.PP

.SS "virtual bool StreamTransformation::IsForwardTransformation () const\fR [pure virtual]\fP"

.PP
Determines if the cipher is being operated in its forward direction\&. 
.PP
\fBReturns\fP
.RS 4
true if DIR is ENCRYPTION, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBIsForwardTransformation()\fP, IsPermutation(), GetCipherDirection() 
.RE
.PP

.PP
Implemented in \fBBlockOrientedCipherModeBase\fP, \fBCCM_Final< T_BlockCipher, T_DefaultDigestSize, T_IsEncryption >\fP, \fBCCM_Final< T_BlockCipher, T_DefaultDigestSize, false >\fP, \fBCCM_Final< T_BlockCipher, T_DefaultDigestSize, true >\fP, \fBChaCha20Poly1305_Final< T_IsEncryption >\fP, \fBChaCha20Poly1305_Final< false >\fP, \fBChaCha20Poly1305_Final< true >\fP, \fBEAX_Final< T_BlockCipher, T_IsEncryption >\fP, \fBEAX_Final< T_BlockCipher, false >\fP, \fBEAX_Final< T_BlockCipher, true >\fP, \fBGCM_Final< T_BlockCipher, T_TablesOption, T_IsEncryption >\fP, \fBGCM_Final< T_BlockCipher, T_TablesOption, false >\fP, \fBGCM_Final< T_BlockCipher, T_TablesOption, true >\fP, \fBPublicBlumBlumShub\fP, \fBWeak1::ARC4_Base\fP, \fBXChaCha20Poly1305_Final< T_IsEncryption >\fP, \fBXChaCha20Poly1305_Final< false >\fP, and \fBXChaCha20Poly1305_Final< true >\fP\&.
.SS "virtual bool StreamTransformation::IsLastBlockSpecial () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines if the last block receives special processing\&. 
.PP
\fBReturns\fP
.RS 4
true if the last block receives special processing, false otherwise\&.
.RE
.PP
Some authenticated encryption modes are not expressed well with \fBMandatoryBlockSize()\fP and \fBMinLastBlockSize()\fP\&. For example, AES/OCB uses 16-byte blocks (MandatoryBlockSize = 16) and the last block requires special processing (MinLastBlockSize = 0)\&. However, 0 is a valid last block size for OCB and the special processing is custom padding, and not standard PKCS padding\&. In response an unambiguous \fBIsLastBlockSpecial()\fP was added\&.

.PP
When \fBIsLastBlockSpecial()\fP returns false nothing special happens\&. All the former rules and behaviors apply\&. This is the default behavior of \fBIsLastBlockSpecial()\fP\&.

.PP
When \fBIsLastBlockSpecial()\fP returns true four things happen\&. First, MinLastBlockSize = 0 means 0 is a valid block size that should be processed\&. Second, standard block cipher padding is \fInot\fP \fIapplied\fP\&. Third, the caller supplies an outString is larger than inString by \fR2*MandatoryBlockSize()\fP\&. That is, there's a reserve available when processing the last block\&. Fourth, the cipher is responsible for finalization like custom padding\&. The cipher will tell the library how many bytes were processed or used by returning the appropriate value from \fBProcessLastBlock()\fP\&.

.PP
The return value of \fBProcessLastBlock()\fP indicates how many bytes were written to \fRoutString\fP\&. A filter pipelining data will send \fRoutString\fP and up to \fRoutLength\fP to an \fRAttachedTransformation()\fP for additional processing\&. Below is an example of the code used in \fR\fBStreamTransformationFilter::LastPut\fP\fP\&. 
.PP
.nf
  if (m_cipher\&.IsLastBlockSpecial())
  {
    size_t reserve = 2*m_cipher\&.\fBMandatoryBlockSize()\fP;
    space = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, length+reserve);
    length = m_cipher\&.ProcessLastBlock(space, length+reserve, inString, length);
    AttachedTransformation()->Put(space, length);
    return;
  }
.fi
.PP
 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 6\&.0 
.RE
.PP

.SS "virtual bool StreamTransformation::IsRandomAccess () const\fR [pure virtual]\fP"

.PP
Determines whether the cipher supports random access\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher supports random access, false otherwise 
.RE
.PP

.PP
Implemented in \fBAuthenticatedSymmetricCipherBase\fP, \fBBlockOrientedCipherModeBase\fP, \fBBlumBlumShub\fP, \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP, and \fBWeak1::ARC4_Base\fP\&.
.SS "virtual bool StreamTransformation::IsSelfInverting () const\fR [pure virtual]\fP"

.PP
Determines whether the cipher is self-inverting\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher is self-inverting, false otherwise
.RE
.PP
IsSelfInverting determines whether this transformation is self-inverting (e\&.g\&. xor with a keystream)\&. 
.PP
Implemented in \fBAuthenticatedSymmetricCipherBase\fP, \fBBlockOrientedCipherModeBase\fP, \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP, \fBPublicBlumBlumShub\fP, and \fBWeak1::ARC4_Base\fP\&.
.SS "virtual unsigned int StreamTransformation::MandatoryBlockSize () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the mandatory block size of the cipher\&. 
.PP
\fBReturns\fP
.RS 4
The block size of the cipher if input must be processed in blocks, 1 otherwise
.RE
.PP
Stream ciphers and some block ciphers modes of operation return 1\&. Modes that return 1 must be able to process a single byte at a time, like counter mode\&. If a mode of operation or block cipher cannot stream then it must not return 1\&.

.PP
When filters operate the mode or cipher, ProcessData will be called with a string of bytes that is determined by MandatoryBlockSize and OptimalBlockSize\&. When a policy is set, like 16-byte strings for a 16-byte block cipher, the filter will buffer bytes until the specified number of bytes is available to the object\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Reimplemented in \fBBlockOrientedCipherModeBase\fP\&.
.SS "virtual unsigned int StreamTransformation::MinLastBlockSize () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the size of the last block\&. 
.PP
\fBReturns\fP
.RS 4
the minimum size of the last block
.RE
.PP
\fBMinLastBlockSize()\fP returns the minimum size of the last block\&. 0 indicates the last block is not special\&.

.PP
\fBMandatoryBlockSize()\fP enlists one of two behaviors\&. First, if \fBMandatoryBlockSize()\fP returns 1, then the cipher can be streamed and \fBProcessData()\fP is called with the tail bytes\&. Second, if \fBMandatoryBlockSize()\fP returns non-0, then the string of bytes is padded to \fBMandatoryBlockSize()\fP according to the padding mode\&. Then, \fBProcessData()\fP is called with the padded string of bytes\&.

.PP
Some authenticated encryption modes are not expressed well with \fBMandatoryBlockSize()\fP and \fBMinLastBlockSize()\fP\&. For example, AES/OCB uses 16-byte blocks (MandatoryBlockSize = 16) and the last block requires special processing (MinLastBlockSize = 0)\&. However, 0 is a valid last block size for OCB and the special processing is custom padding, and not standard PKCS padding\&. In response an unambiguous \fBIsLastBlockSpecial()\fP was added\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Reimplemented in \fBCBC_CTS_Decryption\fP, \fBCBC_CTS_Encryption\fP, \fBCBC_ModeBase\fP, and \fBXTS_ModeBase\fP\&.
.SS "virtual unsigned int StreamTransformation::OptimalBlockSize () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the input block size most efficient for this cipher\&. 
.PP
\fBReturns\fP
.RS 4
The input block size that is most efficient for the cipher
.RE
.PP
The base class implementation returns \fBMandatoryBlockSize()\fP\&. 
.PP
\fBNote\fP
.RS 4
Optimal input length is \fRn * \fBOptimalBlockSize()\fP - \fBGetOptimalBlockSizeUsed()\fP\fP for any \fRn > 0\fP\&. 
.RE
.PP

.PP
Reimplemented in \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP, and \fBECB_OneWay\fP\&.
.SS "unsigned int StreamTransformation::OptimalDataAlignment () const\fR [virtual]\fP"

.PP
Provides input and output data alignment for optimal performance\&. 
.PP
\fBReturns\fP
.RS 4
the input data alignment that provides optimal performance 
.RE
.PP
\fBSee also\fP
.RS 4
GetAlignment() and \fBOptimalBlockSize()\fP 
.RE
.PP

.PP
Reimplemented in \fBCCM_Base\fP, \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP, \fBChaCha20Poly1305_Base\fP, \fBCipherModeBase\fP, \fBEAX_Base\fP, \fBGCM_Base\fP, \fBXChaCha20Poly1305_Base\fP, and \fBXTS_ModeBase\fP\&.
.SS "\fBbyte\fP StreamTransformation::ProcessByte (\fBbyte\fP input)\fR [inline]\fP"

.PP
Encrypt or decrypt a byte\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP the input byte to process
.RE
.PP
Internally, the base class implementation calls \fBProcessData()\fP with a size of 1\&. 
.SS "virtual void StreamTransformation::ProcessData (\fBbyte\fP * outString, const \fBbyte\fP * inString, size_t length)\fR [pure virtual]\fP"

.PP
Encrypt or decrypt an array of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP the output byte buffer 
.br
\fIinString\fP the input byte buffer 
.br
\fIlength\fP the size of the input and output byte buffers, in bytes
.RE
.PP
ProcessData is called with a string of bytes whose size depends on MandatoryBlockSize\&. Either \fRinString == outString\fP, or they must not overlap\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Implemented in \fBAuthenticatedSymmetricCipherBase\fP, \fBCBC_Decryption\fP, \fBCBC_Encryption\fP, \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP, \fBECB_OneWay\fP, \fBPublicBlumBlumShub\fP, \fBWeak1::ARC4_Base\fP, and \fBXTS_ModeBase\fP\&.
.SS "size_t StreamTransformation::ProcessLastBlock (\fBbyte\fP * outString, size_t outLength, const \fBbyte\fP * inString, size_t inLength)\fR [virtual]\fP"

.PP
Encrypt or decrypt the last block of data\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP the output byte buffer 
.br
\fIoutLength\fP the size of the output byte buffer, in bytes 
.br
\fIinString\fP the input byte buffer 
.br
\fIinLength\fP the size of the input byte buffer, in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes used in outString
.RE
.PP
ProcessLastBlock is used when the last block of data is special and requires handling by the cipher\&. The current implementation provides an output buffer with a size \fRinLength+2*MandatoryBlockSize()\fP\&. The return value allows the cipher to expand cipher text during encryption or shrink plain text during decryption\&.

.PP
This member function is used by CBC-CTS and OCB modes\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Reimplemented in \fBCBC_CTS_Decryption\fP, \fBCBC_CTS_Encryption\fP, and \fBXTS_ModeBase\fP\&.
.SS "void StreamTransformation::ProcessString (\fBbyte\fP * inoutString, size_t length)\fR [inline]\fP"

.PP
Encrypt or decrypt a string of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIinoutString\fP the string to process 
.br
\fIlength\fP the size of the inoutString, in bytes
.RE
.PP
Internally, the base class implementation calls \fBProcessData()\fP\&. 
.SS "void StreamTransformation::ProcessString (\fBbyte\fP * outString, const \fBbyte\fP * inString, size_t length)\fR [inline]\fP"

.PP
Encrypt or decrypt a string of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP the output string to process 
.br
\fIinString\fP the input string to process 
.br
\fIlength\fP the size of the input and output strings, in bytes
.RE
.PP
Internally, the base class implementation calls \fBProcessData()\fP\&. 
.SS "\fBStreamTransformation\fP & StreamTransformation::Ref ()\fR [inline]\fP"

.PP
Provides a reference to this object\&. 
.PP
\fBReturns\fP
.RS 4
A reference to this object
.RE
.PP
Useful for passing a temporary object to a function that takes a non-const reference 
.SS "virtual void StreamTransformation::Seek (\fBlword\fP pos)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Seek to an absolute position\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos\fP position to seek 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented\fP\fP 
.RE
.PP
The base class implementation throws \fBNotImplemented\fP\&. The function \fBasserts\fP \fBIsRandomAccess()\fP in debug builds\&. 
.PP
Reimplemented in \fBBlumBlumShub\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
