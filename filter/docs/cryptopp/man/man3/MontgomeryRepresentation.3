.TH "MontgomeryRepresentation" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MontgomeryRepresentation \- Performs modular arithmetic in Montgomery representation for increased speed\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <modarith\&.h>\fP
.PP
Inherits \fBModularArithmetic\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMontgomeryRepresentation\fP (const \fBInteger\fP &modulus)"
.br
.RI "Construct a \fBMontgomeryRepresentation\fP\&. "
.ti -1c
.RI "virtual \fBModularArithmetic\fP * \fBClone\fP () const"
.br
.RI "Clone a \fBMontgomeryRepresentation\fP\&. "
.ti -1c
.RI "bool \fBIsMontgomeryRepresentation\fP () const"
.br
.RI "Retrieves the representation\&. "
.ti -1c
.RI "\fBInteger\fP \fBConvertIn\fP (const \fBInteger\fP &a) const"
.br
.RI "Reduces an element in the congruence class\&. "
.ti -1c
.RI "\fBInteger\fP \fBConvertOut\fP (const \fBInteger\fP &a) const"
.br
.RI "Reduces an element in the congruence class\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBMultiplicativeIdentity\fP () const"
.br
.RI "Retrieves the multiplicative identity\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBMultiply\fP (const \fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "Multiplies elements in the ring\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBSquare\fP (const \fBInteger\fP &a) const"
.br
.RI "\fBSquare\fP an element in the ring\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBMultiplicativeInverse\fP (const \fBInteger\fP &a) const"
.br
.RI "Calculate the multiplicative inverse of an element in the ring\&. "
.ti -1c
.RI "\fBInteger\fP \fBCascadeExponentiate\fP (const \fBInteger\fP &x, const \fBInteger\fP &e1, const \fBInteger\fP &y, const \fBInteger\fP &e2) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "void \fBSimultaneousExponentiate\fP (\fBElement\fP *results, const \fBElement\fP &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Exponentiates a base to multiple exponents in the Ring\&. "
.in -1c

Public Member Functions inherited from \fBModularArithmetic\fP
.in +1c
.ti -1c
.RI "\fBModularArithmetic\fP (const \fBInteger\fP &modulus=\fBInteger::One\fP())"
.br
.RI "Construct a \fBModularArithmetic\fP\&. "
.ti -1c
.RI "\fBModularArithmetic\fP (const \fBModularArithmetic\fP &ma)"
.br
.RI "Copy construct a \fBModularArithmetic\fP\&. "
.ti -1c
.RI "\fBModularArithmetic\fP & \fBoperator=\fP (const \fBModularArithmetic\fP &ma)"
.br
.RI "Assign a \fBModularArithmetic\fP\&. "
.ti -1c
.RI "\fBModularArithmetic\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Construct a \fBModularArithmetic\fP\&. "
.ti -1c
.RI "void \fBDEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encodes in DER format\&. "
.ti -1c
.RI "void \fBDEREncodeElement\fP (\fBBufferedTransformation\fP &out, const \fBElement\fP &a) const"
.br
.RI "Encodes element in DER format\&. "
.ti -1c
.RI "void \fBBERDecodeElement\fP (\fBBufferedTransformation\fP &in, \fBElement\fP &a) const"
.br
.RI "Decodes element in DER format\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBGetModulus\fP () const"
.br
.RI "Retrieves the modulus\&. "
.ti -1c
.RI "void \fBSetModulus\fP (const \fBInteger\fP &newModulus)"
.br
.RI "Sets the modulus\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBHalf\fP (const \fBInteger\fP &a) const"
.br
.RI "Divides an element by 2\&. "
.ti -1c
.RI "bool \fBEqual\fP (const \fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "Compare two elements for equality\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBIdentity\fP () const"
.br
.RI "Provides the Identity element\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBAdd\fP (const \fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "Adds elements in the ring\&. "
.ti -1c
.RI "\fBInteger\fP & \fBAccumulate\fP (\fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBInverse\fP (const \fBInteger\fP &a) const"
.br
.RI "Inverts the element in the ring\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBSubtract\fP (const \fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "Subtracts elements in the ring\&. "
.ti -1c
.RI "\fBInteger\fP & \fBReduce\fP (\fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBDouble\fP (const \fBInteger\fP &a) const"
.br
.RI "Doubles an element in the ring\&. "
.ti -1c
.RI "bool \fBIsUnit\fP (const \fBInteger\fP &a) const"
.br
.RI "Determines whether an element is a unit in the ring\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBDivide\fP (const \fBInteger\fP &a, const \fBInteger\fP &b) const"
.br
.RI "Divides elements in the ring\&. "
.ti -1c
.RI "\fBInteger\fP \fBCascadeExponentiate\fP (const \fBInteger\fP &x, const \fBInteger\fP &e1, const \fBInteger\fP &y, const \fBInteger\fP &e2) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "void \fBSimultaneousExponentiate\fP (\fBElement\fP *results, const \fBElement\fP &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Exponentiates a base to multiple exponents in the ring\&. "
.ti -1c
.RI "unsigned int \fBMaxElementBitLength\fP () const"
.br
.RI "Provides the maximum bit size of an element in the ring\&. "
.ti -1c
.RI "unsigned int \fBMaxElementByteLength\fP () const"
.br
.RI "Provides the maximum byte size of an element in the ring\&. "
.ti -1c
.RI "\fBElement\fP \fBRandomElement\fP (\fBRandomNumberGenerator\fP &rng, const RandomizationParameter &ignore_for_now=0) const"
.br
.RI "Provides a random element in the ring\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBModularArithmetic\fP &rhs) const"
.br
.RI "Compares two \fBModularArithmetic\fP for equality\&. "
.in -1c

Public Member Functions inherited from \fBAbstractRing< Integer >\fP
.in +1c
.ti -1c
.RI "\fBAbstractRing\fP ()"
.br
.RI "Construct an \fBAbstractRing\fP\&. "
.ti -1c
.RI "\fBAbstractRing\fP & \fBoperator=\fP (const \fBAbstractRing\fP &source)"
.br
.RI "Assign an \fBAbstractRing\fP\&. "
.ti -1c
.RI "virtual \fBElement\fP \fBExponentiate\fP (const \fBElement\fP &a, const \fBInteger\fP &e) const"
.br
.RI "Raises a base to an exponent in the group\&. "
.ti -1c
.RI "virtual const \fBAbstractGroup\fP< \fBInteger\fP > & \fBMultiplicativeGroup\fP () const"
.br
.RI "Retrieves the multiplicative group\&. "
.in -1c

Public Member Functions inherited from \fBAbstractGroup< Integer >\fP
.in +1c
.ti -1c
.RI "virtual bool \fBInversionIsFast\fP () const"
.br
.RI "Determine if inversion is fast\&. "
.ti -1c
.RI "virtual const \fBElement\fP & \fBSubtract\fP (const \fBElement\fP &a, const \fBElement\fP &b) const"
.br
.RI "Subtracts elements in the group\&. "
.ti -1c
.RI "virtual \fBElement\fP & \fBAccumulate\fP (\fBElement\fP &a, const \fBElement\fP &b) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "virtual \fBElement\fP & \fBReduce\fP (\fBElement\fP &a, const \fBElement\fP &b) const"
.br
.RI "Reduces an element in the congruence class\&. "
.ti -1c
.RI "virtual \fBElement\fP \fBScalarMultiply\fP (const \fBElement\fP &a, const \fBInteger\fP &e) const"
.br
.RI "Performs a scalar multiplication\&. "
.ti -1c
.RI "virtual \fBElement\fP \fBCascadeScalarMultiply\fP (const \fBElement\fP &x, const \fBInteger\fP &e1, const \fBElement\fP &y, const \fBInteger\fP &e2) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "virtual void \fBSimultaneousMultiply\fP (\fBElement\fP *results, const \fBElement\fP &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Multiplies a base to multiple exponents in a group\&. "
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBModularArithmetic\fP
.in +1c
.ti -1c
.RI "typedef int \fBRandomizationParameter\fP"
.br
.ti -1c
.RI "typedef \fBInteger\fP \fBElement\fP"
.br
.in -1c

Public Types inherited from \fBAbstractRing< Integer >\fP
.in +1c
.ti -1c
.RI "typedef \fBInteger\fP \fBElement\fP"
.br
.in -1c

Public Types inherited from \fBAbstractGroup< Integer >\fP
.in +1c
.ti -1c
.RI "typedef \fBInteger\fP \fBElement\fP"
.br
.in -1c

Static Public Attributes inherited from \fBModularArithmetic\fP
.in +1c
.ti -1c
.RI "static const RandomizationParameter \fBDefaultRandomizationParameter\fP"
.br
.in -1c

Protected Attributes inherited from \fBModularArithmetic\fP
.in +1c
.ti -1c
.RI "\fBInteger\fP \fBm_modulus\fP"
.br
.ti -1c
.RI "\fBInteger\fP \fBm_result\fP"
.br
.ti -1c
.RI "\fBInteger\fP \fBm_result1\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Performs modular arithmetic in Montgomery representation for increased speed\&. 

The Montgomery representation represents each congruence class \fR[a]\fP as \fRa*r%n\fP, where \fRr\fP is a convenient power of 2\&.

.PP
\fRconst Element&\fP returned by member functions are references to internal data members\&. Since each object may have only one such data member for holding results, the following code will produce incorrect results: 
.PP
.nf
    abcd = group\&.Add(group\&.Add(a,b), group\&.Add(c,d));
.fi
.PP
 But this should be fine: 
.PP
.nf
    abcd = group\&.Add(a, group\&.Add(b, group\&.Add(c,d));
.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MontgomeryRepresentation::MontgomeryRepresentation (const \fBInteger\fP & modulus)"

.PP
Construct a \fBMontgomeryRepresentation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fImodulus\fP congruence class modulus 
.RE
.PP
\fBNote\fP
.RS 4
The modulus must be odd\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBInteger\fP MontgomeryRepresentation::CascadeExponentiate (const \fBInteger\fP & x, const \fBInteger\fP & e1, const \fBInteger\fP & y, const \fBInteger\fP & e2) const\fR [inline]\fP, \fR [virtual]\fP"

.PP
TODO\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP first element 
.br
\fIe1\fP first exponent 
.br
\fIy\fP second element 
.br
\fIe2\fP second exponent 
.RE
.PP
\fBReturns\fP
.RS 4
TODO 
.RE
.PP

.PP
Reimplemented from \fBAbstractRing< Integer >\fP\&.
.SS "virtual \fBModularArithmetic\fP * MontgomeryRepresentation::Clone () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Clone a \fBMontgomeryRepresentation\fP\&. 
.PP
\fBReturns\fP
.RS 4
pointer to a new \fBMontgomeryRepresentation\fP
.RE
.PP
Clone effectively copy constructs a new \fBMontgomeryRepresentation\fP\&. The caller is responsible for deleting the pointer returned from this method\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "\fBInteger\fP MontgomeryRepresentation::ConvertIn (const \fBInteger\fP & a) const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Reduces an element in the congruence class\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP element to convert 
.RE
.PP
\fBReturns\fP
.RS 4
the reduced element
.RE
.PP
ConvertIn is useful for derived classes, like \fBMontgomeryRepresentation\fP, which must convert between representations\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "\fBInteger\fP MontgomeryRepresentation::ConvertOut (const \fBInteger\fP & a) const\fR [virtual]\fP"

.PP
Reduces an element in the congruence class\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP element to convert 
.RE
.PP
\fBReturns\fP
.RS 4
the reduced element
.RE
.PP
ConvertOut is useful for derived classes, like \fBMontgomeryRepresentation\fP, which must convert between representations\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "bool MontgomeryRepresentation::IsMontgomeryRepresentation () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieves the representation\&. 
.PP
\fBReturns\fP
.RS 4
true if the if the modulus is in Montgomery form for multiplication, false otherwise 
.RE
.PP

.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "const \fBInteger\fP & MontgomeryRepresentation::MultiplicativeIdentity () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieves the multiplicative identity\&. 
.PP
\fBReturns\fP
.RS 4
the multiplicative identity
.RE
.PP
the base class implementations returns 1\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "const \fBInteger\fP & MontgomeryRepresentation::MultiplicativeInverse (const \fBInteger\fP & a) const\fR [virtual]\fP"

.PP
Calculate the multiplicative inverse of an element in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP the element
.RE
.PP
MultiplicativeInverse returns \fRa\*{-1\*} %n\fP\&. The element \fRa\fP must provide a InverseMod member function\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "const \fBInteger\fP & MontgomeryRepresentation::Multiply (const \fBInteger\fP & a, const \fBInteger\fP & b) const\fR [virtual]\fP"

.PP
Multiplies elements in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP the multiplicand 
.br
\fIb\fP the multiplier 
.RE
.PP
\fBReturns\fP
.RS 4
the product of a and b
.RE
.PP
Multiply returns \fRa*b%n\fP\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.
.SS "void MontgomeryRepresentation::SimultaneousExponentiate (\fBElement\fP * results, const \fBElement\fP & base, const \fBInteger\fP * exponents, unsigned int exponentsCount) const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Exponentiates a base to multiple exponents in the Ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIresults\fP an array of Elements 
.br
\fIbase\fP the base to raise to the exponents 
.br
\fIexponents\fP an array of exponents 
.br
\fIexponentsCount\fP the number of exponents in the array
.RE
.PP
\fBSimultaneousExponentiate()\fP raises the base to each exponent in the exponents array and stores the result at the respective position in the results array\&.

.PP
\fBSimultaneousExponentiate()\fP must be implemented in a derived class\&. 
.PP
\fBPrecondition\fP
.RS 4
\fRCOUNTOF(results) == exponentsCount\fP 

.PP
\fRCOUNTOF(exponents) == exponentsCount\fP 
.RE
.PP

.PP
Reimplemented from \fBAbstractRing< Integer >\fP\&.
.SS "const \fBInteger\fP & MontgomeryRepresentation::Square (const \fBInteger\fP & a) const\fR [virtual]\fP"

.PP
\fBSquare\fP an element in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP the element 
.RE
.PP
\fBReturns\fP
.RS 4
the element squared
.RE
.PP
\fBSquare\fP returns \fRa*a%n\fP\&. The element \fRa\fP must provide a \fBSquare\fP member function\&. 
.PP
Reimplemented from \fBModularArithmetic\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
