.TH "/home/mock/cryptopp-master/ppc_simd.h" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/mock/cryptopp-master/ppc_simd.h \- Support functions for PowerPC and vector operations\&.

.SH SYNOPSIS
.br
.PP
\fR#include 'config\&.h'\fP
.br
\fR#include 'misc\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCONST_V8_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.ti -1c
.RI "#define \fBCONST_V32_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.ti -1c
.RI "#define \fBCONST_V64_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.ti -1c
.RI "#define \fBNCONST_V8_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.ti -1c
.RI "#define \fBNCONST_V32_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.ti -1c
.RI "#define \fBNCONST_V64_CAST\fP(x)"
.br
.RI "Cast array to vector pointer\&. "
.in -1c
.SH "Detailed Description"
.PP
Support functions for PowerPC and vector operations\&.

This header provides an agnostic interface into Clang, GCC and IBM XL C/C++ compilers modulo their different built-in functions for accessing vector instructions\&.

.PP
The abstractions are necessary to support back to GCC 4\&.8 and XLC 11 and 12\&. GCC 4\&.8 and 4\&.9 are still popular, and they are the default compiler for GCC112, GCC119 and others on the compile farm\&. Older IBM XL C/C++ compilers also have the need due to lack of \fRvec_xl\fP and \fRvec_xst\fP support on some platforms\&. Modern compilers provide best support and don't need many of the hacks below\&.

.PP
The library is tested with the following PowerPC machines and compilers\&. GCC110, GCC111, GCC112, GCC119 and GCC135 are provided by the \fRGCC Compile Farm\fP
.IP "\(bu" 2
PowerMac G5, OSX 10\&.5, POWER4, Apple GCC 4\&.0
.IP "\(bu" 2
PowerMac G5, OSX 10\&.5, POWER4, Macports GCC 5\&.0
.IP "\(bu" 2
GCC110, Linux, POWER7, GCC 4\&.8\&.5
.IP "\(bu" 2
GCC110, Linux, POWER7, XLC 12\&.01
.IP "\(bu" 2
GCC111, AIX, POWER7, GCC 4\&.8\&.1
.IP "\(bu" 2
GCC111, AIX, POWER7, XLC 12\&.01
.IP "\(bu" 2
GCC112, Linux, POWER8, GCC 4\&.8\&.5
.IP "\(bu" 2
GCC112, Linux, POWER8, XLC 13\&.01
.IP "\(bu" 2
GCC112, Linux, POWER8, Clang 7\&.0
.IP "\(bu" 2
GCC119, AIX, POWER8, GCC 7\&.2\&.0
.IP "\(bu" 2
GCC119, AIX, POWER8, XLC 13\&.01
.IP "\(bu" 2
GCC135, Linux, POWER9, GCC 7\&.0
.PP

.PP
12 machines are used for testing because the three compilers form five or six profiles\&. The profiles are listed below\&.
.IP "\(bu" 2
GCC (Linux GCC, Macports GCC, etc\&. Consistent across machines)
.IP "\(bu" 2
XLC 13\&.0 and earlier (all IBM components)
.IP "\(bu" 2
XLC 13\&.1 and later on Linux (LLVM front-end, no compatibility macros)
.IP "\(bu" 2
XLC 13\&.1 and later on Linux (LLVM front-end, -qxlcompatmacros option)
.IP "\(bu" 2
early LLVM Clang (traditional Clang compiler)
.IP "\(bu" 2
late LLVM Clang (traditional Clang compiler)
.PP

.PP
The LLVM front-end makes it tricky to write portable code because LLVM pretends to be other compilers but cannot consume other compiler's builtins\&. When using XLC with -qxlcompatmacros the compiler pretends to be GCC, Clang and XLC all at once but it can only consume it's variety of builtins\&.

.PP
At Crypto++ 8\&.0 the various \fRVector{FuncName}\fP were renamed to \fRVec{FuncName}\fP\&. For example, \fRVectorAnd\fP was changed to \fRVecAnd\fP\&. The name change helped consolidate two slightly different implementations\&.

.PP
At Crypto++ 8\&.3 the library added select 64-bit functions for 32-bit Altivec\&. For example, \fRVecAdd64\fP and \fRVecSub64\fP take 32-bit vectors and adds or subtracts them as if there were vectors with two 64-bit elements\&. The functions dramtically improve performance for some algorithms on some platforms, like \fBSIMON128\fP and \fBSPECK128\fP on Power6 and earlier\&. For example, \fBSPECK128\fP improved from 70 cpb to 10 cpb on an old PowerMac\&. Use the functions like shown below\&.
.PP
.nf

   #if defined(_ARCH_PWR8)
   #  define speck128_t uint64x2_p
   #else
   #  define speck128_t uint32x4_p
   #endif

   speck128_t rk, x1, x2, y1, y2;
   rk = (speck128_t)VecLoadAligned(ptr);
   x1 = VecRotateRight64<8>(x1);
   x1 = VecAdd64(x1, y1);
   \&.\&.\&.
.fi
.PP

.PP
\fBSince\fP
.RS 4
Crypto++ 6\&.0, LLVM Clang compiler support since Crypto++ 8\&.0
.RE
.PP

.SH "Macro Definition Documentation"
.PP
.SS "#define CONST_V32_CAST( x)"
\fBValue:\fP
.nf
((unsigned int*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. CONST_V32_CAST casts a const array to a vector pointer for a word array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SS "#define CONST_V64_CAST( x)"
\fBValue:\fP
.nf
((unsigned long long*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. CONST_V64_CAST casts a const array to a vector pointer for a double word array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SS "#define CONST_V8_CAST( x)"
\fBValue:\fP
.nf
((unsigned char*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. CONST_V8_CAST casts a const array to a vector pointer for a byte array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SS "#define NCONST_V32_CAST( x)"
\fBValue:\fP
.nf
((unsigned int*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. NCONST_V32_CAST casts an array to a vector pointer for a word array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SS "#define NCONST_V64_CAST( x)"
\fBValue:\fP
.nf
((unsigned long long*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. NCONST_V64_CAST casts an array to a vector pointer for a double word array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SS "#define NCONST_V8_CAST( x)"
\fBValue:\fP
.nf
((unsigned char*)(x))
.PP
.fi

.PP
Cast array to vector pointer\&. NCONST_V8_CAST casts an array to a vector pointer for a byte array\&. The Power ABI says source arrays are non-const, so this define removes the const\&. XLC++ will fail the compile if the source array is const\&.
.SH "Author"
.PP
Generated automatically by Doxygen for My Project from the source code\&.
