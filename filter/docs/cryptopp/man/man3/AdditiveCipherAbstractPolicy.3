.TH "AdditiveCipherAbstractPolicy" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AdditiveCipherAbstractPolicy \- Policy object for additive stream ciphers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <strciphr\&.h>\fP
.PP
Inherited by \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBModePolicyCommonTemplate< AdditiveCipherAbstractPolicy >\fP, and \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual unsigned int \fBGetAlignment\fP () const"
.br
.RI "Provides data alignment requirements\&. "
.ti -1c
.RI "virtual unsigned int \fBGetBytesPerIteration\fP () const =0"
.br
.RI "Provides number of bytes operated upon during an iteration\&. "
.ti -1c
.RI "virtual unsigned int \fBGetOptimalBlockSize\fP () const"
.br
.RI "Provides number of ideal bytes to process\&. "
.ti -1c
.RI "virtual unsigned int \fBGetIterationsToBuffer\fP () const =0"
.br
.RI "Provides buffer size based on iterations\&. "
.ti -1c
.RI "virtual void \fBWriteKeystream\fP (\fBbyte\fP *keystream, size_t iterationCount)"
.br
.RI "Generate the keystream\&. "
.ti -1c
.RI "virtual bool \fBCanOperateKeystream\fP () const"
.br
.RI "Flag indicating\&. "
.ti -1c
.RI "virtual void \fBOperateKeystream\fP (\fBKeystreamOperation\fP operation, \fBbyte\fP *output, const \fBbyte\fP *input, size_t iterationCount)"
.br
.RI "Operates the keystream\&. "
.ti -1c
.RI "virtual void \fBCipherSetKey\fP (const \fBNameValuePairs\fP &params, const \fBbyte\fP *key, size_t length)=0"
.br
.RI "Key the cipher\&. "
.ti -1c
.RI "virtual void \fBCipherResynchronize\fP (\fBbyte\fP *keystreamBuffer, const \fBbyte\fP *iv, size_t length)"
.br
.RI "Resynchronize the cipher\&. "
.ti -1c
.RI "virtual bool \fBCipherIsRandomAccess\fP () const =0"
.br
.RI "Flag indicating random access\&. "
.ti -1c
.RI "virtual void \fBSeekToIteration\fP (\fBlword\fP iterationCount)"
.br
.RI "Seeks to a random position in the stream\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c
.SH "Detailed Description"
.PP 
Policy object for additive stream ciphers\&. 
.SH "Member Function Documentation"
.PP 
.SS "virtual std::string AdditiveCipherAbstractPolicy::AlgorithmProvider () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieve the provider of this algorithm\&. 
.PP
\fBReturns\fP
.RS 4
the algorithm provider
.RE
.PP
The algorithm provider can be a name like "C++", "SSE", "NEON", "AESNI", "ARMv8" and "Power8"\&. C++ is standard C++ code\&. Other labels, like SSE, usually indicate a specialized implementation using instructions from a higher instruction set architecture (ISA)\&. Future labels may include external hardware like a hardware security module (HSM)\&.

.PP
Generally speaking Wei Dai's original IA-32 ASM code falls under "SSE2"\&. Labels like "SSSE3" and "SSE4\&.1" follow after Wei's code and use intrinsics instead of ASM\&.

.PP
Algorithms which combine different instructions or ISAs provide the dominant one\&. For example on x86 \fRAES/GCM\fP returns "AESNI" rather than "CLMUL" or "AES+SSE4\&.1" or "AES+CLMUL" or "AES+SSE4\&.1+CLMUL"\&. 
.PP
\fBNote\fP
.RS 4
Provider is not universally implemented yet\&. 
.RE
.PP

.PP
Reimplemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBPanamaCipherPolicy< B >\fP, \fBSalsa20_Policy\fP, \fBSosemanukPolicy\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual bool AdditiveCipherAbstractPolicy::CanOperateKeystream () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Flag indicating\&. 
.PP
\fBReturns\fP
.RS 4
true if the stream can be generated independent of the transformation input, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBCanOperateKeystream()\fP, \fBOperateKeystream()\fP, \fBWriteKeystream()\fP 
.RE
.PP

.PP
Reimplemented in \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBCTR_ModePolicy\fP, \fBHC128Policy\fP, \fBHC256Policy\fP, \fBRabbitPolicy\fP, and \fBRabbitWithIVPolicy\fP\&.
.SS "virtual bool AdditiveCipherAbstractPolicy::CipherIsRandomAccess () const\fR [pure virtual]\fP"

.PP
Flag indicating random access\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher is seekable, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBSeekToIteration()\fP 
.RE
.PP

.PP
Implemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBCTR_ModePolicy\fP, \fBHC128Policy\fP, \fBHC256Policy\fP, \fBOFB_ModePolicy\fP, \fBPanamaCipherPolicy< B >\fP, \fBRabbitPolicy\fP, \fBRabbitWithIVPolicy\fP, \fBSalsa20_Policy\fP, \fBSEAL_Policy< B >\fP, \fBSosemanukPolicy\fP, \fBWAKE_Policy< B >\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual void AdditiveCipherAbstractPolicy::CipherResynchronize (\fBbyte\fP * keystreamBuffer, const \fBbyte\fP * iv, size_t length)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Resynchronize the cipher\&. 
.PP
\fBParameters\fP
.RS 4
\fIkeystreamBuffer\fP the keystream buffer 
.br
\fIiv\fP a byte array used to resynchronize the cipher 
.br
\fIlength\fP the size of the IV array 
.RE
.PP

.PP
Reimplemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBCTR_ModePolicy\fP, \fBHC128Policy\fP, \fBHC256Policy\fP, \fBOFB_ModePolicy\fP, \fBPanamaCipherPolicy< B >\fP, \fBRabbitWithIVPolicy\fP, \fBSalsa20_Policy\fP, \fBSEAL_Policy< B >\fP, \fBSosemanukPolicy\fP, \fBXChaCha20_Policy\fP, and \fBXSalsa20_Policy\fP\&.
.SS "virtual void AdditiveCipherAbstractPolicy::CipherSetKey (const \fBNameValuePairs\fP & params, const \fBbyte\fP * key, size_t length)\fR [pure virtual]\fP"

.PP
Key the cipher\&. 
.PP
\fBParameters\fP
.RS 4
\fIparams\fP set of \fBNameValuePairs\fP use to initialize this object 
.br
\fIkey\fP a byte array used to key the cipher 
.br
\fIlength\fP the size of the key array 
.RE
.PP

.PP
Implemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBHC128Policy\fP, \fBHC256Policy\fP, \fBPanamaCipherPolicy< B >\fP, \fBRabbitPolicy\fP, \fBRabbitWithIVPolicy\fP, \fBSalsa20_Policy\fP, \fBSEAL_Policy< B >\fP, \fBSosemanukPolicy\fP, \fBWAKE_Policy< B >\fP, \fBXChaCha20_Policy\fP, and \fBXSalsa20_Policy\fP\&.
.SS "virtual unsigned int AdditiveCipherAbstractPolicy::GetAlignment () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides data alignment requirements\&. 
.PP
\fBReturns\fP
.RS 4
data alignment requirements, in bytes
.RE
.PP
Internally, the default implementation returns 1\&. If the stream cipher is implemented using an SSE2 ASM or intrinsics, then the value returned is usually 16\&. 
.PP
Reimplemented in \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBCTR_ModePolicy\fP, \fBPanamaCipherPolicy< B >\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual unsigned int AdditiveCipherAbstractPolicy::GetBytesPerIteration () const\fR [pure virtual]\fP"

.PP
Provides number of bytes operated upon during an iteration\&. 
.PP
\fBReturns\fP
.RS 4
bytes operated upon during an iteration, in bytes 
.RE
.PP
\fBSee also\fP
.RS 4
\fBGetOptimalBlockSize()\fP 
.RE
.PP

.PP
Implemented in \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBCTR_ModePolicy\fP, and \fBOFB_ModePolicy\fP\&.
.SS "virtual unsigned int AdditiveCipherAbstractPolicy::GetIterationsToBuffer () const\fR [pure virtual]\fP"

.PP
Provides buffer size based on iterations\&. 
.PP
\fBReturns\fP
.RS 4
the buffer size based on iterations, in bytes 
.RE
.PP

.PP
Implemented in \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBCTR_ModePolicy\fP, and \fBOFB_ModePolicy\fP\&.
.SS "virtual unsigned int AdditiveCipherAbstractPolicy::GetOptimalBlockSize () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides number of ideal bytes to process\&. 
.PP
\fBReturns\fP
.RS 4
the ideal number of bytes to process
.RE
.PP
Internally, the default implementation returns \fBGetBytesPerIteration()\fP 
.PP
\fBSee also\fP
.RS 4
\fBGetBytesPerIteration()\fP 
.RE
.PP

.PP
Reimplemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual void AdditiveCipherAbstractPolicy::OperateKeystream (\fBKeystreamOperation\fP operation, \fBbyte\fP * output, const \fBbyte\fP * input, size_t iterationCount)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Operates the keystream\&. 
.PP
\fBParameters\fP
.RS 4
\fIoperation\fP the operation with additional flags 
.br
\fIoutput\fP the output buffer 
.br
\fIinput\fP the input buffer 
.br
\fIiterationCount\fP the number of iterations to perform on the input
.RE
.PP
\fBOperateKeystream()\fP will attempt to operate upon \fBGetOptimalBlockSize()\fP buffer, which will be derived from \fBGetBytesPerIteration()\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBCanOperateKeystream()\fP, \fBOperateKeystream()\fP, \fBWriteKeystream()\fP, \fBKeystreamOperation()\fP 
.RE
.PP

.PP
Reimplemented in \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP, \fBAdditiveCipherConcretePolicy< word32, 1, 64 >\fP, \fBAdditiveCipherConcretePolicy< word32, 16 >\fP, \fBAdditiveCipherConcretePolicy< word32, 20 >\fP, \fBAdditiveCipherConcretePolicy< word32, 256 >\fP, \fBAdditiveCipherConcretePolicy< word32, 4 >\fP, \fBAdditiveCipherConcretePolicy< word32, 8 >\fP, \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBCTR_ModePolicy\fP, \fBHC128Policy\fP, \fBHC256Policy\fP, \fBPanamaCipherPolicy< B >\fP, \fBRabbitPolicy\fP, \fBRabbitWithIVPolicy\fP, \fBSalsa20_Policy\fP, \fBSEAL_Policy< B >\fP, \fBSosemanukPolicy\fP, \fBWAKE_Policy< B >\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual void AdditiveCipherAbstractPolicy::SeekToIteration (\fBlword\fP iterationCount)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Seeks to a random position in the stream\&. 
.PP
\fBSee also\fP
.RS 4
\fBCipherIsRandomAccess()\fP 
.RE
.PP

.PP
Reimplemented in \fBChaCha_Policy\fP, \fBChaChaTLS_Policy\fP, \fBCTR_ModePolicy\fP, \fBSalsa20_Policy\fP, \fBSEAL_Policy< B >\fP, and \fBXChaCha20_Policy\fP\&.
.SS "virtual void AdditiveCipherAbstractPolicy::WriteKeystream (\fBbyte\fP * keystream, size_t iterationCount)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Generate the keystream\&. 
.PP
\fBParameters\fP
.RS 4
\fIkeystream\fP the key stream 
.br
\fIiterationCount\fP the number of iterations to generate the key stream 
.RE
.PP
\fBSee also\fP
.RS 4
\fBCanOperateKeystream()\fP, \fBOperateKeystream()\fP, \fBWriteKeystream()\fP 
.RE
.PP

.PP
Reimplemented in \fBCTR_ModePolicy\fP, and \fBOFB_ModePolicy\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
