.TH "ChannelSwitch" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ChannelSwitch \- Route input to different and/or multiple channels based on channel ID\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <channels\&.h>\fP
.PP
Inherits \fBMultichannel< Sink >\fP, and \fBChannelSwitchTypedefs\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBChannelSwitch\fP (\fBBufferedTransformation\fP &destination)"
.br
.ti -1c
.RI "\fBChannelSwitch\fP (\fBBufferedTransformation\fP &destination, const std::string &outChannel)"
.br
.ti -1c
.RI "void \fBIsolatedInitialize\fP (const \fBNameValuePairs\fP &parameters=g_nullNameValuePairs)"
.br
.RI "Initialize or reinitialize this object, without signal propagation\&. "
.ti -1c
.RI "size_t \fBChannelPut2\fP (const std::string &channel, const \fBbyte\fP *begin, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes for processing on a channel\&. "
.ti -1c
.RI "size_t \fBChannelPutModifiable2\fP (const std::string &channel, \fBbyte\fP *begin, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.ti -1c
.RI "bool \fBChannelFlush\fP (const std::string &channel, bool completeFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output on a channel\&. "
.ti -1c
.RI "bool \fBChannelMessageSeriesEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages on a channel\&. "
.ti -1c
.RI "\fBbyte\fP * \fBChannelCreatePutSpace\fP (const std::string &channel, size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "void \fBAddDefaultRoute\fP (\fBBufferedTransformation\fP &destination)"
.br
.ti -1c
.RI "void \fBRemoveDefaultRoute\fP (\fBBufferedTransformation\fP &destination)"
.br
.ti -1c
.RI "void \fBAddDefaultRoute\fP (\fBBufferedTransformation\fP &destination, const std::string &outChannel)"
.br
.ti -1c
.RI "void \fBRemoveDefaultRoute\fP (\fBBufferedTransformation\fP &destination, const std::string &outChannel)"
.br
.ti -1c
.RI "void \fBAddRoute\fP (const std::string &inChannel, \fBBufferedTransformation\fP &destination, const std::string &outChannel)"
.br
.ti -1c
.RI "void \fBRemoveRoute\fP (const std::string &inChannel, \fBBufferedTransformation\fP &destination, const std::string &outChannel)"
.br
.in -1c

Public Member Functions inherited from \fBMultichannel< Sink >\fP
.in +1c
.ti -1c
.RI "bool \fBFlush\fP (bool hardFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output, with signal propagation\&. "
.ti -1c
.RI "bool \fBMessageSeriesEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages, with signal propagation\&. "
.ti -1c
.RI "\fBbyte\fP * \fBCreatePutSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "size_t \fBPut2\fP (const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes for processing\&. "
.ti -1c
.RI "size_t \fBPutModifiable2\fP (\fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.ti -1c
.RI "\fBbyte\fP * \fBChannelCreatePutSpace\fP (const std::string &channel, size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "bool \fBChannelPutModifiable\fP (const std::string &channel, \fBbyte\fP *inString, size_t length)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.ti -1c
.RI "size_t \fBChannelPutModifiable2\fP (const std::string &channel, \fBbyte\fP *begin, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c

Public Member Functions inherited from \fBSink\fP
.in +1c
.ti -1c
.RI "size_t \fBTransferTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer bytes from this object to another \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "size_t \fBCopyRangeTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &begin, \fBlword\fP end=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c

Public Member Functions inherited from \fBBufferedTransformation\fP
.in +1c
.ti -1c
.RI "\fBBufferedTransformation\fP ()"
.br
.RI "Construct a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "\fBBufferedTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAttachable\fP ()"
.br
.RI "Determines whether the object allows attachment\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBBufferedTransformation\fP * \fBAttachedTransformation\fP ()"
.br
.RI "Returns the object immediately attached to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual const \fBBufferedTransformation\fP * \fBAttachedTransformation\fP () const"
.br
.RI "Returns the object immediately attached to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBDetach\fP (\fBBufferedTransformation\fP *newAttachment=NULLPTR)"
.br
.RI "Delete the current attachment chain and attach a new one\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBAttach\fP (\fBBufferedTransformation\fP *newAttachment)"
.br
.RI "Add newAttachment to the end of attachment chain\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (\fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord16\fP (\fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord32\fP (\fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord64\fP (word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBCanModifyInput\fP () const"
.br
.RI "Determines whether input can be modified by the callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutModifiable\fP (\fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBMessageEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Signals the end of messages to the object\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutMessageEnd\fP (const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBGetMaxWaitObjectCount\fP () const"
.br
.RI "Retrieves the maximum number of waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBGetWaitObjects\fP (WaitObjectContainer &container, CallStack const &callStack)"
.br
.RI "Retrieves waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBIsolatedMessageSeriesEnd\fP (bool blocking)"
.br
.RI "Marks the end of a series of messages, without signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBInitialize\fP (const \fBNameValuePairs\fP &parameters=g_nullNameValuePairs, int propagation=\-1)"
.br
.RI "Initialize or reinitialize this object, with signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetAutoSignalPropagation\fP (int propagation)"
.br
.RI "Set propagation of automatically generated and transferred signals\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual int \fBGetAutoSignalPropagation\fP () const"
.br
.RI "Retrieve automatic signal propagation value\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBMaxRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAnyRetrievable\fP () const"
.br
.RI "Determines whether bytes are ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBGet\fP (\fBbyte\fP &outByte)"
.br
.RI "Retrieve a 8-bit byte\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBGet\fP (\fBbyte\fP *outString, size_t getMax)"
.br
.RI "Retrieve a block of bytes\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPeek\fP (\fBbyte\fP &outByte) const"
.br
.RI "Peek a 8-bit byte\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPeek\fP (\fBbyte\fP *outString, size_t peekMax) const"
.br
.RI "Peek a block of bytes\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBTransferTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP transferMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "move transferMax bytes of the buffered output to target as input "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBSkip\fP (\fBlword\fP skipMax=\fBLWORD_MAX\fP)"
.br
.RI "Discard skipMax bytes from the output buffer\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyRangeTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP position, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object using an index to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBTotalBytesRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessages\fP () const"
.br
.RI "Provides the number of meesages processed by this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAnyMessages\fP () const"
.br
.RI "Determines if any messages are available for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessage\fP ()"
.br
.RI "Start retrieving the next message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBSkipMessages\fP (unsigned int count=UINT_MAX)"
.br
.RI "Skip a number of meessages\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBTransferMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBCopyMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSkipAll\fP ()"
.br
.RI "Skip all messages in the series\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBTransferAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBCopyAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessageSeries\fP ()"
.br
.RI "Retrieve the next message in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessagesInThisSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessageSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferMessagesTo2\fP (\fBBufferedTransformation\fP &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferAllTo2\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, \fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutModifiable\fP (const std::string &channel, \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord16\fP (const std::string &channel, \fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 16-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord32\fP (const std::string &channel, \fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 32-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord64\fP (const std::string &channel, word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 64-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBChannelMessageEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutMessageEnd\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetRetrievalChannel\fP (const std::string &channel)"
.br
.RI "Sets the default retrieval channel\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBWaitable\fP
.in +1c
.ti -1c
.RI "bool \fBWait\fP (unsigned long milliseconds, CallStack const &callStack)"
.br
.RI "Wait on this object\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBChannelRouteIterator\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBChannelSwitchTypedefs\fP
.in +1c
.ti -1c
.RI "typedef std::pair< \fBBufferedTransformation\fP *, std::string > \fBRoute\fP"
.br
.ti -1c
.RI "typedef std::multimap< std::string, Route > \fBRouteMap\fP"
.br
.ti -1c
.RI "typedef std::pair< \fBBufferedTransformation\fP *, \fBvalue_ptr\fP< std::string > > \fBDefaultRoute\fP"
.br
.ti -1c
.RI "typedef std::list< DefaultRoute > \fBDefaultRouteList\fP"
.br
.ti -1c
.RI "typedef RouteMap::iterator \fBMapIterator\fP"
.br
.ti -1c
.RI "typedef DefaultRouteList::iterator \fBListIterator\fP"
.br
.in -1c
.in +1c
.ti -1c
.RI "static int \fBDecrementPropagation\fP (int propagation)"
.br
.RI "Decrements the propagation count while clamping at 0\&. "
.in -1c
.SH "Detailed Description"
.PP 
Route input to different and/or multiple channels based on channel ID\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBbyte\fP * ChannelSwitch::ChannelCreatePutSpace (const std::string & channel, size_t & size)\fR [virtual]\fP"

.PP
Request space which can be written into by the caller\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP the channel to process the data 
.br
\fIsize\fP the requested size of the buffer 
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to a memory block with length size
.RE
.PP
The purpose of this method is to help avoid extra memory allocations\&.

.PP
size is an \fIIN\fP and \fIOUT\fP parameter and used as a hint\&. When the call is made, size is the requested size of the buffer\&. When the call returns, size is the size of the array returned to the caller\&.

.PP
The base class implementation sets size to 0 and returns NULL\&. 
.PP
\fBNote\fP
.RS 4
Some objects, like \fBArraySink()\fP, cannot create a space because its fixed\&. In the case of an \fBArraySink()\fP, the pointer to the array is returned and the size is remaining size\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "bool ChannelSwitch::ChannelFlush (const std::string & channel, bool hardFlush, int propagation = \fR\-1\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Flush buffered input and/or output on a channel\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP the channel to flush the data 
.br
\fIhardFlush\fP is used to indicate whether all data should be flushed 
.br
\fIpropagation\fP the number of attached transformations the \fBChannelFlush()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
true of the Flush was successful
.RE
.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
Implements \fBMultichannel< Sink >\fP\&.
.SS "bool ChannelSwitch::ChannelMessageSeriesEnd (const std::string & channel, int propagation = \fR\-1\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Marks the end of a series of messages on a channel\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP the channel to signal the end of a series of messages 
.br
\fIpropagation\fP the number of attached transformations the \fBChannelMessageSeriesEnd()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
true if the message was successful, false otherwise
.RE
.PP
Each object that receives the signal will perform its processing, decrement propagation, and then pass the signal on to attached transformations if the value is not 0\&.

.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
\fBNote\fP
.RS 4
There should be a \fBMessageEnd()\fP immediately before \fBMessageSeriesEnd()\fP\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t ChannelSwitch::ChannelPut2 (const std::string & channel, const \fBbyte\fP * begin, size_t length, int messageEnd, bool blocking)\fR [virtual]\fP"

.PP
Input multiple bytes for processing on a channel\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP the channel to process the data\&. 
.br
\fIbegin\fP the byte buffer to process\&. 
.br
\fIlength\fP the size of the string, in bytes\&. 
.br
\fImessageEnd\fP means how many filters to signal \fBMessageEnd()\fP to, including this one\&. 
.br
\fIblocking\fP specifies whether the object should block when processing input\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain to be processed (i\&.e\&., bytes not processed) 
.RE
.PP

.PP
Implements \fBMultichannel< Sink >\fP\&.
.SS "size_t ChannelSwitch::ChannelPutModifiable2 (const std::string & channel, \fBbyte\fP * inString, size_t length, int messageEnd, bool blocking)\fR [virtual]\fP"

.PP
Input multiple bytes that may be modified by callee on a channel\&. 
.PP
\fBParameters\fP
.RS 4
\fIchannel\fP the channel to process the data 
.br
\fIinString\fP the byte buffer to process 
.br
\fIlength\fP the size of the string, in bytes 
.br
\fImessageEnd\fP means how many filters to signal \fBMessageEnd()\fP to, including this one 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain to be processed (i\&.e\&., bytes not processed) 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "void ChannelSwitch::IsolatedInitialize (const \fBNameValuePairs\fP & parameters = \fRg_nullNameValuePairs\fP)\fR [virtual]\fP"

.PP
Initialize or reinitialize this object, without signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIparameters\fP a set of \fBNameValuePairs\fP to initialize this object 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented\fP\fP 
.RE
.PP
\fBIsolatedInitialize()\fP is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments\&. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters\&.

.PP
\fBIsolatedInitialize()\fP does not call \fBInitialize()\fP on attached transformations\&. If initialization should be propagated, then use the \fBInitialize()\fP function\&.

.PP
If a derived class does not override \fBIsolatedInitialize()\fP, then the base class throws \fBNotImplemented\fP\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
