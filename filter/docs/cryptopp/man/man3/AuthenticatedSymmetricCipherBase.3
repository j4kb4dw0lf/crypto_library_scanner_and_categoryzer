.TH "AuthenticatedSymmetricCipherBase" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AuthenticatedSymmetricCipherBase \- Base class for authenticated encryption modes of operation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <authenc\&.h>\fP
.PP
Inherits \fBAuthenticatedSymmetricCipher\fP\&.
.PP
Inherited by \fBCCM_Base\fP, \fBChaCha20Poly1305_Base\fP, \fBEAX_Base\fP, \fBGCM_Base\fP, and \fBXChaCha20Poly1305_Base\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBIsRandomAccess\fP () const"
.br
.RI "Determines whether the cipher supports random access\&. "
.ti -1c
.RI "bool \fBIsSelfInverting\fP () const"
.br
.RI "Determines whether the cipher is self-inverting\&. "
.ti -1c
.RI "void \fBSetKey\fP (const \fBbyte\fP *userKey, size_t keylength, const \fBNameValuePairs\fP &params)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBRestart\fP ()"
.br
.RI "Restart the hash\&. "
.ti -1c
.RI "void \fBResynchronize\fP (const \fBbyte\fP *iv, int length=\-1)"
.br
.RI "Resynchronize with an IV\&. "
.ti -1c
.RI "void \fBUpdate\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates a hash with additional input\&. "
.ti -1c
.RI "void \fBProcessData\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)"
.br
.RI "Encrypt or decrypt an array of bytes\&. "
.ti -1c
.RI "void \fBTruncatedFinal\fP (\fBbyte\fP *mac, size_t macSize)"
.br
.RI "Computes the hash of the current message\&. "
.in -1c

Public Member Functions inherited from \fBAuthenticatedSymmetricCipher\fP
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBMaxHeaderLength\fP () const =0"
.br
.RI "Provides the maximum length of AAD that can be input\&. "
.ti -1c
.RI "virtual \fBlword\fP \fBMaxMessageLength\fP () const =0"
.br
.RI "Provides the maximum length of encrypted data\&. "
.ti -1c
.RI "virtual \fBlword\fP \fBMaxFooterLength\fP () const"
.br
.RI "Provides the maximum length of AAD\&. "
.ti -1c
.RI "virtual bool \fBNeedsPrespecifiedDataLengths\fP () const"
.br
.RI "Determines if data lengths must be specified prior to inputting data\&. "
.ti -1c
.RI "void \fBSpecifyDataLengths\fP (\fBlword\fP headerLength, \fBlword\fP messageLength, \fBlword\fP footerLength=0)"
.br
.RI "Prescribes the data lengths\&. "
.ti -1c
.RI "virtual void \fBEncryptAndAuthenticate\fP (\fBbyte\fP *ciphertext, \fBbyte\fP *mac, size_t macSize, const \fBbyte\fP *iv, int ivLength, const \fBbyte\fP *header, size_t headerLength, const \fBbyte\fP *message, size_t messageLength)"
.br
.RI "Encrypts and calculates a MAC in one call\&. "
.ti -1c
.RI "virtual bool \fBDecryptAndVerify\fP (\fBbyte\fP *message, const \fBbyte\fP *mac, size_t macSize, const \fBbyte\fP *iv, int ivLength, const \fBbyte\fP *header, size_t headerLength, const \fBbyte\fP *ciphertext, size_t ciphertextLength)"
.br
.RI "Decrypts and verifies a MAC in one call\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual size_t \fBMinKeyLength\fP () const =0"
.br
.RI "Returns smallest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBMaxKeyLength\fP () const =0"
.br
.RI "Returns largest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBDefaultKeyLength\fP () const =0"
.br
.RI "Returns default key length\&. "
.ti -1c
.RI "virtual size_t \fBGetValidKeyLength\fP (size_t keylength) const =0"
.br
.RI "Returns a valid key length for the algorithm\&. "
.ti -1c
.RI "virtual bool \fBIsValidKeyLength\fP (size_t keylength) const"
.br
.RI "Returns whether keylength is a valid key length\&. "
.ti -1c
.RI "void \fBSetKeyWithRounds\fP (const \fBbyte\fP *key, size_t length, int rounds)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv, size_t ivLength)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "virtual \fBIV_Requirement\fP \fBIVRequirement\fP () const =0"
.br
.RI "Minimal requirement for secure IVs\&. "
.ti -1c
.RI "bool \fBIsResynchronizable\fP () const"
.br
.RI "Determines if the object can be resynchronized\&. "
.ti -1c
.RI "bool \fBCanUseRandomIVs\fP () const"
.br
.RI "Determines if the object can use random IVs\&. "
.ti -1c
.RI "bool \fBCanUsePredictableIVs\fP () const"
.br
.RI "Determines if the object can use random but possibly predictable IVs\&. "
.ti -1c
.RI "bool \fBCanUseStructuredIVs\fP () const"
.br
.RI "Determines if the object can use structured IVs\&. "
.ti -1c
.RI "virtual unsigned int \fBIVSize\fP () const"
.br
.RI "Returns length of the IV accepted by this object\&. "
.ti -1c
.RI "unsigned int \fBDefaultIVLength\fP () const"
.br
.RI "Provides the default size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMinIVLength\fP () const"
.br
.RI "Provides the minimum size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMaxIVLength\fP () const"
.br
.RI "Provides the maximum size of an IV\&. "
.ti -1c
.RI "virtual void \fBGetNextIV\fP (\fBRandomNumberGenerator\fP &rng, \fBbyte\fP *iv)"
.br
.RI "Retrieves a secure IV for the next message\&. "
.in -1c

Public Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "\fBHashTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual \fBbyte\fP * \fBCreateUpdateSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "virtual void \fBFinal\fP (\fBbyte\fP *digest)"
.br
.RI "Computes the hash of the current message\&. "
.ti -1c
.RI "virtual unsigned int \fBDigestSize\fP () const =0"
.br
.ti -1c
.RI "unsigned int \fBTagSize\fP () const"
.br
.ti -1c
.RI "virtual unsigned int \fBBlockSize\fP () const"
.br
.RI "Provides the block size of the compression function\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this hash\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual void \fBCalculateDigest\fP (\fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerify\fP (const \fBbyte\fP *digest)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyDigest\fP (const \fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.ti -1c
.RI "virtual void \fBCalculateTruncatedDigest\fP (\fBbyte\fP *digest, size_t digestSize, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBTruncatedVerify\fP (const \fBbyte\fP *digest, size_t digestLength)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyTruncatedDigest\fP (const \fBbyte\fP *digest, size_t digestLength, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBStreamTransformation\fP
.in +1c
.ti -1c
.RI "\fBStreamTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual unsigned int \fBMandatoryBlockSize\fP () const"
.br
.RI "Provides the mandatory block size of the cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBGetOptimalBlockSizeUsed\fP () const"
.br
.RI "Provides the number of bytes used in the current block when processing at optimal block size\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual size_t \fBProcessLastBlock\fP (\fBbyte\fP *outString, size_t outLength, const \fBbyte\fP *inString, size_t inLength)"
.br
.RI "Encrypt or decrypt the last block of data\&. "
.ti -1c
.RI "virtual unsigned int \fBMinLastBlockSize\fP () const"
.br
.RI "Provides the size of the last block\&. "
.ti -1c
.RI "virtual bool \fBIsLastBlockSpecial\fP () const"
.br
.RI "Determines if the last block receives special processing\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *inoutString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "\fBbyte\fP \fBProcessByte\fP (\fBbyte\fP input)"
.br
.RI "Encrypt or decrypt a byte\&. "
.ti -1c
.RI "virtual void \fBSeek\fP (\fBlword\fP pos)"
.br
.RI "Seek to an absolute position\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum \fBState\fP { \fBState_Start\fP, \fBState_KeySet\fP, \fBState_IVSet\fP, \fBState_AuthUntransformed\fP, \fBState_AuthTransformed\fP, \fBState_AuthFooter\fP }"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBUncheckedSetKey\fP (const \fBbyte\fP *key, unsigned int length, const CryptoPP::NameValuePairs &params)"
.br
.ti -1c
.RI "void \fBAuthenticateData\fP (const \fBbyte\fP *data, size_t len)"
.br
.ti -1c
.RI "const \fBSymmetricCipher\fP & \fBGetSymmetricCipher\fP () const"
.br
.ti -1c
.RI "virtual \fBSymmetricCipher\fP & \fBAccessSymmetricCipher\fP ()=0"
.br
.ti -1c
.RI "virtual bool \fBAuthenticationIsOnPlaintext\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBAuthenticationBlockSize\fP () const =0"
.br
.ti -1c
.RI "virtual void \fBSetKeyWithoutResync\fP (const \fBbyte\fP *userKey, size_t keylength, const \fBNameValuePairs\fP &params)=0"
.br
.ti -1c
.RI "virtual void \fBResync\fP (const \fBbyte\fP *iv, size_t len)=0"
.br
.ti -1c
.RI "virtual size_t \fBAuthenticateBlocks\fP (const \fBbyte\fP *data, size_t len)=0"
.br
.ti -1c
.RI "virtual void \fBAuthenticateLastHeaderBlock\fP ()=0"
.br
.ti -1c
.RI "virtual void \fBAuthenticateLastConfidentialBlock\fP ()"
.br
.ti -1c
.RI "virtual void \fBAuthenticateLastFooterBlock\fP (\fBbyte\fP *mac, size_t macSize)=0"
.br
.in -1c

Protected Member Functions inherited from \fBAuthenticatedSymmetricCipher\fP
.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.ti -1c
.RI "virtual void \fBUncheckedSpecifyDataLengths\fP (\fBlword\fP headerLength, \fBlword\fP messageLength, \fBlword\fP footerLength)"
.br
.in -1c

Protected Member Functions inherited from \fBMessageAuthenticationCode\fP
.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.in -1c

Protected Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual void \fBUncheckedSetKey\fP (const \fBbyte\fP *key, unsigned int length, const \fBNameValuePairs\fP &params)=0"
.br
.RI "Sets the key for this object without performing parameter validation\&. "
.ti -1c
.RI "void \fBThrowIfInvalidKeyLength\fP (size_t length)"
.br
.RI "Validates the key length\&. "
.ti -1c
.RI "void \fBThrowIfResynchronizable\fP ()"
.br
.RI "Validates the object\&. "
.ti -1c
.RI "void \fBThrowIfInvalidIV\fP (const \fBbyte\fP *iv)"
.br
.RI "Validates the IV\&. "
.ti -1c
.RI "size_t \fBThrowIfInvalidIVLength\fP (int length)"
.br
.RI "Validates the IV length\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBGetIVAndThrowIfInvalid\fP (const \fBNameValuePairs\fP &params, size_t &size)"
.br
.RI "Retrieves and validates the IV\&. "
.ti -1c
.RI "void \fBAssertValidKeyLength\fP (size_t length) const"
.br
.RI "Validates the key length\&. "
.in -1c

Protected Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidTruncatedSize\fP (size_t size) const"
.br
.RI "Validates a truncated digest size\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBAlignedSecByteBlock\fP \fBm_buffer\fP"
.br
.ti -1c
.RI "\fBlword\fP \fBm_totalHeaderLength\fP"
.br
.ti -1c
.RI "\fBlword\fP \fBm_totalMessageLength\fP"
.br
.ti -1c
.RI "\fBlword\fP \fBm_totalFooterLength\fP"
.br
.ti -1c
.RI "unsigned int \fBm_bufferedDataLength\fP"
.br
.ti -1c
.RI "State \fBm_state\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "enum \fBIV_Requirement\fP { \fBUNIQUE_IV\fP = 0, \fBRANDOM_IV\fP, \fBUNPREDICTABLE_RANDOM_IV\fP, \fBINTERNALLY_GENERATED_IV\fP, \fBNOT_RESYNCHRONIZABLE\fP }"
.br
.RI "Secure IVs requirements as enumerated values\&. "
.in -1c
.SH "Detailed Description"
.PP 
Base class for authenticated encryption modes of operation\&. 

AuthenticatedSymmetricCipherBase() serves as a base implementation for one direction (encryption or decryption) of a stream cipher or block cipher mode with authentication\&.

.PP
Crypto++ provides four authenticated encryption modes of operation - \fBCCM\fP, \fBEAX\fP, \fBGCM\fP and OCB mode\&. All modes derive from AuthenticatedSymmetricCipherBase() and the motivation for the API, like calling AAD a "header", can be found in Bellare, Rogaway and Wagner's \fRThe EAX Mode of Operation\fP\&. The \fBEAX\fP paper suggested a basic API to help standardize AEAD schemes in software and promote adoption of the modes\&. 
.PP
\fBSee also\fP
.RS 4
\fRAuthenticated Encryption\fP on the Crypto++ wiki\&. 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 5\&.6\&.0 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool AuthenticatedSymmetricCipherBase::IsRandomAccess () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines whether the cipher supports random access\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher supports random access, false otherwise 
.RE
.PP

.PP
Implements \fBStreamTransformation\fP\&.
.SS "bool AuthenticatedSymmetricCipherBase::IsSelfInverting () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines whether the cipher is self-inverting\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher is self-inverting, false otherwise
.RE
.PP
IsSelfInverting determines whether this transformation is self-inverting (e\&.g\&. xor with a keystream)\&. 
.PP
Implements \fBStreamTransformation\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::ProcessData (\fBbyte\fP * outString, const \fBbyte\fP * inString, size_t length)\fR [virtual]\fP"

.PP
Encrypt or decrypt an array of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP the output byte buffer 
.br
\fIinString\fP the input byte buffer 
.br
\fIlength\fP the size of the input and output byte buffers, in bytes
.RE
.PP
ProcessData is called with a string of bytes whose size depends on MandatoryBlockSize\&. Either \fRinString == outString\fP, or they must not overlap\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Implements \fBStreamTransformation\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::Restart ()\fR [inline]\fP, \fR [virtual]\fP"

.PP
Restart the hash\&. Discards the current state, and restart for a new message 
.PP
Reimplemented from \fBHashTransformation\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::Resynchronize (const \fBbyte\fP * iv, int ivLength = \fR\-1\fP)\fR [virtual]\fP"

.PP
Resynchronize with an IV\&. 
.PP
\fBParameters\fP
.RS 4
\fIiv\fP the initialization vector 
.br
\fIivLength\fP the size of the initialization vector, in bytes
.RE
.PP
\fBResynchronize()\fP resynchronizes with an IV provided by the caller\&. \fRivLength=-1\fP means use \fBIVSize()\fP\&. 
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented()\fP\fP if the object does not support resynchronization 
.RE
.PP

.PP
Reimplemented from \fBSimpleKeyingInterface\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::SetKey (const \fBbyte\fP * key, size_t length, const \fBNameValuePairs\fP & params)\fR [virtual]\fP"

.PP
Sets or reset the key of this object\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the key to use when keying the object 
.br
\fIlength\fP the size of the key, in bytes 
.br
\fIparams\fP additional initialization parameters to configure this object 
.RE
.PP

.PP
Reimplemented from \fBSimpleKeyingInterface\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::TruncatedFinal (\fBbyte\fP * digest, size_t digestSize)\fR [virtual]\fP"

.PP
Computes the hash of the current message\&. 
.PP
\fBParameters\fP
.RS 4
\fIdigest\fP a pointer to the buffer to receive the hash 
.br
\fIdigestSize\fP the size of the truncated digest, in bytes
.RE
.PP
\fBTruncatedFinal()\fP calls \fBFinal()\fP and then copies digestSize bytes to digest\&. The hash is restarted the hash for the next message\&. 
.PP
\fBPrecondition\fP
.RS 4
\fRCOUNTOF(digest) <= \fBDigestSize()\fP\fP or \fRCOUNTOF(digest) <= HASH::DIGESTSIZE\fP ensures the output byte buffer is a valid size\&. 
.RE
.PP

.PP
Implements \fBHashTransformation\fP\&.
.SS "void AuthenticatedSymmetricCipherBase::Update (const \fBbyte\fP * input, size_t length)\fR [virtual]\fP"

.PP
Updates a hash with additional input\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP the additional input as a buffer 
.br
\fIlength\fP the size of the buffer, in bytes 
.RE
.PP

.PP
Implements \fBHashTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
