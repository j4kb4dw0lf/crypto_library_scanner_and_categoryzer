.TH "SAFER::Base" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SAFER::Base \- \fBSAFER\fP block cipher default operation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <safer\&.h>\fP
.PP
Inherits \fBBlockCipher\fP\&.
.PP
Inherited by \fBSAFER::Dec\fP, and \fBSAFER::Enc\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "void \fBUncheckedSetKey\fP (const \fBbyte\fP *userkey, unsigned int length, const \fBNameValuePairs\fP &params)"
.br
.RI "Sets the key for this object without performing parameter validation\&. "
.in -1c

Public Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual size_t \fBMinKeyLength\fP () const =0"
.br
.RI "Returns smallest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBMaxKeyLength\fP () const =0"
.br
.RI "Returns largest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBDefaultKeyLength\fP () const =0"
.br
.RI "Returns default key length\&. "
.ti -1c
.RI "virtual size_t \fBGetValidKeyLength\fP (size_t keylength) const =0"
.br
.RI "Returns a valid key length for the algorithm\&. "
.ti -1c
.RI "virtual bool \fBIsValidKeyLength\fP (size_t keylength) const"
.br
.RI "Returns whether keylength is a valid key length\&. "
.ti -1c
.RI "virtual void \fBSetKey\fP (const \fBbyte\fP *key, size_t length, const \fBNameValuePairs\fP &params=g_nullNameValuePairs)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithRounds\fP (const \fBbyte\fP *key, size_t length, int rounds)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv, size_t ivLength)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "virtual \fBIV_Requirement\fP \fBIVRequirement\fP () const =0"
.br
.RI "Minimal requirement for secure IVs\&. "
.ti -1c
.RI "bool \fBIsResynchronizable\fP () const"
.br
.RI "Determines if the object can be resynchronized\&. "
.ti -1c
.RI "bool \fBCanUseRandomIVs\fP () const"
.br
.RI "Determines if the object can use random IVs\&. "
.ti -1c
.RI "bool \fBCanUsePredictableIVs\fP () const"
.br
.RI "Determines if the object can use random but possibly predictable IVs\&. "
.ti -1c
.RI "bool \fBCanUseStructuredIVs\fP () const"
.br
.RI "Determines if the object can use structured IVs\&. "
.ti -1c
.RI "virtual unsigned int \fBIVSize\fP () const"
.br
.RI "Returns length of the IV accepted by this object\&. "
.ti -1c
.RI "unsigned int \fBDefaultIVLength\fP () const"
.br
.RI "Provides the default size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMinIVLength\fP () const"
.br
.RI "Provides the minimum size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMaxIVLength\fP () const"
.br
.RI "Provides the maximum size of an IV\&. "
.ti -1c
.RI "virtual void \fBResynchronize\fP (const \fBbyte\fP *iv, int ivLength=\-1)"
.br
.RI "Resynchronize with an IV\&. "
.ti -1c
.RI "virtual void \fBGetNextIV\fP (\fBRandomNumberGenerator\fP &rng, \fBbyte\fP *iv)"
.br
.RI "Retrieves a secure IV for the next message\&. "
.in -1c

Public Member Functions inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "virtual void \fBProcessAndXorBlock\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const =0"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (const \fBbyte\fP *inBlock, \fBbyte\fP *outBlock) const"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (\fBbyte\fP *inoutBlock) const"
.br
.RI "Encrypt or decrypt a block in place\&. "
.ti -1c
.RI "virtual unsigned int \fBBlockSize\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBIsPermutation\fP () const"
.br
.RI "Determines if the transformation is a permutation\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalNumberOfParallelBlocks\fP () const"
.br
.RI "Determines the number of blocks that can be processed in parallel\&. "
.ti -1c
.RI "virtual size_t \fBAdvancedProcessBlocks\fP (const \fBbyte\fP *inBlocks, const \fBbyte\fP *xorBlocks, \fBbyte\fP *outBlocks, size_t length, \fBword32\fP flags) const"
.br
.RI "Encrypt and xor multiple blocks using additional flags\&. "
.ti -1c
.RI "\fBCipherDir\fP \fBGetCipherDirection\fP () const"
.br
.RI "Provides the direction of the cipher\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBStrengthened\fP () const =0"
.br
.in -1c

Protected Member Functions inherited from \fBBlockCipher\fP
.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.in -1c

Protected Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidKeyLength\fP (size_t length)"
.br
.RI "Validates the key length\&. "
.ti -1c
.RI "void \fBThrowIfResynchronizable\fP ()"
.br
.RI "Validates the object\&. "
.ti -1c
.RI "void \fBThrowIfInvalidIV\fP (const \fBbyte\fP *iv)"
.br
.RI "Validates the IV\&. "
.ti -1c
.RI "size_t \fBThrowIfInvalidIVLength\fP (int length)"
.br
.RI "Validates the IV length\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBGetIVAndThrowIfInvalid\fP (const \fBNameValuePairs\fP &params, size_t &size)"
.br
.RI "Retrieves and validates the IV\&. "
.ti -1c
.RI "void \fBAssertValidKeyLength\fP (size_t length) const"
.br
.RI "Validates the key length\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBSecByteBlock\fP \fBkeySchedule\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static const \fBbyte\fP \fBexp_tab\fP [256]"
.br
.ti -1c
.RI "static const \fBbyte\fP \fBlog_tab\fP [256]"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "enum \fBIV_Requirement\fP { \fBUNIQUE_IV\fP = 0, \fBRANDOM_IV\fP, \fBUNPREDICTABLE_RANDOM_IV\fP, \fBINTERNALLY_GENERATED_IV\fP, \fBNOT_RESYNCHRONIZABLE\fP }"
.br
.RI "Secure IVs requirements as enumerated values\&. "
.in -1c

Public Types inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "enum \fBFlagsForAdvancedProcessBlocks\fP { \fBBT_InBlockIsCounter\fP =1, \fBBT_DontIncrementInOutPointers\fP =2, \fBBT_XorInput\fP =4, \fBBT_ReverseDirection\fP =8, \fBBT_AllowParallel\fP =16 }"
.br
.RI "Bit flags that control \fBAdvancedProcessBlocks()\fP behavior\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBSAFER\fP block cipher default operation\&. 
.SH "Member Function Documentation"
.PP 
.SS "unsigned int SAFER::Base::OptimalDataAlignment () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides input and output data alignment for optimal performance\&. 
.PP
\fBReturns\fP
.RS 4
the input data alignment that provides optimal performance 
.RE
.PP
\fBSee also\fP
.RS 4
GetAlignment() and OptimalBlockSize() 
.RE
.PP

.PP
Reimplemented from \fBBlockTransformation\fP\&.
.SS "void SAFER::Base::UncheckedSetKey (const \fBbyte\fP * key, unsigned int length, const \fBNameValuePairs\fP & params)\fR [virtual]\fP"

.PP
Sets the key for this object without performing parameter validation\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP a byte buffer used to key the cipher 
.br
\fIlength\fP the length of the byte buffer 
.br
\fIparams\fP additional parameters passed as \fBNameValuePairs\fP
.RE
.PP
key must be at least DEFAULT_KEYLENGTH in length\&. 
.PP
Implements \fBSimpleKeyingInterface\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "const \fBbyte\fP SAFER::Base::exp_tab\fR [static]\fP, \fR [protected]\fP"
\fBInitial value:\fP
.nf
=
    {1, 45, 226, 147, 190, 69, 21, 174, 120, 3, 135, 164, 184, 56, 207, 63,
    8, 103, 9, 148, 235, 38, 168, 107, 189, 24, 52, 27, 187, 191, 114, 247,
    64, 53, 72, 156, 81, 47, 59, 85, 227, 192, 159, 216, 211, 243, 141, 177,
    255, 167, 62, 220, 134, 119, 215, 166, 17, 251, 244, 186, 146, 145, 100, 131,
    241, 51, 239, 218, 44, 181, 178, 43, 136, 209, 153, 203, 140, 132, 29, 20,
    129, 151, 113, 202, 95, 163, 139, 87, 60, 130, 196, 82, 92, 28, 232, 160,
    4, 180, 133, 74, 246, 19, 84, 182, 223, 12, 26, 142, 222, 224, 57, 252,
    32, 155, 36, 78, 169, 152, 158, 171, 242, 96, 208, 108, 234, 250, 199, 217,
    0, 212, 31, 110, 67, 188, 236, 83, 137, 254, 122, 93, 73, 201, 50, 194,
    249, 154, 248, 109, 22, 219, 89, 150, 68, 233, 205, 230, 70, 66, 143, 10,
    193, 204, 185, 101, 176, 210, 198, 172, 30, 65, 98, 41, 46, 14, 116, 80,
    2, 90, 195, 37, 123, 138, 42, 91, 240, 6, 13, 71, 111, 112, 157, 126,
    16, 206, 18, 39, 213, 76, 79, 214, 121, 48, 104, 54, 117, 125, 228, 237,
    128, 106, 144, 55, 162, 94, 118, 170, 197, 127, 61, 175, 165, 229, 25, 97,
    253, 77, 124, 183, 11, 238, 173, 75, 34, 245, 231, 115, 35, 33, 200, 5,
    225, 102, 221, 179, 88, 105, 99, 86, 15, 161, 49, 149, 23, 7, 58, 40}
.PP
.fi

.SS "const \fBbyte\fP SAFER::Base::log_tab\fR [static]\fP, \fR [protected]\fP"
\fBInitial value:\fP
.nf
=
    {128, 0, 176, 9, 96, 239, 185, 253, 16, 18, 159, 228, 105, 186, 173, 248,
    192, 56, 194, 101, 79, 6, 148, 252, 25, 222, 106, 27, 93, 78, 168, 130,
    112, 237, 232, 236, 114, 179, 21, 195, 255, 171, 182, 71, 68, 1, 172, 37,
    201, 250, 142, 65, 26, 33, 203, 211, 13, 110, 254, 38, 88, 218, 50, 15,
    32, 169, 157, 132, 152, 5, 156, 187, 34, 140, 99, 231, 197, 225, 115, 198,
    175, 36, 91, 135, 102, 39, 247, 87, 244, 150, 177, 183, 92, 139, 213, 84,
    121, 223, 170, 246, 62, 163, 241, 17, 202, 245, 209, 23, 123, 147, 131, 188,
    189, 82, 30, 235, 174, 204, 214, 53, 8, 200, 138, 180, 226, 205, 191, 217,
    208, 80, 89, 63, 77, 98, 52, 10, 72, 136, 181, 86, 76, 46, 107, 158,
    210, 61, 60, 3, 19, 251, 151, 81, 117, 74, 145, 113, 35, 190, 118, 42,
    95, 249, 212, 85, 11, 220, 55, 49, 22, 116, 215, 119, 167, 230, 7, 219,
    164, 47, 70, 243, 97, 69, 103, 227, 12, 162, 59, 28, 133, 24, 4, 29,
    41, 160, 143, 178, 90, 216, 166, 126, 238, 141, 83, 75, 161, 154, 193, 14,
    122, 73, 165, 44, 129, 196, 199, 54, 43, 127, 67, 149, 51, 242, 108, 104,
    109, 240, 2, 40, 206, 221, 155, 234, 94, 153, 124, 20, 134, 207, 229, 66,
    184, 64, 120, 45, 58, 233, 100, 31, 146, 144, 125, 57, 111, 224, 137, 48}
.PP
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
