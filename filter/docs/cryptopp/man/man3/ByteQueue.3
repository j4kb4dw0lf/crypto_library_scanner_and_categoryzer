.TH "ByteQueue" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ByteQueue \- Data structure used to store byte strings\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <queue\&.h>\fP
.PP
Inherits \fBBufferless< BufferedTransformation >\fP\&.
.PP
Inherited by \fBDERGeneralEncoder\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBWalker\fP"
.br
.RI "A \fBByteQueue\fP iterator\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBByteQueue\fP (size_t nodeSize=0)"
.br
.RI "Construct a \fBByteQueue\fP\&. "
.ti -1c
.RI "\fBByteQueue\fP (const \fBByteQueue\fP &copy)"
.br
.RI "Copy construct a \fBByteQueue\fP\&. "
.ti -1c
.RI "\fBlword\fP \fBMaxRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.ti -1c
.RI "bool \fBAnyRetrievable\fP () const"
.br
.RI "Determines whether bytes are ready for retrieval\&. "
.ti -1c
.RI "void \fBIsolatedInitialize\fP (const \fBNameValuePairs\fP &parameters)"
.br
.RI "Initialize or reinitialize this object, without signal propagation\&. "
.ti -1c
.RI "\fBbyte\fP * \fBCreatePutSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "size_t \fBPut2\fP (const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes for processing\&. "
.ti -1c
.RI "size_t \fBGet\fP (\fBbyte\fP &outByte)"
.br
.RI "Retrieve a 8-bit byte\&. "
.ti -1c
.RI "size_t \fBGet\fP (\fBbyte\fP *outString, size_t getMax)"
.br
.RI "Retrieve a block of bytes\&. "
.ti -1c
.RI "size_t \fBPeek\fP (\fBbyte\fP &outByte) const"
.br
.RI "Peek a 8-bit byte\&. "
.ti -1c
.RI "size_t \fBPeek\fP (\fBbyte\fP *outString, size_t peekMax) const"
.br
.RI "Peek a block of bytes\&. "
.ti -1c
.RI "size_t \fBTransferTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer bytes from this object to another \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "size_t \fBCopyRangeTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &begin, \fBlword\fP end=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBSetNodeSize\fP (size_t nodeSize)"
.br
.RI "Set node size\&. "
.ti -1c
.RI "\fBlword\fP \fBCurrentSize\fP () const"
.br
.RI "Determine data size\&. "
.ti -1c
.RI "bool \fBIsEmpty\fP () const"
.br
.RI "Determine data availability\&. "
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "\fBEmpty\fP the queue\&. "
.ti -1c
.RI "void \fBUnget\fP (\fBbyte\fP inByte)"
.br
.RI "Insert data in the queue\&. "
.ti -1c
.RI "void \fBUnget\fP (const \fBbyte\fP *inString, size_t length)"
.br
.RI "Insert data in the queue\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBSpy\fP (size_t &contiguousSize) const"
.br
.RI "Peek data in the queue\&. "
.ti -1c
.RI "void \fBLazyPut\fP (const \fBbyte\fP *inString, size_t size)"
.br
.RI "Insert data in the queue\&. "
.ti -1c
.RI "void \fBLazyPutModifiable\fP (\fBbyte\fP *inString, size_t size)"
.br
.RI "Insert data in the queue\&. "
.ti -1c
.RI "void \fBUndoLazyPut\fP (size_t size)"
.br
.RI "Remove data from the queue\&. "
.ti -1c
.RI "void \fBFinalizeLazyPut\fP ()"
.br
.RI "Insert data in the queue\&. "
.ti -1c
.RI "\fBByteQueue\fP & \fBoperator=\fP (const \fBByteQueue\fP &rhs)"
.br
.RI "Assign contents from another \fBByteQueue\fP\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBByteQueue\fP &rhs) const"
.br
.RI "Bitwise compare two \fBByteQueue\fP\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBByteQueue\fP &rhs) const"
.br
.RI "Bitwise compare two \fBByteQueue\fP\&. "
.ti -1c
.RI "\fBbyte\fP \fBoperator[]\fP (\fBlword\fP index) const"
.br
.RI "Retrieve data from the queue\&. "
.ti -1c
.RI "void \fBswap\fP (\fBByteQueue\fP &rhs)"
.br
.RI "Swap contents with another \fBByteQueue\fP\&. "
.in -1c

Public Member Functions inherited from \fBBufferless< BufferedTransformation >\fP
.in +1c
.ti -1c
.RI "bool \fBIsolatedFlush\fP (bool hardFlush, bool blocking)"
.br
.RI "Flushes data buffered by this object, without signal propagation\&. "
.in -1c

Public Member Functions inherited from \fBBufferedTransformation\fP
.in +1c
.ti -1c
.RI "\fBBufferedTransformation\fP ()"
.br
.RI "Construct a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "\fBBufferedTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAttachable\fP ()"
.br
.RI "Determines whether the object allows attachment\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBBufferedTransformation\fP * \fBAttachedTransformation\fP ()"
.br
.RI "Returns the object immediately attached to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual const \fBBufferedTransformation\fP * \fBAttachedTransformation\fP () const"
.br
.RI "Returns the object immediately attached to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBDetach\fP (\fBBufferedTransformation\fP *newAttachment=NULLPTR)"
.br
.RI "Delete the current attachment chain and attach a new one\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBAttach\fP (\fBBufferedTransformation\fP *newAttachment)"
.br
.RI "Add newAttachment to the end of attachment chain\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (\fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord16\fP (\fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord32\fP (\fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord64\fP (word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBCanModifyInput\fP () const"
.br
.RI "Determines whether input can be modified by the callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutModifiable\fP (\fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBMessageEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Signals the end of messages to the object\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutMessageEnd\fP (const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPutModifiable2\fP (\fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBGetMaxWaitObjectCount\fP () const"
.br
.RI "Retrieves the maximum number of waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBGetWaitObjects\fP (WaitObjectContainer &container, CallStack const &callStack)"
.br
.RI "Retrieves waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBIsolatedMessageSeriesEnd\fP (bool blocking)"
.br
.RI "Marks the end of a series of messages, without signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBInitialize\fP (const \fBNameValuePairs\fP &parameters=g_nullNameValuePairs, int propagation=\-1)"
.br
.RI "Initialize or reinitialize this object, with signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBFlush\fP (bool hardFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output, with signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBMessageSeriesEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages, with signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetAutoSignalPropagation\fP (int propagation)"
.br
.RI "Set propagation of automatically generated and transferred signals\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual int \fBGetAutoSignalPropagation\fP () const"
.br
.RI "Retrieve automatic signal propagation value\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBTransferTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP transferMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "move transferMax bytes of the buffered output to target as input "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBSkip\fP (\fBlword\fP skipMax=\fBLWORD_MAX\fP)"
.br
.RI "Discard skipMax bytes from the output buffer\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyRangeTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP position, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object using an index to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBTotalBytesRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessages\fP () const"
.br
.RI "Provides the number of meesages processed by this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAnyMessages\fP () const"
.br
.RI "Determines if any messages are available for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessage\fP ()"
.br
.RI "Start retrieving the next message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBSkipMessages\fP (unsigned int count=UINT_MAX)"
.br
.RI "Skip a number of meessages\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBTransferMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBCopyMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSkipAll\fP ()"
.br
.RI "Skip all messages in the series\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBTransferAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBCopyAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessageSeries\fP ()"
.br
.RI "Retrieve the next message in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessagesInThisSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessageSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferMessagesTo2\fP (\fBBufferedTransformation\fP &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferAllTo2\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, \fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutModifiable\fP (const std::string &channel, \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord16\fP (const std::string &channel, \fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 16-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord32\fP (const std::string &channel, \fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 32-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord64\fP (const std::string &channel, word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 64-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBChannelMessageEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutMessageEnd\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBbyte\fP * \fBChannelCreatePutSpace\fP (const std::string &channel, size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBChannelPut2\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBChannelPutModifiable2\fP (const std::string &channel, \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBChannelFlush\fP (const std::string &channel, bool hardFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBChannelMessageSeriesEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetRetrievalChannel\fP (const std::string &channel)"
.br
.RI "Sets the default retrieval channel\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBWaitable\fP
.in +1c
.ti -1c
.RI "bool \fBWait\fP (unsigned long milliseconds, CallStack const &callStack)"
.br
.RI "Wait on this object\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBCleanupUsedNodes\fP ()"
.br
.ti -1c
.RI "void \fBCopyFrom\fP (const \fBByteQueue\fP &copy)"
.br
.ti -1c
.RI "void \fBDestroy\fP ()"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBWalker\fP"
.br
.in -1c
.SS "Additional Inherited Members"

.in +1c
.ti -1c
.RI "static int \fBDecrementPropagation\fP (int propagation)"
.br
.RI "Decrements the propagation count while clamping at 0\&. "
.in -1c
.SH "Detailed Description"
.PP 
Data structure used to store byte strings\&. 

The queue is implemented as a linked list of byte arrays\&. Each byte array is stored in a \fBByteQueueNode\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fRByteQueue\fP on the Crypto++ wiki\&. 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 2\&.0 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "ByteQueue::ByteQueue (size_t nodeSize = \fR0\fP)"

.PP
Construct a \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fInodeSize\fP the initial node size
.RE
.PP
Internally, \fBByteQueue\fP uses a \fBByteQueueNode\fP to store bytes, and \fRnodeSize\fP determines the size of the \fBByteQueueNode\fP\&. A value of 0 indicates the \fBByteQueueNode\fP should be automatically sized, which means a value of 256 is used\&. 
.SS "ByteQueue::ByteQueue (const \fBByteQueue\fP & copy)"

.PP
Copy construct a \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIcopy\fP the other \fBByteQueue\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool ByteQueue::AnyRetrievable () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines whether bytes are ready for retrieval\&. 
.PP
\fBReturns\fP
.RS 4
true if bytes are available for retrieval, false otherwise 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t ByteQueue::CopyRangeTo2 (\fBBufferedTransformation\fP & target, \fBlword\fP & begin, \fBlword\fP end = \fR\fBLWORD_MAX\fP\fP, const std::string & channel = \fRDEFAULT_CHANNEL\fP, bool blocking = \fRtrue\fP) const\fR [virtual]\fP"

.PP
Copy bytes from this object to another \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the destination \fBBufferedTransformation\fP 
.br
\fIbegin\fP the 0-based index of the first byte to copy in the stream 
.br
\fIend\fP the 0-based index of the last byte to copy in the stream 
.br
\fIchannel\fP the channel on which the transfer should occur 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain in the copy block (i\&.e\&., bytes not copied)
.RE
.PP
CopyRangeTo2 copies bytes from this object to the destination\&. The bytes are not removed from this object\&. Copying begins at the index position in the current stream, and not from an absolute position in the stream\&.

.PP
begin is an \fIIN\fP and \fIOUT\fP parameter\&. When the call is made, begin is the starting position of the copy\&. When the call returns, begin is the position of the first byte that was \fInot\fP copied (which may be different than end)\&. begin can be used for subsequent calls to \fBCopyRangeTo2()\fP\&. 
.PP
Implements \fBBufferedTransformation\fP\&.
.SS "\fBbyte\fP * ByteQueue::CreatePutSpace (size_t & size)\fR [virtual]\fP"

.PP
Request space which can be written into by the caller\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP the requested size of the buffer 
.RE
.PP
\fBReturns\fP
.RS 4
byte pointer to the space to input data
.RE
.PP
The purpose of this method is to help avoid extra memory allocations\&.

.PP
size is an \fIIN\fP and \fIOUT\fP parameter and used as a hint\&. When the call is made, size is the requested size of the buffer\&. When the call returns, size is the size of the array returned to the caller\&.

.PP
The base class implementation sets size to 0 and returns NULL\&. 
.PP
\fBNote\fP
.RS 4
Some objects, like \fBArraySink\fP, cannot create a space because its fixed\&. In the case of an \fBArraySink\fP, the pointer to the array is returned and the size is remaining size\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "\fBlword\fP ByteQueue::CurrentSize () const"

.PP
Determine data size\&. 
.PP
\fBReturns\fP
.RS 4
the data size, in bytes 
.RE
.PP

.SS "void ByteQueue::FinalizeLazyPut ()"

.PP
Insert data in the queue\&. \fBFinalizeLazyPut()\fP copies external data inserted using \fBLazyPut()\fP or \fBLazyPutModifiable()\fP into the tail of the queue\&. 
.PP
\fBSee also\fP
.RS 4
\fBLazyPutter\fP 
.RE
.PP

.SS "size_t ByteQueue::Get (\fBbyte\fP & outByte)\fR [virtual]\fP"

.PP
Retrieve a 8-bit byte\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutByte\fP the 8-bit value to be retrieved 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes consumed during the call\&.
.RE
.PP
Use the return value of Get to detect short reads\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t ByteQueue::Get (\fBbyte\fP * outString, size_t getMax)\fR [virtual]\fP"

.PP
Retrieve a block of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP a block of bytes 
.br
\fIgetMax\fP the number of bytes to Get 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes consumed during the call\&.
.RE
.PP
Use the return value of Get to detect short reads\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "bool ByteQueue::IsEmpty () const"

.PP
Determine data availability\&. 
.PP
\fBReturns\fP
.RS 4
true if the \fBByteQueue\fP has data, false otherwise 
.RE
.PP

.SS "void ByteQueue::IsolatedInitialize (const \fBNameValuePairs\fP & parameters)\fR [virtual]\fP"

.PP
Initialize or reinitialize this object, without signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIparameters\fP a set of \fBNameValuePairs\fP to initialize this object 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented\fP\fP 
.RE
.PP
\fBIsolatedInitialize()\fP is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments\&. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters\&.

.PP
\fBIsolatedInitialize()\fP does not call \fBInitialize()\fP on attached transformations\&. If initialization should be propagated, then use the \fBInitialize()\fP function\&.

.PP
If a derived class does not override \fBIsolatedInitialize()\fP, then the base class throws \fBNotImplemented\fP\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "void ByteQueue::LazyPut (const \fBbyte\fP * inString, size_t size)"

.PP
Insert data in the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIinString\fP a byte array to insert 
.br
\fIsize\fP the length of the byte array
.RE
.PP
\fBLazyPut()\fP inserts a byte array at the tail of the queue\&. The data may not be copied at this point\&. Rather, the pointer and size to external data are recorded\&.

.PP
Another call to \fBPut()\fP or \fBLazyPut()\fP will force the data to be copied\&. When lazy puts are used, the data is copied when \fBFinalizeLazyPut()\fP is called\&. 
.PP
\fBSee also\fP
.RS 4
\fBLazyPutter\fP 
.RE
.PP

.SS "void ByteQueue::LazyPutModifiable (\fBbyte\fP * inString, size_t size)"

.PP
Insert data in the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIinString\fP a byte array to insert 
.br
\fIsize\fP the length of the byte array
.RE
.PP
\fBLazyPut()\fP inserts a byte array at the tail of the queue\&. The data may not be copied at this point\&. Rather, the pointer and size to external data are recorded\&.

.PP
Another call to \fBPut()\fP or \fBLazyPut()\fP will force the data to be copied\&. When lazy puts are used, the data is copied when \fBFinalizeLazyPut()\fP is called\&. 
.PP
\fBSee also\fP
.RS 4
\fBLazyPutter\fP 
.RE
.PP

.SS "\fBlword\fP ByteQueue::MaxRetrievable () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the number of bytes ready for retrieval\&. 
.PP
\fBReturns\fP
.RS 4
the number of bytes ready for retrieval
.RE
.PP
The number of bytes available are dependent on the source\&. If an exact value is available, then the exact value is returned\&. The exact value can include 0 if the source is exhausted\&.

.PP
Some stream-based sources do not allow seeking() on the underlying stream, such as some \fBFileSource()\fP\&. If the stream does not allow seeking() then \fBMaxRetrievable()\fP returns LWORD_MAX to indicate there are still bytes to be retrieved\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "bool ByteQueue::operator!= (const \fBByteQueue\fP & rhs) const\fR [inline]\fP"

.PP
Bitwise compare two \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP the other \fBByteQueue\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true if the size and bits are not equal, false otherwise
.RE
.PP
\fBoperator!=()\fP is implemented in terms of \fBoperator==()\fP\&. \fBoperator==()\fP is not constant time\&. 
.SS "\fBByteQueue\fP & ByteQueue::operator= (const \fBByteQueue\fP & rhs)"

.PP
Assign contents from another \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP the other \fBByteQueue\fP 
.RE
.PP
\fBReturns\fP
.RS 4
reference to this \fBByteQueue\fP 
.RE
.PP

.SS "bool ByteQueue::operator== (const \fBByteQueue\fP & rhs) const"

.PP
Bitwise compare two \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP the other \fBByteQueue\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true if the size and bits are equal, false otherwise
.RE
.PP
\fBoperator==()\fP walks each \fBByteQueue\fP comparing bytes in each queue\&. \fBoperator==()\fP is not constant time\&. 
.SS "\fBbyte\fP ByteQueue::operator[] (\fBlword\fP index) const"

.PP
Retrieve data from the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP of byte to retrieve 
.RE
.PP
\fBReturns\fP
.RS 4
byte at the specified index
.RE
.PP
\fBoperator[]()\fP does not perform bounds checking\&. 
.SS "size_t ByteQueue::Peek (\fBbyte\fP & outByte) const\fR [virtual]\fP"

.PP
Peek a 8-bit byte\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutByte\fP the 8-bit value to be retrieved 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes read during the call\&.
.RE
.PP
Peek does not remove bytes from the object\&. Use the return value of \fBGet()\fP to detect short reads\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t ByteQueue::Peek (\fBbyte\fP * outString, size_t peekMax) const\fR [virtual]\fP"

.PP
Peek a block of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP a block of bytes 
.br
\fIpeekMax\fP the number of bytes to Peek 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes read during the call\&.
.RE
.PP
Peek does not remove bytes from the object\&. Use the return value of \fBPeek()\fP to detect short reads\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t ByteQueue::Put2 (const \fBbyte\fP * inString, size_t length, int messageEnd, bool blocking)\fR [virtual]\fP"

.PP
Input multiple bytes for processing\&. 
.PP
\fBParameters\fP
.RS 4
\fIinString\fP the byte buffer to process 
.br
\fIlength\fP the size of the string, in bytes 
.br
\fImessageEnd\fP means how many filters to signal \fBMessageEnd()\fP to, including this one 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain to be processed (i\&.e\&., bytes not processed)\&. 0 indicates all bytes were processed\&.
.RE
.PP
Derived classes must implement \fBPut2()\fP\&. 
.PP
Implements \fBBufferedTransformation\fP\&.
.SS "void ByteQueue::SetNodeSize (size_t nodeSize)"

.PP
Set node size\&. 
.PP
\fBParameters\fP
.RS 4
\fInodeSize\fP the new node size, in bytes
.RE
.PP
The default node size is 256\&. 
.SS "const \fBbyte\fP * ByteQueue::Spy (size_t & contiguousSize) const"

.PP
Peek data in the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIcontiguousSize\fP the size of the data
.RE
.PP
\fBSpy()\fP peeks at data at the head of the queue\&. \fBSpy()\fP does not remove data from the queue\&.

.PP
The data's size is returned in \fRcontiguousSize\fP\&. \fBSpy()\fP returns the size of the first byte array in the list\&. The entire data may be larger since the queue is a linked list of byte arrays\&. 
.SS "void ByteQueue::swap (\fBByteQueue\fP & rhs)"

.PP
Swap contents with another \fBByteQueue\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP the other \fBByteQueue\fP 
.RE
.PP

.SS "size_t ByteQueue::TransferTo2 (\fBBufferedTransformation\fP & target, \fBlword\fP & byteCount, const std::string & channel = \fRDEFAULT_CHANNEL\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Transfer bytes from this object to another \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the destination \fBBufferedTransformation\fP 
.br
\fIbyteCount\fP the number of bytes to transfer 
.br
\fIchannel\fP the channel on which the transfer should occur 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain in the transfer block (i\&.e\&., bytes not transferred)
.RE
.PP
\fBTransferTo2()\fP removes bytes from this object and moves them to the destination\&. Transfer begins at the index position in the current stream, and not from an absolute position in the stream\&.

.PP
byteCount is an \fIIN\fP and \fIOUT\fP parameter\&. When the call is made, byteCount is the requested size of the transfer\&. When the call returns, byteCount is the number of bytes that were transferred\&. 
.PP
Implements \fBBufferedTransformation\fP\&.
.SS "void ByteQueue::UndoLazyPut (size_t size)"

.PP
Remove data from the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP the length of the data 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBInvalidArgument\fP\fP if there is no lazy data in the queue or if size is larger than the lazy string
.RE
.PP
\fBUndoLazyPut()\fP truncates data inserted using \fBLazyPut()\fP by modifying size\&. 
.PP
\fBSee also\fP
.RS 4
\fBLazyPutter\fP 
.RE
.PP

.SS "void ByteQueue::Unget (\fBbyte\fP inByte)"

.PP
Insert data in the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIinByte\fP a byte to insert
.RE
.PP
\fBUnget()\fP inserts a byte at the head of the queue 
.SS "void ByteQueue::Unget (const \fBbyte\fP * inString, size_t length)"

.PP
Insert data in the queue\&. 
.PP
\fBParameters\fP
.RS 4
\fIinString\fP a byte array to insert 
.br
\fIlength\fP the size of the byte array
.RE
.PP
\fBUnget()\fP inserts a byte array at the head of the queue 

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
