.TH "DL_GroupParameters_DSA" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DL_GroupParameters_DSA \- \fBDSA\fP group parameters\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <gfpcrypt\&.h>\fP
.PP
Inherits \fBDL_GroupParameters_GFP\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum { \fBMIN_PRIME_LENGTH\fP = 1024, \fBMAX_PRIME_LENGTH\fP = 3072, \fBPRIME_LENGTH_MULTIPLE\fP = 1024 }"
.br
.RI "\fBDSA\fP prime length\&. "
.in -1c

Public Types inherited from \fBDL_GroupParameters_IntegerBasedImpl< ModExpPrecomputation >\fP
.in +1c
.ti -1c
.RI "typedef \fBModExpPrecomputation::Element\fP \fBElement\fP"
.br
.in -1c

Public Types inherited from \fBDL_GroupParametersImpl< GROUP_PRECOMP, BASE_PRECOMP, BASE >\fP
.in +1c
.ti -1c
.RI "typedef GROUP_PRECOMP \fBGroupPrecomputation\fP"
.br
.ti -1c
.RI "typedef GROUP_PRECOMP::Element \fBElement\fP"
.br
.ti -1c
.RI "typedef BASE_PRECOMP \fBBasePrecomputation\fP"
.br
.in -1c

Public Types inherited from \fBDL_GroupParameters< T >\fP
.in +1c
.ti -1c
.RI "typedef T \fBElement\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBValidateGroup\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check the group for errors\&. "
.ti -1c
.RI "void \fBGenerateRandom\fP (\fBRandomNumberGenerator\fP &rng, const \fBNameValuePairs\fP &alg)"
.br
.RI "Generate a random key or crypto parameters\&. "
.in -1c

Public Member Functions inherited from \fBDL_GroupParameters_GFP\fP
.in +1c
.ti -1c
.RI "bool \fBIsIdentity\fP (const \fBInteger\fP &element) const"
.br
.RI "Determines if an element is an identity\&. "
.ti -1c
.RI "void \fBSimultaneousExponentiate\fP (Element *results, const Element &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Exponentiates a base to multiple exponents\&. "
.ti -1c
.RI "bool \fBGetVoidValue\fP (const char *name, const std::type_info &valueType, void *pValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "Element \fBMultiplyElements\fP (const Element &a, const Element &b) const"
.br
.ti -1c
.RI "Element \fBCascadeExponentiate\fP (const Element &element1, const \fBInteger\fP &exponent1, const Element &element2, const \fBInteger\fP &exponent2) const"
.br
.in -1c

Public Member Functions inherited from \fBDL_GroupParameters_IntegerBasedImpl< ModExpPrecomputation >\fP
.in +1c
.ti -1c
.RI "bool \fBGetVoidValue\fP (const char *name, const std::type_info &valueType, void *pValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "void \fBAssignFrom\fP (const \fBNameValuePairs\fP &source)"
.br
.RI "Assign values to this object\&. "
.ti -1c
.RI "const \fBDL_FixedBasePrecomputation\fP< \fBElement\fP > & \fBGetBasePrecomputation\fP () const"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "\fBDL_FixedBasePrecomputation\fP< \fBElement\fP > & \fBAccessBasePrecomputation\fP ()"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBGetModulus\fP () const"
.br
.RI "Retrieve the modulus for the group\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBGetGenerator\fP () const"
.br
.RI "Retrieves a reference to the group generator\&. "
.ti -1c
.RI "void \fBSetModulusAndSubgroupGenerator\fP (const \fBInteger\fP &p, const \fBInteger\fP &g)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBDL_GroupParameters_IntegerBasedImpl\fP< \fBModExpPrecomputation\fP, \fBDL_FixedBasePrecomputationImpl\fP< typename \fBModExpPrecomputation::Element\fP > > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBDL_GroupParameters_IntegerBasedImpl\fP< \fBModExpPrecomputation\fP, \fBDL_FixedBasePrecomputationImpl\fP< typename \fBModExpPrecomputation::Element\fP > > &rhs) const"
.br
.in -1c

Public Member Functions inherited from \fBDL_GroupParametersImpl< GROUP_PRECOMP, BASE_PRECOMP, BASE >\fP
.in +1c
.ti -1c
.RI "const \fBDL_GroupPrecomputation\fP< Element > & \fBGetGroupPrecomputation\fP () const"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "const \fBDL_FixedBasePrecomputation\fP< Element > & \fBGetBasePrecomputation\fP () const"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "\fBDL_FixedBasePrecomputation\fP< Element > & \fBAccessBasePrecomputation\fP ()"
.br
.RI "Retrieves the group precomputation\&. "
.in -1c

Public Member Functions inherited from \fBDL_GroupParameters< T >\fP
.in +1c
.ti -1c
.RI "bool \fBValidate\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "bool \fBSupportsPrecomputation\fP () const"
.br
.RI "Determines whether the object supports precomputation\&. "
.ti -1c
.RI "void \fBPrecompute\fP (unsigned int precomputationStorage=16)"
.br
.RI "Perform precomputation\&. "
.ti -1c
.RI "void \fBLoadPrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation)"
.br
.RI "Retrieve previously saved precomputation\&. "
.ti -1c
.RI "void \fBSavePrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation) const"
.br
.RI "Save precomputation for later use\&. "
.ti -1c
.RI "virtual const Element & \fBGetSubgroupGenerator\fP () const"
.br
.RI "Retrieves the subgroup generator\&. "
.ti -1c
.RI "virtual void \fBSetSubgroupGenerator\fP (const Element &base)"
.br
.RI "Sets the subgroup generator\&. "
.ti -1c
.RI "virtual Element \fBExponentiateBase\fP (const \fBInteger\fP &exponent) const"
.br
.RI "Exponentiates the base\&. "
.ti -1c
.RI "virtual Element \fBExponentiateElement\fP (const Element &base, const \fBInteger\fP &exponent) const"
.br
.RI "Exponentiates an element\&. "
.ti -1c
.RI "virtual const \fBInteger\fP & \fBGetSubgroupOrder\fP () const =0"
.br
.RI "Retrieves the subgroup order\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBGetMaxExponent\fP () const =0"
.br
.RI "Retrieves the maximum exponent for the group\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBGetGroupOrder\fP () const"
.br
.RI "Retrieves the order of the group\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBGetCofactor\fP () const"
.br
.RI "Retrieves the cofactor\&. "
.ti -1c
.RI "virtual unsigned int \fBGetEncodedElementSize\fP (bool reversible) const =0"
.br
.RI "Retrieves the encoded element's size\&. "
.ti -1c
.RI "virtual void \fBEncodeElement\fP (bool reversible, const Element &element, \fBbyte\fP *encoded) const =0"
.br
.RI "Encodes the element\&. "
.ti -1c
.RI "virtual Element \fBDecodeElement\fP (const \fBbyte\fP *encoded, bool checkForGroupMembership) const =0"
.br
.RI "Decodes the element\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBConvertElementToInteger\fP (const Element &element) const =0"
.br
.RI "Converts an element to an \fBInteger\fP\&. "
.ti -1c
.RI "virtual bool \fBValidateElement\fP (unsigned int level, const Element &element, const \fBDL_FixedBasePrecomputation\fP< Element > *precomp) const =0"
.br
.RI "Check the element for errors\&. "
.ti -1c
.RI "virtual bool \fBFastSubgroupCheckAvailable\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBIsIdentity\fP (const Element &element) const =0"
.br
.RI "Determines if an element is an identity\&. "
.ti -1c
.RI "virtual void \fBSimultaneousExponentiate\fP (Element *results, const Element &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const =0"
.br
.RI "Exponentiates a base to multiple exponents\&. "
.in -1c

Public Member Functions inherited from \fBGeneratableCryptoMaterial\fP
.in +1c
.ti -1c
.RI "void \fBGenerateRandomWithKeySize\fP (\fBRandomNumberGenerator\fP &rng, unsigned int keySize)"
.br
.RI "Generate a random key or crypto parameters\&. "
.in -1c

Public Member Functions inherited from \fBCryptoMaterial\fP
.in +1c
.ti -1c
.RI "virtual void \fBThrowIfInvalid\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "virtual void \fBSave\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Saves a key to a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "virtual void \fBLoad\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Loads a key from a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBDoQuickSanityCheck\fP () const"
.br
.RI "Perform a quick sanity check\&. "
.in -1c

Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "template<class T> bool \fBGetThisObject\fP (T &object) const"
.br
.RI "Get a copy of this object or subobject\&. "
.ti -1c
.RI "template<class T> bool \fBGetThisPointer\fP (T *&ptr) const"
.br
.RI "Get a pointer to this object\&. "
.ti -1c
.RI "template<class T> bool \fBGetValue\fP (const char *name, T &value) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "template<class T> T \fBGetValueWithDefault\fP (const char *name, T defaultValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "CRYPTOPP_DLL std::string \fBGetValueNames\fP () const"
.br
.RI "Get a list of value names that can be retrieved\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetIntValue\fP (const char *name, int &value) const"
.br
.RI "Get a named value with type int\&. "
.ti -1c
.RI "CRYPTOPP_DLL int \fBGetIntValueWithDefault\fP (const char *name, int defaultValue) const"
.br
.RI "Get a named value with type int, with default\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetWord64Value\fP (const char *name, word64 &value) const"
.br
.RI "Get a named value with type word64\&. "
.ti -1c
.RI "CRYPTOPP_DLL word64 \fBGetWord64ValueWithDefault\fP (const char *name, word64 defaultValue) const"
.br
.RI "Get a named value with type word64, with default\&. "
.ti -1c
.RI "template<class T> void \fBGetRequiredParameter\fP (const char *className, const char *name, T &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.ti -1c
.RI "CRYPTOPP_DLL void \fBGetRequiredIntParameter\fP (const char *className, const char *name, int &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool CRYPTOPP_API \fBIsValidPrimeLength\fP (unsigned int pbits)"
.br
.RI "Check the prime length for errors\&. "
.in -1c

Static Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "static CRYPTOPP_DLL void CRYPTOPP_API \fBThrowIfTypeMismatch\fP (const char *name, const std::type_info &stored, const std::type_info &retrieving)"
.br
.RI "Ensures an expected name and type is present\&. "
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBDL_GroupParameters_GFP\fP
.in +1c
.ti -1c
.RI "int \fBGetFieldType\fP () const"
.br
.in -1c

Protected Member Functions inherited from \fBDL_GroupParameters< T >\fP
.in +1c
.ti -1c
.RI "void \fBParametersChanged\fP ()"
.br
.in -1c

Protected Attributes inherited from \fBDL_GroupParametersImpl< GROUP_PRECOMP, BASE_PRECOMP, BASE >\fP
.in +1c
.ti -1c
.RI "GROUP_PRECOMP \fBm_groupPrecomputation\fP"
.br
.ti -1c
.RI "BASE_PRECOMP \fBm_gpc\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBDSA\fP group parameters\&. 

These are GF(p) group parameters that are allowed by the \fBDSA\fP standard 
.PP
\fBSee also\fP
.RS 4
\fBDL_Keys_DSA\fP 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 1\&.0 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBDSA\fP prime length\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMIN_PRIME_LENGTH \fP
Minimum prime length\&. 
.TP
\f(BIMAX_PRIME_LENGTH \fP
Maximum prime length\&. 
.TP
\f(BIPRIME_LENGTH_MULTIPLE \fP
Prime length multiple\&. 
.SH "Member Function Documentation"
.PP 
.SS "void DL_GroupParameters_DSA::GenerateRandom (\fBRandomNumberGenerator\fP & rng, const \fBNameValuePairs\fP & alg)\fR [virtual]\fP"

.PP
Generate a random key or crypto parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP a \fBRandomNumberGenerator\fP to produce keying material 
.br
\fIalg\fP additional initialization parameters
.RE
.PP
\fBNameValuePairs\fP can be ModulusSize alone; or Modulus, SubgroupOrder, and SubgroupGenerator\&. ModulusSize must be between \fRDSA::MIN_PRIME_LENGTH\fP and \fRDSA::MAX_PRIME_LENGTH\fP, and divisible by \fRDSA::PRIME_LENGTH_MULTIPLE\fP\&.

.PP
An example of changing the modulus size using \fBNameValuePairs\fP is shown below\&. 
.PP
.nf

 \fBAlgorithmParameters\fP params = MakeParameters
   (Name::ModulusSize(), 2048);

 \fBDL_GroupParameters_DSA\fP groupParams;
 groupParams\&.GenerateRandom(prng, params);
.fi
.PP
 
.PP
\fBExceptions\fP
.RS 4
\fIKeyingErr\fP if a key can't be generated or algorithm parameters are invalid\&. 
.RE
.PP

.PP
Reimplemented from \fBGeneratableCryptoMaterial\fP\&.
.SS "bool CRYPTOPP_API DL_GroupParameters_DSA::IsValidPrimeLength (unsigned int pbits)\fR [inline]\fP, \fR [static]\fP"

.PP
Check the prime length for errors\&. 
.PP
\fBParameters\fP
.RS 4
\fIpbits\fP number of bits in the prime number 
.RE
.PP
\fBReturns\fP
.RS 4
true if the tests succeed, false otherwise 
.RE
.PP

.SS "bool DL_GroupParameters_DSA::ValidateGroup (\fBRandomNumberGenerator\fP & rng, unsigned int level) const\fR [virtual]\fP"

.PP
Check the group for errors\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP \fBRandomNumberGenerator\fP for objects which use randomized testing 
.br
\fIlevel\fP level of thoroughness 
.RE
.PP
\fBReturns\fP
.RS 4
true if the tests succeed, false otherwise
.RE
.PP
\fBValidateGroup()\fP also checks that the lengths of p and q are allowed by the \fBDSA\fP standard\&.

.PP
There are four levels of thoroughness: 
.PD 0
.IP "\(bu" 2
0 - using this object won't cause a crash or exception 
.IP "\(bu" 2
1 - this object will probably function, and encrypt, sign, other operations correctly 
.IP "\(bu" 2
2 - ensure this object will function correctly, and perform reasonable security checks 
.IP "\(bu" 2
3 - perform reasonable security checks, and do checks that may take a long time 
.PP

.PP
Level 0 does not require a \fBRandomNumberGenerator\fP\&. A \fBNullRNG()\fP can be used for level 0\&. Level 1 may not check for weak keys and such\&. Levels 2 and 3 are recommended\&. 
.PP
Implements \fBDL_GroupParameters< T >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
