.TH "DL_GroupParameters_IntegerBased" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DL_GroupParameters_IntegerBased \- Integer-based GroupParameters specialization\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <gfpcrypt\&.h>\fP
.PP
Inherits \fBASN1CryptoMaterial< DL_GroupParameters< Integer > >\fP\&.
.PP
Inherited by \fBDL_GroupParametersImpl< ModExpPrecomputation, DL_FixedBasePrecomputationImpl< typename ModExpPrecomputation::Element >, DL_GroupParameters_IntegerBased >\fP, \fBDL_GroupParametersImpl< GROUP_PRECOMP, DL_FixedBasePrecomputationImpl< typename GROUP_PRECOMP::Element >, DL_GroupParameters_IntegerBased >\fP, and \fBDL_GroupParametersImpl< DL_GroupPrecomputation_LUC, DL_BasePrecomputation_LUC, DL_GroupParameters_IntegerBased >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBInitialize\fP (const \fBDL_GroupParameters_IntegerBased\fP &params)"
.br
.RI "Initialize a group parameters over integers\&. "
.ti -1c
.RI "void \fBInitialize\fP (\fBRandomNumberGenerator\fP &rng, unsigned int pbits)"
.br
.RI "Create a group parameters over integers\&. "
.ti -1c
.RI "void \fBInitialize\fP (const \fBInteger\fP &p, const \fBInteger\fP &g)"
.br
.RI "Initialize a group parameters over integers\&. "
.ti -1c
.RI "void \fBInitialize\fP (const \fBInteger\fP &p, const \fBInteger\fP &q, const \fBInteger\fP &g)"
.br
.RI "Initialize a group parameters over integers\&. "
.ti -1c
.RI "void \fBBERDecode\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Decode this object from a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBDEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode this object into a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBGenerateRandom\fP (\fBRandomNumberGenerator\fP &rng, const \fBNameValuePairs\fP &alg)"
.br
.RI "Generate a random key\&. "
.ti -1c
.RI "bool \fBGetVoidValue\fP (const char *name, const std::type_info &valueType, void *pValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "void \fBAssignFrom\fP (const \fBNameValuePairs\fP &source)"
.br
.RI "Initialize or reinitialize this key\&. "
.ti -1c
.RI "const \fBInteger\fP & \fBGetSubgroupOrder\fP () const"
.br
.RI "Retrieves the subgroup order\&. "
.ti -1c
.RI "\fBInteger\fP \fBGetGroupOrder\fP () const"
.br
.RI "Retrieves the order of the group\&. "
.ti -1c
.RI "bool \fBValidateGroup\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check the group for errors\&. "
.ti -1c
.RI "bool \fBValidateElement\fP (unsigned int level, const \fBInteger\fP &element, const \fBDL_FixedBasePrecomputation\fP< \fBInteger\fP > *precomp) const"
.br
.RI "Check the element for errors\&. "
.ti -1c
.RI "bool \fBFastSubgroupCheckAvailable\fP () const"
.br
.RI "Determine if subgroup membership check is fast\&. "
.ti -1c
.RI "void \fBEncodeElement\fP (bool reversible, const \fBElement\fP &element, \fBbyte\fP *encoded) const"
.br
.RI "Encodes the element\&. "
.ti -1c
.RI "unsigned int \fBGetEncodedElementSize\fP (bool reversible) const"
.br
.RI "Retrieve the encoded element's size\&. "
.ti -1c
.RI "\fBInteger\fP \fBDecodeElement\fP (const \fBbyte\fP *encoded, bool checkForGroupMembership) const"
.br
.RI "Decodes the element\&. "
.ti -1c
.RI "\fBInteger\fP \fBConvertElementToInteger\fP (const \fBElement\fP &element) const"
.br
.RI "Converts an element to an \fBInteger\fP\&. "
.ti -1c
.RI "\fBInteger\fP \fBGetMaxExponent\fP () const"
.br
.RI "Retrieve the maximum exponent for the group\&. "
.ti -1c
.RI "\fBOID\fP \fBGetAlgorithmID\fP () const"
.br
.RI "Retrieve the \fBOID\fP of the algorithm\&. "
.ti -1c
.RI "virtual const \fBInteger\fP & \fBGetModulus\fP () const =0"
.br
.RI "Retrieve the modulus for the group\&. "
.ti -1c
.RI "virtual void \fBSetModulusAndSubgroupGenerator\fP (const \fBInteger\fP &p, const \fBInteger\fP &g)=0"
.br
.RI "Set group parameters\&. "
.ti -1c
.RI "void \fBSetSubgroupOrder\fP (const \fBInteger\fP &q)"
.br
.RI "Set subgroup order\&. "
.in -1c

Public Member Functions inherited from \fBASN1CryptoMaterial< DL_GroupParameters< Integer > >\fP
.in +1c
.ti -1c
.RI "void \fBSave\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "DER encode ASN\&.1 object\&. "
.ti -1c
.RI "void \fBLoad\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "BER decode ASN\&.1 object\&. "
.in -1c

Public Member Functions inherited from \fBASN1Object\fP
.in +1c
.ti -1c
.RI "virtual void \fBBEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode this object into a \fBBufferedTransformation\fP\&. "
.in -1c

Public Member Functions inherited from \fBDL_GroupParameters< Integer >\fP
.in +1c
.ti -1c
.RI "bool \fBValidate\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "bool \fBSupportsPrecomputation\fP () const"
.br
.RI "Determines whether the object supports precomputation\&. "
.ti -1c
.RI "void \fBPrecompute\fP (unsigned int precomputationStorage=16)"
.br
.RI "Perform precomputation\&. "
.ti -1c
.RI "void \fBLoadPrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation)"
.br
.RI "Retrieve previously saved precomputation\&. "
.ti -1c
.RI "void \fBSavePrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation) const"
.br
.RI "Save precomputation for later use\&. "
.ti -1c
.RI "virtual const \fBElement\fP & \fBGetSubgroupGenerator\fP () const"
.br
.RI "Retrieves the subgroup generator\&. "
.ti -1c
.RI "virtual void \fBSetSubgroupGenerator\fP (const \fBElement\fP &base)"
.br
.RI "Sets the subgroup generator\&. "
.ti -1c
.RI "virtual \fBElement\fP \fBExponentiateBase\fP (const \fBInteger\fP &exponent) const"
.br
.RI "Exponentiates the base\&. "
.ti -1c
.RI "virtual \fBElement\fP \fBExponentiateElement\fP (const \fBElement\fP &base, const \fBInteger\fP &exponent) const"
.br
.RI "Exponentiates an element\&. "
.ti -1c
.RI "virtual const \fBDL_GroupPrecomputation\fP< \fBElement\fP > & \fBGetGroupPrecomputation\fP () const=0"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "virtual const \fBDL_FixedBasePrecomputation\fP< \fBElement\fP > & \fBGetBasePrecomputation\fP () const=0"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "virtual \fBDL_FixedBasePrecomputation\fP< \fBElement\fP > & \fBAccessBasePrecomputation\fP ()=0"
.br
.RI "Retrieves the group precomputation\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBGetCofactor\fP () const"
.br
.RI "Retrieves the cofactor\&. "
.ti -1c
.RI "virtual void \fBEncodeElement\fP (bool reversible, const \fBElement\fP &element, \fBbyte\fP *encoded) const=0"
.br
.RI "Encodes the element\&. "
.ti -1c
.RI "virtual \fBInteger\fP \fBConvertElementToInteger\fP (const \fBElement\fP &element) const=0"
.br
.RI "Converts an element to an \fBInteger\fP\&. "
.ti -1c
.RI "virtual bool \fBIsIdentity\fP (const \fBElement\fP &element) const=0"
.br
.RI "Determines if an element is an identity\&. "
.ti -1c
.RI "virtual void \fBSimultaneousExponentiate\fP (\fBElement\fP *results, const \fBElement\fP &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const=0"
.br
.RI "Exponentiates a base to multiple exponents\&. "
.in -1c

Public Member Functions inherited from \fBGeneratableCryptoMaterial\fP
.in +1c
.ti -1c
.RI "void \fBGenerateRandomWithKeySize\fP (\fBRandomNumberGenerator\fP &rng, unsigned int keySize)"
.br
.RI "Generate a random key or crypto parameters\&. "
.in -1c

Public Member Functions inherited from \fBCryptoMaterial\fP
.in +1c
.ti -1c
.RI "virtual void \fBThrowIfInvalid\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "void \fBDoQuickSanityCheck\fP () const"
.br
.RI "Perform a quick sanity check\&. "
.in -1c

Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "template<class T> bool \fBGetThisObject\fP (T &object) const"
.br
.RI "Get a copy of this object or subobject\&. "
.ti -1c
.RI "template<class T> bool \fBGetThisPointer\fP (T *&ptr) const"
.br
.RI "Get a pointer to this object\&. "
.ti -1c
.RI "template<class T> bool \fBGetValue\fP (const char *name, T &value) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "template<class T> T \fBGetValueWithDefault\fP (const char *name, T defaultValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "CRYPTOPP_DLL std::string \fBGetValueNames\fP () const"
.br
.RI "Get a list of value names that can be retrieved\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetIntValue\fP (const char *name, int &value) const"
.br
.RI "Get a named value with type int\&. "
.ti -1c
.RI "CRYPTOPP_DLL int \fBGetIntValueWithDefault\fP (const char *name, int defaultValue) const"
.br
.RI "Get a named value with type int, with default\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetWord64Value\fP (const char *name, word64 &value) const"
.br
.RI "Get a named value with type word64\&. "
.ti -1c
.RI "CRYPTOPP_DLL word64 \fBGetWord64ValueWithDefault\fP (const char *name, word64 defaultValue) const"
.br
.RI "Get a named value with type word64, with default\&. "
.ti -1c
.RI "template<class T> void \fBGetRequiredParameter\fP (const char *className, const char *name, T &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.ti -1c
.RI "CRYPTOPP_DLL void \fBGetRequiredIntParameter\fP (const char *className, const char *name, int &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string CRYPTOPP_API \fBStaticAlgorithmNamePrefix\fP ()"
.br
.in -1c

Static Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "static CRYPTOPP_DLL void CRYPTOPP_API \fBThrowIfTypeMismatch\fP (const char *name, const std::type_info &stored, const std::type_info &retrieving)"
.br
.RI "Ensures an expected name and type is present\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBInteger\fP \fBComputeGroupOrder\fP (const \fBInteger\fP &modulus) const"
.br
.ti -1c
.RI "virtual int \fBGetFieldType\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBGetDefaultSubgroupOrderSize\fP (unsigned int modulusSize) const"
.br
.in -1c

Protected Member Functions inherited from \fBDL_GroupParameters< Integer >\fP
.in +1c
.ti -1c
.RI "void \fBParametersChanged\fP ()"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBDL_GroupParameters< Integer >\fP
.in +1c
.ti -1c
.RI "typedef \fBInteger\fP \fBElement\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Integer-based GroupParameters specialization\&. 
.SH "Member Function Documentation"
.PP 
.SS "void DL_GroupParameters_IntegerBased::AssignFrom (const \fBNameValuePairs\fP & source)\fR [virtual]\fP"

.PP
Initialize or reinitialize this key\&. 
.PP
\fBParameters\fP
.RS 4
\fIsource\fP \fBNameValuePairs\fP to assign 
.RE
.PP

.PP
Implements \fBCryptoMaterial\fP\&.
.PP
Reimplemented in \fBDL_GroupParameters_IntegerBasedImpl< DL_GroupPrecomputation_LUC, DL_BasePrecomputation_LUC >\fP\&.
.SS "void DL_GroupParameters_IntegerBased::BERDecode (\fBBufferedTransformation\fP & bt)\fR [virtual]\fP"

.PP
Decode this object from a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
Uses Basic Encoding Rules (BER) 
.PP
Implements \fBASN1Object\fP\&.
.SS "\fBInteger\fP DL_GroupParameters_IntegerBased::ConvertElementToInteger (const \fBElement\fP & element) const\fR [inline]\fP"

.PP
Converts an element to an \fBInteger\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIelement\fP the element to convert to an \fBInteger\fP 
.RE
.PP
\fBReturns\fP
.RS 4
Element after converting to an \fBInteger\fP
.RE
.PP
\fBConvertElementToInteger()\fP must be implemented in a derived class\&. 
.SS "\fBInteger\fP DL_GroupParameters_IntegerBased::DecodeElement (const \fBbyte\fP * encoded, bool checkForGroupMembership) const\fR [virtual]\fP"

.PP
Decodes the element\&. 
.PP
\fBParameters\fP
.RS 4
\fIencoded\fP byte array with the encoded element 
.br
\fIcheckForGroupMembership\fP flag indicating if the element should be validated 
.RE
.PP
\fBReturns\fP
.RS 4
Element after decoding
.RE
.PP
\fBDecodeElement()\fP must be implemented in a derived class\&. 
.PP
\fBPrecondition\fP
.RS 4
\fRCOUNTOF(encoded) == \fBGetEncodedElementSize()\fP\fP 
.RE
.PP
\fBSee also\fP
.RS 4
\fBGetEncodedElementSize()\fP, \fBEncodeElement()\fP 
.RE
.PP

.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "void DL_GroupParameters_IntegerBased::DEREncode (\fBBufferedTransformation\fP & bt) const\fR [virtual]\fP"

.PP
Encode this object into a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
Uses Distinguished Encoding Rules (DER) 
.PP
Implements \fBASN1Object\fP\&.
.SS "void DL_GroupParameters_IntegerBased::EncodeElement (bool reversible, const \fBElement\fP & element, \fBbyte\fP * encoded) const"

.PP
Encodes the element\&. 
.PP
\fBParameters\fP
.RS 4
\fIreversible\fP flag indicating the encoding format 
.br
\fIelement\fP reference to the element to encode 
.br
\fIencoded\fP destination byte array for the encoded element
.RE
.PP
\fBEncodeElement()\fP must be implemented in a derived class\&. 
.PP
\fBPrecondition\fP
.RS 4
\fRCOUNTOF(encoded) == \fBGetEncodedElementSize()\fP\fP 
.RE
.PP
\fBSee also\fP
.RS 4
\fBGetEncodedElementSize()\fP, \fBDecodeElement()\fP, \fRCygwin i386 crash at -O3\fP 
.RE
.PP

.SS "bool DL_GroupParameters_IntegerBased::FastSubgroupCheckAvailable () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determine if subgroup membership check is fast\&. 
.PP
\fBReturns\fP
.RS 4
true or false 
.RE
.PP

.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "void DL_GroupParameters_IntegerBased::GenerateRandom (\fBRandomNumberGenerator\fP & rng, const \fBNameValuePairs\fP & alg)\fR [virtual]\fP"

.PP
Generate a random key\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP a \fBRandomNumberGenerator\fP to produce keying material 
.br
\fIalg\fP additional initialization parameters
.RE
.PP
Recognised \fBNameValuePairs\fP are ModulusSize and SubgroupOrderSize (optional) 
.PP
\fBExceptions\fP
.RS 4
\fIKeyingErr\fP if a key can't be generated or algorithm parameters are invalid 
.RE
.PP

.PP
Reimplemented from \fBGeneratableCryptoMaterial\fP\&.
.SS "\fBOID\fP DL_GroupParameters_IntegerBased::GetAlgorithmID () const"

.PP
Retrieve the \fBOID\fP of the algorithm\&. 
.PP
\fBReturns\fP
.RS 4
\fBOID\fP of the algorithm 
.RE
.PP

.SS "unsigned int DL_GroupParameters_IntegerBased::GetEncodedElementSize (bool reversible) const\fR [virtual]\fP"

.PP
Retrieve the encoded element's size\&. 
.PP
\fBParameters\fP
.RS 4
\fIreversible\fP flag indicating the encoding format 
.RE
.PP
\fBReturns\fP
.RS 4
encoded element's size, in bytes
.RE
.PP
The format of the encoded element varies by the underlying type of the element and the reversible flag\&. 
.PP
\fBSee also\fP
.RS 4
\fBEncodeElement()\fP, \fBDecodeElement()\fP 
.RE
.PP

.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "\fBInteger\fP DL_GroupParameters_IntegerBased::GetGroupOrder () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieves the order of the group\&. 
.PP
\fBReturns\fP
.RS 4
the order of the group
.RE
.PP
Either \fBGetGroupOrder()\fP or \fBGetCofactor()\fP must be overridden in a derived class\&. 
.PP
Reimplemented from \fBDL_GroupParameters< Integer >\fP\&.
.SS "\fBInteger\fP DL_GroupParameters_IntegerBased::GetMaxExponent () const\fR [virtual]\fP"

.PP
Retrieve the maximum exponent for the group\&. 
.PP
\fBReturns\fP
.RS 4
the maximum exponent for the group 
.RE
.PP

.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "virtual const \fBInteger\fP & DL_GroupParameters_IntegerBased::GetModulus () const\fR [pure virtual]\fP"

.PP
Retrieve the modulus for the group\&. 
.PP
\fBReturns\fP
.RS 4
the modulus for the group 
.RE
.PP

.PP
Implemented in \fBDL_GroupParameters_IntegerBasedImpl< DL_GroupPrecomputation_LUC, DL_BasePrecomputation_LUC >\fP\&.
.SS "const \fBInteger\fP & DL_GroupParameters_IntegerBased::GetSubgroupOrder () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieves the subgroup order\&. 
.PP
\fBReturns\fP
.RS 4
the order of subgroup generated by the base element 
.RE
.PP

.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "bool DL_GroupParameters_IntegerBased::GetVoidValue (const char * name, const std::type_info & valueType, void * pValue) const\fR [virtual]\fP"

.PP
Get a named value\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP the name of the object or value to retrieve 
.br
\fIvalueType\fP reference to a variable that receives the value 
.br
\fIpValue\fP void pointer to a variable that receives the value 
.RE
.PP
\fBReturns\fP
.RS 4
true if the value was retrieved, false otherwise
.RE
.PP
\fBGetVoidValue()\fP retrieves the value of name if it exists\&. 
.PP
\fBNote\fP
.RS 4
\fBGetVoidValue()\fP is an internal function and should be implemented by derived classes\&. Users should use one of the other functions instead\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBGetValue()\fP, \fBGetValueWithDefault()\fP, \fBGetIntValue()\fP, \fBGetIntValueWithDefault()\fP, \fBGetRequiredParameter()\fP and \fBGetRequiredIntParameter()\fP 
.RE
.PP

.PP
Reimplemented from \fBDL_GroupParameters< Integer >\fP\&.
.PP
Reimplemented in \fBDL_GroupParameters_IntegerBasedImpl< DL_GroupPrecomputation_LUC, DL_BasePrecomputation_LUC >\fP, and \fBDL_GroupParameters_LUC\fP\&.
.SS "void DL_GroupParameters_IntegerBased::Initialize (const \fBDL_GroupParameters_IntegerBased\fP & params)\fR [inline]\fP"

.PP
Initialize a group parameters over integers\&. 
.PP
\fBParameters\fP
.RS 4
\fIparams\fP the group parameters 
.RE
.PP

.SS "void DL_GroupParameters_IntegerBased::Initialize (const \fBInteger\fP & p, const \fBInteger\fP & g)\fR [inline]\fP"

.PP
Initialize a group parameters over integers\&. 
.PP
\fBParameters\fP
.RS 4
\fIp\fP the modulus 
.br
\fIg\fP the generator 
.RE
.PP

.SS "void DL_GroupParameters_IntegerBased::Initialize (const \fBInteger\fP & p, const \fBInteger\fP & q, const \fBInteger\fP & g)\fR [inline]\fP"

.PP
Initialize a group parameters over integers\&. 
.PP
\fBParameters\fP
.RS 4
\fIp\fP the modulus 
.br
\fIq\fP the subgroup order 
.br
\fIg\fP the generator 
.RE
.PP

.SS "void DL_GroupParameters_IntegerBased::Initialize (\fBRandomNumberGenerator\fP & rng, unsigned int pbits)\fR [inline]\fP"

.PP
Create a group parameters over integers\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP a \fBRandomNumberGenerator\fP derived class 
.br
\fIpbits\fP the size of p, in bits
.RE
.PP
This function overload of \fBInitialize()\fP creates a new private key because it takes a \fBRandomNumberGenerator()\fP as a parameter\&. If you have an existing keypair, then use one of the other \fBInitialize()\fP overloads\&. 
.SS "virtual void DL_GroupParameters_IntegerBased::SetModulusAndSubgroupGenerator (const \fBInteger\fP & p, const \fBInteger\fP & g)\fR [pure virtual]\fP"

.PP
Set group parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIp\fP the prime modulus 
.br
\fIg\fP the group generator 
.RE
.PP

.SS "void DL_GroupParameters_IntegerBased::SetSubgroupOrder (const \fBInteger\fP & q)\fR [inline]\fP"

.PP
Set subgroup order\&. 
.PP
\fBParameters\fP
.RS 4
\fIq\fP the subgroup order 
.RE
.PP

.SS "bool DL_GroupParameters_IntegerBased::ValidateElement (unsigned int level, const \fBInteger\fP & element, const \fBDL_FixedBasePrecomputation\fP< \fBInteger\fP > * precomp) const\fR [virtual]\fP"

.PP
Check the element for errors\&. 
.PP
\fBParameters\fP
.RS 4
\fIlevel\fP level of thoroughness 
.br
\fIelement\fP element to check 
.br
\fIprecomp\fP optional pointer to \fBDL_FixedBasePrecomputation\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true if the tests succeed, false otherwise
.RE
.PP
There are four levels of thoroughness: 
.PD 0
.IP "\(bu" 2
0 - using this object won't cause a crash or exception 
.IP "\(bu" 2
1 - this object will probably function, and encrypt, sign, other operations correctly 
.IP "\(bu" 2
2 - ensure this object will function correctly, and perform reasonable security checks 
.IP "\(bu" 2
3 - perform reasonable security checks, and do checks that may take a long time 
.PP

.PP
Level 0 performs group membership checks\&. Level 1 may not check for weak keys and such\&. Levels 2 and 3 are recommended\&.

.PP
\fBValidateElement()\fP must be implemented in a derived class\&. 
.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.
.SS "bool DL_GroupParameters_IntegerBased::ValidateGroup (\fBRandomNumberGenerator\fP & rng, unsigned int level) const\fR [virtual]\fP"

.PP
Check the group for errors\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP \fBRandomNumberGenerator\fP for objects which use randomized testing 
.br
\fIlevel\fP level of thoroughness 
.RE
.PP
\fBReturns\fP
.RS 4
true if the tests succeed, false otherwise
.RE
.PP
There are four levels of thoroughness: 
.PD 0
.IP "\(bu" 2
0 - using this object won't cause a crash or exception 
.IP "\(bu" 2
1 - this object will probably function, and encrypt, sign, other operations correctly 
.IP "\(bu" 2
2 - ensure this object will function correctly, and perform reasonable security checks 
.IP "\(bu" 2
3 - perform reasonable security checks, and do checks that may take a long time 
.PP

.PP
Level 0 does not require a \fBRandomNumberGenerator\fP\&. A \fBNullRNG()\fP can be used for level 0\&. Level 1 may not check for weak keys and such\&. Levels 2 and 3 are recommended\&.

.PP
\fBValidateGroup()\fP must be implemented in a derived class\&. 
.PP
Implements \fBDL_GroupParameters< Integer >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
