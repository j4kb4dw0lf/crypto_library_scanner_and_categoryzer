.TH "Kalyna256::Base" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Kalyna256::Base
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBKalyna_Base\fP, and \fBBlockCipherImpl< Kalyna256_Info >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.in -1c

Public Member Functions inherited from \fBBlockCipherImpl< Kalyna256_Info >\fP
.in +1c
.ti -1c
.RI "unsigned int \fBBlockSize\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBSimpleKeyingInterfaceImpl< TwoBases< BlockCipher, Kalyna256_Info > >\fP
.in +1c
.ti -1c
.RI "size_t \fBMinKeyLength\fP () const"
.br
.RI "The minimum key length used by the algorithm\&. "
.ti -1c
.RI "size_t \fBMaxKeyLength\fP () const"
.br
.RI "The maximum key length used by the algorithm\&. "
.ti -1c
.RI "size_t \fBDefaultKeyLength\fP () const"
.br
.RI "The default key length used by the algorithm\&. "
.ti -1c
.RI "size_t \fBGetValidKeyLength\fP (size_t keylength) const"
.br
.RI "Provides a valid key length for the algorithm\&. "
.ti -1c
.RI "\fBSimpleKeyingInterface::IV_Requirement\fP \fBIVRequirement\fP () const"
.br
.RI "The default IV requirements for the algorithm\&. "
.ti -1c
.RI "unsigned int \fBIVSize\fP () const"
.br
.RI "The initialization vector length for the algorithm\&. "
.in -1c

Public Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual bool \fBIsValidKeyLength\fP (size_t keylength) const"
.br
.RI "Returns whether keylength is a valid key length\&. "
.ti -1c
.RI "virtual void \fBSetKey\fP (const \fBbyte\fP *key, size_t length, const \fBNameValuePairs\fP &params=g_nullNameValuePairs)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithRounds\fP (const \fBbyte\fP *key, size_t length, int rounds)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv, size_t ivLength)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "bool \fBIsResynchronizable\fP () const"
.br
.RI "Determines if the object can be resynchronized\&. "
.ti -1c
.RI "bool \fBCanUseRandomIVs\fP () const"
.br
.RI "Determines if the object can use random IVs\&. "
.ti -1c
.RI "bool \fBCanUsePredictableIVs\fP () const"
.br
.RI "Determines if the object can use random but possibly predictable IVs\&. "
.ti -1c
.RI "bool \fBCanUseStructuredIVs\fP () const"
.br
.RI "Determines if the object can use structured IVs\&. "
.ti -1c
.RI "unsigned int \fBDefaultIVLength\fP () const"
.br
.RI "Provides the default size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMinIVLength\fP () const"
.br
.RI "Provides the minimum size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMaxIVLength\fP () const"
.br
.RI "Provides the maximum size of an IV\&. "
.ti -1c
.RI "virtual void \fBResynchronize\fP (const \fBbyte\fP *iv, int ivLength=\-1)"
.br
.RI "Resynchronize with an IV\&. "
.ti -1c
.RI "virtual void \fBGetNextIV\fP (\fBRandomNumberGenerator\fP &rng, \fBbyte\fP *iv)"
.br
.RI "Retrieves a secure IV for the next message\&. "
.in -1c

Public Member Functions inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "void \fBProcessBlock\fP (const \fBbyte\fP *inBlock, \fBbyte\fP *outBlock) const"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (\fBbyte\fP *inoutBlock) const"
.br
.RI "Encrypt or decrypt a block in place\&. "
.ti -1c
.RI "virtual bool \fBIsPermutation\fP () const"
.br
.RI "Determines if the transformation is a permutation\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalNumberOfParallelBlocks\fP () const"
.br
.RI "Determines the number of blocks that can be processed in parallel\&. "
.ti -1c
.RI "virtual size_t \fBAdvancedProcessBlocks\fP (const \fBbyte\fP *inBlocks, const \fBbyte\fP *xorBlocks, \fBbyte\fP *outBlocks, size_t length, \fBword32\fP flags) const"
.br
.RI "Encrypt and xor multiple blocks using additional flags\&. "
.ti -1c
.RI "\fBCipherDir\fP \fBGetCipherDirection\fP () const"
.br
.RI "Provides the direction of the cipher\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBFixedBlockSize< 32 >\fP
.in +1c
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (BLOCKSIZE=N)"
.br
.RI "The block size of the algorithm provided as a constant\&. "
.in -1c

Public Member Functions inherited from \fBVariableKeyLength< 32, 32, 64 >\fP
.in +1c
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (MIN_KEYLENGTH=N)"
.br
.RI "The minimum key length used by the algorithm provided as a constant\&. "
.ti -1c
.RI "CRYPTOPP_STATIC_CONSTEXPR size_t CRYPTOPP_API \fBStaticGetValidKeyLength\fP (size_t keylength)"
.br
.RI "Provides a valid key length for the algorithm provided by a static function\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBUncheckedSetKey\fP (const \fBbyte\fP *key, unsigned int keylen, const \fBNameValuePairs\fP &params)"
.br
.RI "Sets the key for this object without performing parameter validation\&. "
.ti -1c
.RI "void \fBProcessAndXorBlock\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBSetKey_44\fP (const word64 key[4])"
.br
.ti -1c
.RI "void \fBSetKey_48\fP (const word64 key[8])"
.br
.ti -1c
.RI "void \fBProcessBlock_44\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const"
.br
.ti -1c
.RI "void \fBProcessBlock_48\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const"
.br
.in -1c

Protected Member Functions inherited from \fBBlockCipher\fP
.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.in -1c

Protected Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidKeyLength\fP (size_t length)"
.br
.RI "Validates the key length\&. "
.ti -1c
.RI "void \fBThrowIfResynchronizable\fP ()"
.br
.RI "Validates the object\&. "
.ti -1c
.RI "void \fBThrowIfInvalidIV\fP (const \fBbyte\fP *iv)"
.br
.RI "Validates the IV\&. "
.ti -1c
.RI "size_t \fBThrowIfInvalidIVLength\fP (int length)"
.br
.RI "Validates the IV length\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBGetIVAndThrowIfInvalid\fP (const \fBNameValuePairs\fP &params, size_t &size)"
.br
.RI "Retrieves and validates the IV\&. "
.ti -1c
.RI "void \fBAssertValidKeyLength\fP (size_t length) const"
.br
.RI "Validates the key length\&. "
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "enum \fBIV_Requirement\fP { \fBUNIQUE_IV\fP = 0, \fBRANDOM_IV\fP, \fBUNPREDICTABLE_RANDOM_IV\fP, \fBINTERNALLY_GENERATED_IV\fP, \fBNOT_RESYNCHRONIZABLE\fP }"
.br
.RI "Secure IVs requirements as enumerated values\&. "
.in -1c

Public Types inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "enum \fBFlagsForAdvancedProcessBlocks\fP { \fBBT_InBlockIsCounter\fP =1, \fBBT_DontIncrementInOutPointers\fP =2, \fBBT_XorInput\fP =4, \fBBT_ReverseDirection\fP =8, \fBBT_AllowParallel\fP =16 }"
.br
.RI "Bit flags that control \fBAdvancedProcessBlocks()\fP behavior\&. "
.in -1c

Static Public Member Functions inherited from \fBAlgorithmImpl< SimpleKeyingInterfaceImpl< TwoBases< BlockCipher, Kalyna256_Info > > >\fP
.in +1c
.ti -1c
.RI "static std::string CRYPTOPP_API \fBStaticAlgorithmName\fP ()"
.br
.RI "The algorithm name\&. "
.in -1c

Static Public Member Functions inherited from \fBKalyna256_Info\fP
.in +1c
.ti -1c
.RI "static const char * \fBStaticAlgorithmName\fP ()"
.br
.in -1c

Protected Types inherited from \fBKalyna_Base\fP
.in +1c
.ti -1c
.RI "typedef \fBSecBlock\fP< word64, \fBAllocatorWithCleanup\fP< word64, true > > \fBAlignedSecBlock64\fP"
.br
.in -1c

Protected Attributes inherited from \fBKalyna_Base\fP
.in +1c
.ti -1c
.RI "\fBAlignedSecBlock64\fP \fBm_wspace\fP"
.br
.ti -1c
.RI "\fBAlignedSecBlock64\fP \fBm_mkey\fP"
.br
.ti -1c
.RI "\fBAlignedSecBlock64\fP \fBm_rkeys\fP"
.br
.ti -1c
.RI "unsigned int \fBm_kl\fP"
.br
.ti -1c
.RI "unsigned int \fBm_nb\fP"
.br
.ti -1c
.RI "unsigned int \fBm_nk\fP"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "std::string Kalyna256::Base::AlgorithmName () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the name of this algorithm\&. 
.PP
\fBReturns\fP
.RS 4
the standard algorithm name
.RE
.PP
If the object is unkeyed, then the generic name "Kalyna" is returned to the caller\&. If the algorithm is keyed, then a two or three part name is returned to the caller\&. The name follows DSTU 7624:2014, where block size is provided first and then key length\&. The library uses a dash to identify block size and parenthesis to identify key length\&. For example, Kalyna-128(256) is Kalyna with a 128-bit block size and a 256-bit key length\&. If a mode is associated with the object, then it follows as expected\&. For example, Kalyna-128(256)/ECB\&. DSTU is a little more complex with more parameters, dashes, underscores, but the library does not use the delimiters or full convention\&. 
.PP
Reimplemented from \fBAlgorithmImpl< SimpleKeyingInterfaceImpl< TwoBases< BlockCipher, Kalyna256_Info > > >\fP\&.
.SS "unsigned int Kalyna256::Base::OptimalDataAlignment () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides input and output data alignment for optimal performance\&. 
.PP
\fBReturns\fP
.RS 4
the input data alignment that provides optimal performance 
.RE
.PP
\fBSee also\fP
.RS 4
GetAlignment() and OptimalBlockSize() 
.RE
.PP

.PP
Reimplemented from \fBBlockTransformation\fP\&.
.SS "void Kalyna256::Base::ProcessAndXorBlock (const \fBbyte\fP * inBlock, const \fBbyte\fP * xorBlock, \fBbyte\fP * outBlock) const\fR [protected]\fP, \fR [virtual]\fP"

.PP
Encrypt or decrypt a block\&. 
.PP
\fBParameters\fP
.RS 4
\fIinBlock\fP the input message before processing 
.br
\fIoutBlock\fP the output message after processing 
.br
\fIxorBlock\fP an optional XOR mask
.RE
.PP
ProcessAndXorBlock encrypts or decrypts inBlock, xor with xorBlock, and write to outBlock\&.

.PP
The size of the block is determined by the block cipher and its documentation\&. Use BLOCKSIZE at compile time, or \fBBlockSize()\fP at runtime\&. 
.PP
\fBNote\fP
.RS 4
The message can be transformed in-place, or the buffers must \fInot\fP overlap 
.RE
.PP
\fBSee also\fP
.RS 4
\fBFixedBlockSize\fP, \fBBlockCipherFinal\fP from \fBseckey\&.h\fP and \fBBlockSize()\fP 
.RE
.PP

.PP
Implements \fBBlockTransformation\fP\&.
.SS "void Kalyna256::Base::UncheckedSetKey (const \fBbyte\fP * key, unsigned int length, const \fBNameValuePairs\fP & params)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Sets the key for this object without performing parameter validation\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP a byte buffer used to key the cipher 
.br
\fIlength\fP the length of the byte buffer 
.br
\fIparams\fP additional parameters passed as \fBNameValuePairs\fP
.RE
.PP
key must be at least DEFAULT_KEYLENGTH in length\&. 
.PP
Implements \fBSimpleKeyingInterface\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
