.TH "X917RNG" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
X917RNG \- ANSI X9\&.17 RNG\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <rng\&.h>\fP
.PP
Inherits \fBRandomNumberGenerator\fP, and \fBNotCopyable\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBX917RNG\fP (\fBBlockTransformation\fP *cipher, const \fBbyte\fP *seed, const \fBbyte\fP *deterministicTimeVector=NULLPTR)"
.br
.RI "Construct a \fBX917RNG\fP\&. "
.ti -1c
.RI "void \fBGenerateIntoBufferedTransformation\fP (\fBBufferedTransformation\fP &target, const std::string &channel, \fBlword\fP size)"
.br
.RI "Generate random bytes into a \fBBufferedTransformation\fP\&. "
.in -1c

Public Member Functions inherited from \fBRandomNumberGenerator\fP
.in +1c
.ti -1c
.RI "virtual void \fBIncorporateEntropy\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Update RNG state with additional unpredictable values\&. "
.ti -1c
.RI "virtual bool \fBCanIncorporateEntropy\fP () const"
.br
.RI "Determines if a generator can accept additional entropy\&. "
.ti -1c
.RI "virtual \fBbyte\fP \fBGenerateByte\fP ()"
.br
.RI "Generate new random byte and return it\&. "
.ti -1c
.RI "virtual unsigned int \fBGenerateBit\fP ()"
.br
.RI "Generate new random bit and return it\&. "
.ti -1c
.RI "virtual \fBword32\fP \fBGenerateWord32\fP (\fBword32\fP min=0, \fBword32\fP max=0xffffffffUL)"
.br
.RI "Generate a random 32 bit word in the range min to max, inclusive\&. "
.ti -1c
.RI "virtual void \fBGenerateBlock\fP (\fBbyte\fP *output, size_t size)"
.br
.RI "Generate random array of bytes\&. "
.ti -1c
.RI "virtual void \fBDiscardBytes\fP (size_t n)"
.br
.RI "Generate and discard n bytes\&. "
.ti -1c
.RI "template<class IT> void \fBShuffle\fP (IT begin, IT end)"
.br
.RI "Randomly shuffle the specified array\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SH "Detailed Description"
.PP 
ANSI X9\&.17 RNG\&. 

\fBX917RNG\fP is from ANSI X9\&.17 Appendix C, and it uses a 64-bit block cipher, like TripleDES\&. If you use a 128-bit block cipher, like AES, then you are effectively using an ANSI X9\&.31 generator\&.

.PP
You should reseed the generator after a fork() to avoid multiple generators with the same internal state\&. 
.PP
\fBSee also\fP
.RS 4
AutoSeededX917RNG, DefaultAutoSeededRNG 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "X917RNG::X917RNG (\fBBlockTransformation\fP * cipher, const \fBbyte\fP * seed, const \fBbyte\fP * deterministicTimeVector = \fRNULLPTR\fP)"

.PP
Construct a \fBX917RNG\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIcipher\fP the block cipher to use for the generator 
.br
\fIseed\fP a byte buffer to use as a seed 
.br
\fIdeterministicTimeVector\fP additional entropy
.RE
.PP
\fRcipher\fP will be deleted by the destructor\&. \fRseed\fP must be at least BlockSize() in length\&. \fRdeterministicTimeVector = 0\fP means obtain time vector from the system\&.

.PP
When constructing a \fBX917RNG\fP, the generator must be keyed or an access violation will occur because the time vector is encrypted using the block cipher\&. To key the generator during constructions, perform the following: 
.PP
.nf

 SecByteBlock key(AES::DEFAULT_KEYLENGTH), seed(AES::BLOCKSIZE);
 OS_GenerateRandomBlock(false, key, key\&.size());
 OS_GenerateRandomBlock(false, seed, seed\&.size());
 \fBX917RNG\fP prng(new AES::Encryption(key, AES::DEFAULT_KEYLENGTH), seed, NULLPTR);
.fi
.PP
 
.PP
\fBSee also\fP
.RS 4
AutoSeededX917RNG 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void X917RNG::GenerateIntoBufferedTransformation (\fBBufferedTransformation\fP & target, const std::string & channel, \fBlword\fP length)\fR [virtual]\fP"

.PP
Generate random bytes into a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the \fBBufferedTransformation\fP object which receives the bytes 
.br
\fIchannel\fP the channel on which the bytes should be pumped 
.br
\fIlength\fP the number of bytes to generate
.RE
.PP
The default implementation calls \fBGenerateBlock()\fP and pumps the result into the DEFAULT_CHANNEL of the target\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
\fBNote\fP
.RS 4
A derived generator \fImust\fP override either \fBGenerateBlock()\fP or \fBGenerateIntoBufferedTransformation()\fP\&. They can override both, or have one call the other\&. 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
