.TH "RandomPool" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RandomPool \- Randomness Pool based on AES-256\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <randpool\&.h>\fP
.PP
Inherits \fBRandomNumberGenerator\fP, and \fBNotCopyable\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRandomPool\fP ()"
.br
.RI "Construct a \fBRandomPool\fP\&. "
.ti -1c
.RI "bool \fBCanIncorporateEntropy\fP () const"
.br
.RI "Determines if a generator can accept additional entropy\&. "
.ti -1c
.RI "void \fBIncorporateEntropy\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Update RNG state with additional unpredictable values\&. "
.ti -1c
.RI "void \fBGenerateIntoBufferedTransformation\fP (\fBBufferedTransformation\fP &target, const std::string &channel, \fBlword\fP size)"
.br
.RI "Generate random bytes into a \fBBufferedTransformation\fP\&. "
.in -1c

Public Member Functions inherited from \fBRandomNumberGenerator\fP
.in +1c
.ti -1c
.RI "virtual \fBbyte\fP \fBGenerateByte\fP ()"
.br
.RI "Generate new random byte and return it\&. "
.ti -1c
.RI "virtual unsigned int \fBGenerateBit\fP ()"
.br
.RI "Generate new random bit and return it\&. "
.ti -1c
.RI "virtual \fBword32\fP \fBGenerateWord32\fP (\fBword32\fP min=0, \fBword32\fP max=0xffffffffUL)"
.br
.RI "Generate a random 32 bit word in the range min to max, inclusive\&. "
.ti -1c
.RI "virtual void \fBGenerateBlock\fP (\fBbyte\fP *output, size_t size)"
.br
.RI "Generate random array of bytes\&. "
.ti -1c
.RI "virtual void \fBDiscardBytes\fP (size_t n)"
.br
.RI "Generate and discard n bytes\&. "
.ti -1c
.RI "template<class IT> void \fBShuffle\fP (IT begin, IT end)"
.br
.RI "Randomly shuffle the specified array\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SH "Detailed Description"
.PP 
Randomness Pool based on AES-256\&. 

\fBRandomPool\fP can be used to generate cryptographic quality pseudorandom bytes after seeding the pool with \fBIncorporateEntropy()\fP\&. Internally, the generator uses AES-256 to produce the stream\&. Entropy is stirred in using SHA-256\&.

.PP
\fBRandomPool\fP used to follow the design of randpool in PGP 2\&.6\&.x\&. At version 5\&.5 \fBRandomPool\fP was redesigned to reduce the risk of reusing random numbers after state rollback, which may occur when running in a virtual machine like VMware or a hosted environment\&.

.PP
You should reseed the generator after a fork() to avoid multiple generators with the same internal state\&.

.PP
If you need the pre-Crypto++ 5\&.5 generator then use \fBOldRandomPool\fP class\&. You should migrate away from \fBOldRandomPool\fP at the earliest opportunity\&. 
.PP
\fBSee also\fP
.RS 4
\fBOldRandomPool\fP 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 4\&.0 (PGP 2\&.6\&.x style), Crypto++ 5\&.5 (AES-256 based) 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "bool RandomPool::CanIncorporateEntropy () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines if a generator can accept additional entropy\&. 
.PP
\fBReturns\fP
.RS 4
true if \fBIncorporateEntropy()\fP is implemented 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void RandomPool::GenerateIntoBufferedTransformation (\fBBufferedTransformation\fP & target, const std::string & channel, \fBlword\fP length)\fR [virtual]\fP"

.PP
Generate random bytes into a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the \fBBufferedTransformation\fP object which receives the bytes 
.br
\fIchannel\fP the channel on which the bytes should be pumped 
.br
\fIlength\fP the number of bytes to generate
.RE
.PP
The default implementation calls \fBGenerateBlock()\fP and pumps the result into the DEFAULT_CHANNEL of the target\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
\fBNote\fP
.RS 4
A derived generator \fImust\fP override either \fBGenerateBlock()\fP or \fBGenerateIntoBufferedTransformation()\fP\&. They can override both, or have one call the other\&. 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void RandomPool::IncorporateEntropy (const \fBbyte\fP * input, size_t length)\fR [virtual]\fP"

.PP
Update RNG state with additional unpredictable values\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP the entropy to add to the generator 
.br
\fIlength\fP the size of the input buffer 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented\fP\fP 
.RE
.PP
A generator may or may not accept additional entropy\&. Call \fBCanIncorporateEntropy()\fP to test for the ability to use additional entropy\&.

.PP
If a derived class does not override \fBIncorporateEntropy()\fP, then the base class throws \fBNotImplemented\fP\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
