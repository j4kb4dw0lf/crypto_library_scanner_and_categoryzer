.TH "AbstractEuclideanDomain< T >" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AbstractEuclideanDomain< T > \- Abstract Euclidean domain\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <algebra\&.h>\fP
.PP
Inherits \fBAbstractRing< T >\fP\&.
.PP
Inherited by \fBEuclideanDomainOf< T >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef T \fBElement\fP"
.br
.in -1c

Public Types inherited from \fBAbstractRing< T >\fP
.in +1c
.ti -1c
.RI "typedef T \fBElement\fP"
.br
.in -1c

Public Types inherited from \fBAbstractGroup< T >\fP
.in +1c
.ti -1c
.RI "typedef T \fBElement\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBDivisionAlgorithm\fP (Element &r, Element &q, const Element &a, const Element &d) const =0"
.br
.RI "Performs the division algorithm on two elements in the ring\&. "
.ti -1c
.RI "virtual const Element & \fBMod\fP (const Element &a, const Element &b) const =0"
.br
.RI "Performs a modular reduction in the ring\&. "
.ti -1c
.RI "virtual const Element & \fBGcd\fP (const Element &a, const Element &b) const"
.br
.RI "Calculates the greatest common denominator in the ring\&. "
.in -1c

Public Member Functions inherited from \fBAbstractRing< T >\fP
.in +1c
.ti -1c
.RI "\fBAbstractRing\fP ()"
.br
.RI "Construct an \fBAbstractRing\fP\&. "
.ti -1c
.RI "\fBAbstractRing\fP (const \fBAbstractRing\fP &source)"
.br
.RI "Copy construct an \fBAbstractRing\fP\&. "
.ti -1c
.RI "\fBAbstractRing\fP & \fBoperator=\fP (const \fBAbstractRing\fP &source)"
.br
.RI "Assign an \fBAbstractRing\fP\&. "
.ti -1c
.RI "virtual bool \fBIsUnit\fP (const Element &a) const =0"
.br
.RI "Determines whether an element is a unit in the group\&. "
.ti -1c
.RI "virtual const Element & \fBMultiplicativeIdentity\fP () const =0"
.br
.RI "Retrieves the multiplicative identity\&. "
.ti -1c
.RI "virtual const Element & \fBMultiply\fP (const Element &a, const Element &b) const =0"
.br
.RI "Multiplies elements in the group\&. "
.ti -1c
.RI "virtual const Element & \fBMultiplicativeInverse\fP (const Element &a) const =0"
.br
.RI "Calculate the multiplicative inverse of an element in the group\&. "
.ti -1c
.RI "virtual const Element & \fBSquare\fP (const Element &a) const"
.br
.RI "\fBSquare\fP an element in the group\&. "
.ti -1c
.RI "virtual const Element & \fBDivide\fP (const Element &a, const Element &b) const"
.br
.RI "Divides elements in the group\&. "
.ti -1c
.RI "virtual Element \fBExponentiate\fP (const Element &a, const \fBInteger\fP &e) const"
.br
.RI "Raises a base to an exponent in the group\&. "
.ti -1c
.RI "virtual Element \fBCascadeExponentiate\fP (const Element &x, const \fBInteger\fP &e1, const Element &y, const \fBInteger\fP &e2) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "virtual void \fBSimultaneousExponentiate\fP (Element *results, const Element &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Exponentiates a base to multiple exponents in the Ring\&. "
.ti -1c
.RI "virtual const \fBAbstractGroup\fP< T > & \fBMultiplicativeGroup\fP () const"
.br
.RI "Retrieves the multiplicative group\&. "
.in -1c

Public Member Functions inherited from \fBAbstractGroup< T >\fP
.in +1c
.ti -1c
.RI "virtual bool \fBEqual\fP (const Element &a, const Element &b) const =0"
.br
.RI "Compare two elements for equality\&. "
.ti -1c
.RI "virtual const Element & \fBIdentity\fP () const =0"
.br
.RI "Provides the Identity element\&. "
.ti -1c
.RI "virtual const Element & \fBAdd\fP (const Element &a, const Element &b) const =0"
.br
.RI "Adds elements in the group\&. "
.ti -1c
.RI "virtual const Element & \fBInverse\fP (const Element &a) const =0"
.br
.RI "Inverts the element in the group\&. "
.ti -1c
.RI "virtual bool \fBInversionIsFast\fP () const"
.br
.RI "Determine if inversion is fast\&. "
.ti -1c
.RI "virtual const Element & \fBDouble\fP (const Element &a) const"
.br
.RI "Doubles an element in the group\&. "
.ti -1c
.RI "virtual const Element & \fBSubtract\fP (const Element &a, const Element &b) const"
.br
.RI "Subtracts elements in the group\&. "
.ti -1c
.RI "virtual Element & \fBAccumulate\fP (Element &a, const Element &b) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "virtual Element & \fBReduce\fP (Element &a, const Element &b) const"
.br
.RI "Reduces an element in the congruence class\&. "
.ti -1c
.RI "virtual Element \fBScalarMultiply\fP (const Element &a, const \fBInteger\fP &e) const"
.br
.RI "Performs a scalar multiplication\&. "
.ti -1c
.RI "virtual Element \fBCascadeScalarMultiply\fP (const Element &x, const \fBInteger\fP &e1, const Element &y, const \fBInteger\fP &e2) const"
.br
.RI "TODO\&. "
.ti -1c
.RI "virtual void \fBSimultaneousMultiply\fP (Element *results, const Element &base, const \fBInteger\fP *exponents, unsigned int exponentsCount) const"
.br
.RI "Multiplies a base to multiple exponents in a group\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "Element \fBresult\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T>
.br
class AbstractEuclideanDomain< T >"Abstract Euclidean domain\&. 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP element class or type
.RE
.PP
\fRconst Element&\fP returned by member functions are references to internal data members\&. Since each object may have only one such data member for holding results, the following code will produce incorrect results: 
.PP
.nf
    abcd = group\&.Add(group\&.Add(a,b), group\&.Add(c,d));
.fi
.PP
 But this should be fine: 
.PP
.nf
    abcd = group\&.Add(a, group\&.Add(b, group\&.Add(c,d));
.fi
.PP
 
.SH "Member Function Documentation"
.PP 
.SS "template<class T> virtual void \fBAbstractEuclideanDomain\fP< T >::DivisionAlgorithm (Element & r, Element & q, const Element & a, const Element & d) const\fR [pure virtual]\fP"

.PP
Performs the division algorithm on two elements in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIr\fP the remainder 
.br
\fIq\fP the quotient 
.br
\fIa\fP the dividend 
.br
\fId\fP the divisor 
.RE
.PP

.PP
Implemented in \fBEuclideanDomainOf< T >\fP, and \fBEuclideanDomainOf< PolynomialMod2 >\fP\&.
.SS "template<class T> const T & \fBAbstractEuclideanDomain\fP< T >::Gcd (const Element & a, const Element & b) const\fR [virtual]\fP"

.PP
Calculates the greatest common denominator in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP the first element 
.br
\fIb\fP the second element 
.RE
.PP
\fBReturns\fP
.RS 4
the greatest common denominator of a and b\&. 
.RE
.PP

.SS "template<class T> const T & \fBAbstractEuclideanDomain\fP< T >::Mod (const Element & a, const Element & b) const\fR [pure virtual]\fP"

.PP
Performs a modular reduction in the ring\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP the element 
.br
\fIb\fP the modulus 
.RE
.PP
\fBReturns\fP
.RS 4
the result of \fRab\fP\&. 
.RE
.PP

.PP
Implemented in \fBEuclideanDomainOf< T >\fP, and \fBEuclideanDomainOf< PolynomialMod2 >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
