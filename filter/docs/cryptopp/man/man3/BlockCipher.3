.TH "BlockCipher" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BlockCipher \- Interface for one direction (encryption or decryption) of a block cipher\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <cryptlib\&.h>\fP
.PP
Inherits \fBSimpleKeyingInterface\fP, and \fBBlockTransformation\fP\&.
.PP
Inherited by \fBSimpleKeyingInterfaceImpl< BlockCipher, BTEA_Info >\fP, \fBTwoBases< BlockCipher, ARIA_Info >\fP, \fBTwoBases< BlockCipher, INFO >\fP, \fBTwoBases< BlockCipher, Blowfish_Info >\fP, \fBTwoBases< BlockCipher, CAST128_Info >\fP, \fBTwoBases< BlockCipher, CAST256_Info >\fP, \fBTwoBases< BlockCipher, CHAM128_Info >\fP, \fBTwoBases< BlockCipher, CHAM64_Info >\fP, \fBTwoBases< BlockCipher, Camellia_Info >\fP, \fBTwoBases< BlockCipher, DES_Info >\fP, \fBTwoBases< BlockCipher, DES_EDE2_Info >\fP, \fBTwoBases< BlockCipher, DES_EDE3_Info >\fP, \fBTwoBases< BlockCipher, DES_XEX3_Info >\fP, \fBTwoBases< BlockCipher, GOST_Info >\fP, \fBTwoBases< BlockCipher, HIGHT_Info >\fP, \fBTwoBases< BlockCipher, IDEA_Info >\fP, \fBTwoBases< BlockCipher, Kalyna128_Info >\fP, \fBTwoBases< BlockCipher, Kalyna256_Info >\fP, \fBTwoBases< BlockCipher, Kalyna512_Info >\fP, \fBTwoBases< BlockCipher, LEA_Info >\fP, \fBTwoBases< BlockCipher, LR_Info< T > >\fP, \fBTwoBases< BlockCipher, MARS_Info >\fP, \fBTwoBases< BlockCipher, MDC_Info< H > >\fP, \fBTwoBases< BlockCipher, RC2_Info >\fP, \fBTwoBases< BlockCipher, RC5_Info >\fP, \fBTwoBases< BlockCipher, RC6_Info >\fP, \fBTwoBases< BlockCipher, Rijndael_Info >\fP, \fBTwoBases< BlockCipher, SEED_Info >\fP, \fBTwoBases< BlockCipher, SHACAL2_Info >\fP, \fBTwoBases< BlockCipher, SHARK_Info >\fP, \fBTwoBases< BlockCipher, SIMECK32_Info >\fP, \fBTwoBases< BlockCipher, SIMECK64_Info >\fP, \fBTwoBases< BlockCipher, SIMON_Info< 16, 16, 16, 32 > >\fP, \fBTwoBases< BlockCipher, SIMON_Info< 8, 12, 12, 16 > >\fP, \fBTwoBases< BlockCipher, SKIPJACK_Info >\fP, \fBTwoBases< BlockCipher, SM4_Info >\fP, \fBTwoBases< BlockCipher, SPECK_Info< 16, 16, 16, 32 > >\fP, \fBTwoBases< BlockCipher, SPECK_Info< 8, 12, 12, 16 > >\fP, \fBTwoBases< BlockCipher, Serpent_Info >\fP, \fBTwoBases< BlockCipher, Square_Info >\fP, \fBTwoBases< BlockCipher, TEA_Info >\fP, \fBTwoBases< BlockCipher, ThreeWay_Info >\fP, \fBTwoBases< BlockCipher, Threefish_Info< 128 > >\fP, \fBTwoBases< BlockCipher, Threefish_Info< 32 > >\fP, \fBTwoBases< BlockCipher, Threefish_Info< 64 > >\fP, \fBTwoBases< BlockCipher, Twofish_Info >\fP, \fBTwoBases< BlockCipher, XTEA_Info >\fP, and \fBSAFER::Base\fP\&.
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.in -1c

Protected Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual void \fBUncheckedSetKey\fP (const \fBbyte\fP *key, unsigned int length, const \fBNameValuePairs\fP &params)=0"
.br
.RI "Sets the key for this object without performing parameter validation\&. "
.ti -1c
.RI "void \fBThrowIfInvalidKeyLength\fP (size_t length)"
.br
.RI "Validates the key length\&. "
.ti -1c
.RI "void \fBThrowIfResynchronizable\fP ()"
.br
.RI "Validates the object\&. "
.ti -1c
.RI "void \fBThrowIfInvalidIV\fP (const \fBbyte\fP *iv)"
.br
.RI "Validates the IV\&. "
.ti -1c
.RI "size_t \fBThrowIfInvalidIVLength\fP (int length)"
.br
.RI "Validates the IV length\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBGetIVAndThrowIfInvalid\fP (const \fBNameValuePairs\fP &params, size_t &size)"
.br
.RI "Retrieves and validates the IV\&. "
.ti -1c
.RI "void \fBAssertValidKeyLength\fP (size_t length) const"
.br
.RI "Validates the key length\&. "
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "enum \fBIV_Requirement\fP { \fBUNIQUE_IV\fP = 0, \fBRANDOM_IV\fP, \fBUNPREDICTABLE_RANDOM_IV\fP, \fBINTERNALLY_GENERATED_IV\fP, \fBNOT_RESYNCHRONIZABLE\fP }"
.br
.RI "Secure IVs requirements as enumerated values\&. "
.in -1c

Public Types inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "enum \fBFlagsForAdvancedProcessBlocks\fP { \fBBT_InBlockIsCounter\fP =1, \fBBT_DontIncrementInOutPointers\fP =2, \fBBT_XorInput\fP =4, \fBBT_ReverseDirection\fP =8, \fBBT_AllowParallel\fP =16 }"
.br
.RI "Bit flags that control \fBAdvancedProcessBlocks()\fP behavior\&. "
.in -1c

Public Member Functions inherited from \fBSimpleKeyingInterface\fP
.in +1c
.ti -1c
.RI "virtual size_t \fBMinKeyLength\fP () const =0"
.br
.RI "Returns smallest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBMaxKeyLength\fP () const =0"
.br
.RI "Returns largest valid key length\&. "
.ti -1c
.RI "virtual size_t \fBDefaultKeyLength\fP () const =0"
.br
.RI "Returns default key length\&. "
.ti -1c
.RI "virtual size_t \fBGetValidKeyLength\fP (size_t keylength) const =0"
.br
.RI "Returns a valid key length for the algorithm\&. "
.ti -1c
.RI "virtual bool \fBIsValidKeyLength\fP (size_t keylength) const"
.br
.RI "Returns whether keylength is a valid key length\&. "
.ti -1c
.RI "virtual void \fBSetKey\fP (const \fBbyte\fP *key, size_t length, const \fBNameValuePairs\fP &params=g_nullNameValuePairs)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithRounds\fP (const \fBbyte\fP *key, size_t length, int rounds)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv, size_t ivLength)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "void \fBSetKeyWithIV\fP (const \fBbyte\fP *key, size_t length, const \fBbyte\fP *iv)"
.br
.RI "Sets or reset the key of this object\&. "
.ti -1c
.RI "virtual \fBIV_Requirement\fP \fBIVRequirement\fP () const =0"
.br
.RI "Minimal requirement for secure IVs\&. "
.ti -1c
.RI "bool \fBIsResynchronizable\fP () const"
.br
.RI "Determines if the object can be resynchronized\&. "
.ti -1c
.RI "bool \fBCanUseRandomIVs\fP () const"
.br
.RI "Determines if the object can use random IVs\&. "
.ti -1c
.RI "bool \fBCanUsePredictableIVs\fP () const"
.br
.RI "Determines if the object can use random but possibly predictable IVs\&. "
.ti -1c
.RI "bool \fBCanUseStructuredIVs\fP () const"
.br
.RI "Determines if the object can use structured IVs\&. "
.ti -1c
.RI "virtual unsigned int \fBIVSize\fP () const"
.br
.RI "Returns length of the IV accepted by this object\&. "
.ti -1c
.RI "unsigned int \fBDefaultIVLength\fP () const"
.br
.RI "Provides the default size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMinIVLength\fP () const"
.br
.RI "Provides the minimum size of an IV\&. "
.ti -1c
.RI "virtual unsigned int \fBMaxIVLength\fP () const"
.br
.RI "Provides the maximum size of an IV\&. "
.ti -1c
.RI "virtual void \fBResynchronize\fP (const \fBbyte\fP *iv, int ivLength=\-1)"
.br
.RI "Resynchronize with an IV\&. "
.ti -1c
.RI "virtual void \fBGetNextIV\fP (\fBRandomNumberGenerator\fP &rng, \fBbyte\fP *iv)"
.br
.RI "Retrieves a secure IV for the next message\&. "
.in -1c

Public Member Functions inherited from \fBBlockTransformation\fP
.in +1c
.ti -1c
.RI "virtual void \fBProcessAndXorBlock\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const =0"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (const \fBbyte\fP *inBlock, \fBbyte\fP *outBlock) const"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (\fBbyte\fP *inoutBlock) const"
.br
.RI "Encrypt or decrypt a block in place\&. "
.ti -1c
.RI "virtual unsigned int \fBBlockSize\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual bool \fBIsPermutation\fP () const"
.br
.RI "Determines if the transformation is a permutation\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalNumberOfParallelBlocks\fP () const"
.br
.RI "Determines the number of blocks that can be processed in parallel\&. "
.ti -1c
.RI "virtual size_t \fBAdvancedProcessBlocks\fP (const \fBbyte\fP *inBlocks, const \fBbyte\fP *xorBlocks, \fBbyte\fP *outBlocks, size_t length, \fBword32\fP flags) const"
.br
.RI "Encrypt and xor multiple blocks using additional flags\&. "
.ti -1c
.RI "\fBCipherDir\fP \fBGetCipherDirection\fP () const"
.br
.RI "Provides the direction of the cipher\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SH "Detailed Description"
.PP 
Interface for one direction (encryption or decryption) of a block cipher\&. 

These objects usually should not be used directly\&. See \fBBlockTransformation\fP for more details\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBAlgorithm\fP & BlockCipher::GetAlgorithm () const\fR [inline]\fP, \fR [protected]\fP, \fR [virtual]\fP"

.PP
Returns the base class \fBAlgorithm\fP\&. 
.PP
\fBReturns\fP
.RS 4
the base class \fBAlgorithm\fP 
.RE
.PP

.PP
Implements \fBSimpleKeyingInterface\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
