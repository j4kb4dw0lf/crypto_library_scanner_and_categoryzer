.TH "Filter" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Filter \- Implementation of \fBBufferedTransformation\fP's attachment interface\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <filters\&.h>\fP
.PP
Inherits \fBBufferedTransformation\fP, and \fBNotCopyable\fP\&.
.PP
Inherited by \fBAutoSignaling< Filter >\fP, \fBBufferless< Filter >\fP, \fBCustomFlushPropagation< Filter >\fP, \fBInputRejecting< Filter >\fP, \fBUnflushable< Filter >\fP, \fBEncodedObjectFilter\fP, \fBFilterWithBufferedInput\fP, \fBFilterWithInputQueue\fP, and \fBLowFirstBitWriter\fP\&.
.SS "Public Member Functions"

.PP
.RI "\fBATTACHMENT\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBFilter\fP (\fBBufferedTransformation\fP *attachment=NULLPTR)"
.br
.RI "Construct a \fBFilter\fP\&. "
.ti -1c
.RI "bool \fBAttachable\fP ()"
.br
.RI "Determine if attachable\&. "
.ti -1c
.RI "\fBBufferedTransformation\fP * \fBAttachedTransformation\fP ()"
.br
.RI "Retrieve attached transformation\&. "
.ti -1c
.RI "const \fBBufferedTransformation\fP * \fBAttachedTransformation\fP () const"
.br
.RI "Retrieve attached transformation\&. "
.ti -1c
.RI "void \fBDetach\fP (\fBBufferedTransformation\fP *newAttachment=NULLPTR)"
.br
.RI "Replace an attached transformation\&. "
.in -1c
.in -1c
.PP
.RI "\fBRETRIEVAL OF ONE MESSAGE\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "size_t \fBTransferTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &transferBytes, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer bytes from this object to another \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "size_t \fBCopyRangeTo2\fP (\fBBufferedTransformation\fP &target, \fBlword\fP &begin, \fBlword\fP end=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in -1c

Public Member Functions inherited from \fBBufferedTransformation\fP
.in +1c
.ti -1c
.RI "\fBBufferedTransformation\fP ()"
.br
.RI "Construct a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "\fBBufferedTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBAttach\fP (\fBBufferedTransformation\fP *newAttachment)"
.br
.RI "Add newAttachment to the end of attachment chain\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (\fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPut\fP (const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord16\fP (\fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord32\fP (\fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutWord64\fP (word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBbyte\fP * \fBCreatePutSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBCanModifyInput\fP () const"
.br
.RI "Determines whether input can be modified by the callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutModifiable\fP (\fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBMessageEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Signals the end of messages to the object\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPutMessageEnd\fP (const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPut2\fP (const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)=0"
.br
.RI "Input multiple bytes for processing\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPutModifiable2\fP (\fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBGetMaxWaitObjectCount\fP () const"
.br
.RI "Retrieves the maximum number of waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBGetWaitObjects\fP (WaitObjectContainer &container, CallStack const &callStack)"
.br
.RI "Retrieves waitable objects\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBIsolatedInitialize\fP (const \fBNameValuePairs\fP &parameters)"
.br
.RI "Initialize or reinitialize this object, without signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBIsolatedFlush\fP (bool hardFlush, bool blocking)=0"
.br
.RI "Flushes data buffered by this object, without signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBIsolatedMessageSeriesEnd\fP (bool blocking)"
.br
.RI "Marks the end of a series of messages, without signal propagation\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetAutoSignalPropagation\fP (int propagation)"
.br
.RI "Set propagation of automatically generated and transferred signals\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual int \fBGetAutoSignalPropagation\fP () const"
.br
.RI "Retrieve automatic signal propagation value\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBMaxRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAnyRetrievable\fP () const"
.br
.RI "Determines whether bytes are ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBGet\fP (\fBbyte\fP &outByte)"
.br
.RI "Retrieve a 8-bit byte\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBGet\fP (\fBbyte\fP *outString, size_t getMax)"
.br
.RI "Retrieve a block of bytes\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPeek\fP (\fBbyte\fP &outByte) const"
.br
.RI "Peek a 8-bit byte\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBPeek\fP (\fBbyte\fP *outString, size_t peekMax) const"
.br
.RI "Peek a block of bytes\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBGetWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP)"
.br
.RI "Retrieve a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord16\fP (\fBword16\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 16-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord32\fP (\fBword32\fP &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 32-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBPeekWord64\fP (word64 &value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP) const"
.br
.RI "Peek a 64-bit word\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBTransferTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP transferMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "move transferMax bytes of the buffered output to target as input "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBSkip\fP (\fBlword\fP skipMax=\fBLWORD_MAX\fP)"
.br
.RI "Discard skipMax bytes from the output buffer\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "\fBlword\fP \fBCopyRangeTo\fP (\fBBufferedTransformation\fP &target, \fBlword\fP position, \fBlword\fP copyMax=\fBLWORD_MAX\fP, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy bytes from this object using an index to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBlword\fP \fBTotalBytesRetrievable\fP () const"
.br
.RI "Provides the number of bytes ready for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessages\fP () const"
.br
.RI "Provides the number of meesages processed by this object\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBAnyMessages\fP () const"
.br
.RI "Determines if any messages are available for retrieval\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessage\fP ()"
.br
.RI "Start retrieving the next message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBSkipMessages\fP (unsigned int count=UINT_MAX)"
.br
.RI "Skip a number of meessages\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBTransferMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "unsigned int \fBCopyMessagesTo\fP (\fBBufferedTransformation\fP &target, unsigned int count=UINT_MAX, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSkipAll\fP ()"
.br
.RI "Skip all messages in the series\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBTransferAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "void \fBCopyAllTo\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL) const"
.br
.RI "Copy messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBGetNextMessageSeries\fP ()"
.br
.RI "Retrieve the next message in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessagesInThisSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual unsigned int \fBNumberOfMessageSeries\fP () const"
.br
.RI "Provides the number of messages in a series\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferMessagesTo2\fP (\fBBufferedTransformation\fP &target, unsigned int &messageCount, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer messages from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBTransferAllTo2\fP (\fBBufferedTransformation\fP &target, const std::string &channel=DEFAULT_CHANNEL, bool blocking=true)"
.br
.RI "Transfer all bytes from this object to another \fBBufferedTransformation\fP\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, \fBbyte\fP inByte, bool blocking=true)"
.br
.RI "Input a byte for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPut\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input a byte buffer for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutModifiable\fP (const std::string &channel, \fBbyte\fP *inString, size_t length, bool blocking=true)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord16\fP (const std::string &channel, \fBword16\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 16-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord32\fP (const std::string &channel, \fBword32\fP value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 32-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutWord64\fP (const std::string &channel, word64 value, \fBByteOrder\fP order=\fBBIG_ENDIAN_ORDER\fP, bool blocking=true)"
.br
.RI "Input a 64-bit word for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "bool \fBChannelMessageEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "size_t \fBChannelPutMessageEnd\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, int propagation=\-1, bool blocking=true)"
.br
.RI "Input multiple bytes for processing and signal the end of a message\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual \fBbyte\fP * \fBChannelCreatePutSpace\fP (const std::string &channel, size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBChannelPut2\fP (const std::string &channel, const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes for processing on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual size_t \fBChannelPutModifiable2\fP (const std::string &channel, \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking)"
.br
.RI "Input multiple bytes that may be modified by callee on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBChannelFlush\fP (const std::string &channel, bool hardFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual bool \fBChannelMessageSeriesEnd\fP (const std::string &channel, int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages on a channel\&. "
.in -1c
.in +1c
.ti -1c
.RI "virtual void \fBSetRetrievalChannel\fP (const std::string &channel)"
.br
.RI "Sets the default retrieval channel\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBWaitable\fP
.in +1c
.ti -1c
.RI "bool \fBWait\fP (unsigned long milliseconds, CallStack const &callStack)"
.br
.RI "Wait on this object\&. "
.in -1c
.SS "SIGNALS"

.in +1c
.ti -1c
.RI "size_t \fBm_inputPosition\fP"
.br
.ti -1c
.RI "int \fBm_continueAt\fP"
.br
.ti -1c
.RI "void \fBInitialize\fP (const \fBNameValuePairs\fP &parameters=g_nullNameValuePairs, int propagation=\-1)"
.br
.RI "Initialize or reinitialize this object, with signal propagation\&. "
.ti -1c
.RI "bool \fBFlush\fP (bool hardFlush, int propagation=\-1, bool blocking=true)"
.br
.RI "Flush buffered input and/or output, with signal propagation\&. "
.ti -1c
.RI "bool \fBMessageSeriesEnd\fP (int propagation=\-1, bool blocking=true)"
.br
.RI "Marks the end of a series of messages, with signal propagation\&. "
.ti -1c
.RI "virtual \fBBufferedTransformation\fP * \fBNewDefaultAttachment\fP () const"
.br
.ti -1c
.RI "void \fBInsert\fP (\fBFilter\fP *nextFilter)"
.br
.ti -1c
.RI "virtual bool \fBShouldPropagateMessageEnd\fP () const"
.br
.ti -1c
.RI "virtual bool \fBShouldPropagateMessageSeriesEnd\fP () const"
.br
.ti -1c
.RI "void \fBPropagateInitialize\fP (const \fBNameValuePairs\fP &parameters, int propagation)"
.br
.ti -1c
.RI "size_t \fBOutput\fP (int outputSite, const \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Forward processed data on to attached transformation\&. "
.ti -1c
.RI "size_t \fBOutputModifiable\fP (int outputSite, \fBbyte\fP *inString, size_t length, int messageEnd, bool blocking, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Output multiple bytes that may be modified by callee\&. "
.ti -1c
.RI "bool \fBOutputMessageEnd\fP (int outputSite, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Signals the end of messages to the object\&. "
.ti -1c
.RI "bool \fBOutputFlush\fP (int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Flush buffered input and/or output, with signal propagation\&. "
.ti -1c
.RI "bool \fBOutputMessageSeriesEnd\fP (int outputSite, int propagation, bool blocking, const std::string &channel=DEFAULT_CHANNEL)"
.br
.RI "Marks the end of a series of messages, with signal propagation\&. "
.in -1c
.SS "Additional Inherited Members"

.in +1c
.ti -1c
.RI "static int \fBDecrementPropagation\fP (int propagation)"
.br
.RI "Decrements the propagation count while clamping at 0\&. "
.in -1c
.SH "Detailed Description"
.PP 
Implementation of \fBBufferedTransformation\fP's attachment interface\&. 

\fBFilter\fP is a cornerstone of the Pipeline trinity\&. Data flows from Sources, through Filters, and then terminates in Sinks\&. The difference between a \fBSource\fP and \fBFilter\fP is a \fBSource\fP \fIpumps\fP data, while a \fBFilter\fP does not\&. The difference between a \fBFilter\fP and a \fBSink\fP is a \fBFilter\fP allows an attached transformation, while a \fBSink\fP does not\&.

.PP
See the discussion of \fBBufferedTransformation\fP in \fBcryptlib\&.h\fP for more details\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Filter::Filter (\fBBufferedTransformation\fP * attachment = \fRNULLPTR\fP)"

.PP
Construct a \fBFilter\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIattachment\fP an optional attached transformation
.RE
.PP
attachment can be NULL\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Filter::Attachable ()\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determine if attachable\&. 
.PP
\fBReturns\fP
.RS 4
true if the object allows attached transformations, false otherwise\&. 
.RE
.PP
\fBNote\fP
.RS 4
\fBSource\fP and \fBFilter\fP offer attached transformations; while \fBSink\fP does not\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "\fBBufferedTransformation\fP * Filter::AttachedTransformation ()\fR [virtual]\fP"

.PP
Retrieve attached transformation\&. 
.PP
\fBReturns\fP
.RS 4
pointer to a \fBBufferedTransformation\fP if there is an attached transformation, NULL otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "const \fBBufferedTransformation\fP * Filter::AttachedTransformation () const\fR [virtual]\fP"

.PP
Retrieve attached transformation\&. 
.PP
\fBReturns\fP
.RS 4
pointer to a \fBBufferedTransformation\fP if there is an attached transformation, NULL otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "size_t Filter::CopyRangeTo2 (\fBBufferedTransformation\fP & target, \fBlword\fP & begin, \fBlword\fP end = \fR\fBLWORD_MAX\fP\fP, const std::string & channel = \fRDEFAULT_CHANNEL\fP, bool blocking = \fRtrue\fP) const\fR [virtual]\fP"

.PP
Copy bytes from this object to another \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the destination \fBBufferedTransformation\fP 
.br
\fIbegin\fP the 0-based index of the first byte to copy in the stream 
.br
\fIend\fP the 0-based index of the last byte to copy in the stream 
.br
\fIchannel\fP the channel on which the transfer should occur 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain in the copy block (i\&.e\&., bytes not copied)
.RE
.PP
CopyRangeTo2 copies bytes from this object to the destination\&. The bytes are not removed from this object\&. Copying begins at the index position in the current stream, and not from an absolute position in the stream\&.

.PP
begin is an \fIIN\fP and \fIOUT\fP parameter\&. When the call is made, begin is the starting position of the copy\&. When the call returns, begin is the position of the first byte that was \fInot\fP copied (which may be different than end)\&. begin can be used for subsequent calls to \fBCopyRangeTo2()\fP\&. 
.PP
Implements \fBBufferedTransformation\fP\&.
.SS "void Filter::Detach (\fBBufferedTransformation\fP * newAttachment = \fRNULLPTR\fP)\fR [virtual]\fP"

.PP
Replace an attached transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fInewAttachment\fP an optional attached transformation
.RE
.PP
newAttachment can be a single filter, a chain of filters or NULL\&. Pass NULL to remove an existing \fBBufferedTransformation\fP or chain of filters 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "bool Filter::Flush (bool hardFlush, int propagation = \fR\-1\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Flush buffered input and/or output, with signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIhardFlush\fP is used to indicate whether all data should be flushed 
.br
\fIpropagation\fP the number of attached transformations the \fBFlush()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
true if the flush was successful, false otherwise
.RE
.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
\fBNote\fP
.RS 4
Hard flushes must be used with care\&. It means try to process and output everything, even if there may not be enough data to complete the action\&. For example, hard flushing a \fBHexDecoder\fP would cause an error if you do it after inputing an odd number of hex encoded characters\&. 

.PP
For some types of filters, like \fBZlibDecompressor\fP, hard flushes can only be done at "synchronization points"\&. These synchronization points are positions in the data stream that are created by hard flushes on the corresponding reverse filters, in this example \fBZlibCompressor\fP\&. This is useful when zlib compressed data is moved across a network in packets and compression state is preserved across packets, as in the SSH2 protocol\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.PP
Reimplemented in \fBInformationDispersal\fP, \fBMultichannel< Filter >\fP, \fBSecretSharing\fP, \fBUnflushable< Filter >\fP, and \fBUnflushable< Multichannel< Filter > >\fP\&.
.SS "void Filter::Initialize (const \fBNameValuePairs\fP & parameters = \fRg_nullNameValuePairs\fP, int propagation = \fR\-1\fP)\fR [virtual]\fP"

.PP
Initialize or reinitialize this object, with signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIparameters\fP a set of \fBNameValuePairs\fP to initialize or reinitialize this object 
.br
\fIpropagation\fP the number of attached transformations the \fBInitialize()\fP signal should be passed
.RE
.PP
\fBInitialize()\fP is used to initialize or reinitialize an object using a variable number of arbitrarily typed arguments\&. The function avoids the need for multiple constructors providing all possible combintations of configurable parameters\&.

.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.SS "bool Filter::MessageSeriesEnd (int propagation = \fR\-1\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Marks the end of a series of messages, with signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIpropagation\fP the number of attached transformations the \fBMessageSeriesEnd()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
true if the message was successful, false otherwise
.RE
.PP
Each object that receives the signal will perform its processing, decrement propagation, and then pass the signal on to attached transformations if the value is not 0\&.

.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
\fBNote\fP
.RS 4
There should be a \fBMessageEnd()\fP immediately before \fBMessageSeriesEnd()\fP\&. 
.RE
.PP

.PP
Reimplemented from \fBBufferedTransformation\fP\&.
.PP
Reimplemented in \fBMultichannel< Filter >\fP\&.
.SS "size_t Filter::Output (int outputSite, const \fBbyte\fP * inString, size_t length, int messageEnd, bool blocking, const std::string & channel = \fRDEFAULT_CHANNEL\fP)\fR [protected]\fP"

.PP
Forward processed data on to attached transformation\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutputSite\fP unknown, system crash between keyboard and chair\&.\&.\&. 
.br
\fIinString\fP the byte buffer to process 
.br
\fIlength\fP the size of the string, in bytes 
.br
\fImessageEnd\fP means how many filters to signal \fBMessageEnd()\fP to, including this one 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.br
\fIchannel\fP the channel to process the data 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain to be processed (i\&.e\&., bytes not processed)\&. 0 indicates all bytes were processed\&. 
.RE
.PP

.SS "bool Filter::OutputFlush (int outputSite, bool hardFlush, int propagation, bool blocking, const std::string & channel = \fRDEFAULT_CHANNEL\fP)\fR [protected]\fP"

.PP
Flush buffered input and/or output, with signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutputSite\fP unknown, system crash between keyboard and chair\&.\&.\&. 
.br
\fIhardFlush\fP is used to indicate whether all data should be flushed 
.br
\fIpropagation\fP the number of attached transformations the \fBFlush()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.br
\fIchannel\fP the channel to process the data 
.RE
.PP
\fBReturns\fP
.RS 4
true is the Flush signal was successful, false otherwise\&.
.RE
.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
\fBNote\fP
.RS 4
Hard flushes must be used with care\&. It means try to process and output everything, even if there may not be enough data to complete the action\&. For example, hard flushing a \fBHexDecoder\fP would cause an error if you do it after inputing an odd number of hex encoded characters\&. 

.PP
For some types of filters, like \fBZlibDecompressor\fP, hard flushes can only be done at "synchronization points"\&. These synchronization points are positions in the data stream that are created by hard flushes on the corresponding reverse filters, in this example \fBZlibCompressor\fP\&. This is useful when zlib compressed data is moved across a network in packets and compression state is preserved across packets, as in the SSH2 protocol\&. 
.RE
.PP

.SS "bool Filter::OutputMessageEnd (int outputSite, int propagation, bool blocking, const std::string & channel = \fRDEFAULT_CHANNEL\fP)\fR [protected]\fP"

.PP
Signals the end of messages to the object\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutputSite\fP unknown, system crash between keyboard and chair\&.\&.\&. 
.br
\fIpropagation\fP the number of attached transformations the \fBMessageEnd()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.br
\fIchannel\fP the channel to process the data 
.RE
.PP
\fBReturns\fP
.RS 4
true is the MessageEnd signal was successful, false otherwise\&.
.RE
.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.SS "bool Filter::OutputMessageSeriesEnd (int outputSite, int propagation, bool blocking, const std::string & channel = \fRDEFAULT_CHANNEL\fP)\fR [protected]\fP"

.PP
Marks the end of a series of messages, with signal propagation\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutputSite\fP unknown, system crash between keyboard and chair\&.\&.\&. 
.br
\fIpropagation\fP the number of attached transformations the \fBMessageSeriesEnd()\fP signal should be passed 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.br
\fIchannel\fP the channel to process the data 
.RE
.PP
\fBReturns\fP
.RS 4
true is the MessageEnd signal was successful, false otherwise\&.
.RE
.PP
Each object that receives the signal will perform its processing, decrement propagation, and then pass the signal on to attached transformations if the value is not 0\&.

.PP
propagation count includes this object\&. Setting propagation to \fR1\fP means this object only\&. Setting propagation to \fR-1\fP means unlimited propagation\&. 
.PP
\fBNote\fP
.RS 4
There should be a \fBMessageEnd()\fP immediately before \fBMessageSeriesEnd()\fP\&. 
.RE
.PP

.SS "size_t Filter::OutputModifiable (int outputSite, \fBbyte\fP * inString, size_t length, int messageEnd, bool blocking, const std::string & channel = \fRDEFAULT_CHANNEL\fP)\fR [protected]\fP"

.PP
Output multiple bytes that may be modified by callee\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutputSite\fP unknown, system crash between keyboard and chair\&.\&.\&. 
.br
\fIinString\fP the byte buffer to process 
.br
\fIlength\fP the size of the string, in bytes 
.br
\fImessageEnd\fP means how many filters to signal \fBMessageEnd()\fP to, including this one 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.br
\fIchannel\fP the channel to process the data 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain to be processed (i\&.e\&., bytes not processed)\&. 0 indicates all bytes were processed\&. 
.RE
.PP

.SS "size_t Filter::TransferTo2 (\fBBufferedTransformation\fP & target, \fBlword\fP & byteCount, const std::string & channel = \fRDEFAULT_CHANNEL\fP, bool blocking = \fRtrue\fP)\fR [virtual]\fP"

.PP
Transfer bytes from this object to another \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the destination \fBBufferedTransformation\fP 
.br
\fIbyteCount\fP the number of bytes to transfer 
.br
\fIchannel\fP the channel on which the transfer should occur 
.br
\fIblocking\fP specifies whether the object should block when processing input 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes that remain in the transfer block (i\&.e\&., bytes not transferred)
.RE
.PP
\fBTransferTo2()\fP removes bytes from this object and moves them to the destination\&. Transfer begins at the index position in the current stream, and not from an absolute position in the stream\&.

.PP
byteCount is an \fIIN\fP and \fIOUT\fP parameter\&. When the call is made, byteCount is the requested size of the transfer\&. When the call returns, byteCount is the number of bytes that were transferred\&. 
.PP
Implements \fBBufferedTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
