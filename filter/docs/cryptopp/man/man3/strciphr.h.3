.TH "/home/mock/cryptopp-master/strciphr.h" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/mock/cryptopp-master/strciphr.h \- Classes for implementing stream ciphers\&.

.SH SYNOPSIS
.br
.PP
\fR#include 'config\&.h'\fP
.br
\fR#include 'cryptlib\&.h'\fP
.br
\fR#include 'seckey\&.h'\fP
.br
\fR#include 'secblock\&.h'\fP
.br
\fR#include 'argnames\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBAbstractPolicyHolder< POLICY_INTERFACE, BASE >\fP"
.br
.RI "Access a stream cipher policy object\&. "
.ti -1c
.RI "class \fBConcretePolicyHolder< POLICY, BASE, POLICY_INTERFACE >\fP"
.br
.RI "Stream cipher policy object\&. "
.ti -1c
.RI "struct \fBAdditiveCipherAbstractPolicy\fP"
.br
.RI "Policy object for additive stream ciphers\&. "
.ti -1c
.RI "struct \fBAdditiveCipherConcretePolicy< WT, W, X, BASE >\fP"
.br
.RI "Base class for additive stream ciphers\&. "
.ti -1c
.RI "class \fBAdditiveCipherTemplate< BASE >\fP"
.br
.RI "Base class for additive stream ciphers with \fBSymmetricCipher\fP interface\&. "
.ti -1c
.RI "class \fBCFB_CipherAbstractPolicy\fP"
.br
.RI "Policy object for feedback based stream ciphers\&. "
.ti -1c
.RI "struct \fBCFB_CipherConcretePolicy< WT, W, BASE >\fP"
.br
.RI "Base class for feedback based stream ciphers\&. "
.ti -1c
.RI "struct \fBCFB_CipherConcretePolicy< WT, W, BASE >::RegisterOutput< B >\fP"
.br
.RI "Provides alternate access to a feedback register\&. "
.ti -1c
.RI "class \fBCFB_CipherTemplate< BASE >\fP"
.br
.RI "Base class for feedback based stream ciphers with \fBSymmetricCipher\fP interface\&. "
.ti -1c
.RI "class \fBCFB_EncryptionTemplate< BASE >\fP"
.br
.RI "Base class for feedback based stream ciphers in the forward direction with \fBSymmetricCipher\fP interface\&. "
.ti -1c
.RI "class \fBCFB_DecryptionTemplate< BASE >\fP"
.br
.RI "Base class for feedback based stream ciphers in the reverse direction with \fBSymmetricCipher\fP interface\&. "
.ti -1c
.RI "class \fBCFB_RequireFullDataBlocks< BASE >\fP"
.br
.RI "Base class for feedback based stream ciphers with a mandatory block size\&. "
.ti -1c
.RI "class \fBSymmetricCipherFinal< BASE, INFO >\fP"
.br
.RI "\fBSymmetricCipher\fP implementation\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCRYPTOPP_KEYSTREAM_OUTPUT_WORD\fP(x,  b,  i,  a)"
.br
.RI "Helper macro to implement OperateKeystream\&. "
.ti -1c
.RI "#define \fBCRYPTOPP_KEYSTREAM_OUTPUT_XMM\fP(x,  i,  a)"
.br
.RI "Helper macro to implement OperateKeystream\&. "
.ti -1c
.RI "#define \fBCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH\fP(x,  y)"
.br
.RI "Helper macro to implement OperateKeystream\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKeystreamOperationFlags\fP { \fBOUTPUT_ALIGNED\fP =1, \fBINPUT_ALIGNED\fP =2, \fBINPUT_NULL\fP = 4 }"
.br
.RI "Keystream operation flags\&. "
.ti -1c
.RI "enum \fBKeystreamOperation\fP { \fBWRITE_KEYSTREAM\fP = INPUT_NULL, \fBWRITE_KEYSTREAM_ALIGNED\fP = INPUT_NULL | OUTPUT_ALIGNED, \fBXOR_KEYSTREAM\fP = 0, \fBXOR_KEYSTREAM_INPUT_ALIGNED\fP = INPUT_ALIGNED, \fBXOR_KEYSTREAM_OUTPUT_ALIGNED\fP = OUTPUT_ALIGNED, \fBXOR_KEYSTREAM_BOTH_ALIGNED\fP = OUTPUT_ALIGNED | INPUT_ALIGNED }"
.br
.RI "Keystream operation flags\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "NAMESPACE_END CRYPTOPP_DLL_TEMPLATE_CLASS \fBAbstractPolicyHolder< AdditiveCipherAbstractPolicy, SymmetricCipher >\fP"
.br
.ti -1c
.RI "CRYPTOPP_DLL_TEMPLATE_CLASS \fBAdditiveCipherTemplate< AbstractPolicyHolder< AdditiveCipherAbstractPolicy, SymmetricCipher > >\fP"
.br
.ti -1c
.RI "CRYPTOPP_DLL_TEMPLATE_CLASS \fBCFB_CipherTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP"
.br
.ti -1c
.RI "CRYPTOPP_DLL_TEMPLATE_CLASS \fBCFB_EncryptionTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP"
.br
.ti -1c
.RI "CRYPTOPP_DLL_TEMPLATE_CLASS \fBCFB_DecryptionTemplate< AbstractPolicyHolder< CFB_CipherAbstractPolicy, SymmetricCipher > >\fP"
.br
.in -1c
.SH "Detailed Description"
.PP
Classes for implementing stream ciphers\&.

This file contains helper classes for implementing stream ciphers\&. All this infrastructure may look very complex compared to what's in Crypto++ 4\&.x, but stream ciphers implementations now support a lot of new functionality, including better performance (minimizing copying), resetting of keys and IVs, and methods to query which features are supported by a cipher\&.

.PP
Here's an explanation of these classes\&. The word "policy" is used here to mean a class with a set of methods that must be implemented by individual stream cipher implementations\&. This is usually much simpler than the full stream cipher API, which is implemented by either \fBAdditiveCipherTemplate\fP or \fBCFB_CipherTemplate\fP using the policy\&. So for example, an implementation of \fBSEAL\fP only needs to implement the \fBAdditiveCipherAbstractPolicy\fP interface (since it's an additive cipher, i\&.e\&., it xors a keystream into the plaintext)\&. See this line in \fBseal\&.h\fP:
.PP
.nf

    typedef \fBSymmetricCipherFinal\fP<\fBConcretePolicyHolder\fP<\fBSEAL_Policy\fP<B>, \fBAdditiveCipherTemplate\fP<> > > Encryption;
.fi
.PP

.PP
\fBAdditiveCipherTemplate\fP and \fBCFB_CipherTemplate\fP are designed so that they don't need to take a policy class as a template parameter (although this is allowed), so that their code is not duplicated for each new cipher\&. Instead they each get a reference to an abstract policy interface by calling AccessPolicy() on itself, so AccessPolicy() must be overridden to return the actual policy reference\&. This is done by the \fBConcretePolicyHolder\fP class\&. Finally, \fBSymmetricCipherFinal\fP implements the constructors and other functions that must be implemented by the most derived class\&.
.SH "Macro Definition Documentation"
.PP
.SS "#define CRYPTOPP_KEYSTREAM_OUTPUT_SWITCH( x,  y)"
\fBValue:\fP
.nf
    switch (operation)                              \\
    {                                               \\
        case WRITE_KEYSTREAM:                       \\
            x(EnumToInt(WRITE_KEYSTREAM))   \\
            break;                                  \\
        case XOR_KEYSTREAM:                         \\
            x(EnumToInt(XOR_KEYSTREAM))     \\
            input += y;                             \\
            break;                                  \\
        case XOR_KEYSTREAM_INPUT_ALIGNED:           \\
            x(EnumToInt(XOR_KEYSTREAM_INPUT_ALIGNED))       \\
            input += y;                             \\
            break;                                  \\
        case XOR_KEYSTREAM_OUTPUT_ALIGNED:          \\
            x(EnumToInt(XOR_KEYSTREAM_OUTPUT_ALIGNED))      \\
            input += y;                             \\
            break;                                  \\
        case WRITE_KEYSTREAM_ALIGNED:               \\
            x(EnumToInt(WRITE_KEYSTREAM_ALIGNED))           \\
            break;                                  \\
        case XOR_KEYSTREAM_BOTH_ALIGNED:            \\
            x(EnumToInt(XOR_KEYSTREAM_BOTH_ALIGNED))        \\
            input += y;                             \\
            break;                                  \\
    }                                               \\
    output += y;
.PP
.fi

.PP
Helper macro to implement OperateKeystream\&.
.SS "#define CRYPTOPP_KEYSTREAM_OUTPUT_WORD( x,  b,  i,  a)"
\fBValue:\fP
.nf
    PutWord(((x & OUTPUT_ALIGNED) != 0), b, output+i*sizeof(WordType), (x & INPUT_NULL) ? (a) : (a) ^ GetWord<WordType>(((x & INPUT_ALIGNED) != 0), b, input+i*sizeof(WordType)));
.PP
.fi

.PP
Helper macro to implement OperateKeystream\&.
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBKeystreamOperation\fP mask
.br
\fIb\fP Endian order
.br
\fIi\fP index in output buffer
.br
\fIa\fP value to output
.RE
.PP

.SS "#define CRYPTOPP_KEYSTREAM_OUTPUT_XMM( x,  i,  a)"
\fBValue:\fP
.nf
    {\\
    __m128i t = (x & INPUT_NULL) ? a : _mm_xor_si128(a, (x & INPUT_ALIGNED) ? _mm_load_si128((__m128i *)input+i) : _mm_loadu_si128((__m128i *)input+i));\\
    if (x & OUTPUT_ALIGNED) _mm_store_si128((__m128i *)output+i, t);\\
    else _mm_storeu_si128((__m128i *)output+i, t);}
.PP
.fi

.PP
Helper macro to implement OperateKeystream\&.
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBKeystreamOperation\fP mask
.br
\fIi\fP index in output buffer
.br
\fIa\fP value to output
.RE
.PP

.SH "Enumeration Type Documentation"
.PP
.SS "enum \fBKeystreamOperation\fP"

.PP
Keystream operation flags\&.
.PP
\fBSee also\fP
.RS 4
\fBAdditiveCipherAbstractPolicy::GetBytesPerIteration()\fP, \fBAdditiveCipherAbstractPolicy::GetOptimalBlockSize()\fP and \fBAdditiveCipherAbstractPolicy::GetAlignment()\fP
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIWRITE_KEYSTREAM \fP
Write the keystream to the output buffer, input is NULL\&.
.TP
\f(BIWRITE_KEYSTREAM_ALIGNED \fP
Write the keystream to the aligned output buffer, input is NULL\&.
.TP
\f(BIXOR_KEYSTREAM \fP
XOR the input buffer and keystream, write to the output buffer\&.
.TP
\f(BIXOR_KEYSTREAM_INPUT_ALIGNED \fP
XOR the aligned input buffer and keystream, write to the output buffer\&.
.TP
\f(BIXOR_KEYSTREAM_OUTPUT_ALIGNED \fP
XOR the input buffer and keystream, write to the aligned output buffer\&.
.TP
\f(BIXOR_KEYSTREAM_BOTH_ALIGNED \fP
XOR the aligned input buffer and keystream, write to the aligned output buffer\&.
.SS "enum \fBKeystreamOperationFlags\fP"

.PP
Keystream operation flags\&.
.PP
\fBSee also\fP
.RS 4
\fBAdditiveCipherAbstractPolicy::GetBytesPerIteration()\fP, \fBAdditiveCipherAbstractPolicy::GetOptimalBlockSize()\fP and \fBAdditiveCipherAbstractPolicy::GetAlignment()\fP
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIOUTPUT_ALIGNED \fP
Output buffer is aligned\&.
.TP
\f(BIINPUT_ALIGNED \fP
Input buffer is aligned\&.
.TP
\f(BIINPUT_NULL \fP
Input buffer is NULL\&.
.SH "Author"
.PP
Generated automatically by Doxygen for My Project from the source code\&.
