.TH "ed25519_MessageAccumulator" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ed25519_MessageAccumulator \- \fBed25519\fP message accumulator  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <xed25519\&.h>\fP
.PP
Inherits \fBPK_MessageAccumulator\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (RESERVE_SIZE=2048+64)"
.br
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (SIGNATURE_LENGTH=64)"
.br
.ti -1c
.RI "\fBed25519_MessageAccumulator\fP ()"
.br
.RI "Create a message accumulator\&. "
.ti -1c
.RI "\fBed25519_MessageAccumulator\fP (\fBRandomNumberGenerator\fP &rng)"
.br
.RI "Create a message accumulator\&. "
.ti -1c
.RI "void \fBUpdate\fP (const \fBbyte\fP *msg, size_t len)"
.br
.RI "Add data to the accumulator\&. "
.ti -1c
.RI "void \fBRestart\fP ()"
.br
.RI "Reset the accumulator\&. "
.ti -1c
.RI "\fBbyte\fP * \fBsignature\fP ()"
.br
.RI "Retrieve pointer to signature buffer\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBsignature\fP () const"
.br
.RI "Retrieve pointer to signature buffer\&. "
.ti -1c
.RI "const \fBbyte\fP * \fBdata\fP () const"
.br
.RI "Retrieve pointer to data buffer\&. "
.ti -1c
.RI "size_t \fBsize\fP () const"
.br
.RI "Retrieve size of data buffer\&. "
.in -1c

Public Member Functions inherited from \fBPK_MessageAccumulator\fP
.in +1c
.ti -1c
.RI "unsigned int \fBDigestSize\fP () const"
.br
.ti -1c
.RI "void \fBTruncatedFinal\fP (\fBbyte\fP *digest, size_t digestSize)"
.br
.in -1c

Public Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "\fBHashTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual \fBbyte\fP * \fBCreateUpdateSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "virtual void \fBFinal\fP (\fBbyte\fP *digest)"
.br
.RI "Computes the hash of the current message\&. "
.ti -1c
.RI "unsigned int \fBTagSize\fP () const"
.br
.ti -1c
.RI "virtual unsigned int \fBBlockSize\fP () const"
.br
.RI "Provides the block size of the compression function\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this hash\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual void \fBCalculateDigest\fP (\fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerify\fP (const \fBbyte\fP *digest)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyDigest\fP (const \fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.ti -1c
.RI "virtual void \fBCalculateTruncatedDigest\fP (\fBbyte\fP *digest, size_t digestSize, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBTruncatedVerify\fP (const \fBbyte\fP *digest, size_t digestLength)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyTruncatedDigest\fP (const \fBbyte\fP *digest, size_t digestLength, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBbyte\fP, \fBAllocatorWithCleanup\fP< \fBbyte\fP > > \fBm_msg\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidTruncatedSize\fP (size_t size) const"
.br
.RI "Validates a truncated digest size\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBed25519\fP message accumulator 

\fBed25519\fP buffers the entire message, and does not digest the message incrementally\&. You should be careful with large messages like files on-disk\&. The behavior is by design because Bernstein feels small messages should be authenticated; and larger messages will be digested by the application\&.

.PP
The accumulator is used for signing and verification\&. The first 64-bytes of storage is reserved for the signature\&. During signing the signature storage is unused\&. During verification the first 64 bytes holds the signature\&. The signature is provided by the \fBPK_Verifier\fP framework and the call to PK_Signer::InputSignature\&. Member functions \fBdata()\fP and \fBsize()\fP refer to the accumulated message\&. Member function \fBsignature()\fP refers to the signature with an implicit size of SIGNATURE_LENGTH bytes\&.

.PP
Applications which digest large messages, like an ISO disk file, should take care because the design effectively disgorges the format operation from the signing operation\&. Put another way, be careful to ensure what you are signing is is in fact a digest of the intended message, and not a different message digest supplied by an attacker\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ed25519_MessageAccumulator::ed25519_MessageAccumulator (\fBRandomNumberGenerator\fP & rng)\fR [inline]\fP"

.PP
Create a message accumulator\&. \fBed25519\fP does not use a RNG\&. You can safely use \fBNullRNG()\fP because IsProbablistic returns false\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBbyte\fP * ed25519_MessageAccumulator::data () const\fR [inline]\fP"

.PP
Retrieve pointer to data buffer\&. 
.PP
\fBReturns\fP
.RS 4
pointer to data buffer 
.RE
.PP

.SS "void ed25519_MessageAccumulator::Restart ()\fR [inline]\fP, \fR [virtual]\fP"

.PP
Reset the accumulator\&. 
.PP
Reimplemented from \fBHashTransformation\fP\&.
.SS "\fBbyte\fP * ed25519_MessageAccumulator::signature ()\fR [inline]\fP"

.PP
Retrieve pointer to signature buffer\&. 
.PP
\fBReturns\fP
.RS 4
pointer to signature buffer 
.RE
.PP

.SS "const \fBbyte\fP * ed25519_MessageAccumulator::signature () const\fR [inline]\fP"

.PP
Retrieve pointer to signature buffer\&. 
.PP
\fBReturns\fP
.RS 4
pointer to signature buffer 
.RE
.PP

.SS "size_t ed25519_MessageAccumulator::size () const\fR [inline]\fP"

.PP
Retrieve size of data buffer\&. 
.PP
\fBReturns\fP
.RS 4
size of the data buffer, in bytes 
.RE
.PP

.SS "void ed25519_MessageAccumulator::Update (const \fBbyte\fP * msg, size_t len)\fR [inline]\fP, \fR [virtual]\fP"

.PP
Add data to the accumulator\&. 
.PP
\fBParameters\fP
.RS 4
\fImsg\fP pointer to the data to accumulate 
.br
\fIlen\fP the size of the data, in bytes 
.RE
.PP

.PP
Implements \fBHashTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
