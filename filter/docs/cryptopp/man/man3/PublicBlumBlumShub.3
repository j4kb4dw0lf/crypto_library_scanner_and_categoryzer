.TH "PublicBlumBlumShub" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
PublicBlumBlumShub \- \fBBlumBlumShub\fP without factorization of the modulus\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <blumshub\&.h>\fP
.PP
Inherits \fBRandomNumberGenerator\fP, and \fBStreamTransformation\fP\&.
.PP
Inherited by \fBBlumBlumShub\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPublicBlumBlumShub\fP (const \fBInteger\fP &n, const \fBInteger\fP &seed)"
.br
.RI "Construct a \fBPublicBlumBlumShub\fP\&. "
.ti -1c
.RI "unsigned int \fBGenerateBit\fP ()"
.br
.RI "Generate new random bit and return it\&. "
.ti -1c
.RI "\fBbyte\fP \fBGenerateByte\fP ()"
.br
.RI "Generate new random byte and return it\&. "
.ti -1c
.RI "void \fBGenerateBlock\fP (\fBbyte\fP *output, size_t size)"
.br
.RI "Generate random array of bytes\&. "
.ti -1c
.RI "void \fBProcessData\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)"
.br
.RI "Encrypt or decrypt an array of bytes\&. "
.ti -1c
.RI "bool \fBIsSelfInverting\fP () const"
.br
.RI "Determines whether the cipher is self-inverting\&. "
.ti -1c
.RI "bool \fBIsForwardTransformation\fP () const"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.in -1c

Public Member Functions inherited from \fBRandomNumberGenerator\fP
.in +1c
.ti -1c
.RI "virtual void \fBIncorporateEntropy\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Update RNG state with additional unpredictable values\&. "
.ti -1c
.RI "virtual bool \fBCanIncorporateEntropy\fP () const"
.br
.RI "Determines if a generator can accept additional entropy\&. "
.ti -1c
.RI "virtual \fBword32\fP \fBGenerateWord32\fP (\fBword32\fP min=0, \fBword32\fP max=0xffffffffUL)"
.br
.RI "Generate a random 32 bit word in the range min to max, inclusive\&. "
.ti -1c
.RI "virtual void \fBGenerateIntoBufferedTransformation\fP (\fBBufferedTransformation\fP &target, const std::string &channel, \fBlword\fP length)"
.br
.RI "Generate random bytes into a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "virtual void \fBDiscardBytes\fP (size_t n)"
.br
.RI "Generate and discard n bytes\&. "
.ti -1c
.RI "template<class IT> void \fBShuffle\fP (IT begin, IT end)"
.br
.RI "Randomly shuffle the specified array\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c

Public Member Functions inherited from \fBStreamTransformation\fP
.in +1c
.ti -1c
.RI "\fBStreamTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual unsigned int \fBMandatoryBlockSize\fP () const"
.br
.RI "Provides the mandatory block size of the cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this cipher\&. "
.ti -1c
.RI "virtual unsigned int \fBGetOptimalBlockSizeUsed\fP () const"
.br
.RI "Provides the number of bytes used in the current block when processing at optimal block size\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual size_t \fBProcessLastBlock\fP (\fBbyte\fP *outString, size_t outLength, const \fBbyte\fP *inString, size_t inLength)"
.br
.RI "Encrypt or decrypt the last block of data\&. "
.ti -1c
.RI "virtual unsigned int \fBMinLastBlockSize\fP () const"
.br
.RI "Provides the size of the last block\&. "
.ti -1c
.RI "virtual bool \fBIsLastBlockSpecial\fP () const"
.br
.RI "Determines if the last block receives special processing\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *inoutString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "void \fBProcessString\fP (\fBbyte\fP *outString, const \fBbyte\fP *inString, size_t length)"
.br
.RI "Encrypt or decrypt a string of bytes\&. "
.ti -1c
.RI "\fBbyte\fP \fBProcessByte\fP (\fBbyte\fP input)"
.br
.RI "Encrypt or decrypt a byte\&. "
.ti -1c
.RI "virtual bool \fBIsRandomAccess\fP () const =0"
.br
.RI "Determines whether the cipher supports random access\&. "
.ti -1c
.RI "virtual void \fBSeek\fP (\fBlword\fP pos)"
.br
.RI "Seek to an absolute position\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBModularArithmetic\fP \fBmodn\fP"
.br
.ti -1c
.RI "\fBInteger\fP \fBcurrent\fP"
.br
.ti -1c
.RI "word \fBmaxBits\fP"
.br
.ti -1c
.RI "word \fBbitsLeft\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBBlumBlumShub\fP without factorization of the modulus\&. 

You should reseed the generator after a fork() to avoid multiple generators with the same internal state\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "PublicBlumBlumShub::PublicBlumBlumShub (const \fBInteger\fP & n, const \fBInteger\fP & seed)"

.PP
Construct a \fBPublicBlumBlumShub\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP the modulus 
.br
\fIseed\fP the seed for the generator
.RE
.PP
seed is the secret key and should be about as large as n\&. 
.SH "Member Function Documentation"
.PP 
.SS "unsigned int PublicBlumBlumShub::GenerateBit ()\fR [virtual]\fP"

.PP
Generate new random bit and return it\&. 
.PP
\fBReturns\fP
.RS 4
a random bit
.RE
.PP
The default implementation calls \fBGenerateByte()\fP and return its lowest bit\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void PublicBlumBlumShub::GenerateBlock (\fBbyte\fP * output, size_t size)\fR [virtual]\fP"

.PP
Generate random array of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP the byte buffer 
.br
\fIsize\fP the length of the buffer, in bytes
.RE
.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
\fBNote\fP
.RS 4
A derived generator \fImust\fP override either \fBGenerateBlock()\fP or \fBGenerateIntoBufferedTransformation()\fP\&. They can override both, or have one call the other\&. 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "\fBbyte\fP PublicBlumBlumShub::GenerateByte ()\fR [virtual]\fP"

.PP
Generate new random byte and return it\&. 
.PP
\fBReturns\fP
.RS 4
a random 8-bit byte
.RE
.PP
Default implementation calls \fBGenerateBlock()\fP with one byte\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "bool PublicBlumBlumShub::IsForwardTransformation () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines if the cipher is being operated in its forward direction\&. 
.PP
\fBReturns\fP
.RS 4
true if DIR is ENCRYPTION, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBIsForwardTransformation()\fP, IsPermutation(), GetCipherDirection() 
.RE
.PP

.PP
Implements \fBStreamTransformation\fP\&.
.SS "bool PublicBlumBlumShub::IsSelfInverting () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines whether the cipher is self-inverting\&. 
.PP
\fBReturns\fP
.RS 4
true if the cipher is self-inverting, false otherwise
.RE
.PP
IsSelfInverting determines whether this transformation is self-inverting (e\&.g\&. xor with a keystream)\&. 
.PP
Implements \fBStreamTransformation\fP\&.
.SS "void PublicBlumBlumShub::ProcessData (\fBbyte\fP * outString, const \fBbyte\fP * inString, size_t length)\fR [virtual]\fP"

.PP
Encrypt or decrypt an array of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutString\fP the output byte buffer 
.br
\fIinString\fP the input byte buffer 
.br
\fIlength\fP the size of the input and output byte buffers, in bytes
.RE
.PP
ProcessData is called with a string of bytes whose size depends on MandatoryBlockSize\&. Either \fRinString == outString\fP, or they must not overlap\&. 
.PP
\fBSee also\fP
.RS 4
\fBProcessData\fP, \fBProcessLastBlock\fP, \fBMandatoryBlockSize\fP, \fBMinLastBlockSize\fP, \fBBlockPaddingSchemeDef\fP, \fBIsLastBlockSpecial\fP 
.RE
.PP

.PP
Implements \fBStreamTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
