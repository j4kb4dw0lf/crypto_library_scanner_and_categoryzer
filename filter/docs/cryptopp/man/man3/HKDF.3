.TH "HKDF< T >" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
HKDF< T > \- Extract-and-Expand Key Derivation Function (\fBHKDF\fP)  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <hkdf\&.h>\fP
.PP
Inherits \fBKeyDerivationFunction\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "size_t \fBMaxDerivedKeyLength\fP () const"
.br
.RI "Determine maximum number of bytes\&. "
.ti -1c
.RI "size_t \fBGetValidDerivedLength\fP (size_t keylength) const"
.br
.RI "Returns a valid key length for the derivation function\&. "
.ti -1c
.RI "size_t \fBDeriveKey\fP (\fBbyte\fP *derived, size_t derivedLen, const \fBbyte\fP *secret, size_t secretLen, const \fBNameValuePairs\fP &params) const"
.br
.RI "Derive a key from a seed\&. "
.ti -1c
.RI "size_t \fBDeriveKey\fP (\fBbyte\fP *derived, size_t derivedLen, const \fBbyte\fP *secret, size_t secretLen, const \fBbyte\fP *salt, size_t saltLen, const \fBbyte\fP *info, size_t infoLen) const"
.br
.RI "Derive a key from a seed\&. "
.in -1c

Public Member Functions inherited from \fBKeyDerivationFunction\fP
.in +1c
.ti -1c
.RI "virtual size_t \fBMinDerivedKeyLength\fP () const"
.br
.RI "Determine minimum number of bytes\&. "
.ti -1c
.RI "virtual bool \fBIsValidDerivedLength\fP (size_t keylength) const"
.br
.RI "Returns whether keylength is a valid key length\&. "
.ti -1c
.RI "virtual void \fBSetParameters\fP (const \fBNameValuePairs\fP &params)"
.br
.RI "Set or change parameters\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBStaticAlgorithmName\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef \fBbyte\fP \fBNullVectorType\fP[T::DIGESTSIZE]"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "const \fBAlgorithm\fP & \fBGetAlgorithm\fP () const"
.br
.RI "Returns the base class \fBAlgorithm\fP\&. "
.in -1c

Protected Member Functions inherited from \fBKeyDerivationFunction\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidDerivedKeyLength\fP (size_t length) const"
.br
.RI "Validates the derived key length\&. "
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const NullVectorType & \fBGetNullVector\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T>
.br
class HKDF< T >"Extract-and-Expand Key Derivation Function (\fBHKDF\fP) 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP \fBHashTransformation\fP class 
.RE
.PP
\fBSee also\fP
.RS 4
\fRCryptographic Extraction and Key Derivation: The HKDF Scheme\fP and \fRHMAC-based Extract-and-Expand Key Derivation Function (HKDF)\fP 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 5\&.6\&.3 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class T> std::string \fBHKDF\fP< T >::AlgorithmName () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the name of this algorithm\&. 
.PP
\fBReturns\fP
.RS 4
the standard algorithm name 
.RE
.PP

.PP
Implements \fBKeyDerivationFunction\fP\&.
.SS "template<class T> size_t \fBHKDF\fP< T >::DeriveKey (\fBbyte\fP * derived, size_t derivedLen, const \fBbyte\fP * secret, size_t secretLen, const \fBbyte\fP * salt, size_t saltLen, const \fBbyte\fP * info, size_t infoLen) const"

.PP
Derive a key from a seed\&. 
.PP
\fBParameters\fP
.RS 4
\fIderived\fP the derived output buffer 
.br
\fIderivedLen\fP the size of the derived buffer, in bytes 
.br
\fIsecret\fP the seed input buffer 
.br
\fIsecretLen\fP the size of the secret buffer, in bytes 
.br
\fIsalt\fP the salt input buffer 
.br
\fIsaltLen\fP the size of the salt buffer, in bytes 
.br
\fIinfo\fP the additional input buffer 
.br
\fIinfoLen\fP the size of the info buffer, in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
the number of iterations performed 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBInvalidDerivedKeyLength\fP\fP if \fRderivedLen\fP is invalid for the scheme
.RE
.PP
\fBDeriveKey()\fP provides a standard interface to derive a key from a seed and other parameters\&. Each class that derives from \fBKeyDerivationFunction\fP provides an overload that accepts most parameters used by the derivation function\&.

.PP
\fRsalt\fP and \fRinfo\fP can be \fRnullptr\fP with 0 length\&. \fBHKDF\fP is unusual in that a non-NULL salt with length 0 is different than a NULL \fRsalt\fP\&. A NULL \fRsalt\fP causes \fBHKDF\fP to use a string of 0's of length \fRT::DIGESTSIZE\fP for the \fRsalt\fP\&.

.PP
\fBHKDF\fP always returns 1 because it only performs 1 iteration\&. Other derivation functions, like PBKDF's, will return more interesting values\&. 
.SS "template<class T> size_t \fBHKDF\fP< T >::DeriveKey (\fBbyte\fP * derived, size_t derivedLen, const \fBbyte\fP * secret, size_t secretLen, const \fBNameValuePairs\fP & params) const\fR [virtual]\fP"

.PP
Derive a key from a seed\&. 
.PP
\fBParameters\fP
.RS 4
\fIderived\fP the derived output buffer 
.br
\fIderivedLen\fP the size of the derived buffer, in bytes 
.br
\fIsecret\fP the seed input buffer 
.br
\fIsecretLen\fP the size of the secret buffer, in bytes 
.br
\fIparams\fP additional initialization parameters to configure this object 
.RE
.PP
\fBReturns\fP
.RS 4
the number of iterations performed 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBInvalidDerivedKeyLength\fP\fP if \fRderivedLen\fP is invalid for the scheme
.RE
.PP
\fBDeriveKey()\fP provides a standard interface to derive a key from a secret seed and other parameters\&. Each class that derives from \fBKeyDerivationFunction\fP provides an overload that accepts most parameters used by the derivation function\&.

.PP
the number of iterations performed by \fBDeriveKey()\fP may be 1\&. For example, a scheme like \fBHKDF\fP does not use the iteration count so it returns 1\&. 
.PP
Implements \fBKeyDerivationFunction\fP\&.
.SS "template<class T> const \fBAlgorithm\fP & \fBHKDF\fP< T >::GetAlgorithm () const\fR [inline]\fP, \fR [protected]\fP, \fR [virtual]\fP"

.PP
Returns the base class \fBAlgorithm\fP\&. 
.PP
\fBReturns\fP
.RS 4
the base class \fBAlgorithm\fP 
.RE
.PP

.PP
Implements \fBKeyDerivationFunction\fP\&.
.SS "template<class T> size_t \fBHKDF\fP< T >::GetValidDerivedLength (size_t keylength) const\fR [virtual]\fP"

.PP
Returns a valid key length for the derivation function\&. 
.PP
\fBParameters\fP
.RS 4
\fIkeylength\fP the size of the derived key, in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
the valid key length, in bytes 
.RE
.PP

.PP
Implements \fBKeyDerivationFunction\fP\&.
.SS "template<class T> size_t \fBHKDF\fP< T >::MaxDerivedKeyLength () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determine maximum number of bytes\&. 
.PP
\fBReturns\fP
.RS 4
Maximum number of bytes which can be derived 
.RE
.PP

.PP
Reimplemented from \fBKeyDerivationFunction\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
