.TH "BlockTransformation" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BlockTransformation \- Interface for the data processing part of block ciphers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <cryptlib\&.h>\fP
.PP
Inherits \fBAlgorithm\fP\&.
.PP
Inherited by \fBBlockCipher\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBFlagsForAdvancedProcessBlocks\fP { \fBBT_InBlockIsCounter\fP =1, \fBBT_DontIncrementInOutPointers\fP =2, \fBBT_XorInput\fP =4, \fBBT_ReverseDirection\fP =8, \fBBT_AllowParallel\fP =16 }"
.br
.RI "Bit flags that control \fBAdvancedProcessBlocks()\fP behavior\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBProcessAndXorBlock\fP (const \fBbyte\fP *inBlock, const \fBbyte\fP *xorBlock, \fBbyte\fP *outBlock) const =0"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (const \fBbyte\fP *inBlock, \fBbyte\fP *outBlock) const"
.br
.RI "Encrypt or decrypt a block\&. "
.ti -1c
.RI "void \fBProcessBlock\fP (\fBbyte\fP *inoutBlock) const"
.br
.RI "Encrypt or decrypt a block in place\&. "
.ti -1c
.RI "virtual unsigned int \fBBlockSize\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "virtual bool \fBIsPermutation\fP () const"
.br
.RI "Determines if the transformation is a permutation\&. "
.ti -1c
.RI "virtual bool \fBIsForwardTransformation\fP () const =0"
.br
.RI "Determines if the cipher is being operated in its forward direction\&. "
.ti -1c
.RI "virtual unsigned int \fBOptimalNumberOfParallelBlocks\fP () const"
.br
.RI "Determines the number of blocks that can be processed in parallel\&. "
.ti -1c
.RI "virtual size_t \fBAdvancedProcessBlocks\fP (const \fBbyte\fP *inBlocks, const \fBbyte\fP *xorBlocks, \fBbyte\fP *outBlocks, size_t length, \fBword32\fP flags) const"
.br
.RI "Encrypt and xor multiple blocks using additional flags\&. "
.ti -1c
.RI "\fBCipherDir\fP \fBGetCipherDirection\fP () const"
.br
.RI "Provides the direction of the cipher\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SH "Detailed Description"
.PP 
Interface for the data processing part of block ciphers\&. 

Classes derived from \fBBlockTransformation\fP are block ciphers in ECB mode (for example the \fBDES::Encryption\fP class), which are stateless\&. These classes should not be used directly, but only in combination with a mode class (see \fBCipherModeDocumentation\fP in \fBmodes\&.h\fP)\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBBlockTransformation::FlagsForAdvancedProcessBlocks\fP"

.PP
Bit flags that control \fBAdvancedProcessBlocks()\fP behavior\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBT_InBlockIsCounter \fP
inBlock is a counter 
.TP
\f(BIBT_DontIncrementInOutPointers \fP
should not modify block pointers 
.TP
\f(BIBT_XorInput \fP
Xor inputs before transformation\&. 
.TP
\f(BIBT_ReverseDirection \fP
perform the transformation in reverse 
.TP
\f(BIBT_AllowParallel \fP
Allow parallel transformations\&. 
.SH "Member Function Documentation"
.PP 
.SS "size_t BlockTransformation::AdvancedProcessBlocks (const \fBbyte\fP * inBlocks, const \fBbyte\fP * xorBlocks, \fBbyte\fP * outBlocks, size_t length, \fBword32\fP flags) const\fR [virtual]\fP"

.PP
Encrypt and xor multiple blocks using additional flags\&. 
.PP
\fBParameters\fP
.RS 4
\fIinBlocks\fP the input message before processing 
.br
\fIxorBlocks\fP an optional XOR mask 
.br
\fIoutBlocks\fP the output message after processing 
.br
\fIlength\fP the size of the blocks, in bytes 
.br
\fIflags\fP additional flags to control processing
.RE
.PP
Encrypt and xor multiple blocks according to \fBFlagsForAdvancedProcessBlocks\fP flags\&. 
.PP
\fBNote\fP
.RS 4
If BT_InBlockIsCounter is set, then the last byte of inBlocks may be modified\&. 
.RE
.PP

.SS "virtual unsigned int BlockTransformation::BlockSize () const\fR [pure virtual]\fP"
Provides the block size of the cipher 
.PP
\fBReturns\fP
.RS 4
the block size of the cipher, in bytes 
.RE
.PP

.PP
Implemented in \fBBlockCipherImpl< INFO, BASE >\fP, \fBBlockCipherImpl< ARIA_Info >\fP, \fBBlockCipherImpl< Blowfish_Info >\fP, \fBBlockCipherImpl< Camellia_Info >\fP, \fBBlockCipherImpl< CAST128_Info >\fP, \fBBlockCipherImpl< CAST256_Info >\fP, \fBBlockCipherImpl< CHAM128_Info >\fP, \fBBlockCipherImpl< CHAM64_Info >\fP, \fBBlockCipherImpl< DES_EDE2_Info >\fP, \fBBlockCipherImpl< DES_EDE3_Info >\fP, \fBBlockCipherImpl< DES_Info >\fP, \fBBlockCipherImpl< DES_XEX3_Info >\fP, \fBBlockCipherImpl< GOST_Info >\fP, \fBBlockCipherImpl< HIGHT_Info >\fP, \fBBlockCipherImpl< IDEA_Info >\fP, \fBBlockCipherImpl< Kalyna128_Info >\fP, \fBBlockCipherImpl< Kalyna256_Info >\fP, \fBBlockCipherImpl< Kalyna512_Info >\fP, \fBBlockCipherImpl< LEA_Info >\fP, \fBBlockCipherImpl< LR_Info< T > >\fP, \fBBlockCipherImpl< MARS_Info >\fP, \fBBlockCipherImpl< MDC_Info< H > >\fP, \fBBlockCipherImpl< RC2_Info >\fP, \fBBlockCipherImpl< RC5_Info >\fP, \fBBlockCipherImpl< RC6_Info >\fP, \fBBlockCipherImpl< Rijndael_Info >\fP, \fBBlockCipherImpl< SEED_Info >\fP, \fBBlockCipherImpl< Serpent_Info >\fP, \fBBlockCipherImpl< SHACAL2_Info >\fP, \fBBlockCipherImpl< SHARK_Info >\fP, \fBBlockCipherImpl< SIMECK32_Info >\fP, \fBBlockCipherImpl< SIMECK64_Info >\fP, \fBBlockCipherImpl< SIMON_Info< 16, 16, 16, 32 > >\fP, \fBBlockCipherImpl< SIMON_Info< 8, 12, 12, 16 > >\fP, \fBBlockCipherImpl< SKIPJACK_Info >\fP, \fBBlockCipherImpl< SM4_Info >\fP, \fBBlockCipherImpl< SPECK_Info< 16, 16, 16, 32 > >\fP, \fBBlockCipherImpl< SPECK_Info< 8, 12, 12, 16 > >\fP, \fBBlockCipherImpl< Square_Info >\fP, \fBBlockCipherImpl< TEA_Info >\fP, \fBBlockCipherImpl< Threefish_Info< 128 > >\fP, \fBBlockCipherImpl< Threefish_Info< 32 > >\fP, \fBBlockCipherImpl< Threefish_Info< 64 > >\fP, \fBBlockCipherImpl< ThreeWay_Info >\fP, \fBBlockCipherImpl< Twofish_Info >\fP, and \fBBlockCipherImpl< XTEA_Info >\fP\&.
.SS "\fBCipherDir\fP BlockTransformation::GetCipherDirection () const\fR [inline]\fP"

.PP
Provides the direction of the cipher\&. 
.PP
\fBReturns\fP
.RS 4
ENCRYPTION if \fBIsForwardTransformation()\fP is true, DECRYPTION otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBIsForwardTransformation()\fP, \fBIsPermutation()\fP 
.RE
.PP

.SS "virtual bool BlockTransformation::IsForwardTransformation () const\fR [pure virtual]\fP"

.PP
Determines if the cipher is being operated in its forward direction\&. 
.PP
\fBReturns\fP
.RS 4
true if DIR is ENCRYPTION, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBIsForwardTransformation()\fP, \fBIsPermutation()\fP, \fBGetCipherDirection()\fP 
.RE
.PP

.SS "virtual bool BlockTransformation::IsPermutation () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines if the transformation is a permutation\&. 
.PP
\fBReturns\fP
.RS 4
true if this is a permutation (i\&.e\&. there is an inverse transformation) 
.RE
.PP

.SS "unsigned int BlockTransformation::OptimalDataAlignment () const\fR [virtual]\fP"

.PP
Provides input and output data alignment for optimal performance\&. 
.PP
\fBReturns\fP
.RS 4
the input data alignment that provides optimal performance 
.RE
.PP
\fBSee also\fP
.RS 4
GetAlignment() and OptimalBlockSize() 
.RE
.PP

.PP
Reimplemented in \fBKalyna128::Base\fP, \fBKalyna256::Base\fP, \fBKalyna512::Base\fP, \fBSAFER::Base\fP, \fBSIMON128::Base\fP, \fBSIMON64::Base\fP, \fBSPECK128::Base\fP, and \fBSPECK64::Base\fP\&.
.SS "virtual unsigned int BlockTransformation::OptimalNumberOfParallelBlocks () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines the number of blocks that can be processed in parallel\&. 
.PP
\fBReturns\fP
.RS 4
the number of blocks that can be processed in parallel, for bit-slicing implementations
.RE
.PP
Bit-slicing is often used to improve throughput and minimize timing attacks\&. 
.SS "virtual void BlockTransformation::ProcessAndXorBlock (const \fBbyte\fP * inBlock, const \fBbyte\fP * xorBlock, \fBbyte\fP * outBlock) const\fR [pure virtual]\fP"

.PP
Encrypt or decrypt a block\&. 
.PP
\fBParameters\fP
.RS 4
\fIinBlock\fP the input message before processing 
.br
\fIoutBlock\fP the output message after processing 
.br
\fIxorBlock\fP an optional XOR mask
.RE
.PP
ProcessAndXorBlock encrypts or decrypts inBlock, xor with xorBlock, and write to outBlock\&.

.PP
The size of the block is determined by the block cipher and its documentation\&. Use BLOCKSIZE at compile time, or \fBBlockSize()\fP at runtime\&. 
.PP
\fBNote\fP
.RS 4
The message can be transformed in-place, or the buffers must \fInot\fP overlap 
.RE
.PP
\fBSee also\fP
.RS 4
\fBFixedBlockSize\fP, \fBBlockCipherFinal\fP from \fBseckey\&.h\fP and \fBBlockSize()\fP 
.RE
.PP

.PP
Implemented in \fBARIA::Base\fP, \fBCHAM128::Dec\fP, \fBCHAM128::Enc\fP, \fBCHAM64::Dec\fP, \fBCHAM64::Enc\fP, \fBHIGHT::Dec\fP, \fBHIGHT::Enc\fP, \fBKalyna128::Base\fP, \fBKalyna256::Base\fP, \fBKalyna512::Base\fP, \fBLEA::Dec\fP, \fBLEA::Enc\fP, \fBSAFER::Dec\fP, \fBSAFER::Enc\fP, \fBSIMECK32::Dec\fP, \fBSIMECK32::Enc\fP, \fBSIMECK64::Dec\fP, \fBSIMECK64::Enc\fP, \fBSIMON128::Dec\fP, \fBSIMON128::Enc\fP, \fBSIMON64::Dec\fP, \fBSIMON64::Enc\fP, \fBSM4::Dec\fP, \fBSM4::Enc\fP, \fBSPECK128::Dec\fP, \fBSPECK128::Enc\fP, \fBSPECK64::Dec\fP, \fBSPECK64::Enc\fP, \fBThreefish1024::Dec\fP, \fBThreefish1024::Enc\fP, \fBThreefish256::Dec\fP, \fBThreefish256::Enc\fP, \fBThreefish512::Dec\fP, and \fBThreefish512::Enc\fP\&.
.SS "void BlockTransformation::ProcessBlock (\fBbyte\fP * inoutBlock) const\fR [inline]\fP"

.PP
Encrypt or decrypt a block in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIinoutBlock\fP the input message before processing
.RE
.PP
ProcessBlock encrypts or decrypts inoutBlock in-place\&.

.PP
The size of the block is determined by the block cipher and its documentation\&. Use BLOCKSIZE at compile time, or \fBBlockSize()\fP at runtime\&. 
.PP
\fBSee also\fP
.RS 4
\fBFixedBlockSize\fP, \fBBlockCipherFinal\fP from \fBseckey\&.h\fP and \fBBlockSize()\fP 
.RE
.PP

.SS "void BlockTransformation::ProcessBlock (const \fBbyte\fP * inBlock, \fBbyte\fP * outBlock) const\fR [inline]\fP"

.PP
Encrypt or decrypt a block\&. 
.PP
\fBParameters\fP
.RS 4
\fIinBlock\fP the input message before processing 
.br
\fIoutBlock\fP the output message after processing
.RE
.PP
ProcessBlock encrypts or decrypts inBlock and write to outBlock\&.

.PP
The size of the block is determined by the block cipher and its documentation\&. Use BLOCKSIZE at compile time, or \fBBlockSize()\fP at runtime\&. 
.PP
\fBSee also\fP
.RS 4
\fBFixedBlockSize\fP, \fBBlockCipherFinal\fP from \fBseckey\&.h\fP and \fBBlockSize()\fP 
.RE
.PP
\fBNote\fP
.RS 4
The message can be transformed in-place, or the buffers must \fInot\fP overlap 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
