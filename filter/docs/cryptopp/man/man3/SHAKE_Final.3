.TH "SHAKE_Final< T_Strength >" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SHAKE_Final< T_Strength > \- \fBSHAKE\fP message digest template\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <shake\&.h>\fP
.PP
Inherits \fBSHAKE\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (DIGESTSIZE=(T_Strength==128 ? 32 :64))"
.br
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (BLOCKSIZE=(T_Strength==128 ? 1344/8 :1088/8))"
.br
.ti -1c
.RI "\fBSHAKE_Final\fP (unsigned int outputSize=DIGESTSIZE)"
.br
.RI "Construct a SHAKE-X message digest\&. "
.ti -1c
.RI "unsigned int \fBBlockSize\fP () const"
.br
.RI "Provides the block size of the compression function\&. "
.ti -1c
.RI "std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBSHAKE\fP
.in +1c
.ti -1c
.RI "unsigned int \fBDigestSize\fP () const"
.br
.ti -1c
.RI "unsigned int \fBOptimalDataAlignment\fP () const"
.br
.RI "Provides input and output data alignment for optimal performance\&. "
.ti -1c
.RI "void \fBUpdate\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates a hash with additional input\&. "
.ti -1c
.RI "void \fBRestart\fP ()"
.br
.RI "Restart the hash\&. "
.ti -1c
.RI "void \fBTruncatedFinal\fP (\fBbyte\fP *hash, size_t size)"
.br
.RI "Computes the hash of the current message\&. "
.in -1c

Public Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "\fBHashTransformation\fP & \fBRef\fP ()"
.br
.RI "Provides a reference to this object\&. "
.ti -1c
.RI "virtual \fBbyte\fP * \fBCreateUpdateSpace\fP (size_t &size)"
.br
.RI "Request space which can be written into by the caller\&. "
.ti -1c
.RI "virtual void \fBFinal\fP (\fBbyte\fP *digest)"
.br
.RI "Computes the hash of the current message\&. "
.ti -1c
.RI "unsigned int \fBTagSize\fP () const"
.br
.ti -1c
.RI "virtual unsigned int \fBOptimalBlockSize\fP () const"
.br
.RI "Provides the input block size most efficient for this hash\&. "
.ti -1c
.RI "virtual void \fBCalculateDigest\fP (\fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerify\fP (const \fBbyte\fP *digest)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyDigest\fP (const \fBbyte\fP *digest, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.ti -1c
.RI "virtual void \fBCalculateTruncatedDigest\fP (\fBbyte\fP *digest, size_t digestSize, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and computes the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBTruncatedVerify\fP (const \fBbyte\fP *digest, size_t digestLength)"
.br
.RI "Verifies the hash of the current message\&. "
.ti -1c
.RI "virtual bool \fBVerifyTruncatedDigest\fP (const \fBbyte\fP *digest, size_t digestLength, const \fBbyte\fP *input, size_t length)"
.br
.RI "Updates the hash with additional input and verifies the hash of the current message\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBStaticAlgorithmName\fP ()"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBSHAKE\fP
.in +1c
.ti -1c
.RI "\fBSHAKE\fP (unsigned int digestSize)"
.br
.RI "Construct a \fBSHAKE\fP\&. "
.ti -1c
.RI "unsigned int \fBr\fP () const"
.br
.ti -1c
.RI "void \fBThrowIfInvalidTruncatedSize\fP (size_t size) const"
.br
.in -1c

Protected Member Functions inherited from \fBHashTransformation\fP
.in +1c
.ti -1c
.RI "void \fBThrowIfInvalidTruncatedSize\fP (size_t size) const"
.br
.RI "Validates a truncated digest size\&. "
.in -1c

Protected Attributes inherited from \fBSHAKE\fP
.in +1c
.ti -1c
.RI "\fBFixedSizeSecBlock\fP< word64, 25 > \fBm_state\fP"
.br
.ti -1c
.RI "unsigned int \fBm_digestSize\fP"
.br
.ti -1c
.RI "unsigned int \fBm_counter\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int T_Strength>
.br
class SHAKE_Final< T_Strength >"\fBSHAKE\fP message digest template\&. 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIT_Strength\fP the strength of the digest 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 8\&.1 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int T_Strength> \fBSHAKE_Final\fP< T_Strength >\fB::SHAKE_Final\fP (unsigned int outputSize = \fRDIGESTSIZE\fP)\fR [inline]\fP"

.PP
Construct a SHAKE-X message digest\&. \fBSHAKE128\fP and \fBSHAKE256\fP don't need the output size in advance because the output size does not affect the digest\&. TruncatedFinal produces the correct digest for any output size\&. However, cSHAKE requires the output size in advance because the algorithm uses output size as a parameter to the hash function\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<unsigned int T_Strength> std::string \fBSHAKE_Final\fP< T_Strength >::AlgorithmName () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the name of this algorithm\&. 
.PP
\fBReturns\fP
.RS 4
the standard algorithm name
.RE
.PP
The standard algorithm name can be a name like \fRAES\fP or \fRAES/GCM\fP\&. Some algorithms do not have standard names yet\&. For example, there is no standard algorithm name for Shoup's \fBECIES\fP\&. 
.PP
\fBNote\fP
.RS 4
AlgorithmName is not universally implemented yet\&. 
.RE
.PP

.PP
Reimplemented from \fBAlgorithm\fP\&.
.SS "template<unsigned int T_Strength> unsigned int \fBSHAKE_Final\fP< T_Strength >::BlockSize () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Provides the block size of the compression function\&. 
.PP
\fBReturns\fP
.RS 4
block size of the compression function, in bytes
.RE
.PP
\fBBlockSize()\fP will return 0 if the hash is not block based or does not have an equivalent block size\&. For example, \fBKeccak\fP and SHA-3 do not have a block size, but they do have an equivalent to block size called rate expressed as \fRr\fP\&. 
.PP
Reimplemented from \fBHashTransformation\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
