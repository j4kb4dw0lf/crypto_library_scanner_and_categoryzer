.TH "ed25519PublicKey" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ed25519PublicKey \- Ed25519 public key\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <xed25519\&.h>\fP
.PP
Inherits \fBX509PublicKey\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBInteger\fP \fBElement\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCRYPTOPP_CONSTANT\fP (PUBLIC_KEYLENGTH=32)"
.br
.RI "Size of the public key\&. "
.ti -1c
.RI "\fBOID\fP \fBGetAlgorithmID\fP () const"
.br
.RI "Retrieves the \fBOID\fP of the algorithm\&. "
.ti -1c
.RI "void \fBSave\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "DER encode ASN\&.1 object\&. "
.ti -1c
.RI "void \fBLoad\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "BER decode ASN\&.1 object\&. "
.ti -1c
.RI "void \fBBERDecode\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Decode this object from a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBDEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode this object into a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBBERDecodePublicKey\fP (\fBBufferedTransformation\fP &bt, bool parametersPresent, size_t size)"
.br
.RI "Decode subjectPublicKey part of subjectPublicKeyInfo\&. "
.ti -1c
.RI "void \fBDEREncodePublicKey\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode subjectPublicKey part of subjectPublicKeyInfo\&. "
.ti -1c
.RI "void \fBBERDecodeAndCheckAlgorithmID\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Determine if \fBOID\fP is valid for this object\&. "
.ti -1c
.RI "bool \fBValidate\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "bool \fBGetVoidValue\fP (const char *name, const std::type_info &valueType, void *pValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "void \fBAssignFrom\fP (const \fBNameValuePairs\fP &source)"
.br
.RI "Assign values to this object\&. "
.ti -1c
.RI "void \fBSetPublicElement\fP (const \fBbyte\fP y[PUBLIC_KEYLENGTH])"
.br
.ti -1c
.RI "void \fBSetPublicElement\fP (const \fBElement\fP &y)"
.br
.ti -1c
.RI "const \fBElement\fP & \fBGetPublicElement\fP () const"
.br
.ti -1c
.RI "const \fBbyte\fP * \fBGetPublicKeyBytePtr\fP () const"
.br
.RI "Retrieve public key byte array\&. "
.in -1c

Public Member Functions inherited from \fBX509PublicKey\fP
.in +1c
.ti -1c
.RI "void \fBBERDecode\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Decode this object from a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "void \fBDEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode this object into a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "virtual bool \fBBERDecodeAlgorithmParameters\fP (\fBBufferedTransformation\fP &bt)"
.br
.RI "Decode algorithm parameters\&. "
.ti -1c
.RI "virtual bool \fBDEREncodeAlgorithmParameters\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode algorithm parameters\&. "
.in -1c

Public Member Functions inherited from \fBASN1Object\fP
.in +1c
.ti -1c
.RI "virtual void \fBBEREncode\fP (\fBBufferedTransformation\fP &bt) const"
.br
.RI "Encode this object into a \fBBufferedTransformation\fP\&. "
.in -1c

Public Member Functions inherited from \fBCryptoMaterial\fP
.in +1c
.ti -1c
.RI "virtual void \fBThrowIfInvalid\fP (\fBRandomNumberGenerator\fP &rng, unsigned int level) const"
.br
.RI "Check this object for errors\&. "
.ti -1c
.RI "virtual bool \fBSupportsPrecomputation\fP () const"
.br
.RI "Determines whether the object supports precomputation\&. "
.ti -1c
.RI "virtual void \fBPrecompute\fP (unsigned int precomputationStorage)"
.br
.RI "Perform precomputation\&. "
.ti -1c
.RI "virtual void \fBLoadPrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation)"
.br
.RI "Retrieve previously saved precomputation\&. "
.ti -1c
.RI "virtual void \fBSavePrecomputation\fP (\fBBufferedTransformation\fP &storedPrecomputation) const"
.br
.RI "Save precomputation for later use\&. "
.ti -1c
.RI "void \fBDoQuickSanityCheck\fP () const"
.br
.RI "Perform a quick sanity check\&. "
.in -1c

Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "template<class T> bool \fBGetThisObject\fP (T &object) const"
.br
.RI "Get a copy of this object or subobject\&. "
.ti -1c
.RI "template<class T> bool \fBGetThisPointer\fP (T *&ptr) const"
.br
.RI "Get a pointer to this object\&. "
.ti -1c
.RI "template<class T> bool \fBGetValue\fP (const char *name, T &value) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "template<class T> T \fBGetValueWithDefault\fP (const char *name, T defaultValue) const"
.br
.RI "Get a named value\&. "
.ti -1c
.RI "CRYPTOPP_DLL std::string \fBGetValueNames\fP () const"
.br
.RI "Get a list of value names that can be retrieved\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetIntValue\fP (const char *name, int &value) const"
.br
.RI "Get a named value with type int\&. "
.ti -1c
.RI "CRYPTOPP_DLL int \fBGetIntValueWithDefault\fP (const char *name, int defaultValue) const"
.br
.RI "Get a named value with type int, with default\&. "
.ti -1c
.RI "CRYPTOPP_DLL bool \fBGetWord64Value\fP (const char *name, word64 &value) const"
.br
.RI "Get a named value with type word64\&. "
.ti -1c
.RI "CRYPTOPP_DLL word64 \fBGetWord64ValueWithDefault\fP (const char *name, word64 defaultValue) const"
.br
.RI "Get a named value with type word64, with default\&. "
.ti -1c
.RI "template<class T> void \fBGetRequiredParameter\fP (const char *className, const char *name, T &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.ti -1c
.RI "CRYPTOPP_DLL void \fBGetRequiredIntParameter\fP (const char *className, const char *name, int &value) const"
.br
.RI "Retrieves a required name/value pair\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBFixedSizeSecBlock\fP< \fBbyte\fP, PUBLIC_KEYLENGTH > \fBm_pk\fP"
.br
.ti -1c
.RI "\fBOID\fP \fBm_oid\fP"
.br
.ti -1c
.RI "\fBInteger\fP \fBm_y\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Static Public Member Functions inherited from \fBNameValuePairs\fP
.in +1c
.ti -1c
.RI "static CRYPTOPP_DLL void CRYPTOPP_API \fBThrowIfTypeMismatch\fP (const char *name, const std::type_info &stored, const std::type_info &retrieving)"
.br
.RI "Ensures an expected name and type is present\&. "
.in -1c
.SH "Detailed Description"
.PP 
Ed25519 public key\&. 

\fBed25519PublicKey\fP is somewhat of a hack\&. It needed to provide \fBDL_PublicKey\fP interface to fit into the existing framework, but it lacks a lot of the internals of a true \fBDL_PublicKey\fP\&. The missing pieces include GroupParameters and Point, which provide the low level field operations found in traditional implementations like NIST curves over prime and binary fields\&.

.PP
\fBed25519PublicKey\fP is also unusual because the class members of interest are byte arrays and not Integers\&. In addition, the byte arrays are little-endian meaning LSB is at element 0 and the MSB is at element 31\&. If you call GetPublicElement() then the little-endian byte array is converted to a big-endian \fBInteger()\fP so it can be returned the way a caller expects\&. And calling SetPublicElement() performs a similar internal conversion\&. 
.PP
\fBSince\fP
.RS 4
Crypto++ 8\&.0 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void ed25519PublicKey::AssignFrom (const \fBNameValuePairs\fP & source)\fR [virtual]\fP"

.PP
Assign values to this object\&. This function can be used to create a public key from a private key\&. 
.PP
Implements \fBCryptoMaterial\fP\&.
.SS "void ed25519PublicKey::BERDecode (\fBBufferedTransformation\fP & bt)\fR [virtual]\fP"

.PP
Decode this object from a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
Uses Basic Encoding Rules (BER) 
.PP
Implements \fBASN1Object\fP\&.
.SS "void ed25519PublicKey::BERDecodeAndCheckAlgorithmID (\fBBufferedTransformation\fP & bt)"

.PP
Determine if \fBOID\fP is valid for this object\&. \fBBERDecodeAndCheckAlgorithmID()\fP parses the \fBOID\fP from \fRbt\fP and determines if it valid for this object\&. The problem in practice is there are multiple OIDs available to denote curve25519 operations\&. The OIDs include an old GNU \fBOID\fP used by SSH, OIDs specified in draft-josefsson-pkix-newcurves, and OIDs specified in draft-ietf-curdle-pkix\&.

.PP
By default \fBBERDecodeAndCheckAlgorithmID()\fP accepts an \fBOID\fP set by the user, \fRASN1::curve25519()\fP and \fRASN1::Ed25519()\fP\&. \fRASN1::curve25519()\fP is generic and says "this key is valid for curve25519 operations"\&. \fRASN1::Ed25519()\fP is specific and says "this key is valid for ed25519 signing\&." 
.SS "void ed25519PublicKey::BERDecodePublicKey (\fBBufferedTransformation\fP & bt, bool parametersPresent, size_t size)\fR [virtual]\fP"

.PP
Decode subjectPublicKey part of subjectPublicKeyInfo\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object 
.br
\fIparametersPresent\fP flag indicating if algorithm parameters are present 
.br
\fIsize\fP number of octets to read for the parameters, in bytes
.RE
.PP
\fBBERDecodePublicKey()\fP the decodes subjectPublicKey part of subjectPublicKeyInfo, without the BIT STRING header\&.

.PP
When \fRparametersPresent = true\fP then \fBBERDecodePublicKey()\fP calls \fBBERDecodeAlgorithmParameters()\fP to parse algorithm parameters\&. 
.PP
\fBSee also\fP
.RS 4
\fBBERDecodeAlgorithmParameters\fP 
.RE
.PP

.PP
Implements \fBX509PublicKey\fP\&.
.SS "ed25519PublicKey::CRYPTOPP_CONSTANT (PUBLIC_KEYLENGTH  = \fR32\fP)"

.PP
Size of the public key\&. PUBLIC_KEYLENGTH is the size of the public key, in bytes\&. 
.SS "void ed25519PublicKey::DEREncode (\fBBufferedTransformation\fP & bt) const\fR [virtual]\fP"

.PP
Encode this object into a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
Uses Distinguished Encoding Rules (DER) 
.PP
Implements \fBASN1Object\fP\&.
.SS "void ed25519PublicKey::DEREncodePublicKey (\fBBufferedTransformation\fP & bt) const\fR [virtual]\fP"

.PP
Encode subjectPublicKey part of subjectPublicKeyInfo\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
\fBDEREncodePublicKey()\fP encodes the subjectPublicKey part of subjectPublicKeyInfo, without the BIT STRING header\&. 
.PP
\fBSee also\fP
.RS 4
\fBDEREncodeAlgorithmParameters\fP 
.RE
.PP

.PP
Implements \fBX509PublicKey\fP\&.
.SS "\fBOID\fP ed25519PublicKey::GetAlgorithmID () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Retrieves the \fBOID\fP of the algorithm\&. 
.PP
\fBReturns\fP
.RS 4
\fBOID\fP of the algorithm 
.RE
.PP

.PP
Implements \fBX509PublicKey\fP\&.
.SS "const \fBbyte\fP * ed25519PublicKey::GetPublicKeyBytePtr () const\fR [inline]\fP"

.PP
Retrieve public key byte array\&. 
.PP
\fBReturns\fP
.RS 4
the public key byte array
.RE
.PP
\fBGetPublicKeyBytePtr()\fP is used by signing code to call ed25519_sign\&. 
.SS "bool ed25519PublicKey::GetVoidValue (const char * name, const std::type_info & valueType, void * pValue) const\fR [virtual]\fP"

.PP
Get a named value\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP the name of the object or value to retrieve 
.br
\fIvalueType\fP reference to a variable that receives the value 
.br
\fIpValue\fP void pointer to a variable that receives the value 
.RE
.PP
\fBReturns\fP
.RS 4
true if the value was retrieved, false otherwise
.RE
.PP
\fBGetVoidValue()\fP retrieves the value of name if it exists\&. 
.PP
\fBNote\fP
.RS 4
\fBGetVoidValue()\fP is an internal function and should be implemented by derived classes\&. Users should use one of the other functions instead\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBGetValue()\fP, \fBGetValueWithDefault()\fP, \fBGetIntValue()\fP, \fBGetIntValueWithDefault()\fP, \fBGetRequiredParameter()\fP and \fBGetRequiredIntParameter()\fP 
.RE
.PP

.PP
Implements \fBNameValuePairs\fP\&.
.SS "void ed25519PublicKey::Load (\fBBufferedTransformation\fP & bt)\fR [inline]\fP, \fR [virtual]\fP"

.PP
BER decode ASN\&.1 object\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object 
.RE
.PP
\fBSee also\fP
.RS 4
\fRRFC 5958, Asymmetric Key Packages\fP 
.RE
.PP

.PP
Reimplemented from \fBASN1CryptoMaterial< PublicKey >\fP\&.
.SS "void ed25519PublicKey::Save (\fBBufferedTransformation\fP & bt) const\fR [inline]\fP, \fR [virtual]\fP"

.PP
DER encode ASN\&.1 object\&. 
.PP
\fBParameters\fP
.RS 4
\fIbt\fP \fBBufferedTransformation\fP object
.RE
.PP
\fBSave()\fP will write the \fBOID\fP associated with algorithm or scheme\&. In the case of public and private keys, this function writes the subjectPublicKeyInfo parts\&.

.PP
The default \fBOID\fP is from RFC 8410 using \fRid-X25519\fP\&. The default private key format is RFC 5208, which is the old format\&. The old format provides the best interop, and keys will work with OpenSSL\&. 
.PP
Reimplemented from \fBASN1CryptoMaterial< PublicKey >\fP\&.
.SS "bool ed25519PublicKey::Validate (\fBRandomNumberGenerator\fP & rng, unsigned int level) const\fR [virtual]\fP"

.PP
Check this object for errors\&. 
.PP
\fBParameters\fP
.RS 4
\fIrng\fP a \fBRandomNumberGenerator\fP for objects which use randomized testing 
.br
\fIlevel\fP the level of thoroughness 
.RE
.PP
\fBReturns\fP
.RS 4
true if the tests succeed, false otherwise
.RE
.PP
There are four levels of thoroughness: 
.PD 0
.IP "\(bu" 2
0 - using this object won't cause a crash or exception 
.IP "\(bu" 2
1 - this object will probably function, and encrypt, sign, other operations correctly 
.IP "\(bu" 2
2 - ensure this object will function correctly, and perform reasonable security checks 
.IP "\(bu" 2
3 - perform reasonable security checks, and do checks that may take a long time 
.PP

.PP
Level 0 does not require a \fBRandomNumberGenerator\fP\&. A \fBNullRNG()\fP can be used for level 0\&. Level 1 may not check for weak keys and such\&. Levels 2 and 3 are recommended\&. 
.PP
\fBSee also\fP
.RS 4
\fBThrowIfInvalid()\fP 
.RE
.PP

.PP
Implements \fBCryptoMaterial\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
