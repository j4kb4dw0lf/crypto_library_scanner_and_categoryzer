.TH "OldRandomPool" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
OldRandomPool \- Randomness Pool based on PGP 2\&.6\&.x with \fBMDC\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <randpool\&.h>\fP
.PP
Inherits \fBRandomNumberGenerator\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBOldRandomPool\fP (unsigned int poolSize=384)"
.br
.RI "Construct an \fBOldRandomPool\fP\&. "
.ti -1c
.RI "bool \fBCanIncorporateEntropy\fP () const"
.br
.RI "Determines if a generator can accept additional entropy\&. "
.ti -1c
.RI "void \fBIncorporateEntropy\fP (const \fBbyte\fP *input, size_t length)"
.br
.RI "Update RNG state with additional unpredictable values\&. "
.ti -1c
.RI "void \fBGenerateIntoBufferedTransformation\fP (\fBBufferedTransformation\fP &target, const std::string &channel, \fBlword\fP size)"
.br
.RI "Generate random bytes into a \fBBufferedTransformation\fP\&. "
.ti -1c
.RI "\fBbyte\fP \fBGenerateByte\fP ()"
.br
.RI "Generate new random byte and return it\&. "
.ti -1c
.RI "void \fBGenerateBlock\fP (\fBbyte\fP *output, size_t size)"
.br
.RI "Generate random array of bytes\&. "
.ti -1c
.RI "\fBword32\fP \fBGenerateWord32\fP (\fBword32\fP min=0, \fBword32\fP max=0xffffffffUL)"
.br
.RI "Generate a random 32 bit word in the range min to max, inclusive\&. "
.in -1c

Public Member Functions inherited from \fBRandomNumberGenerator\fP
.in +1c
.ti -1c
.RI "virtual unsigned int \fBGenerateBit\fP ()"
.br
.RI "Generate new random bit and return it\&. "
.ti -1c
.RI "virtual void \fBDiscardBytes\fP (size_t n)"
.br
.RI "Generate and discard n bytes\&. "
.ti -1c
.RI "template<class IT> void \fBShuffle\fP (IT begin, IT end)"
.br
.RI "Randomly shuffle the specified array\&. "
.in -1c

Public Member Functions inherited from \fBAlgorithm\fP
.in +1c
.ti -1c
.RI "\fBAlgorithm\fP (bool checkSelfTestStatus=true)"
.br
.RI "Interface for all crypto algorithms\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmName\fP () const"
.br
.RI "Provides the name of this algorithm\&. "
.ti -1c
.RI "virtual std::string \fBAlgorithmProvider\fP () const"
.br
.RI "Retrieve the provider of this algorithm\&. "
.in -1c

Public Member Functions inherited from \fBClonable\fP
.in +1c
.ti -1c
.RI "virtual \fBClonable\fP * \fBClone\fP () const"
.br
.RI "Copies this object\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBStir\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Randomness Pool based on PGP 2\&.6\&.x with \fBMDC\fP\&. 

If you need the pre-Crypto++ 5\&.5 generator then use \fBOldRandomPool\fP class\&. The \fBOldRandomPool\fP also provides the modern interface, including \fRCanIncorporateEntropy\fP, \fRIncorporateEntropy\fP and \fRGenerateIntoBufferedTransformation\fP\&.

.PP
You should reseed the generator after a fork() to avoid multiple generators with the same internal state\&.

.PP
You should migrate away from \fBOldRandomPool\fP at the earliest opportunity\&. Use a modern random number generator or key derivation function, like AutoSeededRandomPool or \fBHKDF\fP\&. 
.PP
\fBWarning\fP
.RS 4
This class uses an old style PGP 2\&.6\&.x with \fBMDC\fP\&. The generator risks reusing random numbers after state rollback\&. You should migrate away from \fBOldRandomPool\fP at the earliest opportunity\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBRandomPool\fP, AutoSeededRandomPool, \fBHKDF\fP, \fBP1363_KDF2\fP, \fBPKCS12_PBKDF\fP, \fBPKCS5_PBKDF2_HMAC\fP 
.RE
.PP
\fBSince\fP
.RS 4
Crypto++ 6\&.0 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "OldRandomPool::OldRandomPool (unsigned int poolSize = \fR384\fP)"

.PP
Construct an \fBOldRandomPool\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIpoolSize\fP internal pool size of the generator
.RE
.PP
poolSize must be greater than 16 
.SH "Member Function Documentation"
.PP 
.SS "bool OldRandomPool::CanIncorporateEntropy () const\fR [inline]\fP, \fR [virtual]\fP"

.PP
Determines if a generator can accept additional entropy\&. 
.PP
\fBReturns\fP
.RS 4
true if \fBIncorporateEntropy()\fP is implemented 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void OldRandomPool::GenerateBlock (\fBbyte\fP * output, size_t size)\fR [virtual]\fP"

.PP
Generate random array of bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP the byte buffer 
.br
\fIsize\fP the length of the buffer, in bytes
.RE
.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
\fBNote\fP
.RS 4
A derived generator \fImust\fP override either \fBGenerateBlock()\fP or \fBGenerateIntoBufferedTransformation()\fP\&. They can override both, or have one call the other\&. 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "\fBbyte\fP OldRandomPool::GenerateByte ()\fR [virtual]\fP"

.PP
Generate new random byte and return it\&. 
.PP
\fBReturns\fP
.RS 4
a random 8-bit byte
.RE
.PP
Default implementation calls \fBGenerateBlock()\fP with one byte\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void OldRandomPool::GenerateIntoBufferedTransformation (\fBBufferedTransformation\fP & target, const std::string & channel, \fBlword\fP length)\fR [virtual]\fP"

.PP
Generate random bytes into a \fBBufferedTransformation\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItarget\fP the \fBBufferedTransformation\fP object which receives the bytes 
.br
\fIchannel\fP the channel on which the bytes should be pumped 
.br
\fIlength\fP the number of bytes to generate
.RE
.PP
The default implementation calls \fBGenerateBlock()\fP and pumps the result into the DEFAULT_CHANNEL of the target\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
\fBNote\fP
.RS 4
A derived generator \fImust\fP override either \fBGenerateBlock()\fP or \fBGenerateIntoBufferedTransformation()\fP\&. They can override both, or have one call the other\&. 
.RE
.PP

.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "\fBword32\fP OldRandomPool::GenerateWord32 (\fBword32\fP min = \fR0\fP, \fBword32\fP max = \fR0xffffffffUL\fP)\fR [virtual]\fP"

.PP
Generate a random 32 bit word in the range min to max, inclusive\&. 
.PP
\fBParameters\fP
.RS 4
\fImin\fP the lower bound of the range 
.br
\fImax\fP the upper bound of the range 
.RE
.PP
\fBReturns\fP
.RS 4
a random 32-bit word
.RE
.PP
The default implementation calls \fBCrop()\fP on the difference between max and min, and then returns the result added to min\&.

.PP
All generated values are uniformly distributed over the range specified within the the constraints of a particular generator\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.
.SS "void OldRandomPool::IncorporateEntropy (const \fBbyte\fP * input, size_t length)\fR [virtual]\fP"

.PP
Update RNG state with additional unpredictable values\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP the entropy to add to the generator 
.br
\fIlength\fP the size of the input buffer 
.RE
.PP
\fBExceptions\fP
.RS 4
\fI\fBNotImplemented\fP\fP 
.RE
.PP
A generator may or may not accept additional entropy\&. Call \fBCanIncorporateEntropy()\fP to test for the ability to use additional entropy\&.

.PP
If a derived class does not override \fBIncorporateEntropy()\fP, then the base class throws \fBNotImplemented\fP\&. 
.PP
Reimplemented from \fBRandomNumberGenerator\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
