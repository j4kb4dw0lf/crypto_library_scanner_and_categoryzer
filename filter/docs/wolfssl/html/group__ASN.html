<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: ASN.1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ASN.1 </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd9209218503a6aa6750307200d3de76" id="r_gacd9209218503a6aa6750307200d3de76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a> (Cert *)</td></tr>
<tr class="memdesc:gacd9209218503a6aa6750307200d3de76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a default cert, with the default options: version = 3 (0x2), serial = 0, sigType = SHA_WITH_RSA, issuer = blank, daysValid = 500, selfSigned = 1 (true) use subject as issuer, subject = blank.  <br /></td></tr>
<tr class="memitem:gaa9f208512ea6f3ecaf3c8c1a788fad89" id="r_gaa9f208512ea6f3ecaf3c8c1a788fad89"><td class="memItemLeft" align="right" valign="top">Cert *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89">wc_CertNew</a> (void *heap)</td></tr>
<tr class="memdesc:gaa9f208512ea6f3ecaf3c8c1a788fad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates a new Cert structure for use during cert operations without the application having to allocate the structure itself. The Cert structure is also initialized by this function thus removing the need to call <a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert()</a>. When the application is finished using the allocated Cert structure <a class="el" href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b" title="This function frees the memory allocated for a cert structure by a previous call to wc_CertNew().">wc_CertFree()</a> must be called.  <br /></td></tr>
<tr class="memitem:ga73e33fa6c7e332b0bc6bdaa66ed4f12b" id="r_ga73e33fa6c7e332b0bc6bdaa66ed4f12b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b">wc_CertFree</a> (Cert *cert)</td></tr>
<tr class="memdesc:ga73e33fa6c7e332b0bc6bdaa66ed4f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the memory allocated for a cert structure by a previous call to <a class="el" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89" title="This function allocates a new Cert structure for use during cert operations without the application h...">wc_CertNew()</a>.  <br /></td></tr>
<tr class="memitem:gaf5c9dd81eafddb0b911192d1a559865a" id="r_gaf5c9dd81eafddb0b911192d1a559865a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a">wc_MakeCert</a> (Cert *cert, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey, WC_RNG *rng)</td></tr>
<tr class="memdesc:gaf5c9dd81eafddb0b911192d1a559865a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to make CA signed certs. Called after the subject information has been entered. This function makes an x509 Certificate v3 RSA or ECC from a cert input. It then writes this cert to derBuffer. It takes in either an rsaKey or an eccKey to generate the certificate. The certificate must be initialized with wc_InitCert before this method is called.  <br /></td></tr>
<tr class="memitem:ga1ab8dd06b7195bcfaae5fdf1d65a524e" id="r_ga1ab8dd06b7195bcfaae5fdf1d65a524e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e">wc_MakeCertReq</a> (Cert *cert, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey)</td></tr>
<tr class="memdesc:ga1ab8dd06b7195bcfaae5fdf1d65a524e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes a certificate signing request using the input certificate and writes the output to derBuffer. It takes in either an rsaKey or an eccKey to generate the certificate request. <a class="el" href="#ga6cb11be9830690899b9ae7f8e424c7cf" title="This function signs buffer and adds the signature to the end of buffer. It takes in a signature type....">wc_SignCert()</a> will need to be called after this function to sign the certificate request. Please see the wolfCrypt test application (./wolfcrypt/test/test.c) for an example usage of this function.  <br /></td></tr>
<tr class="memitem:ga6cb11be9830690899b9ae7f8e424c7cf" id="r_ga6cb11be9830690899b9ae7f8e424c7cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cb11be9830690899b9ae7f8e424c7cf">wc_SignCert</a> (int requestSz, int sigType, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga6cb11be9830690899b9ae7f8e424c7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs buffer and adds the signature to the end of buffer. It takes in a signature type. Must be called after <a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert()</a> or <a class="el" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e" title="This function makes a certificate signing request using the input certificate and writes the output t...">wc_MakeCertReq()</a> if creating a CA signed cert.  <br /></td></tr>
<tr class="memitem:ga4d66835dcea8596ae7421ce3d46d9a46" id="r_ga4d66835dcea8596ae7421ce3d46d9a46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d66835dcea8596ae7421ce3d46d9a46">wc_MakeSelfCert</a> (Cert *cert, byte *derBuffer, word32 derSz, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga4d66835dcea8596ae7421ce3d46d9a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a combination of the previous two functions, wc_MakeCert and wc_SignCert for self signing (the previous functions may be used for CA requests). It makes a certificate, and then signs it, generating a self-signed certificate.  <br /></td></tr>
<tr class="memitem:ga3d2b9553cf3d0cf821a76700dd442eb9" id="r_ga3d2b9553cf3d0cf821a76700dd442eb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d2b9553cf3d0cf821a76700dd442eb9">wc_SetIssuer</a> (Cert *cert, const char *issuerFile)</td></tr>
<tr class="memdesc:ga3d2b9553cf3d0cf821a76700dd442eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the issuer for a certificate to the issuer in the provided pem issuerFile. It also changes the certificate’s self-signed attribute to false. The issuer specified in issuerFile is verified prior to setting the cert issuer. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:ga0f986e1224380c77b2458010f432e832" id="r_ga0f986e1224380c77b2458010f432e832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f986e1224380c77b2458010f432e832">wc_SetSubject</a> (Cert *cert, const char *subjectFile)</td></tr>
<tr class="memdesc:ga0f986e1224380c77b2458010f432e832"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the subject for a certificate to the subject in the provided pem subjectFile. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:gaac9a70c1061eae1a8ce862a4cf5be0d3" id="r_gaac9a70c1061eae1a8ce862a4cf5be0d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac9a70c1061eae1a8ce862a4cf5be0d3">wc_SetSubjectRaw</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:gaac9a70c1061eae1a8ce862a4cf5be0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the raw subject for a certificate from the subject in the provided der buffer. This method is used to set the raw subject field prior to signing.  <br /></td></tr>
<tr class="memitem:ga4a19fbbfa99ae9503fc96f9fe0d46e7a" id="r_ga4a19fbbfa99ae9503fc96f9fe0d46e7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a19fbbfa99ae9503fc96f9fe0d46e7a">wc_GetSubjectRaw</a> (byte **subjectRaw, Cert *cert)</td></tr>
<tr class="memdesc:ga4a19fbbfa99ae9503fc96f9fe0d46e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the raw subject from the certificate structure.  <br /></td></tr>
<tr class="memitem:gaae29d5e62d11ac76be5ef13dcb33d1e3" id="r_gaae29d5e62d11ac76be5ef13dcb33d1e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaae29d5e62d11ac76be5ef13dcb33d1e3">wc_SetAltNames</a> (Cert *cert, const char *file)</td></tr>
<tr class="memdesc:gaae29d5e62d11ac76be5ef13dcb33d1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the alternate names for a certificate to the alternate names in the provided pem file. This is useful in the case that one wishes to secure multiple domains with the same certificate. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:gaa1eabea68369ae080e73934bc157b7f8" id="r_gaa1eabea68369ae080e73934bc157b7f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1eabea68369ae080e73934bc157b7f8">wc_SetIssuerBuffer</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:gaa1eabea68369ae080e73934bc157b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the issuer for a certificate from the issuer in the provided der buffer. It also changes the certificate’s self-signed attribute to false. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:gab93f6254e2dbe2bfb5b397b83fa079e5" id="r_gab93f6254e2dbe2bfb5b397b83fa079e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab93f6254e2dbe2bfb5b397b83fa079e5">wc_SetIssuerRaw</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:gab93f6254e2dbe2bfb5b397b83fa079e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the raw issuer for a certificate from the issuer in the provided der buffer. This method is used to set the raw issuer field prior to signing.  <br /></td></tr>
<tr class="memitem:ga604be3a1f3b0fdd3640eb4612bd5a19a" id="r_ga604be3a1f3b0fdd3640eb4612bd5a19a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga604be3a1f3b0fdd3640eb4612bd5a19a">wc_SetSubjectBuffer</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:ga604be3a1f3b0fdd3640eb4612bd5a19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the subject for a certificate from the subject in the provided der buffer. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:ga32527debb2d5c946e1516619b7c3c44c" id="r_ga32527debb2d5c946e1516619b7c3c44c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32527debb2d5c946e1516619b7c3c44c">wc_SetAltNamesBuffer</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:ga32527debb2d5c946e1516619b7c3c44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the alternate names for a certificate from the alternate names in the provided der buffer. This is useful in the case that one wishes to secure multiple domains with the same certificate. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:gae5b1f5d1fea568ef4b3e68e86e11ddf9" id="r_gae5b1f5d1fea568ef4b3e68e86e11ddf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5b1f5d1fea568ef4b3e68e86e11ddf9">wc_SetDatesBuffer</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:gae5b1f5d1fea568ef4b3e68e86e11ddf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the dates for a certificate from the date range in the provided der buffer. This method is used to set fields prior to signing.  <br /></td></tr>
<tr class="memitem:ga426dd86646159b5b06e059d634aaa250" id="r_ga426dd86646159b5b06e059d634aaa250"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga426dd86646159b5b06e059d634aaa250">wc_SetAuthKeyIdFromPublicKey</a> (Cert *cert, RsaKey *rsakey, ecc_key *eckey)</td></tr>
<tr class="memdesc:ga426dd86646159b5b06e059d634aaa250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set AKID from either an RSA or ECC public key. note: Only set one of rsakey or eckey, not both.  <br /></td></tr>
<tr class="memitem:gad4c62e9cf11e1e0ff7172e3e619f7cef" id="r_gad4c62e9cf11e1e0ff7172e3e619f7cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4c62e9cf11e1e0ff7172e3e619f7cef">wc_SetAuthKeyIdFromCert</a> (Cert *cert, const byte *der, int derSz)</td></tr>
<tr class="memdesc:gad4c62e9cf11e1e0ff7172e3e619f7cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set AKID from from DER encoded certificate.  <br /></td></tr>
<tr class="memitem:gae562d97bc2f35d364dffbc80b4a76a53" id="r_gae562d97bc2f35d364dffbc80b4a76a53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae562d97bc2f35d364dffbc80b4a76a53">wc_SetAuthKeyId</a> (Cert *cert, const char *file)</td></tr>
<tr class="memdesc:gae562d97bc2f35d364dffbc80b4a76a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set AKID from certificate file in PEM format.  <br /></td></tr>
<tr class="memitem:ga74ea06ed118ab20c22bfcbb8d4c756fe" id="r_ga74ea06ed118ab20c22bfcbb8d4c756fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74ea06ed118ab20c22bfcbb8d4c756fe">wc_SetSubjectKeyIdFromPublicKey</a> (Cert *cert, RsaKey *rsakey, ecc_key *eckey)</td></tr>
<tr class="memdesc:ga74ea06ed118ab20c22bfcbb8d4c756fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SKID from RSA or ECC public key.  <br /></td></tr>
<tr class="memitem:ga38b456be77b159ca8238ac5897a66688" id="r_ga38b456be77b159ca8238ac5897a66688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38b456be77b159ca8238ac5897a66688">wc_SetSubjectKeyId</a> (Cert *cert, const char *file)</td></tr>
<tr class="memdesc:ga38b456be77b159ca8238ac5897a66688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SKID from public key file in PEM format. Both arguments are required.  <br /></td></tr>
<tr class="memitem:ga3eacabc57785f3406b92961e20f0aec9" id="r_ga3eacabc57785f3406b92961e20f0aec9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3eacabc57785f3406b92961e20f0aec9">wc_PemPubKeyToDer</a> (const char *fileName, unsigned char *derBuf, int derSz)</td></tr>
<tr class="memdesc:ga3eacabc57785f3406b92961e20f0aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a PEM key from a file and converts to a DER encoded buffer.  <br /></td></tr>
<tr class="memitem:ga1accae3c1bbba637c74e025eab85c667" id="r_ga1accae3c1bbba637c74e025eab85c667"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1accae3c1bbba637c74e025eab85c667">wc_PubKeyPemToDer</a> (const unsigned char *pem, int pemSz, unsigned char *buff, int buffSz)</td></tr>
<tr class="memdesc:ga1accae3c1bbba637c74e025eab85c667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a PEM encoded public key to DER. Returns the number of bytes written to the buffer or a negative value for an error.  <br /></td></tr>
<tr class="memitem:ga1881b0197dfca3b68e96147f57115bc9" id="r_ga1881b0197dfca3b68e96147f57115bc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1881b0197dfca3b68e96147f57115bc9">wc_PemCertToDer</a> (const char *fileName, unsigned char *derBuf, int derSz)</td></tr>
<tr class="memdesc:ga1881b0197dfca3b68e96147f57115bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a pem certificate to a der certificate, and places the resulting certificate in the derBuf buffer provided.  <br /></td></tr>
<tr class="memitem:ga4b973eddc04922d3735c5353868a679b" id="r_ga4b973eddc04922d3735c5353868a679b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b973eddc04922d3735c5353868a679b">wc_DerToPem</a> (const byte *der, word32 derSz, byte *output, word32 outSz, int type)</td></tr>
<tr class="memdesc:ga4b973eddc04922d3735c5353868a679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a der formatted input certificate, contained in the der buffer, into a pem formatted output certificate, contained in the output buffer. It should be noted that this is not an in place conversion, and a separate buffer must be utilized to store the pem formatted output.  <br /></td></tr>
<tr class="memitem:gaa23858ae67d70555c3f952f0cca4a129" id="r_gaa23858ae67d70555c3f952f0cca4a129"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa23858ae67d70555c3f952f0cca4a129">wc_DerToPemEx</a> (const byte *der, word32 derSz, byte *output, word32 outSz, byte *cipher_info, int type)</td></tr>
<tr class="memdesc:gaa23858ae67d70555c3f952f0cca4a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a der formatted input certificate, contained in the der buffer, into a pem formatted output certificate, contained in the output buffer. It should be noted that this is not an in place conversion, and a separate buffer must be utilized to store the pem formatted output. Allows setting cipher info.  <br /></td></tr>
<tr class="memitem:gad8171b7dcac7dff2c38a1bf9e2e0bb25" id="r_gad8171b7dcac7dff2c38a1bf9e2e0bb25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8171b7dcac7dff2c38a1bf9e2e0bb25">wc_EccPrivateKeyDecode</a> (const byte *input, word32 *inOutIdx, ecc_key *key, word32 inSz)</td></tr>
<tr class="memdesc:gad8171b7dcac7dff2c38a1bf9e2e0bb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads in an ECC private key from the input buffer, input, parses the private key, and uses it to generate an ecc_key object, which it stores in key.  <br /></td></tr>
<tr class="memitem:ga77f85c4bfba15c19b12ef1f07552b0db" id="r_ga77f85c4bfba15c19b12ef1f07552b0db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77f85c4bfba15c19b12ef1f07552b0db">wc_EccKeyToDer</a> (ecc_key *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga77f85c4bfba15c19b12ef1f07552b0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a private ECC key to der format.  <br /></td></tr>
<tr class="memitem:ga748630c3374d8e5352438ade73f6d37b" id="r_ga748630c3374d8e5352438ade73f6d37b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga748630c3374d8e5352438ade73f6d37b">wc_EccPublicKeyDecode</a> (const byte *input, word32 *inOutIdx, ecc_key *key, word32 inSz)</td></tr>
<tr class="memdesc:ga748630c3374d8e5352438ade73f6d37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes an ECC public key from an input buffer. It will parse an ASN sequence to retrieve the ECC key.  <br /></td></tr>
<tr class="memitem:gabc19c7569f17c7d4c0cb740e5713d28c" id="r_gabc19c7569f17c7d4c0cb740e5713d28c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc19c7569f17c7d4c0cb740e5713d28c">wc_EccPublicKeyToDer</a> (ecc_key *key, byte *output, word32 inLen, int with_AlgCurve)</td></tr>
<tr class="memdesc:gabc19c7569f17c7d4c0cb740e5713d28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the ECC public key to DER format. It returns the size of buffer used. The public ECC key in DER format is stored in output buffer. The with_AlgCurve flag will include a header that has the Algorithm and Curve information.  <br /></td></tr>
<tr class="memitem:ga7495b26573c2456c6a62ee1872938ca2" id="r_ga7495b26573c2456c6a62ee1872938ca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7495b26573c2456c6a62ee1872938ca2">wc_EccPublicKeyToDer_ex</a> (ecc_key *key, byte *output, word32 inLen, int with_AlgCurve, int comp)</td></tr>
<tr class="memdesc:ga7495b26573c2456c6a62ee1872938ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the ECC public key to DER format. It returns the size of buffer used. The public ECC key in DER format is stored in output buffer. The with_AlgCurve flag will include a header that has the Algorithm and Curve information. The comp parameter determines if the public key will be exported as compressed.  <br /></td></tr>
<tr class="memitem:ga12a719da0dd8a0cc89851215d0e2737e" id="r_ga12a719da0dd8a0cc89851215d0e2737e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12a719da0dd8a0cc89851215d0e2737e">wc_Curve25519PrivateKeyDecode</a> (const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</td></tr>
<tr class="memdesc:ga12a719da0dd8a0cc89851215d0e2737e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes a Curve25519 private key (only) from a DER encoded buffer.  <br /></td></tr>
<tr class="memitem:ga66ef6fceddb954aeff4963ae0a26dd8c" id="r_ga66ef6fceddb954aeff4963ae0a26dd8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66ef6fceddb954aeff4963ae0a26dd8c">wc_Curve25519PublicKeyDecode</a> (const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</td></tr>
<tr class="memdesc:ga66ef6fceddb954aeff4963ae0a26dd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes a Curve25519 public key (only) from a DER encoded buffer.  <br /></td></tr>
<tr class="memitem:ga3897ad303fb0af6fb5b932e1c160ee95" id="r_ga3897ad303fb0af6fb5b932e1c160ee95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3897ad303fb0af6fb5b932e1c160ee95">wc_Curve25519KeyDecode</a> (const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</td></tr>
<tr class="memdesc:ga3897ad303fb0af6fb5b932e1c160ee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes a Curve25519 key from a DER encoded buffer. It can decode either a private key, a public key, or both.  <br /></td></tr>
<tr class="memitem:ga34af291ea27e9f42794cae27745dd3e3" id="r_ga34af291ea27e9f42794cae27745dd3e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34af291ea27e9f42794cae27745dd3e3">wc_Curve25519PrivateKeyToDer</a> (curve25519_key *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga34af291ea27e9f42794cae27745dd3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encodes a Curve25519 private key to DER format. If the input key structure contains a public key, it will be ignored.  <br /></td></tr>
<tr class="memitem:gab80c2a300573708d1c02a4cb002288ac" id="r_gab80c2a300573708d1c02a4cb002288ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab80c2a300573708d1c02a4cb002288ac">wc_Curve25519PublicKeyToDer</a> (curve25519_key *key, byte *output, word32 inLen, int withAlg)</td></tr>
<tr class="memdesc:gab80c2a300573708d1c02a4cb002288ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encodes a Curve25519 public key to DER format. If the input key structure contains a private key, it will be ignored.  <br /></td></tr>
<tr class="memitem:gaa0baf75ba2e540f90c2dc6e4a928b3b1" id="r_gaa0baf75ba2e540f90c2dc6e4a928b3b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1">wc_Curve25519KeyToDer</a> (curve25519_key *key, byte *output, word32 inLen, int withAlg)</td></tr>
<tr class="memdesc:gaa0baf75ba2e540f90c2dc6e4a928b3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encodes a Curve25519 key to DER format. It can encode either a private key, a public key, or both.  <br /></td></tr>
<tr class="memitem:gabf1b4a96b34f41ed4fbffaff2cacac2e" id="r_gabf1b4a96b34f41ed4fbffaff2cacac2e"><td class="memItemLeft" align="right" valign="top">word32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf1b4a96b34f41ed4fbffaff2cacac2e">wc_EncodeSignature</a> (byte *out, const byte *digest, word32 digSz, int hashOID)</td></tr>
<tr class="memdesc:gabf1b4a96b34f41ed4fbffaff2cacac2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encodes a digital signature into the output buffer, and returns the size of the encoded signature created.  <br /></td></tr>
<tr class="memitem:gabaefce3e50456a39826cc7431f66eb33" id="r_gabaefce3e50456a39826cc7431f66eb33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabaefce3e50456a39826cc7431f66eb33">wc_GetCTC_HashOID</a> (int type)</td></tr>
<tr class="memdesc:gabaefce3e50456a39826cc7431f66eb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the hash OID that corresponds to a hashing type. For example, when given the type: WC_SHA512, this function returns the identifier corresponding to a SHA512 hash, SHA512h.  <br /></td></tr>
<tr class="memitem:gae77c95063dd863e74255e3ca402e7534" id="r_gae77c95063dd863e74255e3ca402e7534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae77c95063dd863e74255e3ca402e7534">wc_SetCert_Free</a> (Cert *cert)</td></tr>
<tr class="memdesc:gae77c95063dd863e74255e3ca402e7534"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function cleans up memory and resources used by the certificate structure's decoded cert cache. When WOLFSSL_CERT_GEN_CACHE is defined the decoded cert structure is cached in the certificate structure. This allows subsequent calls to certificate set functions to avoid parsing the decoded cert on each call.  <br /></td></tr>
<tr class="memitem:gae6c42f3dc41e784c6b8075ca279b9b80" id="r_gae6c42f3dc41e784c6b8075ca279b9b80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6c42f3dc41e784c6b8075ca279b9b80">wc_GetPkcs8TraditionalOffset</a> (byte *input, word32 *inOutIdx, word32 sz)</td></tr>
<tr class="memdesc:gae6c42f3dc41e784c6b8075ca279b9b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.  <br /></td></tr>
<tr class="memitem:gacd36602384fcaf44f74d73ba83a0bde7" id="r_gacd36602384fcaf44f74d73ba83a0bde7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd36602384fcaf44f74d73ba83a0bde7">wc_CreatePKCS8Key</a> (byte *out, word32 *outSz, byte *key, word32 keySz, int algoID, const byte *curveOID, word32 oidSz)</td></tr>
<tr class="memdesc:gacd36602384fcaf44f74d73ba83a0bde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS#12 shrouded key bags. See RFC 5208.  <br /></td></tr>
<tr class="memitem:ga3b3076c1a3d4ce531bc67b766a3e7182" id="r_ga3b3076c1a3d4ce531bc67b766a3e7182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b3076c1a3d4ce531bc67b766a3e7182">wc_EncryptPKCS8Key</a> (byte *key, word32 keySz, byte *out, word32 *outSz, const char *password, int passwordSz, int vPKCS, int pbeOid, int encAlgId, byte *salt, word32 saltSz, int itt, WC_RNG *rng, void *heap)</td></tr>
<tr class="memdesc:ga3b3076c1a3d4ce531bc67b766a3e7182"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and converts it to PKCS#8 encrypted format. The resulting encrypted key can be decrypted using wc_DecryptPKCS8Key. See RFC 5208.  <br /></td></tr>
<tr class="memitem:ga226ab6cfcc17b9c7233c0b0331ed7d7d" id="r_ga226ab6cfcc17b9c7233c0b0331ed7d7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d">wc_DecryptPKCS8Key</a> (byte *input, word32 sz, const char *password, int passwordSz)</td></tr>
<tr class="memdesc:ga226ab6cfcc17b9c7233c0b0331ed7d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER. Undoes the encryption done by wc_EncryptPKCS8Key. See RFC5208. The input buffer is overwritten with the decrypted data.  <br /></td></tr>
<tr class="memitem:ga2b90b217f96796be0eb0f6cf9ed231aa" id="r_ga2b90b217f96796be0eb0f6cf9ed231aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b90b217f96796be0eb0f6cf9ed231aa">wc_CreateEncryptedPKCS8Key</a> (byte *key, word32 keySz, byte *out, word32 *outSz, const char *password, int passwordSz, int vPKCS, int pbeOid, int encAlgId, byte *salt, word32 saltSz, int itt, WC_RNG *rng, void *heap)</td></tr>
<tr class="memdesc:ga2b90b217f96796be0eb0f6cf9ed231aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it. It uses wc_CreatePKCS8Key and wc_EncryptPKCS8Key to do this.  <br /></td></tr>
<tr class="memitem:gad713e892f23ba17144e33e2992b2f41d" id="r_gad713e892f23ba17144e33e2992b2f41d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad713e892f23ba17144e33e2992b2f41d">wc_InitDecodedCert</a> (struct DecodedCert *cert, const byte *source, word32 inSz, void *heap)</td></tr>
<tr class="memdesc:gad713e892f23ba17144e33e2992b2f41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the DecodedCert pointed to by the "cert" parameter. It saves the "source" pointer to a DER-encoded certificate of length "inSz." This certificate can be parsed by a subsequent call to wc_ParseCert.  <br /></td></tr>
<tr class="memitem:ga6732f10a963f0f55a51e03f2ce2ed64a" id="r_ga6732f10a963f0f55a51e03f2ce2ed64a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6732f10a963f0f55a51e03f2ce2ed64a">wc_ParseCert</a> (DecodedCert *cert, int type, int verify, void *cm)</td></tr>
<tr class="memdesc:ga6732f10a963f0f55a51e03f2ce2ed64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses the DER-encoded certificate saved in the DecodedCert object and populates the fields of that object. The DecodedCert must have been initialized with a prior call to wc_InitDecodedCert. This function takes an optional pointer to a CertificateManager object, which is used to populate the certificate authority information of the DecodedCert, if the CA is found in the CertificateManager.  <br /></td></tr>
<tr class="memitem:ga2be9ca18448fba206de8331c08ceb752" id="r_ga2be9ca18448fba206de8331c08ceb752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2be9ca18448fba206de8331c08ceb752">wc_FreeDecodedCert</a> (struct DecodedCert *cert)</td></tr>
<tr class="memdesc:ga2be9ca18448fba206de8331c08ceb752"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees a DecodedCert that was previously initialized with wc_InitDecodedCert.  <br /></td></tr>
<tr class="memitem:ga01fcb66e496dae631b667608beb8229b" id="r_ga01fcb66e496dae631b667608beb8229b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga01fcb66e496dae631b667608beb8229b">wc_SetTimeCb</a> (wc_time_cb f)</td></tr>
<tr class="memdesc:ga01fcb66e496dae631b667608beb8229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a time callback that will be used anytime wolfSSL needs to get the current time. The prototype of the callback should be the same as the "time" function from the C standard library.  <br /></td></tr>
<tr class="memitem:ga606ed4a08b474311d46273ce3b69b45d" id="r_ga606ed4a08b474311d46273ce3b69b45d"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga606ed4a08b474311d46273ce3b69b45d">wc_Time</a> (time_t *t)</td></tr>
<tr class="memdesc:ga606ed4a08b474311d46273ce3b69b45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current time. By default, it uses the XTIME macro, which varies between platforms. The user can use a function of their choosing instead via the wc_SetTimeCb function.  <br /></td></tr>
<tr class="memitem:gaa32299ffae69195d68f2020c582bc317" id="r_gaa32299ffae69195d68f2020c582bc317"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa32299ffae69195d68f2020c582bc317">wc_SetCustomExtension</a> (Cert *cert, int critical, const char *oid, const byte *der, word32 derSz)</td></tr>
<tr class="memdesc:gaa32299ffae69195d68f2020c582bc317"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function injects a custom extension in to an X.509 certificate. note: The content at the address pointed to by any of the parameters that are pointers must not be modified until the certificate is generated and you have the der output. This function does NOT copy the contents to another buffer.  <br /></td></tr>
<tr class="memitem:ga8d65aa447d6d58a49e20ecc1303e5bb2" id="r_ga8d65aa447d6d58a49e20ecc1303e5bb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d65aa447d6d58a49e20ecc1303e5bb2">wc_SetUnknownExtCallback</a> (DecodedCert *cert, wc_UnknownExtCallback cb)</td></tr>
<tr class="memdesc:ga8d65aa447d6d58a49e20ecc1303e5bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a callback that will be used anytime wolfSSL encounters an unknown X.509 extension in a certificate while parsing a certificate. The prototype of the callback should be:  <br /></td></tr>
<tr class="memitem:ga17a47e29ae508bb3f9f9d6c15c8cf7f4" id="r_ga17a47e29ae508bb3f9f9d6c15c8cf7f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga17a47e29ae508bb3f9f9d6c15c8cf7f4">wc_CheckCertSigPubKey</a> (const byte *cert, word32 certSz, void *heap, const byte *pubKey, word32 pubKeySz, int pubKeyOID)</td></tr>
<tr class="memdesc:ga17a47e29ae508bb3f9f9d6c15c8cf7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the signature in the der form of an X.509 certificate against a public key. The public key is expected to be the full subject public key info in der form.  <br /></td></tr>
<tr class="memitem:ga914b252092e18313dfc9e2ba26b22e56" id="r_ga914b252092e18313dfc9e2ba26b22e56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga914b252092e18313dfc9e2ba26b22e56">wc_Asn1PrintOptions_Init</a> (Asn1PrintOptions *opts)</td></tr>
<tr class="memdesc:ga914b252092e18313dfc9e2ba26b22e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the ASN.1 print options.  <br /></td></tr>
<tr class="memitem:gaa1ff4f4751fa450b9bddd04d47ecbea2" id="r_gaa1ff4f4751fa450b9bddd04d47ecbea2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1ff4f4751fa450b9bddd04d47ecbea2">wc_Asn1PrintOptions_Set</a> (Asn1PrintOptions *opts, enum Asn1PrintOpt opt, word32 val)</td></tr>
<tr class="memdesc:gaa1ff4f4751fa450b9bddd04d47ecbea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a print option into an ASN.1 print options object.  <br /></td></tr>
<tr class="memitem:ga8c5649de0ef326863f625436eebdeaea" id="r_ga8c5649de0ef326863f625436eebdeaea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c5649de0ef326863f625436eebdeaea">wc_Asn1_Init</a> (Asn1 *asn1)</td></tr>
<tr class="memdesc:ga8c5649de0ef326863f625436eebdeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ASN.1 parsing object.  <br /></td></tr>
<tr class="memitem:gaec39f218bcc33b568794fb3018f42cf6" id="r_gaec39f218bcc33b568794fb3018f42cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec39f218bcc33b568794fb3018f42cf6">wc_Asn1_SetFile</a> (Asn1 *asn1, XFILE file)</td></tr>
<tr class="memdesc:gaec39f218bcc33b568794fb3018f42cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the file to use when printing into an ASN.1 parsing object.  <br /></td></tr>
<tr class="memitem:ga20c2f98d93305ebac30574680a68e779" id="r_ga20c2f98d93305ebac30574680a68e779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20c2f98d93305ebac30574680a68e779">wc_Asn1_PrintAll</a> (Asn1 *asn1, Asn1PrintOptions *opts, unsigned char *data, word32 len)</td></tr>
<tr class="memdesc:ga20c2f98d93305ebac30574680a68e779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all ASN.1 items.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga8c5649de0ef326863f625436eebdeaea" name="ga8c5649de0ef326863f625436eebdeaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c5649de0ef326863f625436eebdeaea">&#9670;&#160;</a></span>wc_Asn1_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Asn1_Init </td>
          <td>(</td>
          <td class="paramtype">Asn1 *</td>          <td class="paramname"><span class="paramname"><em>asn1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an ASN.1 parsing object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG when asn1 is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asn1</td><td>ASN.1 parse object.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Asn1 asn1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 parse object before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga8c5649de0ef326863f625436eebdeaea">wc_Asn1_Init</a>(&amp;asn1);</div>
<div class="ttc" id="agroup__ASN_html_ga8c5649de0ef326863f625436eebdeaea"><div class="ttname"><a href="#ga8c5649de0ef326863f625436eebdeaea">wc_Asn1_Init</a></div><div class="ttdeci">int wc_Asn1_Init(Asn1 *asn1)</div><div class="ttdoc">This function initializes an ASN.1 parsing object.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaec39f218bcc33b568794fb3018f42cf6" title="This function sets the file to use when printing into an ASN.1 parsing object.">wc_Asn1_SetFile</a> </dd>
<dd>
<a class="el" href="#ga20c2f98d93305ebac30574680a68e779" title="Print all ASN.1 items.">wc_Asn1_PrintAll</a> </dd></dl>

</div>
</div>
<a id="ga20c2f98d93305ebac30574680a68e779" name="ga20c2f98d93305ebac30574680a68e779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20c2f98d93305ebac30574680a68e779">&#9670;&#160;</a></span>wc_Asn1_PrintAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Asn1_PrintAll </td>
          <td>(</td>
          <td class="paramtype">Asn1 *</td>          <td class="paramname"><span class="paramname"><em>asn1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Asn1PrintOptions *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print all ASN.1 items. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG when asn1 or opts is NULL. </dd>
<dd>
ASN_LEN_E when ASN.1 item's length too long. </dd>
<dd>
ASN_DEPTH_E when end offset invalid. </dd>
<dd>
ASN_PARSE_E when not all of an ASN.1 item parsed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asn1</td><td>The ASN.1 parse object. </td></tr>
    <tr><td class="paramname">opts</td><td>The ASN.1 print options. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer containing BER/DER data to print. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data to print in bytes.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">Asn1PrintOptions opts;</div>
<div class="line">Asn1 asn1;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data[] = { Initialize with DER/BER data };</div>
<div class="line">word32 len = <span class="keyword">sizeof</span>(data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 print options before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga914b252092e18313dfc9e2ba26b22e56">wc_Asn1PrintOptions_Init</a>(&amp;opt);</div>
<div class="line"><span class="comment">// Set the number of indents when printing tag name to be 1.</span></div>
<div class="line"><a class="code hl_function" href="#gaa1ff4f4751fa450b9bddd04d47ecbea2">wc_Asn1PrintOptions_Set</a>(&amp;opt, ASN1_PRINT_OPT_INDENT, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 parse object before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga8c5649de0ef326863f625436eebdeaea">wc_Asn1_Init</a>(&amp;asn1);</div>
<div class="line"><span class="comment">// Set standard out to be the file descriptor to write to.</span></div>
<div class="line"><a class="code hl_function" href="#gaec39f218bcc33b568794fb3018f42cf6">wc_Asn1_SetFile</a>(&amp;asn1, stdout);</div>
<div class="line"><span class="comment">// Print all ASN.1 items in buffer with the specified print options.</span></div>
<div class="line"><a class="code hl_function" href="#ga20c2f98d93305ebac30574680a68e779">wc_Asn1_PrintAll</a>(&amp;asn1, &amp;opts, data, len);</div>
<div class="ttc" id="agroup__ASN_html_ga20c2f98d93305ebac30574680a68e779"><div class="ttname"><a href="#ga20c2f98d93305ebac30574680a68e779">wc_Asn1_PrintAll</a></div><div class="ttdeci">int wc_Asn1_PrintAll(Asn1 *asn1, Asn1PrintOptions *opts, unsigned char *data, word32 len)</div><div class="ttdoc">Print all ASN.1 items.</div></div>
<div class="ttc" id="agroup__ASN_html_ga914b252092e18313dfc9e2ba26b22e56"><div class="ttname"><a href="#ga914b252092e18313dfc9e2ba26b22e56">wc_Asn1PrintOptions_Init</a></div><div class="ttdeci">int wc_Asn1PrintOptions_Init(Asn1PrintOptions *opts)</div><div class="ttdoc">This function initializes the ASN.1 print options.</div></div>
<div class="ttc" id="agroup__ASN_html_gaa1ff4f4751fa450b9bddd04d47ecbea2"><div class="ttname"><a href="#gaa1ff4f4751fa450b9bddd04d47ecbea2">wc_Asn1PrintOptions_Set</a></div><div class="ttdeci">int wc_Asn1PrintOptions_Set(Asn1PrintOptions *opts, enum Asn1PrintOpt opt, word32 val)</div><div class="ttdoc">This function sets a print option into an ASN.1 print options object.</div></div>
<div class="ttc" id="agroup__ASN_html_gaec39f218bcc33b568794fb3018f42cf6"><div class="ttname"><a href="#gaec39f218bcc33b568794fb3018f42cf6">wc_Asn1_SetFile</a></div><div class="ttdeci">int wc_Asn1_SetFile(Asn1 *asn1, XFILE file)</div><div class="ttdoc">This function sets the file to use when printing into an ASN.1 parsing object.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8c5649de0ef326863f625436eebdeaea" title="This function initializes an ASN.1 parsing object.">wc_Asn1_Init</a> </dd>
<dd>
<a class="el" href="#gaec39f218bcc33b568794fb3018f42cf6" title="This function sets the file to use when printing into an ASN.1 parsing object.">wc_Asn1_SetFile</a> </dd></dl>

</div>
</div>
<a id="gaec39f218bcc33b568794fb3018f42cf6" name="gaec39f218bcc33b568794fb3018f42cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec39f218bcc33b568794fb3018f42cf6">&#9670;&#160;</a></span>wc_Asn1_SetFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Asn1_SetFile </td>
          <td>(</td>
          <td class="paramtype">Asn1 *</td>          <td class="paramname"><span class="paramname"><em>asn1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFILE</td>          <td class="paramname"><span class="paramname"><em>file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the file to use when printing into an ASN.1 parsing object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG when asn1 is NULL. </dd>
<dd>
BAD_FUNC_ARG when file is XBADFILE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asn1</td><td>The ASN.1 parse object. </td></tr>
    <tr><td class="paramname">file</td><td>File to print to.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Asn1 asn1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 parse object before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga8c5649de0ef326863f625436eebdeaea">wc_Asn1_Init</a>(&amp;asn1);</div>
<div class="line"><span class="comment">// Set standard out to be the file descriptor to write to.</span></div>
<div class="line"><a class="code hl_function" href="#gaec39f218bcc33b568794fb3018f42cf6">wc_Asn1_SetFile</a>(&amp;asn1, stdout);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8c5649de0ef326863f625436eebdeaea" title="This function initializes an ASN.1 parsing object.">wc_Asn1_Init</a> </dd>
<dd>
<a class="el" href="#ga20c2f98d93305ebac30574680a68e779" title="Print all ASN.1 items.">wc_Asn1_PrintAll</a> </dd></dl>

</div>
</div>
<a id="ga914b252092e18313dfc9e2ba26b22e56" name="ga914b252092e18313dfc9e2ba26b22e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga914b252092e18313dfc9e2ba26b22e56">&#9670;&#160;</a></span>wc_Asn1PrintOptions_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Asn1PrintOptions_Init </td>
          <td>(</td>
          <td class="paramtype">Asn1PrintOptions *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the ASN.1 print options. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG when asn1 is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The ASN.1 options for printing.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Asn1PrintOptions opt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 print options before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga914b252092e18313dfc9e2ba26b22e56">wc_Asn1PrintOptions_Init</a>(&amp;opt);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa1ff4f4751fa450b9bddd04d47ecbea2" title="This function sets a print option into an ASN.1 print options object.">wc_Asn1PrintOptions_Set</a> </dd>
<dd>
<a class="el" href="#ga20c2f98d93305ebac30574680a68e779" title="Print all ASN.1 items.">wc_Asn1_PrintAll</a> </dd></dl>

</div>
</div>
<a id="gaa1ff4f4751fa450b9bddd04d47ecbea2" name="gaa1ff4f4751fa450b9bddd04d47ecbea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ff4f4751fa450b9bddd04d47ecbea2">&#9670;&#160;</a></span>wc_Asn1PrintOptions_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Asn1PrintOptions_Set </td>
          <td>(</td>
          <td class="paramtype">Asn1PrintOptions *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum Asn1PrintOpt</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a print option into an ASN.1 print options object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG when asn1 is NULL. </dd>
<dd>
BAD_FUNC_ARG when val is out of range for option.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The ASN.1 options for printing. </td></tr>
    <tr><td class="paramname">opt</td><td>An option to set value for. </td></tr>
    <tr><td class="paramname">val</td><td>The value to set.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Asn1PrintOptions opt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize ASN.1 print options before use.</span></div>
<div class="line"><a class="code hl_function" href="#ga914b252092e18313dfc9e2ba26b22e56">wc_Asn1PrintOptions_Init</a>(&amp;opt);</div>
<div class="line"><span class="comment">// Set the number of indents when printing tag name to be 1.</span></div>
<div class="line"><a class="code hl_function" href="#gaa1ff4f4751fa450b9bddd04d47ecbea2">wc_Asn1PrintOptions_Set</a>(&amp;opt, ASN1_PRINT_OPT_INDENT, 1);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga914b252092e18313dfc9e2ba26b22e56" title="This function initializes the ASN.1 print options.">wc_Asn1PrintOptions_Init</a> </dd>
<dd>
<a class="el" href="#ga20c2f98d93305ebac30574680a68e779" title="Print all ASN.1 items.">wc_Asn1_PrintAll</a> </dd></dl>

</div>
</div>
<a id="ga73e33fa6c7e332b0bc6bdaa66ed4f12b" name="ga73e33fa6c7e332b0bc6bdaa66ed4f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b">&#9670;&#160;</a></span>wc_CertFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_CertFree </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the memory allocated for a cert structure by a previous call to <a class="el" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89" title="This function allocates a new Cert structure for use during cert operations without the application h...">wc_CertNew()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>pointer to the cert structure to free.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert*   myCert;</div>
<div class="line"> </div>
<div class="line">myCert = <a class="code hl_function" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89">wc_CertNew</a>(NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform cert operations.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b">wc_CertFree</a>(myCert);</div>
<div class="ttc" id="agroup__ASN_html_ga73e33fa6c7e332b0bc6bdaa66ed4f12b"><div class="ttname"><a href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b">wc_CertFree</a></div><div class="ttdeci">void wc_CertFree(Cert *cert)</div><div class="ttdoc">This function frees the memory allocated for a cert structure by a previous call to wc_CertNew().</div></div>
<div class="ttc" id="agroup__ASN_html_gaa9f208512ea6f3ecaf3c8c1a788fad89"><div class="ttname"><a href="#gaa9f208512ea6f3ecaf3c8c1a788fad89">wc_CertNew</a></div><div class="ttdeci">Cert * wc_CertNew(void *heap)</div><div class="ttdoc">This function allocates a new Cert structure for use during cert operations without the application h...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd>
<dd>
<a class="el" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89" title="This function allocates a new Cert structure for use during cert operations without the application h...">wc_CertNew</a> </dd></dl>

</div>
</div>
<a id="gaa9f208512ea6f3ecaf3c8c1a788fad89" name="gaa9f208512ea6f3ecaf3c8c1a788fad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9f208512ea6f3ecaf3c8c1a788fad89">&#9670;&#160;</a></span>wc_CertNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cert * wc_CertNew </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates a new Cert structure for use during cert operations without the application having to allocate the structure itself. The Cert structure is also initialized by this function thus removing the need to call <a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert()</a>. When the application is finished using the allocated Cert structure <a class="el" href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b" title="This function frees the memory allocated for a cert structure by a previous call to wc_CertNew().">wc_CertFree()</a> must be called. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a pointer to the newly allocated and initialized Cert. </dd>
<dd>
NULL On a memory allocation failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>pointer to the heap used for dynamic allocation. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert*   myCert;</div>
<div class="line"> </div>
<div class="line">myCert = <a class="code hl_function" href="#gaa9f208512ea6f3ecaf3c8c1a788fad89">wc_CertNew</a>(NULL);</div>
<div class="line"><span class="keywordflow">if</span> (myCert == NULL) {</div>
<div class="line">    <span class="comment">// Cert creation failure</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd>
<dd>
<a class="el" href="#ga73e33fa6c7e332b0bc6bdaa66ed4f12b" title="This function frees the memory allocated for a cert structure by a previous call to wc_CertNew().">wc_CertFree</a> </dd></dl>

</div>
</div>
<a id="ga17a47e29ae508bb3f9f9d6c15c8cf7f4" name="ga17a47e29ae508bb3f9f9d6c15c8cf7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17a47e29ae508bb3f9f9d6c15c8cf7f4">&#9670;&#160;</a></span>wc_CheckCertSigPubKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_CheckCertSigPubKey </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>certSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>pubKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>pubKeySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pubKeyOID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the signature in the der form of an X.509 certificate against a public key. The public key is expected to be the full subject public key info in der form. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>The der encoding of the X.509 certificate. </td></tr>
    <tr><td class="paramname">certSz</td><td>The size in bytes of cert. </td></tr>
    <tr><td class="paramname">heap</td><td>A pointer to the heap used for dynamic allocation. Can be NULL. </td></tr>
    <tr><td class="paramname">pubKey</td><td>The der encoding of the public key. </td></tr>
    <tr><td class="paramname">pubKeySz</td><td>The size in bytes of pubKey. </td></tr>
    <tr><td class="paramname">pubKeyOID</td><td>OID identifying the algorithm of the public key. (ie: ECDSAk, DSAk or RSAk) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b90b217f96796be0eb0f6cf9ed231aa" name="ga2b90b217f96796be0eb0f6cf9ed231aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b90b217f96796be0eb0f6cf9ed231aa">&#9670;&#160;</a></span>wc_CreateEncryptedPKCS8Key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_CreateEncryptedPKCS8Key </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>passwordSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vPKCS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pbeOid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>encAlgId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>saltSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>itt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it. It uses wc_CreatePKCS8Key and wc_EncryptPKCS8Key to do this. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the encrypted key placed in out on success. </dd>
<dd>
LENGTH_ONLY_E if out is NULL, with required output buffer size in outSz. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Buffer with traditional DER key. </td></tr>
    <tr><td class="paramname">keySz</td><td>Size of key buffer. </td></tr>
    <tr><td class="paramname">out</td><td>Buffer to place result in. If NULL, required out buffer size returned in outSz. </td></tr>
    <tr><td class="paramname">outSz</td><td>Size of out buffer. </td></tr>
    <tr><td class="paramname">password</td><td>The password to use for the password-based encryption algorithm. </td></tr>
    <tr><td class="paramname">passwordSz</td><td>The length of the password (not including the NULL terminator). </td></tr>
    <tr><td class="paramname">vPKCS</td><td>The PKCS version to use. Can be 1 for PKCS12 or PKCS5. </td></tr>
    <tr><td class="paramname">pbeOid</td><td>The OID of the PBE scheme to use (e.g. PBES2 or one of the OIDs for PBES1 in RFC 2898 A.3). </td></tr>
    <tr><td class="paramname">encAlgId</td><td>The encryption algorithm ID to use (e.g. AES256CBCb). </td></tr>
    <tr><td class="paramname">salt</td><td>The salt buffer to use. If NULL, a random salt will be used. </td></tr>
    <tr><td class="paramname">saltSz</td><td>The length of the salt buffer. Can be 0 if passing NULL for salt. </td></tr>
    <tr><td class="paramname">itt</td><td>The number of iterations to use for the KDF. </td></tr>
    <tr><td class="paramname">rng</td><td>A pointer to an initialized WC_RNG object. </td></tr>
    <tr><td class="paramname">heap</td><td>A pointer to the heap used for dynamic allocation. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* key;            <span class="comment">// Traditional private key (DER formatted).</span></div>
<div class="line">word32 keySz;         <span class="comment">// Size of key.</span></div>
<div class="line"><span class="keywordtype">byte</span>* pkcs8Enc;       <span class="comment">// Encrypted PKCS#8 key.</span></div>
<div class="line">word32 pkcs8EncSz;    <span class="comment">// Size of pkcs8Enc.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* password; <span class="comment">// Password to use for encryption.</span></div>
<div class="line"><span class="keywordtype">int</span> passwordSz;       <span class="comment">// Length of password (not including NULL terminator).</span></div>
<div class="line">WC_RNG rng;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following produces an encrypted, PKCS#8 version of key in pkcs8Enc.</span></div>
<div class="line"><span class="comment">// The encryption uses password-based encryption scheme 2 (PBE2) from PKCS#5</span></div>
<div class="line"><span class="comment">// and the AES cipher in CBC mode with a 256-bit key. See RFC 8018 for more</span></div>
<div class="line"><span class="comment">// on PKCS#5.</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga2b90b217f96796be0eb0f6cf9ed231aa">wc_CreateEncryptedPKCS8Key</a>(key, keySz, pkcs8Enc, &amp;pkcs8EncSz,</div>
<div class="line">        password, passwordSz, PKCS5, PBES2, AES256CBCb, NULL, 0,</div>
<div class="line">        WC_PKCS12_ITT_DEFAULT, &amp;rng, NULL);</div>
<div class="ttc" id="agroup__ASN_html_ga2b90b217f96796be0eb0f6cf9ed231aa"><div class="ttname"><a href="#ga2b90b217f96796be0eb0f6cf9ed231aa">wc_CreateEncryptedPKCS8Key</a></div><div class="ttdeci">int wc_CreateEncryptedPKCS8Key(byte *key, word32 keySz, byte *out, word32 *outSz, const char *password, int passwordSz, int vPKCS, int pbeOid, int encAlgId, byte *salt, word32 saltSz, int itt, WC_RNG *rng, void *heap)</div><div class="ttdoc">This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae6c42f3dc41e784c6b8075ca279b9b80" title="This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.">wc_GetPkcs8TraditionalOffset</a> </dd>
<dd>
<a class="el" href="#gacd36602384fcaf44f74d73ba83a0bde7" title="This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS...">wc_CreatePKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga3b3076c1a3d4ce531bc67b766a3e7182" title="This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and conv...">wc_EncryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d" title="This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER....">wc_DecryptPKCS8Key</a> </dd></dl>

</div>
</div>
<a id="gacd36602384fcaf44f74d73ba83a0bde7" name="gacd36602384fcaf44f74d73ba83a0bde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd36602384fcaf44f74d73ba83a0bde7">&#9670;&#160;</a></span>wc_CreatePKCS8Key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_CreatePKCS8Key </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>algoID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>curveOID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>oidSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS#12 shrouded key bags. See RFC 5208. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the PKCS#8 key placed into out on success. </dd>
<dd>
LENGTH_ONLY_E if out is NULL, with required output buffer size in outSz. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Buffer to place result in. If NULL, required out buffer size returned in outSz. </td></tr>
    <tr><td class="paramname">outSz</td><td>Size of out buffer. </td></tr>
    <tr><td class="paramname">key</td><td>Buffer with traditional DER key. </td></tr>
    <tr><td class="paramname">keySz</td><td>Size of key buffer. </td></tr>
    <tr><td class="paramname">algoID</td><td>Algorithm ID (e.g. RSAk). </td></tr>
    <tr><td class="paramname">curveOID</td><td>ECC curve OID if used. Should be NULL for RSA keys. </td></tr>
    <tr><td class="paramname">oidSz</td><td>Size of curve OID. Is set to 0 if curveOID is NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key eccKey;              <span class="comment">// wolfSSL ECC key object.</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;                   <span class="comment">// DER-encoded ECC key.</span></div>
<div class="line">word32 derSize;              <span class="comment">// Size of der.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">byte</span>* curveOid = NULL; <span class="comment">// OID of curve used by eccKey.</span></div>
<div class="line">word32 curveOidSz = 0;       <span class="comment">// Size of curve OID.</span></div>
<div class="line"><span class="keywordtype">byte</span>* pkcs8;                 <span class="comment">// Output buffer for PKCS#8 key.</span></div>
<div class="line">word32 pkcs8Sz;              <span class="comment">// Size of output buffer.</span></div>
<div class="line"> </div>
<div class="line">derSize = wc_EccKeyDerSize(&amp;eccKey, 1);</div>
<div class="line">...</div>
<div class="line">derSize = <a class="code hl_function" href="#ga77f85c4bfba15c19b12ef1f07552b0db">wc_EccKeyToDer</a>(&amp;eccKey, der, derSize);</div>
<div class="line">...</div>
<div class="line">ret = wc_ecc_get_oid(eccKey.dp-&gt;oidSum, &amp;curveOid, &amp;curveOidSz);</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#gacd36602384fcaf44f74d73ba83a0bde7">wc_CreatePKCS8Key</a>(NULL, &amp;pkcs8Sz, der,</div>
<div class="line">    derSize, ECDSAk, curveOid, curveOidSz); <span class="comment">// Get size needed in pkcs8Sz.</span></div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#gacd36602384fcaf44f74d73ba83a0bde7">wc_CreatePKCS8Key</a>(pkcs8, &amp;pkcs8Sz, der,</div>
<div class="line">    derSize, ECDSAk, curveOid, curveOidSz);</div>
<div class="ttc" id="agroup__ASN_html_ga77f85c4bfba15c19b12ef1f07552b0db"><div class="ttname"><a href="#ga77f85c4bfba15c19b12ef1f07552b0db">wc_EccKeyToDer</a></div><div class="ttdeci">int wc_EccKeyToDer(ecc_key *key, byte *output, word32 inLen)</div><div class="ttdoc">This function writes a private ECC key to der format.</div></div>
<div class="ttc" id="agroup__ASN_html_gacd36602384fcaf44f74d73ba83a0bde7"><div class="ttname"><a href="#gacd36602384fcaf44f74d73ba83a0bde7">wc_CreatePKCS8Key</a></div><div class="ttdeci">int wc_CreatePKCS8Key(byte *out, word32 *outSz, byte *key, word32 keySz, int algoID, const byte *curveOID, word32 oidSz)</div><div class="ttdoc">This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae6c42f3dc41e784c6b8075ca279b9b80" title="This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.">wc_GetPkcs8TraditionalOffset</a> </dd>
<dd>
<a class="el" href="#ga3b3076c1a3d4ce531bc67b766a3e7182" title="This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and conv...">wc_EncryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d" title="This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER....">wc_DecryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga2b90b217f96796be0eb0f6cf9ed231aa" title="This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it....">wc_CreateEncryptedPKCS8Key</a> </dd></dl>

</div>
</div>
<a id="ga3897ad303fb0af6fb5b932e1c160ee95" name="ga3897ad303fb0af6fb5b932e1c160ee95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3897ad303fb0af6fb5b932e1c160ee95">&#9670;&#160;</a></span>wc_Curve25519KeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519KeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decodes a Curve25519 key from a DER encoded buffer. It can decode either a private key, a public key, or both. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returns if input, inOutIdx or key is null </dd>
<dd>
ASN_PARSE_E Returns if there is an error parsing the DER encoded data </dd>
<dd>
ECC_BAD_ARG_E Returns if the key length is not CURVE25519_KEYSIZE or the DER key contains other issues despite being properly formatted. </dd>
<dd>
BUFFER_E Returns if the input buffer is too small to contain a valid DER encoded key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Pointer to buffer containing DER encoded key </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>Index to start reading input buffer from. On output, index is set to last position parsed of input buffer. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure to store decoded key </td></tr>
    <tr><td class="paramname">inSz</td><td>Size of input DER buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga12a719da0dd8a0cc89851215d0e2737e" title="This function decodes a Curve25519 private key (only) from a DER encoded buffer.">wc_Curve25519PrivateKeyDecode</a> </dd>
<dd>
<a class="el" href="#ga66ef6fceddb954aeff4963ae0a26dd8c" title="This function decodes a Curve25519 public key (only) from a DER encoded buffer.">wc_Curve25519PublicKeyDecode</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> der[] = { <span class="comment">// DER encoded key };</span></div>
<div class="line">word32 idx = 0;</div>
<div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga3897ad303fb0af6fb5b932e1c160ee95">wc_Curve25519KeyDecode</a>(der, &amp;idx, &amp;key, <span class="keyword">sizeof</span>(der)) != 0) {</div>
<div class="line">    <span class="comment">// Error decoding key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga3897ad303fb0af6fb5b932e1c160ee95"><div class="ttname"><a href="#ga3897ad303fb0af6fb5b932e1c160ee95">wc_Curve25519KeyDecode</a></div><div class="ttdeci">int wc_Curve25519KeyDecode(const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</div><div class="ttdoc">This function decodes a Curve25519 key from a DER encoded buffer. It can decode either a private key,...</div></div>
<div class="ttc" id="agroup__Curve25519_html_ga72e4bc602a049c47aea35d2e52ad90ab"><div class="ttname"><a href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a></div><div class="ttdeci">int wc_curve25519_init(curve25519_key *key)</div><div class="ttdoc">This function initializes a Curve25519 key. It should be called before generating a key for the struc...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa0baf75ba2e540f90c2dc6e4a928b3b1" name="gaa0baf75ba2e540f90c2dc6e4a928b3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1">&#9670;&#160;</a></span>wc_Curve25519KeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519KeyToDer </td>
          <td>(</td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>withAlg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encodes a Curve25519 key to DER format. It can encode either a private key, a public key, or both. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, length of DER encoding </dd>
<dd>
BAD_FUNC_ARG Returns if key or output is null </dd>
<dd>
MEMORY_E Returns if there is an allocation failure </dd>
<dd>
BUFFER_E Returns if output buffer is too small</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure containing key to encode </td></tr>
    <tr><td class="paramname">output</td><td>Buffer to hold DER encoding </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of output buffer </td></tr>
    <tr><td class="paramname">withAlg</td><td>Whether to include algorithm identifier in the DER encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga34af291ea27e9f42794cae27745dd3e3" title="This function encodes a Curve25519 private key to DER format. If the input key structure contains a p...">wc_Curve25519PrivateKeyToDer</a> </dd>
<dd>
<a class="el" href="#gab80c2a300573708d1c02a4cb002288ac" title="This function encodes a Curve25519 public key to DER format. If the input key structure contains a pr...">wc_Curve25519PublicKeyToDer</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line">...</div>
<div class="line">int derSz = 128; <span class="comment">// Some appropriate size for output DER</span></div>
<div class="line"><span class="keywordtype">byte</span> der[derSz];</div>
<div class="line"><a class="code hl_function" href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1">wc_Curve25519KeyToDer</a>(&amp;key, der, derSz, 1);</div>
<div class="ttc" id="agroup__ASN_html_gaa0baf75ba2e540f90c2dc6e4a928b3b1"><div class="ttname"><a href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1">wc_Curve25519KeyToDer</a></div><div class="ttdeci">int wc_Curve25519KeyToDer(curve25519_key *key, byte *output, word32 inLen, int withAlg)</div><div class="ttdoc">This function encodes a Curve25519 key to DER format. It can encode either a private key,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga12a719da0dd8a0cc89851215d0e2737e" name="ga12a719da0dd8a0cc89851215d0e2737e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a719da0dd8a0cc89851215d0e2737e">&#9670;&#160;</a></span>wc_Curve25519PrivateKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519PrivateKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decodes a Curve25519 private key (only) from a DER encoded buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returns if input, inOutIdx or key is null </dd>
<dd>
ASN_PARSE_E Returns if there is an error parsing the DER encoded data </dd>
<dd>
ECC_BAD_ARG_E Returns if the key length is not CURVE25519_KEYSIZE or the DER key contains other issues despite being properly formatted. </dd>
<dd>
BUFFER_E Returns if the input buffer is too small to contain a valid DER encoded key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Pointer to buffer containing DER encoded private key </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>Index to start reading input buffer from. On output, index is set to last position parsed of input buffer. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure to store decoded key </td></tr>
    <tr><td class="paramname">inSz</td><td>Size of input DER buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3897ad303fb0af6fb5b932e1c160ee95" title="This function decodes a Curve25519 key from a DER encoded buffer. It can decode either a private key,...">wc_Curve25519KeyDecode</a> </dd>
<dd>
<a class="el" href="#ga66ef6fceddb954aeff4963ae0a26dd8c" title="This function decodes a Curve25519 public key (only) from a DER encoded buffer.">wc_Curve25519PublicKeyDecode</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> der[] = { <span class="comment">// DER encoded key };</span></div>
<div class="line">word32 idx = 0;</div>
<div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga12a719da0dd8a0cc89851215d0e2737e">wc_Curve25519PrivateKeyDecode</a>(der, &amp;idx, &amp;key, <span class="keyword">sizeof</span>(der)) != 0) {</div>
<div class="line">    <span class="comment">// Error decoding private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga12a719da0dd8a0cc89851215d0e2737e"><div class="ttname"><a href="#ga12a719da0dd8a0cc89851215d0e2737e">wc_Curve25519PrivateKeyDecode</a></div><div class="ttdeci">int wc_Curve25519PrivateKeyDecode(const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</div><div class="ttdoc">This function decodes a Curve25519 private key (only) from a DER encoded buffer.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga34af291ea27e9f42794cae27745dd3e3" name="ga34af291ea27e9f42794cae27745dd3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34af291ea27e9f42794cae27745dd3e3">&#9670;&#160;</a></span>wc_Curve25519PrivateKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519PrivateKeyToDer </td>
          <td>(</td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encodes a Curve25519 private key to DER format. If the input key structure contains a public key, it will be ignored. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, length of DER encoding </dd>
<dd>
BAD_FUNC_ARG Returns if key or output is null </dd>
<dd>
MEMORY_E Returns if there is an allocation failure </dd>
<dd>
BUFFER_E Returns if output buffer is too small</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure containing private key to encode </td></tr>
    <tr><td class="paramname">output</td><td>Buffer to hold DER encoding </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of output buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1" title="This function encodes a Curve25519 key to DER format. It can encode either a private key,...">wc_Curve25519KeyToDer</a> </dd>
<dd>
<a class="el" href="#gab80c2a300573708d1c02a4cb002288ac" title="This function encodes a Curve25519 public key to DER format. If the input key structure contains a pr...">wc_Curve25519PublicKeyToDer</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line">...</div>
<div class="line">int derSz = 128; <span class="comment">// Some appropriate size for output DER</span></div>
<div class="line"><span class="keywordtype">byte</span> der[derSz];</div>
<div class="line"><a class="code hl_function" href="#ga34af291ea27e9f42794cae27745dd3e3">wc_Curve25519PrivateKeyToDer</a>(&amp;key, der, derSz);</div>
<div class="ttc" id="agroup__ASN_html_ga34af291ea27e9f42794cae27745dd3e3"><div class="ttname"><a href="#ga34af291ea27e9f42794cae27745dd3e3">wc_Curve25519PrivateKeyToDer</a></div><div class="ttdeci">int wc_Curve25519PrivateKeyToDer(curve25519_key *key, byte *output, word32 inLen)</div><div class="ttdoc">This function encodes a Curve25519 private key to DER format. If the input key structure contains a p...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga66ef6fceddb954aeff4963ae0a26dd8c" name="ga66ef6fceddb954aeff4963ae0a26dd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ef6fceddb954aeff4963ae0a26dd8c">&#9670;&#160;</a></span>wc_Curve25519PublicKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519PublicKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decodes a Curve25519 public key (only) from a DER encoded buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returns if input, inOutIdx or key is null </dd>
<dd>
ASN_PARSE_E Returns if there is an error parsing the DER encoded data </dd>
<dd>
ECC_BAD_ARG_E Returns if the key length is not CURVE25519_KEYSIZE or the DER key contains other issues despite being properly formatted. </dd>
<dd>
BUFFER_E Returns if the input buffer is too small to contain a valid DER encoded key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Pointer to buffer containing DER encoded public key </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>Index to start reading input buffer from. On output, index is set to last position parsed of input buffer. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure to store decoded key </td></tr>
    <tr><td class="paramname">inSz</td><td>Size of input DER buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3897ad303fb0af6fb5b932e1c160ee95" title="This function decodes a Curve25519 key from a DER encoded buffer. It can decode either a private key,...">wc_Curve25519KeyDecode</a> </dd>
<dd>
<a class="el" href="#ga12a719da0dd8a0cc89851215d0e2737e" title="This function decodes a Curve25519 private key (only) from a DER encoded buffer.">wc_Curve25519PrivateKeyDecode</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> der[] = { <span class="comment">// DER encoded key };</span></div>
<div class="line">word32 idx = 0;</div>
<div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga66ef6fceddb954aeff4963ae0a26dd8c">wc_Curve25519PublicKeyDecode</a>(der, &amp;idx, &amp;key, <span class="keyword">sizeof</span>(der)) != 0) {</div>
<div class="line">    <span class="comment">// Error decoding public key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga66ef6fceddb954aeff4963ae0a26dd8c"><div class="ttname"><a href="#ga66ef6fceddb954aeff4963ae0a26dd8c">wc_Curve25519PublicKeyDecode</a></div><div class="ttdeci">int wc_Curve25519PublicKeyDecode(const byte *input, word32 *inOutIdx, curve25519_key *key, word32 inSz)</div><div class="ttdoc">This function decodes a Curve25519 public key (only) from a DER encoded buffer.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab80c2a300573708d1c02a4cb002288ac" name="gab80c2a300573708d1c02a4cb002288ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab80c2a300573708d1c02a4cb002288ac">&#9670;&#160;</a></span>wc_Curve25519PublicKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_Curve25519PublicKeyToDer </td>
          <td>(</td>
          <td class="paramtype">curve25519_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>withAlg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encodes a Curve25519 public key to DER format. If the input key structure contains a private key, it will be ignored. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, length of DER encoding </dd>
<dd>
BAD_FUNC_ARG Returns if key or output is null </dd>
<dd>
MEMORY_E Returns if there is an allocation failure </dd>
<dd>
BUFFER_E Returns if output buffer is too small</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to curve25519_key structure containing public key to encode </td></tr>
    <tr><td class="paramname">output</td><td>Buffer to hold DER encoding </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of output buffer </td></tr>
    <tr><td class="paramname">withAlg</td><td>Whether to include algorithm identifier in the DER encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa0baf75ba2e540f90c2dc6e4a928b3b1" title="This function encodes a Curve25519 key to DER format. It can encode either a private key,...">wc_Curve25519KeyToDer</a> </dd>
<dd>
<a class="el" href="#ga34af291ea27e9f42794cae27745dd3e3" title="This function encodes a Curve25519 private key to DER format. If the input key structure contains a p...">wc_Curve25519PrivateKeyToDer</a></dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">curve25519_key key;</div>
<div class="line"><a class="code hl_function" href="group__Curve25519.html#ga72e4bc602a049c47aea35d2e52ad90ab">wc_curve25519_init</a>(&amp;key);</div>
<div class="line">...</div>
<div class="line">int derSz = 128; <span class="comment">// Some appropriate size for output DER</span></div>
<div class="line"><span class="keywordtype">byte</span> der[derSz];</div>
<div class="line"><a class="code hl_function" href="#gab80c2a300573708d1c02a4cb002288ac">wc_Curve25519PublicKeyToDer</a>(&amp;key, der, derSz, 1);</div>
<div class="ttc" id="agroup__ASN_html_gab80c2a300573708d1c02a4cb002288ac"><div class="ttname"><a href="#gab80c2a300573708d1c02a4cb002288ac">wc_Curve25519PublicKeyToDer</a></div><div class="ttdeci">int wc_Curve25519PublicKeyToDer(curve25519_key *key, byte *output, word32 inLen, int withAlg)</div><div class="ttdoc">This function encodes a Curve25519 public key to DER format. If the input key structure contains a pr...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga226ab6cfcc17b9c7233c0b0331ed7d7d" name="ga226ab6cfcc17b9c7233c0b0331ed7d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d">&#9670;&#160;</a></span>wc_DecryptPKCS8Key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_DecryptPKCS8Key </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>passwordSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER. Undoes the encryption done by wc_EncryptPKCS8Key. See RFC5208. The input buffer is overwritten with the decrypted data. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the decrypted buffer on success. </dd>
<dd>
Negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>On input, buffer containing encrypted PKCS#8 key. On successful output, contains the decrypted key. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of the input buffer. </td></tr>
    <tr><td class="paramname">password</td><td>The password used to encrypt the key. </td></tr>
    <tr><td class="paramname">passwordSz</td><td>The length of the password (not including NULL terminator).</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* pkcs8Enc;       <span class="comment">// Encrypted PKCS#8 key made with wc_EncryptPKCS8Key.</span></div>
<div class="line">word32 pkcs8EncSz;    <span class="comment">// Size of pkcs8Enc.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* password; <span class="comment">// Password to use for decryption.</span></div>
<div class="line"><span class="keywordtype">int</span> passwordSz;       <span class="comment">// Length of password (not including NULL terminator).</span></div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d">wc_DecryptPKCS8Key</a>(pkcs8Enc, pkcs8EncSz, password, passwordSz);</div>
<div class="ttc" id="agroup__ASN_html_ga226ab6cfcc17b9c7233c0b0331ed7d7d"><div class="ttname"><a href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d">wc_DecryptPKCS8Key</a></div><div class="ttdeci">int wc_DecryptPKCS8Key(byte *input, word32 sz, const char *password, int passwordSz)</div><div class="ttdoc">This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae6c42f3dc41e784c6b8075ca279b9b80" title="This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.">wc_GetPkcs8TraditionalOffset</a> </dd>
<dd>
<a class="el" href="#gacd36602384fcaf44f74d73ba83a0bde7" title="This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS...">wc_CreatePKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga3b3076c1a3d4ce531bc67b766a3e7182" title="This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and conv...">wc_EncryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga2b90b217f96796be0eb0f6cf9ed231aa" title="This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it....">wc_CreateEncryptedPKCS8Key</a> </dd></dl>

</div>
</div>
<a id="ga4b973eddc04922d3735c5353868a679b" name="ga4b973eddc04922d3735c5353868a679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b973eddc04922d3735c5353868a679b">&#9670;&#160;</a></span>wc_DerToPem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_DerToPem </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a der formatted input certificate, contained in the der buffer, into a pem formatted output certificate, contained in the output buffer. It should be noted that this is not an in place conversion, and a separate buffer must be utilized to store the pem formatted output. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully making a pem certificate from the input der cert, returns the size of the pem cert generated. </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error parsing the der file and storing it as a pem file </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_INPUT_E Returned in the case of a base64 encoding error </dd>
<dd>
BUFFER_E May be returned if the output buffer is too small to store the pem formatted certificate</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">der</td><td>pointer to the buffer of the certificate to convert </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the the certificate to convert </td></tr>
    <tr><td class="paramname">output</td><td>pointer to the buffer in which to store the pem formatted certificate </td></tr>
    <tr><td class="paramname">outSz</td><td>size of the buffer in which to store the pem formatted certificate </td></tr>
    <tr><td class="paramname">type</td><td>the type of certificate to generate. Valid types are: CERT_TYPE, PRIVATEKEY_TYPE, ECC_PRIVATEKEY_TYPE, and CERTREQ_TYPE.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line"><span class="comment">// initialize der with certificate</span></div>
<div class="line"><span class="keywordtype">byte</span>* pemFormatted[FOURK_BUF];</div>
<div class="line"> </div>
<div class="line">word32 pemSz;</div>
<div class="line">pemSz = <a class="code hl_function" href="#ga4b973eddc04922d3735c5353868a679b">wc_DerToPem</a>(der, derSz,pemFormatted,FOURK_BUF, CERT_TYPE);</div>
<div class="ttc" id="agroup__ASN_html_ga4b973eddc04922d3735c5353868a679b"><div class="ttname"><a href="#ga4b973eddc04922d3735c5353868a679b">wc_DerToPem</a></div><div class="ttdeci">int wc_DerToPem(const byte *der, word32 derSz, byte *output, word32 outSz, int type)</div><div class="ttdoc">This function converts a der formatted input certificate, contained in the der buffer,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1881b0197dfca3b68e96147f57115bc9" title="This function converts a pem certificate to a der certificate, and places the resulting certificate i...">wc_PemCertToDer</a> </dd></dl>

</div>
</div>
<a id="gaa23858ae67d70555c3f952f0cca4a129" name="gaa23858ae67d70555c3f952f0cca4a129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23858ae67d70555c3f952f0cca4a129">&#9670;&#160;</a></span>wc_DerToPemEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_DerToPemEx </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>cipher_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a der formatted input certificate, contained in the der buffer, into a pem formatted output certificate, contained in the output buffer. It should be noted that this is not an in place conversion, and a separate buffer must be utilized to store the pem formatted output. Allows setting cipher info. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully making a pem certificate from the input der cert, returns the size of the pem cert generated. </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error parsing the der file and storing it as a pem file </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_INPUT_E Returned in the case of a base64 encoding error </dd>
<dd>
BUFFER_E May be returned if the output buffer is too small to store the pem formatted certificate</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">der</td><td>pointer to the buffer of the certificate to convert </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the the certificate to convert </td></tr>
    <tr><td class="paramname">output</td><td>pointer to the buffer in which to store the pem formatted certificate </td></tr>
    <tr><td class="paramname">outSz</td><td>size of the buffer in which to store the pem formatted certificate </td></tr>
    <tr><td class="paramname">cipher_info</td><td>Additional cipher information. </td></tr>
    <tr><td class="paramname">type</td><td>the type of certificate to generate. Valid types are: CERT_TYPE, PRIVATEKEY_TYPE, ECC_PRIVATEKEY_TYPE, and CERTREQ_TYPE.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line"><span class="comment">// initialize der with certificate</span></div>
<div class="line"><span class="keywordtype">byte</span>* pemFormatted[FOURK_BUF];</div>
<div class="line"> </div>
<div class="line">word32 pemSz;</div>
<div class="line"><span class="keywordtype">byte</span>* cipher_info[] { Additional cipher info. }</div>
<div class="line">pemSz = <a class="code hl_function" href="#gaa23858ae67d70555c3f952f0cca4a129">wc_DerToPemEx</a>(der, derSz, pemFormatted, FOURK_BUF, cipher_info, CERT_TYPE);</div>
<div class="ttc" id="agroup__ASN_html_gaa23858ae67d70555c3f952f0cca4a129"><div class="ttname"><a href="#gaa23858ae67d70555c3f952f0cca4a129">wc_DerToPemEx</a></div><div class="ttdeci">int wc_DerToPemEx(const byte *der, word32 derSz, byte *output, word32 outSz, byte *cipher_info, int type)</div><div class="ttdoc">This function converts a der formatted input certificate, contained in the der buffer,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1881b0197dfca3b68e96147f57115bc9" title="This function converts a pem certificate to a der certificate, and places the resulting certificate i...">wc_PemCertToDer</a> </dd></dl>

</div>
</div>
<a id="ga77f85c4bfba15c19b12ef1f07552b0db" name="ga77f85c4bfba15c19b12ef1f07552b0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f85c4bfba15c19b12ef1f07552b0db">&#9670;&#160;</a></span>wc_EccKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EccKeyToDer </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a private ECC key to der format. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully writing the ECC key to der format, returns the length written to the buffer </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null, or inLen equals zero </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the converted certificate is too large to store in the output buffer </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the ECC key used is of an unknown type </dd>
<dd>
MP_MEM Returned if there is an error in the math library used while parsing the private key </dd>
<dd>
MP_VAL Returned if there is an error in the math library used while parsing the private key </dd>
<dd>
MP_RANGE Returned if there is an error in the math library used while parsing the private key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the buffer containing the input ecc key </td></tr>
    <tr><td class="paramname">output</td><td>pointer to a buffer in which to store the der formatted key </td></tr>
    <tr><td class="paramname">inLen</td><td>the length of the buffer in which to store the der formatted key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> derSz;</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize and make key</span></div>
<div class="line"><span class="keywordtype">byte</span> der[FOURK_BUF];</div>
<div class="line"><span class="comment">// store der formatted key here</span></div>
<div class="line"> </div>
<div class="line">derSz = <a class="code hl_function" href="#ga77f85c4bfba15c19b12ef1f07552b0db">wc_EccKeyToDer</a>(&amp;key, der, FOURK_BUF);</div>
<div class="line"><span class="keywordflow">if</span>(derSz &lt; 0) {</div>
<div class="line">    <span class="comment">// error converting ecc key to der buffer</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RSA.html#ga428f841fea0e37d3c855c31b32f39dbd" title="This function converts an RsaKey key to DER format. The result is written to output and it returns th...">wc_RsaKeyToDer</a> </dd></dl>

</div>
</div>
<a id="gad8171b7dcac7dff2c38a1bf9e2e0bb25" name="gad8171b7dcac7dff2c38a1bf9e2e0bb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8171b7dcac7dff2c38a1bf9e2e0bb25">&#9670;&#160;</a></span>wc_EccPrivateKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EccPrivateKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads in an ECC private key from the input buffer, input, parses the private key, and uses it to generate an ecc_key object, which it stores in key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 On successfully decoding the private key and storing the result in the ecc_key struct </dd>
<dd>
ASN_PARSE_E: Returned if there is an error parsing the der file and storing it as a pem file </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the certificate to convert is large than the specified max certificate size </dd>
<dd>
ASN_OBJECT_ID_E Returned if the certificate encoding has an invalid object id </dd>
<dd>
ECC_CURVE_OID_E Returned if the ECC curve of the provided key is not supported </dd>
<dd>
ECC_BAD_ARG_E Returned if there is an error in the ECC key format </dd>
<dd>
NOT_COMPILED_IN Returned if the private key is compressed, and no compression key is provided </dd>
<dd>
MP_MEM Returned if there is an error in the math library used while parsing the private key </dd>
<dd>
MP_VAL Returned if there is an error in the math library used while parsing the private key </dd>
<dd>
MP_RANGE Returned if there is an error in the math library used while parsing the private key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the buffer containing the input private key </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>pointer to a word32 object containing the index in the buffer at which to start </td></tr>
    <tr><td class="paramname">key</td><td>pointer to an initialized ecc object, on which to store the decoded private key </td></tr>
    <tr><td class="paramname">inSz</td><td>size of the input buffer containing the private key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret, idx=0;</div>
<div class="line">ecc_key key; <span class="comment">// to store key in</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span>* tmp; <span class="comment">// tmp buffer to read key from</span></div>
<div class="line">tmp = (<span class="keywordtype">byte</span>*) malloc(FOURK_BUF);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> inSz;</div>
<div class="line">inSz = fread(tmp, 1, FOURK_BUF, privateKeyFile);</div>
<div class="line"><span class="comment">// read key into tmp buffer</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line">ret = <a class="code hl_function" href="#gad8171b7dcac7dff2c38a1bf9e2e0bb25">wc_EccPrivateKeyDecode</a>(tmp, &amp;idx, &amp;key, (word32)inSz);</div>
<div class="line"><span class="keywordflow">if</span>(ret &lt; 0) {</div>
<div class="line">    <span class="comment">// error decoding ecc key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gad8171b7dcac7dff2c38a1bf9e2e0bb25"><div class="ttname"><a href="#gad8171b7dcac7dff2c38a1bf9e2e0bb25">wc_EccPrivateKeyDecode</a></div><div class="ttdeci">int wc_EccPrivateKeyDecode(const byte *input, word32 *inOutIdx, ecc_key *key, word32 inSz)</div><div class="ttdoc">This function reads in an ECC private key from the input buffer, input, parses the private key,...</div></div>
<div class="ttc" id="agroup__ECC_html_gaaa0c3f56e07df66db857966e26106e18"><div class="ttname"><a href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a></div><div class="ttdeci">int wc_ecc_init(ecc_key *key)</div><div class="ttdoc">This function initializes an ecc_key object for future use with message verification or key negotiati...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RSA_PrivateKeyDecode </dd></dl>

</div>
</div>
<a id="ga748630c3374d8e5352438ade73f6d37b" name="ga748630c3374d8e5352438ade73f6d37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748630c3374d8e5352438ade73f6d37b">&#9670;&#160;</a></span>wc_EccPublicKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EccPublicKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes an ECC public key from an input buffer. It will parse an ASN sequence to retrieve the ECC key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returns if any arguments are null. </dd>
<dd>
ASN_PARSE_E Returns if there is an error parsing </dd>
<dd>
ASN_ECC_KEY_E Returns if there is an error importing the key. See wc_ecc_import_x963 for possible reasons.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Buffer containing DER encoded key to decode. </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>Index to start reading input buffer from. On output, index is set to last position parsed of input buffer. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to ecc_key struct to store the public key. </td></tr>
    <tr><td class="paramname">inSz</td><td>Size of the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">word32 idx = 0;</div>
<div class="line"><span class="keywordtype">byte</span> buff[] = { <span class="comment">// initialize with key };</span></div>
<div class="line">ecc_key pubKey;</div>
<div class="line"><a class="code hl_function" href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;pubKey);</div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code hl_function" href="#ga748630c3374d8e5352438ade73f6d37b">wc_EccPublicKeyDecode</a>(buff, &amp;idx, &amp;pubKey, <span class="keyword">sizeof</span>(buff)) != 0) {</div>
<div class="line">        <span class="comment">// error decoding key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga748630c3374d8e5352438ade73f6d37b"><div class="ttname"><a href="#ga748630c3374d8e5352438ade73f6d37b">wc_EccPublicKeyDecode</a></div><div class="ttdeci">int wc_EccPublicKeyDecode(const byte *input, word32 *inOutIdx, ecc_key *key, word32 inSz)</div><div class="ttdoc">Decodes an ECC public key from an input buffer. It will parse an ASN sequence to retrieve the ECC key...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ECC.html#ga1c4116facdbb32a302c7f03cd20adac7" title="This function imports a public ECC key from a buffer containing the key stored in ANSI X9....">wc_ecc_import_x963</a> </dd></dl>

</div>
</div>
<a id="gabc19c7569f17c7d4c0cb740e5713d28c" name="gabc19c7569f17c7d4c0cb740e5713d28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc19c7569f17c7d4c0cb740e5713d28c">&#9670;&#160;</a></span>wc_EccPublicKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EccPublicKeyToDer </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>with_AlgCurve</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the ECC public key to DER format. It returns the size of buffer used. The public ECC key in DER format is stored in output buffer. The with_AlgCurve flag will include a header that has the Algorithm and Curve information. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, size of buffer used </dd>
<dd>
BAD_FUNC_ARG Returned if output or key is null. </dd>
<dd>
LENGTH_ONLY_E Error in getting ECC public key size. </dd>
<dd>
BUFFER_E Returned when output buffer is too small.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to ECC key </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output buffer to write to. </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">with_AlgCurve</td><td>a flag for when to include a header that has the Algorithm and Curve information.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="group__ECC.html#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div>
<div class="line"><span class="keywordtype">int</span> derSz = <span class="comment">// Some appropriate size for der;</span></div>
<div class="line"><span class="keywordtype">byte</span> der[derSz];</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gabc19c7569f17c7d4c0cb740e5713d28c">wc_EccPublicKeyToDer</a>(&amp;key, der, derSz, 1) &lt; 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error converting ECC public key to der</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gabc19c7569f17c7d4c0cb740e5713d28c"><div class="ttname"><a href="#gabc19c7569f17c7d4c0cb740e5713d28c">wc_EccPublicKeyToDer</a></div><div class="ttdeci">int wc_EccPublicKeyToDer(ecc_key *key, byte *output, word32 inLen, int with_AlgCurve)</div><div class="ttdoc">This function converts the ECC public key to DER format. It returns the size of buffer used....</div></div>
<div class="ttc" id="agroup__ECC_html_ga6d0f268d7b0d7ad4b3fac490c1397fc8"><div class="ttname"><a href="group__ECC.html#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a></div><div class="ttdeci">int wc_ecc_make_key(WC_RNG *rng, int keysize, ecc_key *key)</div><div class="ttdoc">This function generates a new ecc_key and stores it in key.</div></div>
<div class="ttc" id="agroup__Random_html_ga1a87307fac65d3c2a47ffb743020f83c"><div class="ttname"><a href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a></div><div class="ttdeci">int wc_InitRng(WC_RNG *)</div><div class="ttdoc">Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga77f85c4bfba15c19b12ef1f07552b0db" title="This function writes a private ECC key to der format.">wc_EccKeyToDer</a> </dd>
<dd>
<a class="el" href="#gad8171b7dcac7dff2c38a1bf9e2e0bb25" title="This function reads in an ECC private key from the input buffer, input, parses the private key,...">wc_EccPrivateKeyDecode</a> </dd></dl>

</div>
</div>
<a id="ga7495b26573c2456c6a62ee1872938ca2" name="ga7495b26573c2456c6a62ee1872938ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7495b26573c2456c6a62ee1872938ca2">&#9670;&#160;</a></span>wc_EccPublicKeyToDer_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EccPublicKeyToDer_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>with_AlgCurve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the ECC public key to DER format. It returns the size of buffer used. The public ECC key in DER format is stored in output buffer. The with_AlgCurve flag will include a header that has the Algorithm and Curve information. The comp parameter determines if the public key will be exported as compressed. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, size of buffer used </dd>
<dd>
BAD_FUNC_ARG Returned if output or key is null. </dd>
<dd>
LENGTH_ONLY_E Error in getting ECC public key size. </dd>
<dd>
BUFFER_E Returned when output buffer is too small.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to ECC key </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output buffer to write to. </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">with_AlgCurve</td><td>a flag for when to include a header that has the Algorithm and Curve information. </td></tr>
    <tr><td class="paramname">comp</td><td>If 1 (non-zero) the ECC public key will be written in compressed form. If 0 it will be written in an uncompressed format.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="group__ECC.html#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div>
<div class="line"><span class="keywordtype">int</span> derSz = <span class="comment">// Some appropriate size for der;</span></div>
<div class="line"><span class="keywordtype">byte</span> der[derSz];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write out a compressed ECC key</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga7495b26573c2456c6a62ee1872938ca2">wc_EccPublicKeyToDer_ex</a>(&amp;key, der, derSz, 1, 1) &lt; 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error converting ECC public key to der</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga7495b26573c2456c6a62ee1872938ca2"><div class="ttname"><a href="#ga7495b26573c2456c6a62ee1872938ca2">wc_EccPublicKeyToDer_ex</a></div><div class="ttdeci">int wc_EccPublicKeyToDer_ex(ecc_key *key, byte *output, word32 inLen, int with_AlgCurve, int comp)</div><div class="ttdoc">This function converts the ECC public key to DER format. It returns the size of buffer used....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga77f85c4bfba15c19b12ef1f07552b0db" title="This function writes a private ECC key to der format.">wc_EccKeyToDer</a> </dd>
<dd>
<a class="el" href="#ga748630c3374d8e5352438ade73f6d37b" title="Decodes an ECC public key from an input buffer. It will parse an ASN sequence to retrieve the ECC key...">wc_EccPublicKeyDecode</a> </dd></dl>

</div>
</div>
<a id="gabf1b4a96b34f41ed4fbffaff2cacac2e" name="gabf1b4a96b34f41ed4fbffaff2cacac2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf1b4a96b34f41ed4fbffaff2cacac2e">&#9670;&#160;</a></span>wc_EncodeSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word32 wc_EncodeSignature </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>digest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>digSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hashOID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encodes a digital signature into the output buffer, and returns the size of the encoded signature created. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully writing the encoded signature to output, returns the length written to the buffer</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>pointer to the buffer where the encoded signature will be written </td></tr>
    <tr><td class="paramname">digest</td><td>pointer to the digest to use to encode the signature </td></tr>
    <tr><td class="paramname">digSz</td><td>the length of the buffer containing the digest </td></tr>
    <tr><td class="paramname">hashOID</td><td>OID identifying the hash type used to generate the signature. Valid options, depending on build configurations, are: SHAh, SHA256h, SHA384h, SHA512h, MD2h, MD5h, DESb, DES3b, CTC_MD5wRSA, CTC_SHAwRSA, CTC_SHA256wRSA, CTC_SHA384wRSA, CTC_SHA512wRSA, CTC_SHAwECDSA, CTC_SHA256wECDSA, CTC_SHA384wECDSA, and CTC_SHA512wECDSA.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> signSz;</div>
<div class="line"><span class="keywordtype">byte</span> encodedSig[MAX_ENCODED_SIG_SZ];</div>
<div class="line">Sha256 sha256;</div>
<div class="line"><span class="comment">// initialize sha256 for hashing</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span>* dig = = (<span class="keywordtype">byte</span>*)malloc(WC_SHA256_DIGEST_SIZE);</div>
<div class="line"><span class="comment">// perform hashing and hash updating so dig stores SHA-256 hash</span></div>
<div class="line"><span class="comment">// (see wc_InitSha256, wc_Sha256Update and wc_Sha256Final)</span></div>
<div class="line">signSz = <a class="code hl_function" href="#gabf1b4a96b34f41ed4fbffaff2cacac2e">wc_EncodeSignature</a>(encodedSig, dig, WC_SHA256_DIGEST_SIZE, SHA256h);</div>
<div class="ttc" id="agroup__ASN_html_gabf1b4a96b34f41ed4fbffaff2cacac2e"><div class="ttname"><a href="#gabf1b4a96b34f41ed4fbffaff2cacac2e">wc_EncodeSignature</a></div><div class="ttdeci">word32 wc_EncodeSignature(byte *out, const byte *digest, word32 digSz, int hashOID)</div><div class="ttdoc">This function encodes a digital signature into the output buffer, and returns the size of the encoded...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga3b3076c1a3d4ce531bc67b766a3e7182" name="ga3b3076c1a3d4ce531bc67b766a3e7182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b3076c1a3d4ce531bc67b766a3e7182">&#9670;&#160;</a></span>wc_EncryptPKCS8Key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_EncryptPKCS8Key </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>password</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>passwordSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vPKCS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pbeOid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>encAlgId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>saltSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>itt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and converts it to PKCS#8 encrypted format. The resulting encrypted key can be decrypted using wc_DecryptPKCS8Key. See RFC 5208. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the encrypted key placed in out on success. </dd>
<dd>
LENGTH_ONLY_E if out is NULL, with required output buffer size in outSz. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Buffer with traditional DER key. </td></tr>
    <tr><td class="paramname">keySz</td><td>Size of key buffer. </td></tr>
    <tr><td class="paramname">out</td><td>Buffer to place result in. If NULL, required out buffer size returned in outSz. </td></tr>
    <tr><td class="paramname">outSz</td><td>Size of out buffer. </td></tr>
    <tr><td class="paramname">password</td><td>The password to use for the password-based encryption algorithm. </td></tr>
    <tr><td class="paramname">passwordSz</td><td>The length of the password (not including the NULL terminator). </td></tr>
    <tr><td class="paramname">vPKCS</td><td>The PKCS version to use. Can be 1 for PKCS12 or PKCS5. </td></tr>
    <tr><td class="paramname">pbeOid</td><td>The OID of the PBE scheme to use (e.g. PBES2 or one of the OIDs for PBES1 in RFC 2898 A.3). </td></tr>
    <tr><td class="paramname">encAlgId</td><td>The encryption algorithm ID to use (e.g. AES256CBCb). </td></tr>
    <tr><td class="paramname">salt</td><td>The salt buffer to use. If NULL, a random salt will be used. </td></tr>
    <tr><td class="paramname">saltSz</td><td>The length of the salt buffer. Can be 0 if passing NULL for salt. </td></tr>
    <tr><td class="paramname">itt</td><td>The number of iterations to use for the KDF. </td></tr>
    <tr><td class="paramname">rng</td><td>A pointer to an initialized WC_RNG object. </td></tr>
    <tr><td class="paramname">heap</td><td>A pointer to the heap used for dynamic allocation. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* pkcs8;          <span class="comment">// Unencrypted PKCS#8 key.</span></div>
<div class="line">word32 pkcs8Sz;       <span class="comment">// Size of pkcs8.</span></div>
<div class="line"><span class="keywordtype">byte</span>* pkcs8Enc;       <span class="comment">// Encrypted PKCS#8 key.</span></div>
<div class="line">word32 pkcs8EncSz;    <span class="comment">// Size of pkcs8Enc.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* password; <span class="comment">// Password to use for encryption.</span></div>
<div class="line"><span class="keywordtype">int</span> passwordSz;       <span class="comment">// Length of password (not including NULL terminator).</span></div>
<div class="line">WC_RNG rng;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following produces an encrypted version of pkcs8 in pkcs8Enc. The</span></div>
<div class="line"><span class="comment">// encryption uses password-based encryption scheme 2 (PBE2) from PKCS#5 and</span></div>
<div class="line"><span class="comment">// the AES cipher in CBC mode with a 256-bit key. See RFC 8018 for more on</span></div>
<div class="line"><span class="comment">// PKCS#5.</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga3b3076c1a3d4ce531bc67b766a3e7182">wc_EncryptPKCS8Key</a>(pkcs8, pkcs8Sz, pkcs8Enc, &amp;pkcs8EncSz, password,</div>
<div class="line">        passwordSz, PKCS5, PBES2, AES256CBCb, NULL, 0,</div>
<div class="line">        WC_PKCS12_ITT_DEFAULT, &amp;rng, NULL);</div>
<div class="ttc" id="agroup__ASN_html_ga3b3076c1a3d4ce531bc67b766a3e7182"><div class="ttname"><a href="#ga3b3076c1a3d4ce531bc67b766a3e7182">wc_EncryptPKCS8Key</a></div><div class="ttdeci">int wc_EncryptPKCS8Key(byte *key, word32 keySz, byte *out, word32 *outSz, const char *password, int passwordSz, int vPKCS, int pbeOid, int encAlgId, byte *salt, word32 saltSz, int itt, WC_RNG *rng, void *heap)</div><div class="ttdoc">This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and conv...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae6c42f3dc41e784c6b8075ca279b9b80" title="This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.">wc_GetPkcs8TraditionalOffset</a> </dd>
<dd>
<a class="el" href="#gacd36602384fcaf44f74d73ba83a0bde7" title="This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS...">wc_CreatePKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d" title="This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER....">wc_DecryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga2b90b217f96796be0eb0f6cf9ed231aa" title="This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it....">wc_CreateEncryptedPKCS8Key</a> </dd></dl>

</div>
</div>
<a id="ga2be9ca18448fba206de8331c08ceb752" name="ga2be9ca18448fba206de8331c08ceb752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be9ca18448fba206de8331c08ceb752">&#9670;&#160;</a></span>wc_FreeDecodedCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_FreeDecodedCert </td>
          <td>(</td>
          <td class="paramtype">struct DecodedCert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees a DecodedCert that was previously initialized with wc_InitDecodedCert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to an initialized DecodedCert object.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">DecodedCert decodedCert; <span class="comment">// Decoded certificate object.</span></div>
<div class="line"><span class="keywordtype">byte</span>* certBuf;           <span class="comment">// DER-encoded certificate buffer.</span></div>
<div class="line">word32 certBufSz;        <span class="comment">// Size of certBuf in bytes.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#gad713e892f23ba17144e33e2992b2f41d">wc_InitDecodedCert</a>(&amp;decodedCert, certBuf, certBufSz, NULL);</div>
<div class="line">ret = <a class="code hl_function" href="#ga6732f10a963f0f55a51e03f2ce2ed64a">wc_ParseCert</a>(&amp;decodedCert, CERT_TYPE, NO_VERIFY, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;wc_ParseCert failed.\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="#ga2be9ca18448fba206de8331c08ceb752">wc_FreeDecodedCert</a>(&amp;decodedCert);</div>
<div class="ttc" id="agroup__ASN_html_ga2be9ca18448fba206de8331c08ceb752"><div class="ttname"><a href="#ga2be9ca18448fba206de8331c08ceb752">wc_FreeDecodedCert</a></div><div class="ttdeci">void wc_FreeDecodedCert(struct DecodedCert *cert)</div><div class="ttdoc">This function frees a DecodedCert that was previously initialized with wc_InitDecodedCert.</div></div>
<div class="ttc" id="agroup__ASN_html_ga6732f10a963f0f55a51e03f2ce2ed64a"><div class="ttname"><a href="#ga6732f10a963f0f55a51e03f2ce2ed64a">wc_ParseCert</a></div><div class="ttdeci">int wc_ParseCert(DecodedCert *cert, int type, int verify, void *cm)</div><div class="ttdoc">This function parses the DER-encoded certificate saved in the DecodedCert object and populates the fi...</div></div>
<div class="ttc" id="agroup__ASN_html_gad713e892f23ba17144e33e2992b2f41d"><div class="ttname"><a href="#gad713e892f23ba17144e33e2992b2f41d">wc_InitDecodedCert</a></div><div class="ttdeci">void wc_InitDecodedCert(struct DecodedCert *cert, const byte *source, word32 inSz, void *heap)</div><div class="ttdoc">This function initializes the DecodedCert pointed to by the &quot;cert&quot; parameter. It saves the &quot;source&quot; p...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad713e892f23ba17144e33e2992b2f41d" title="This function initializes the DecodedCert pointed to by the &quot;cert&quot; parameter. It saves the &quot;source&quot; p...">wc_InitDecodedCert</a> </dd>
<dd>
<a class="el" href="#ga6732f10a963f0f55a51e03f2ce2ed64a" title="This function parses the DER-encoded certificate saved in the DecodedCert object and populates the fi...">wc_ParseCert</a> </dd></dl>

</div>
</div>
<a id="gabaefce3e50456a39826cc7431f66eb33" name="gabaefce3e50456a39826cc7431f66eb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaefce3e50456a39826cc7431f66eb33">&#9670;&#160;</a></span>wc_GetCTC_HashOID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_GetCTC_HashOID </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the hash OID that corresponds to a hashing type. For example, when given the type: WC_SHA512, this function returns the identifier corresponding to a SHA512 hash, SHA512h. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On success, returns the OID corresponding to the appropriate hash to use with that encryption type. </dd>
<dd>
0 Returned if an unrecognized hash type is passed in as argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the hash type for which to find the OID. Valid options, depending on build configuration, include: WC_MD5, WC_SHA, WC_SHA256, WC_SHA384, WC_SHA512, WC_SHA3_224, WC_SHA3_256, WC_SHA3_384 or WC_SHA3_512</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> hashOID;</div>
<div class="line"> </div>
<div class="line">hashOID = <a class="code hl_function" href="#gabaefce3e50456a39826cc7431f66eb33">wc_GetCTC_HashOID</a>(WC_SHA512);</div>
<div class="line"><span class="keywordflow">if</span> (hashOID == 0) {</div>
<div class="line">    <span class="comment">// WOLFSSL_SHA512 not defined</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gabaefce3e50456a39826cc7431f66eb33"><div class="ttname"><a href="#gabaefce3e50456a39826cc7431f66eb33">wc_GetCTC_HashOID</a></div><div class="ttdeci">int wc_GetCTC_HashOID(int type)</div><div class="ttdoc">This function returns the hash OID that corresponds to a hashing type. For example,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="gae6c42f3dc41e784c6b8075ca279b9b80" name="gae6c42f3dc41e784c6b8075ca279b9b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c42f3dc41e784c6b8075ca279b9b80">&#9670;&#160;</a></span>wc_GetPkcs8TraditionalOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_GetPkcs8TraditionalOffset </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Length of traditional private key on success. </dd>
<dd>
Negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Buffer containing unencrypted PKCS#8 private key. </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>Index into the input buffer. On input, it should be a byte offset to the beginning of the the PKCS#8 buffer. On output, it will be the byte offset to the traditional private key within the input buffer. </td></tr>
    <tr><td class="paramname">sz</td><td>The number of bytes in the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* pkcs8Buf; <span class="comment">// Buffer containing PKCS#8 key.</span></div>
<div class="line">word32 idx = 0;</div>
<div class="line">word32 sz; <span class="comment">// Size of pkcs8Buf.</span></div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#gae6c42f3dc41e784c6b8075ca279b9b80">wc_GetPkcs8TraditionalOffset</a>(pkcs8Buf, &amp;idx, sz);</div>
<div class="line"><span class="comment">// pkcs8Buf + idx is now the beginning of the traditional private key bytes.</span></div>
<div class="ttc" id="agroup__ASN_html_gae6c42f3dc41e784c6b8075ca279b9b80"><div class="ttname"><a href="#gae6c42f3dc41e784c6b8075ca279b9b80">wc_GetPkcs8TraditionalOffset</a></div><div class="ttdeci">int wc_GetPkcs8TraditionalOffset(byte *input, word32 *inOutIdx, word32 sz)</div><div class="ttdoc">This function finds the beginning of the traditional private key inside a PKCS#8 unencrypted buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd36602384fcaf44f74d73ba83a0bde7" title="This function takes in a DER private key and converts it to PKCS#8 format. Also used in creating PKCS...">wc_CreatePKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga3b3076c1a3d4ce531bc67b766a3e7182" title="This function takes in an unencrypted PKCS#8 DER key (e.g. one created by wc_CreatePKCS8Key) and conv...">wc_EncryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga226ab6cfcc17b9c7233c0b0331ed7d7d" title="This function takes an encrypted PKCS#8 DER key and decrypts it to PKCS#8 unencrypted DER....">wc_DecryptPKCS8Key</a> </dd>
<dd>
<a class="el" href="#ga2b90b217f96796be0eb0f6cf9ed231aa" title="This function takes a traditional, DER key, converts it to PKCS#8 format, and encrypts it....">wc_CreateEncryptedPKCS8Key</a> </dd></dl>

</div>
</div>
<a id="ga4a19fbbfa99ae9503fc96f9fe0d46e7a" name="ga4a19fbbfa99ae9503fc96f9fe0d46e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a19fbbfa99ae9503fc96f9fe0d46e7a">&#9670;&#160;</a></span>wc_GetSubjectRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_GetSubjectRaw </td>
          <td>(</td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>subjectRaw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the raw subject from the certificate structure. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully getting the subject from the certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subjectRaw</td><td>pointer-pointer to the raw subject upon successful return </td></tr>
    <tr><td class="paramname">cert</td><td>pointer to the cert from which to get the raw subject</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="keywordtype">byte</span> *subjRaw;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga4a19fbbfa99ae9503fc96f9fe0d46e7a">wc_GetSubjectRaw</a>(&amp;subjRaw, &amp;myCert) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga4a19fbbfa99ae9503fc96f9fe0d46e7a"><div class="ttname"><a href="#ga4a19fbbfa99ae9503fc96f9fe0d46e7a">wc_GetSubjectRaw</a></div><div class="ttdeci">int wc_GetSubjectRaw(byte **subjectRaw, Cert *cert)</div><div class="ttdoc">This function gets the raw subject from the certificate structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaac9a70c1061eae1a8ce862a4cf5be0d3" title="This function sets the raw subject for a certificate from the subject in the provided der buffer....">wc_SetSubjectRaw</a> </dd></dl>

</div>
</div>
<a id="gacd9209218503a6aa6750307200d3de76" name="gacd9209218503a6aa6750307200d3de76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9209218503a6aa6750307200d3de76">&#9670;&#160;</a></span>wc_InitCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_InitCert </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a default cert, with the default options: version = 3 (0x2), serial = 0, sigType = SHA_WITH_RSA, issuer = blank, daysValid = 500, selfSigned = 1 (true) use subject as issuer, subject = blank. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to an uninitialized cert structure to initialize</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;myCert);</div>
<div class="ttc" id="agroup__ASN_html_gacd9209218503a6aa6750307200d3de76"><div class="ttname"><a href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a></div><div class="ttdeci">int wc_InitCert(Cert *)</div><div class="ttdoc">This function initializes a default cert, with the default options: version = 3 (0x2),...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd>
<dd>
<a class="el" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e" title="This function makes a certificate signing request using the input certificate and writes the output t...">wc_MakeCertReq</a> </dd></dl>

</div>
</div>
<a id="gad713e892f23ba17144e33e2992b2f41d" name="gad713e892f23ba17144e33e2992b2f41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad713e892f23ba17144e33e2992b2f41d">&#9670;&#160;</a></span>wc_InitDecodedCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_InitDecodedCert </td>
          <td>(</td>
          <td class="paramtype">struct DecodedCert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the DecodedCert pointed to by the "cert" parameter. It saves the "source" pointer to a DER-encoded certificate of length "inSz." This certificate can be parsed by a subsequent call to wc_ParseCert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to an allocated DecodedCert object. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to a DER-encoded certificate. </td></tr>
    <tr><td class="paramname">inSz</td><td>Length of the DER-encoded certificate in bytes. </td></tr>
    <tr><td class="paramname">heap</td><td>A pointer to the heap used for dynamic allocation. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">DecodedCert decodedCert; <span class="comment">// Decoded certificate object.</span></div>
<div class="line"><span class="keywordtype">byte</span>* certBuf;           <span class="comment">// DER-encoded certificate buffer.</span></div>
<div class="line">word32 certBufSz;        <span class="comment">// Size of certBuf in bytes.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#gad713e892f23ba17144e33e2992b2f41d">wc_InitDecodedCert</a>(&amp;decodedCert, certBuf, certBufSz, NULL);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6732f10a963f0f55a51e03f2ce2ed64a" title="This function parses the DER-encoded certificate saved in the DecodedCert object and populates the fi...">wc_ParseCert</a> </dd>
<dd>
<a class="el" href="#ga2be9ca18448fba206de8331c08ceb752" title="This function frees a DecodedCert that was previously initialized with wc_InitDecodedCert.">wc_FreeDecodedCert</a> </dd></dl>

</div>
</div>
<a id="gaf5c9dd81eafddb0b911192d1a559865a" name="gaf5c9dd81eafddb0b911192d1a559865a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c9dd81eafddb0b911192d1a559865a">&#9670;&#160;</a></span>wc_MakeCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_MakeCert </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>derBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>rsaKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>eccKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to make CA signed certs. Called after the subject information has been entered. This function makes an x509 Certificate v3 RSA or ECC from a cert input. It then writes this cert to derBuffer. It takes in either an rsaKey or an eccKey to generate the certificate. The certificate must be initialized with wc_InitCert before this method is called. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully making an x509 certificate from the specified input cert, returns the size of the cert generated. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the provided derBuffer is too small to store the generated certificate </dd>
<dd>
Others Additional error messages may be returned if the cert generation is not successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to an initialized cert structure </td></tr>
    <tr><td class="paramname">derBuffer</td><td>pointer to the buffer in which to hold the generated cert </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer in which to store the cert </td></tr>
    <tr><td class="paramname">rsaKey</td><td>pointer to an RsaKey structure containing the rsa key used to generate the certificate </td></tr>
    <tr><td class="paramname">eccKey</td><td>pointer to an EccKey structure containing the ecc key used to generate the certificate </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to the random number generator used to make the cert</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;myCert);</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="comment">//initialize rng;</span></div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="comment">//initialize key;</span></div>
<div class="line"><span class="keywordtype">byte</span> * derCert = malloc(FOURK_BUF);</div>
<div class="line">word32 certSz;</div>
<div class="line">certSz = <a class="code hl_function" href="#gaf5c9dd81eafddb0b911192d1a559865a">wc_MakeCert</a>(&amp;myCert, derCert, FOURK_BUF, &amp;key, NULL, &amp;rng);</div>
<div class="ttc" id="agroup__ASN_html_gaf5c9dd81eafddb0b911192d1a559865a"><div class="ttname"><a href="#gaf5c9dd81eafddb0b911192d1a559865a">wc_MakeCert</a></div><div class="ttdeci">int wc_MakeCert(Cert *cert, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey, WC_RNG *rng)</div><div class="ttdoc">Used to make CA signed certs. Called after the subject information has been entered....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e" title="This function makes a certificate signing request using the input certificate and writes the output t...">wc_MakeCertReq</a> </dd></dl>

</div>
</div>
<a id="ga1ab8dd06b7195bcfaae5fdf1d65a524e" name="ga1ab8dd06b7195bcfaae5fdf1d65a524e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e">&#9670;&#160;</a></span>wc_MakeCertReq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_MakeCertReq </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>derBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>rsaKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>eccKey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function makes a certificate signing request using the input certificate and writes the output to derBuffer. It takes in either an rsaKey or an eccKey to generate the certificate request. <a class="el" href="#ga6cb11be9830690899b9ae7f8e424c7cf" title="This function signs buffer and adds the signature to the end of buffer. It takes in a signature type....">wc_SignCert()</a> will need to be called after this function to sign the certificate request. Please see the wolfCrypt test application (./wolfcrypt/test/test.c) for an example usage of this function. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully making an X.509 certificate request from the specified input cert, returns the size of the certificate request generated. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the provided derBuffer is too small to store the generated certificate </dd>
<dd>
Other Additional error messages may be returned if the certificate request generation is not successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to an initialized cert structure </td></tr>
    <tr><td class="paramname">derBuffer</td><td>pointer to the buffer in which to hold the generated certificate request </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer in which to store the certificate request </td></tr>
    <tr><td class="paramname">rsaKey</td><td>pointer to an RsaKey structure containing the rsa key used to generate the certificate request </td></tr>
    <tr><td class="paramname">eccKey</td><td>pointer to an EccKey structure containing the ecc key used to generate the certificate request</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line">EccKey key;</div>
<div class="line"><span class="comment">//initialize key;</span></div>
<div class="line"><span class="keywordtype">byte</span>* derCert = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"> </div>
<div class="line">word32 certSz;</div>
<div class="line">certSz = <a class="code hl_function" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e">wc_MakeCertReq</a>(&amp;myCert, derCert, FOURK_BUF, NULL, &amp;key);</div>
<div class="ttc" id="agroup__ASN_html_ga1ab8dd06b7195bcfaae5fdf1d65a524e"><div class="ttname"><a href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e">wc_MakeCertReq</a></div><div class="ttdeci">int wc_MakeCertReq(Cert *cert, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey)</div><div class="ttdoc">This function makes a certificate signing request using the input certificate and writes the output t...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd></dl>

</div>
</div>
<a id="ga4d66835dcea8596ae7421ce3d46d9a46" name="ga4d66835dcea8596ae7421ce3d46d9a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d66835dcea8596ae7421ce3d46d9a46">&#9670;&#160;</a></span>wc_MakeSelfCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_MakeSelfCert </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>derBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a combination of the previous two functions, wc_MakeCert and wc_SignCert for self signing (the previous functions may be used for CA requests). It makes a certificate, and then signs it, generating a self-signed certificate. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully signing the certificate, returns the new size of the cert. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the provided buffer is too small to store the generated certificate </dd>
<dd>
Other Additional error messages may be returned if the cert generation is not successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert to make and sign </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to the buffer in which to hold the signed certificate </td></tr>
    <tr><td class="paramname">buffSz</td><td>size of the buffer in which to store the signed certificate </td></tr>
    <tr><td class="paramname">key</td><td>pointer to an RsaKey structure containing the rsa key to used to sign the certificate </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to the random number generator used to generate and sign the certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="keywordtype">byte</span>* derCert = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize myCert, derCert</span></div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="comment">// initialize key;</span></div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="comment">// initialize rng</span></div>
<div class="line"> </div>
<div class="line">word32 certSz;</div>
<div class="line">certSz = <a class="code hl_function" href="#ga4d66835dcea8596ae7421ce3d46d9a46">wc_MakeSelfCert</a>(&amp;myCert, derCert, FOURK_BUF, &amp;key, NULL, &amp;rng);</div>
<div class="ttc" id="agroup__ASN_html_ga4d66835dcea8596ae7421ce3d46d9a46"><div class="ttname"><a href="#ga4d66835dcea8596ae7421ce3d46d9a46">wc_MakeSelfCert</a></div><div class="ttdeci">int wc_MakeSelfCert(Cert *cert, byte *derBuffer, word32 derSz, RsaKey *key, WC_RNG *rng)</div><div class="ttdoc">This function is a combination of the previous two functions, wc_MakeCert and wc_SignCert for self si...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd>
<dd>
<a class="el" href="#ga6cb11be9830690899b9ae7f8e424c7cf" title="This function signs buffer and adds the signature to the end of buffer. It takes in a signature type....">wc_SignCert</a> </dd></dl>

</div>
</div>
<a id="ga6732f10a963f0f55a51e03f2ce2ed64a" name="ga6732f10a963f0f55a51e03f2ce2ed64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6732f10a963f0f55a51e03f2ce2ed64a">&#9670;&#160;</a></span>wc_ParseCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ParseCert </td>
          <td>(</td>
          <td class="paramtype">DecodedCert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>verify</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses the DER-encoded certificate saved in the DecodedCert object and populates the fields of that object. The DecodedCert must have been initialized with a prior call to wc_InitDecodedCert. This function takes an optional pointer to a CertificateManager object, which is used to populate the certificate authority information of the DecodedCert, if the CA is found in the CertificateManager. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to an initialized DecodedCert object. </td></tr>
    <tr><td class="paramname">type</td><td>Type of certificate. See the CertType enum in <a class="el" href="asn__public_8h.html">asn_public.h</a>. </td></tr>
    <tr><td class="paramname">verify</td><td>Flag that, if set, indicates the user wants to verify the validity of the certificate. </td></tr>
    <tr><td class="paramname">cm</td><td>An optional pointer to a CertificateManager. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">DecodedCert decodedCert; <span class="comment">// Decoded certificate object.</span></div>
<div class="line"><span class="keywordtype">byte</span>* certBuf;           <span class="comment">// DER-encoded certificate buffer.</span></div>
<div class="line">word32 certBufSz;        <span class="comment">// Size of certBuf in bytes.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#gad713e892f23ba17144e33e2992b2f41d">wc_InitDecodedCert</a>(&amp;decodedCert, certBuf, certBufSz, NULL);</div>
<div class="line">ret = <a class="code hl_function" href="#ga6732f10a963f0f55a51e03f2ce2ed64a">wc_ParseCert</a>(&amp;decodedCert, CERT_TYPE, NO_VERIFY, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;wc_ParseCert failed.\n&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad713e892f23ba17144e33e2992b2f41d" title="This function initializes the DecodedCert pointed to by the &quot;cert&quot; parameter. It saves the &quot;source&quot; p...">wc_InitDecodedCert</a> </dd>
<dd>
<a class="el" href="#ga2be9ca18448fba206de8331c08ceb752" title="This function frees a DecodedCert that was previously initialized with wc_InitDecodedCert.">wc_FreeDecodedCert</a> </dd></dl>

</div>
</div>
<a id="ga1881b0197dfca3b68e96147f57115bc9" name="ga1881b0197dfca3b68e96147f57115bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1881b0197dfca3b68e96147f57115bc9">&#9670;&#160;</a></span>wc_PemCertToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_PemCertToDer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>derBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a pem certificate to a der certificate, and places the resulting certificate in the derBuf buffer provided. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On success returns the size of the derBuf generated </dd>
<dd>
BUFFER_E Returned if the size of derBuf is too small to hold the certificate generated </dd>
<dd>
MEMORY_E Returned if the call to XMALLOC fails</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>path to the file containing a pem certificate to convert to a der certificate </td></tr>
    <tr><td class="paramname">derBuf</td><td>pointer to a char buffer in which to store the converted certificate </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the char buffer in which to store the converted certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> * file = “./certs/client-cert.pem”;</div>
<div class="line"><span class="keywordtype">int</span> derSz;</div>
<div class="line"><span class="keywordtype">byte</span>* der = (<span class="keywordtype">byte</span>*)<a class="code hl_function" href="group__Memory.html#ga7bcea80bb2e9107e342eb99e17238aa6">XMALLOC</a>((8*1024), NULL, DYNAMIC_TYPE_CERT);</div>
<div class="line"> </div>
<div class="line">derSz = <a class="code hl_function" href="#ga1881b0197dfca3b68e96147f57115bc9">wc_PemCertToDer</a>(file, der, (8*1024));</div>
<div class="line"><span class="keywordflow">if</span> (derSz &lt;= 0) {</div>
<div class="line">    <span class="comment">//PemCertToDer error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga1881b0197dfca3b68e96147f57115bc9"><div class="ttname"><a href="#ga1881b0197dfca3b68e96147f57115bc9">wc_PemCertToDer</a></div><div class="ttdeci">int wc_PemCertToDer(const char *fileName, unsigned char *derBuf, int derSz)</div><div class="ttdoc">This function converts a pem certificate to a der certificate, and places the resulting certificate i...</div></div>
<div class="ttc" id="agroup__Memory_html_ga7bcea80bb2e9107e342eb99e17238aa6"><div class="ttname"><a href="group__Memory.html#ga7bcea80bb2e9107e342eb99e17238aa6">XMALLOC</a></div><div class="ttdeci">void * XMALLOC(size_t n, void *heap, int type)</div><div class="ttdoc">This is not actually a function, but rather a preprocessor macro, which allows the user to substitute...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga3eacabc57785f3406b92961e20f0aec9" name="ga3eacabc57785f3406b92961e20f0aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eacabc57785f3406b92961e20f0aec9">&#9670;&#160;</a></span>wc_PemPubKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_PemPubKeyToDer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>derBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a PEM key from a file and converts to a DER encoded buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
&lt;0 Error </dd>
<dd>
SSL_BAD_FILE There is a problem with opening the file. </dd>
<dd>
MEMORY_E There is an error allocating memory for the file buffer. </dd>
<dd>
BUFFER_E derBuf is not large enough to hold the converted key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Name of the file to load. </td></tr>
    <tr><td class="paramname">derBuf</td><td>Buffer for DER encoded key. </td></tr>
    <tr><td class="paramname">derSz</td><td>Size of DER buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">char</span>* some_file = <span class="stringliteral">&quot;filename&quot;</span>;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> der[];</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga3eacabc57785f3406b92961e20f0aec9">wc_PemPubKeyToDer</a>(some_file, der, <span class="keyword">sizeof</span>(der)) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga3eacabc57785f3406b92961e20f0aec9"><div class="ttname"><a href="#ga3eacabc57785f3406b92961e20f0aec9">wc_PemPubKeyToDer</a></div><div class="ttdeci">int wc_PemPubKeyToDer(const char *fileName, unsigned char *derBuf, int derSz)</div><div class="ttdoc">Loads a PEM key from a file and converts to a DER encoded buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1accae3c1bbba637c74e025eab85c667" title="Convert a PEM encoded public key to DER. Returns the number of bytes written to the buffer or a negat...">wc_PubKeyPemToDer</a> </dd></dl>

</div>
</div>
<a id="ga1accae3c1bbba637c74e025eab85c667" name="ga1accae3c1bbba637c74e025eab85c667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1accae3c1bbba637c74e025eab85c667">&#9670;&#160;</a></span>wc_PubKeyPemToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_PubKeyPemToDer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>pem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pemSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>buffSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a PEM encoded public key to DER. Returns the number of bytes written to the buffer or a negative value for an error. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, number of bytes written. </dd>
<dd>
BAD_FUNC_ARG Returns if pem, buff, or buffSz are null </dd>
<dd>
&lt;0 An error occurred in the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem</td><td>PEM encoded key </td></tr>
    <tr><td class="paramname">pemSz</td><td>Size of pem </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to buffer for output. </td></tr>
    <tr><td class="paramname">buffSz</td><td>Size of buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> some_pem[] = { Initialize with PEM key }</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> out_buffer[1024]; <span class="comment">// Ensure buffer is large enough to fit DER</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga1accae3c1bbba637c74e025eab85c667">wc_PubKeyPemToDer</a>(some_pem, <span class="keyword">sizeof</span>(some_pem), out_buffer,</div>
<div class="line"><span class="keyword">sizeof</span>(out_buffer)) &lt; 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga1accae3c1bbba637c74e025eab85c667"><div class="ttname"><a href="#ga1accae3c1bbba637c74e025eab85c667">wc_PubKeyPemToDer</a></div><div class="ttdeci">int wc_PubKeyPemToDer(const unsigned char *pem, int pemSz, unsigned char *buff, int buffSz)</div><div class="ttdoc">Convert a PEM encoded public key to DER. Returns the number of bytes written to the buffer or a negat...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3eacabc57785f3406b92961e20f0aec9" title="Loads a PEM key from a file and converts to a DER encoded buffer.">wc_PemPubKeyToDer</a> </dd></dl>

</div>
</div>
<a id="gaae29d5e62d11ac76be5ef13dcb33d1e3" name="gaae29d5e62d11ac76be5ef13dcb33d1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae29d5e62d11ac76be5ef13dcb33d1e3">&#9670;&#160;</a></span>wc_SetAltNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetAltNames </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the alternate names for a certificate to the alternate names in the provided pem file. This is useful in the case that one wishes to secure multiple domains with the same certificate. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the alt names for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the alt names </td></tr>
    <tr><td class="paramname">file</td><td>path of the file containing the pem formatted certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga0f986e1224380c77b2458010f432e832">wc_SetSubject</a>(&amp;myCert, ”./path/to/ca-cert.pem”) != 0) {</div>
<div class="line">    <span class="comment">// error setting alt names</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga0f986e1224380c77b2458010f432e832"><div class="ttname"><a href="#ga0f986e1224380c77b2458010f432e832">wc_SetSubject</a></div><div class="ttdeci">int wc_SetSubject(Cert *cert, const char *subjectFile)</div><div class="ttdoc">This function sets the subject for a certificate to the subject in the provided pem subjectFile....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga3d2b9553cf3d0cf821a76700dd442eb9" title="This function sets the issuer for a certificate to the issuer in the provided pem issuerFile....">wc_SetIssuer</a> </dd></dl>

</div>
</div>
<a id="ga32527debb2d5c946e1516619b7c3c44c" name="ga32527debb2d5c946e1516619b7c3c44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32527debb2d5c946e1516619b7c3c44c">&#9670;&#160;</a></span>wc_SetAltNamesBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetAltNamesBuffer </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the alternate names for a certificate from the alternate names in the provided der buffer. This is useful in the case that one wishes to secure multiple domains with the same certificate. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the alternate names for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the alternate names </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the alternate names </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the alternate names</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga32527debb2d5c946e1516619b7c3c44c">wc_SetAltNamesBuffer</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga32527debb2d5c946e1516619b7c3c44c"><div class="ttname"><a href="#ga32527debb2d5c946e1516619b7c3c44c">wc_SetAltNamesBuffer</a></div><div class="ttdeci">int wc_SetAltNamesBuffer(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the alternate names for a certificate from the alternate names in the provided der...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaae29d5e62d11ac76be5ef13dcb33d1e3" title="This function sets the alternate names for a certificate to the alternate names in the provided pem f...">wc_SetAltNames</a> </dd></dl>

</div>
</div>
<a id="gae562d97bc2f35d364dffbc80b4a76a53" name="gae562d97bc2f35d364dffbc80b4a76a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae562d97bc2f35d364dffbc80b4a76a53">&#9670;&#160;</a></span>wc_SetAuthKeyId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetAuthKeyId </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set AKID from certificate file in PEM format. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Error if cert or file is null. </dd>
<dd>
MEMORY_E Error if problem allocating memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Cert struct you want to set the AKID of. </td></tr>
    <tr><td class="paramname">file</td><td>Buffer containing PEM cert file.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">char</span>* file_name = <span class="stringliteral">&quot;/path/to/file&quot;</span>;</div>
<div class="line">cert some_cert;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;some_cert);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gae562d97bc2f35d364dffbc80b4a76a53">wc_SetAuthKeyId</a>(&amp;some_cert, file_name) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gae562d97bc2f35d364dffbc80b4a76a53"><div class="ttname"><a href="#gae562d97bc2f35d364dffbc80b4a76a53">wc_SetAuthKeyId</a></div><div class="ttdeci">int wc_SetAuthKeyId(Cert *cert, const char *file)</div><div class="ttdoc">Set AKID from certificate file in PEM format.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga426dd86646159b5b06e059d634aaa250" title="Set AKID from either an RSA or ECC public key. note: Only set one of rsakey or eckey,...">wc_SetAuthKeyIdFromPublicKey</a> </dd>
<dd>
<a class="el" href="#gad4c62e9cf11e1e0ff7172e3e619f7cef" title="Set AKID from from DER encoded certificate.">wc_SetAuthKeyIdFromCert</a> </dd></dl>

</div>
</div>
<a id="gad4c62e9cf11e1e0ff7172e3e619f7cef" name="gad4c62e9cf11e1e0ff7172e3e619f7cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c62e9cf11e1e0ff7172e3e619f7cef">&#9670;&#160;</a></span>wc_SetAuthKeyIdFromCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetAuthKeyIdFromCert </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set AKID from from DER encoded certificate. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Error if any argument is null or derSz is less than 0. </dd>
<dd>
MEMORY_E Error if problem allocating memory. </dd>
<dd>
ASN_NO_SKID No subject key ID found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>The Cert struct to write to. </td></tr>
    <tr><td class="paramname">der</td><td>The DER encoded certificate buffer. </td></tr>
    <tr><td class="paramname">derSz</td><td>Size of der in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert some_cert;</div>
<div class="line"><span class="keywordtype">byte</span> some_der[] = { <span class="comment">// Initialize a DER buffer };</span></div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;some_cert);</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gad4c62e9cf11e1e0ff7172e3e619f7cef">wc_SetAuthKeyIdFromCert</a>(&amp;some_cert, some_der, <span class="keyword">sizeof</span>(some_der) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gad4c62e9cf11e1e0ff7172e3e619f7cef"><div class="ttname"><a href="#gad4c62e9cf11e1e0ff7172e3e619f7cef">wc_SetAuthKeyIdFromCert</a></div><div class="ttdeci">int wc_SetAuthKeyIdFromCert(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">Set AKID from from DER encoded certificate.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga426dd86646159b5b06e059d634aaa250" title="Set AKID from either an RSA or ECC public key. note: Only set one of rsakey or eckey,...">wc_SetAuthKeyIdFromPublicKey</a> </dd>
<dd>
<a class="el" href="#gae562d97bc2f35d364dffbc80b4a76a53" title="Set AKID from certificate file in PEM format.">wc_SetAuthKeyId</a> </dd></dl>

</div>
</div>
<a id="ga426dd86646159b5b06e059d634aaa250" name="ga426dd86646159b5b06e059d634aaa250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426dd86646159b5b06e059d634aaa250">&#9670;&#160;</a></span>wc_SetAuthKeyIdFromPublicKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetAuthKeyIdFromPublicKey </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>rsakey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>eckey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set AKID from either an RSA or ECC public key. note: Only set one of rsakey or eckey, not both. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Either cert is null or both rsakey and eckey are null. </dd>
<dd>
MEMORY_E Error allocating memory. </dd>
<dd>
PUBLIC_KEY_E Error writing to the key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to the certificate to set the SKID. </td></tr>
    <tr><td class="paramname">rsakey</td><td>Pointer to the RsaKey struct to read from. </td></tr>
    <tr><td class="paramname">eckey</td><td>Pointer to the ecc_key to read from.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line">RsaKey keypub;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__RSA.html#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;keypub, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga426dd86646159b5b06e059d634aaa250">wc_SetAuthKeyIdFromPublicKey</a>(&amp;myCert, &amp;keypub, NULL) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga426dd86646159b5b06e059d634aaa250"><div class="ttname"><a href="#ga426dd86646159b5b06e059d634aaa250">wc_SetAuthKeyIdFromPublicKey</a></div><div class="ttdeci">int wc_SetAuthKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)</div><div class="ttdoc">Set AKID from either an RSA or ECC public key. note: Only set one of rsakey or eckey,...</div></div>
<div class="ttc" id="agroup__RSA_html_ga02c9b34d405c5f1c24956ee84a843ef6"><div class="ttname"><a href="group__RSA.html#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a></div><div class="ttdeci">int wc_InitRsaKey(RsaKey *key, void *heap)</div><div class="ttdoc">This function initializes a provided RsaKey struct. It also takes in a heap identifier,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga38b456be77b159ca8238ac5897a66688" title="Set SKID from public key file in PEM format. Both arguments are required.">wc_SetSubjectKeyId</a> </dd>
<dd>
<a class="el" href="#gae562d97bc2f35d364dffbc80b4a76a53" title="Set AKID from certificate file in PEM format.">wc_SetAuthKeyId</a> </dd>
<dd>
<a class="el" href="#gad4c62e9cf11e1e0ff7172e3e619f7cef" title="Set AKID from from DER encoded certificate.">wc_SetAuthKeyIdFromCert</a> </dd></dl>

</div>
</div>
<a id="gae77c95063dd863e74255e3ca402e7534" name="gae77c95063dd863e74255e3ca402e7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77c95063dd863e74255e3ca402e7534">&#9670;&#160;</a></span>wc_SetCert_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_SetCert_Free </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function cleans up memory and resources used by the certificate structure's decoded cert cache. When WOLFSSL_CERT_GEN_CACHE is defined the decoded cert structure is cached in the certificate structure. This allows subsequent calls to certificate set functions to avoid parsing the decoded cert on each call. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
BAD_FUNC_ARG Returned if invalid pointer is passed in as argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to an uninitialized certificate information structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert cert; <span class="comment">// Initialized certificate structure</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#gae77c95063dd863e74255e3ca402e7534">wc_SetCert_Free</a>(&amp;cert);</div>
<div class="ttc" id="agroup__ASN_html_gae77c95063dd863e74255e3ca402e7534"><div class="ttname"><a href="#gae77c95063dd863e74255e3ca402e7534">wc_SetCert_Free</a></div><div class="ttdeci">void wc_SetCert_Free(Cert *cert)</div><div class="ttdoc">This function cleans up memory and resources used by the certificate structure&#39;s decoded cert cache....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad4c62e9cf11e1e0ff7172e3e619f7cef" title="Set AKID from from DER encoded certificate.">wc_SetAuthKeyIdFromCert</a> </dd>
<dd>
<a class="el" href="#gaa1eabea68369ae080e73934bc157b7f8" title="This function sets the issuer for a certificate from the issuer in the provided der buffer....">wc_SetIssuerBuffer</a> </dd>
<dd>
<a class="el" href="#ga604be3a1f3b0fdd3640eb4612bd5a19a" title="This function sets the subject for a certificate from the subject in the provided der buffer....">wc_SetSubjectBuffer</a> </dd>
<dd>
<a class="el" href="#gaac9a70c1061eae1a8ce862a4cf5be0d3" title="This function sets the raw subject for a certificate from the subject in the provided der buffer....">wc_SetSubjectRaw</a> </dd>
<dd>
<a class="el" href="#gab93f6254e2dbe2bfb5b397b83fa079e5" title="This function sets the raw issuer for a certificate from the issuer in the provided der buffer....">wc_SetIssuerRaw</a> </dd>
<dd>
<a class="el" href="#ga32527debb2d5c946e1516619b7c3c44c" title="This function sets the alternate names for a certificate from the alternate names in the provided der...">wc_SetAltNamesBuffer</a> </dd>
<dd>
<a class="el" href="#gae5b1f5d1fea568ef4b3e68e86e11ddf9" title="This function sets the dates for a certificate from the date range in the provided der buffer....">wc_SetDatesBuffer</a> </dd></dl>

</div>
</div>
<a id="gaa32299ffae69195d68f2020c582bc317" name="gaa32299ffae69195d68f2020c582bc317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32299ffae69195d68f2020c582bc317">&#9670;&#160;</a></span>wc_SetCustomExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetCustomExtension </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>critical</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>oid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function injects a custom extension in to an X.509 certificate. note: The content at the address pointed to by any of the parameters that are pointers must not be modified until the certificate is generated and you have the der output. This function does NOT copy the contents to another buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to an initialized DecodedCert object. </td></tr>
    <tr><td class="paramname">critical</td><td>If 0, the extension will not be marked critical, otherwise it will be marked critical. </td></tr>
    <tr><td class="paramname">oid</td><td>Dot separated oid as a string. For example "1.2.840.10045.3.1.7" </td></tr>
    <tr><td class="paramname">der</td><td>The der encoding of the content of the extension. </td></tr>
    <tr><td class="paramname">derSz</td><td>The size in bytes of the der encoding.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">Cert newCert;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;newCert);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Code to setup subject, public key, issuer, and other things goes here.</span></div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaa32299ffae69195d68f2020c582bc317">wc_SetCustomExtension</a>(&amp;newCert, 1, <span class="stringliteral">&quot;1.2.3.4.5&quot;</span>,</div>
<div class="line">          (<span class="keyword">const</span> <span class="keywordtype">byte</span> *)<span class="stringliteral">&quot;This is a critical extension&quot;</span>, 28);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// Failed to set the extension.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaa32299ffae69195d68f2020c582bc317">wc_SetCustomExtension</a>(&amp;newCert, 0, <span class="stringliteral">&quot;1.2.3.4.6&quot;</span>,</div>
<div class="line">          (<span class="keyword">const</span> <span class="keywordtype">byte</span> *)<span class="stringliteral">&quot;This is NOT a critical extension&quot;</span>, 32)</div>
<div class="line">if (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// Failed to set the extension.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Code to sign the certificate and then write it out goes here.</span></div>
<div class="ttc" id="agroup__ASN_html_gaa32299ffae69195d68f2020c582bc317"><div class="ttname"><a href="#gaa32299ffae69195d68f2020c582bc317">wc_SetCustomExtension</a></div><div class="ttdeci">int wc_SetCustomExtension(Cert *cert, int critical, const char *oid, const byte *der, word32 derSz)</div><div class="ttdoc">This function injects a custom extension in to an X.509 certificate. note: The content at the address...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga8d65aa447d6d58a49e20ecc1303e5bb2" title="This function registers a callback that will be used anytime wolfSSL encounters an unknown X....">wc_SetUnknownExtCallback</a> </dd></dl>

</div>
</div>
<a id="gae5b1f5d1fea568ef4b3e68e86e11ddf9" name="gae5b1f5d1fea568ef4b3e68e86e11ddf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b1f5d1fea568ef4b3e68e86e11ddf9">&#9670;&#160;</a></span>wc_SetDatesBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetDatesBuffer </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the dates for a certificate from the date range in the provided der buffer. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the dates for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the dates </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the date range </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the date range</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gae5b1f5d1fea568ef4b3e68e86e11ddf9">wc_SetDatesBuffer</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gae5b1f5d1fea568ef4b3e68e86e11ddf9"><div class="ttname"><a href="#gae5b1f5d1fea568ef4b3e68e86e11ddf9">wc_SetDatesBuffer</a></div><div class="ttdeci">int wc_SetDatesBuffer(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the dates for a certificate from the date range in the provided der buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd></dl>

</div>
</div>
<a id="ga3d2b9553cf3d0cf821a76700dd442eb9" name="ga3d2b9553cf3d0cf821a76700dd442eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2b9553cf3d0cf821a76700dd442eb9">&#9670;&#160;</a></span>wc_SetIssuer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetIssuer </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>issuerFile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the issuer for a certificate to the issuer in the provided pem issuerFile. It also changes the certificate’s self-signed attribute to false. The issuer specified in issuerFile is verified prior to setting the cert issuer. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the issuer for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the issuer </td></tr>
    <tr><td class="paramname">issuerFile</td><td>path of the file containing the pem formatted certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga3d2b9553cf3d0cf821a76700dd442eb9">wc_SetIssuer</a>(&amp;myCert, ”./path/to/ca-cert.pem”) != 0) {</div>
<div class="line">    <span class="comment">// error setting issuer</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga3d2b9553cf3d0cf821a76700dd442eb9"><div class="ttname"><a href="#ga3d2b9553cf3d0cf821a76700dd442eb9">wc_SetIssuer</a></div><div class="ttdeci">int wc_SetIssuer(Cert *cert, const char *issuerFile)</div><div class="ttdoc">This function sets the issuer for a certificate to the issuer in the provided pem issuerFile....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga0f986e1224380c77b2458010f432e832" title="This function sets the subject for a certificate to the subject in the provided pem subjectFile....">wc_SetSubject</a> </dd>
<dd>
<a class="el" href="#gaa1eabea68369ae080e73934bc157b7f8" title="This function sets the issuer for a certificate from the issuer in the provided der buffer....">wc_SetIssuerBuffer</a> </dd></dl>

</div>
</div>
<a id="gaa1eabea68369ae080e73934bc157b7f8" name="gaa1eabea68369ae080e73934bc157b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1eabea68369ae080e73934bc157b7f8">&#9670;&#160;</a></span>wc_SetIssuerBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetIssuerBuffer </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the issuer for a certificate from the issuer in the provided der buffer. It also changes the certificate’s self-signed attribute to false. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the issuer for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the issuer </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the issuer </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the issuer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gaa1eabea68369ae080e73934bc157b7f8">wc_SetIssuerBuffer</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting issuer</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gaa1eabea68369ae080e73934bc157b7f8"><div class="ttname"><a href="#gaa1eabea68369ae080e73934bc157b7f8">wc_SetIssuerBuffer</a></div><div class="ttdeci">int wc_SetIssuerBuffer(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the issuer for a certificate from the issuer in the provided der buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga3d2b9553cf3d0cf821a76700dd442eb9" title="This function sets the issuer for a certificate to the issuer in the provided pem issuerFile....">wc_SetIssuer</a> </dd></dl>

</div>
</div>
<a id="gab93f6254e2dbe2bfb5b397b83fa079e5" name="gab93f6254e2dbe2bfb5b397b83fa079e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93f6254e2dbe2bfb5b397b83fa079e5">&#9670;&#160;</a></span>wc_SetIssuerRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetIssuerRaw </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the raw issuer for a certificate from the issuer in the provided der buffer. This method is used to set the raw issuer field prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the issuer for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the raw issuer </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the subject </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the subject</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gab93f6254e2dbe2bfb5b397b83fa079e5">wc_SetIssuerRaw</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gab93f6254e2dbe2bfb5b397b83fa079e5"><div class="ttname"><a href="#gab93f6254e2dbe2bfb5b397b83fa079e5">wc_SetIssuerRaw</a></div><div class="ttdeci">int wc_SetIssuerRaw(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the raw issuer for a certificate from the issuer in the provided der buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga3d2b9553cf3d0cf821a76700dd442eb9" title="This function sets the issuer for a certificate to the issuer in the provided pem issuerFile....">wc_SetIssuer</a> </dd></dl>

</div>
</div>
<a id="ga0f986e1224380c77b2458010f432e832" name="ga0f986e1224380c77b2458010f432e832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f986e1224380c77b2458010f432e832">&#9670;&#160;</a></span>wc_SetSubject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetSubject </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>subjectFile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the subject for a certificate to the subject in the provided pem subjectFile. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the issuer for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the issuer </td></tr>
    <tr><td class="paramname">subjectFile</td><td>path of the file containing the pem formatted certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga0f986e1224380c77b2458010f432e832">wc_SetSubject</a>(&amp;myCert, ”./path/to/ca-cert.pem”) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga3d2b9553cf3d0cf821a76700dd442eb9" title="This function sets the issuer for a certificate to the issuer in the provided pem issuerFile....">wc_SetIssuer</a> </dd></dl>

</div>
</div>
<a id="ga604be3a1f3b0fdd3640eb4612bd5a19a" name="ga604be3a1f3b0fdd3640eb4612bd5a19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604be3a1f3b0fdd3640eb4612bd5a19a">&#9670;&#160;</a></span>wc_SetSubjectBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetSubjectBuffer </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the subject for a certificate from the subject in the provided der buffer. This method is used to set fields prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the subject for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the subject </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the subject </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the subject</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga604be3a1f3b0fdd3640eb4612bd5a19a">wc_SetSubjectBuffer</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga604be3a1f3b0fdd3640eb4612bd5a19a"><div class="ttname"><a href="#ga604be3a1f3b0fdd3640eb4612bd5a19a">wc_SetSubjectBuffer</a></div><div class="ttdeci">int wc_SetSubjectBuffer(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the subject for a certificate from the subject in the provided der buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga0f986e1224380c77b2458010f432e832" title="This function sets the subject for a certificate to the subject in the provided pem subjectFile....">wc_SetSubject</a> </dd></dl>

</div>
</div>
<a id="ga38b456be77b159ca8238ac5897a66688" name="ga38b456be77b159ca8238ac5897a66688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b456be77b159ca8238ac5897a66688">&#9670;&#160;</a></span>wc_SetSubjectKeyId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetSubjectKeyId </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SKID from public key file in PEM format. Both arguments are required. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returns if cert or file is null. </dd>
<dd>
MEMORY_E Returns if there is a problem allocating memory for key. </dd>
<dd>
PUBLIC_KEY_E Returns if there is an error decoding the public key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Cert structure to set the SKID of. </td></tr>
    <tr><td class="paramname">file</td><td>Contains the PEM encoded file.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* file_name = <span class="stringliteral">&quot;path/to/file&quot;</span>;</div>
<div class="line">Cert some_cert;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;some_cert);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga38b456be77b159ca8238ac5897a66688">wc_SetSubjectKeyId</a>(&amp;some_cert, file_name) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga38b456be77b159ca8238ac5897a66688"><div class="ttname"><a href="#ga38b456be77b159ca8238ac5897a66688">wc_SetSubjectKeyId</a></div><div class="ttdeci">int wc_SetSubjectKeyId(Cert *cert, const char *file)</div><div class="ttdoc">Set SKID from public key file in PEM format. Both arguments are required.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga74ea06ed118ab20c22bfcbb8d4c756fe" title="Set SKID from RSA or ECC public key.">wc_SetSubjectKeyIdFromPublicKey</a> </dd></dl>

</div>
</div>
<a id="ga74ea06ed118ab20c22bfcbb8d4c756fe" name="ga74ea06ed118ab20c22bfcbb8d4c756fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ea06ed118ab20c22bfcbb8d4c756fe">&#9670;&#160;</a></span>wc_SetSubjectKeyIdFromPublicKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetSubjectKeyIdFromPublicKey </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>rsakey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>eckey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SKID from RSA or ECC public key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned if cert or rsakey and eckey are null. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory. </dd>
<dd>
PUBLIC_KEY_E Returned if there is an error getting the public key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to a Cert structure to be used. </td></tr>
    <tr><td class="paramname">rsakey</td><td>Pointer to an RsaKey structure </td></tr>
    <tr><td class="paramname">eckey</td><td>Pointer to an ecc_key structure</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert some_cert;</div>
<div class="line">RsaKey some_key;</div>
<div class="line"><a class="code hl_function" href="#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;some_cert);</div>
<div class="line"><a class="code hl_function" href="group__RSA.html#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;some_key);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga74ea06ed118ab20c22bfcbb8d4c756fe">wc_SetSubjectKeyIdFromPublicKey</a>(&amp;some_cert,&amp;some_key, NULL) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga74ea06ed118ab20c22bfcbb8d4c756fe"><div class="ttname"><a href="#ga74ea06ed118ab20c22bfcbb8d4c756fe">wc_SetSubjectKeyIdFromPublicKey</a></div><div class="ttdeci">int wc_SetSubjectKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)</div><div class="ttdoc">Set SKID from RSA or ECC public key.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga38b456be77b159ca8238ac5897a66688" title="Set SKID from public key file in PEM format. Both arguments are required.">wc_SetSubjectKeyId</a> </dd></dl>

</div>
</div>
<a id="gaac9a70c1061eae1a8ce862a4cf5be0d3" name="gaac9a70c1061eae1a8ce862a4cf5be0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac9a70c1061eae1a8ce862a4cf5be0d3">&#9670;&#160;</a></span>wc_SetSubjectRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetSubjectRaw </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the raw subject for a certificate from the subject in the provided der buffer. This method is used to set the raw subject field prior to signing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully setting the subject for the certificate </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the cert header file </dd>
<dd>
ASN_OBJECT_ID_E Returned if there is an error parsing the encryption type from the cert </dd>
<dd>
ASN_EXPECT_0_E Returned if there is a formatting error in the encryption specification of the cert file </dd>
<dd>
ASN_BEFORE_DATE_E Returned if the date is before the certificate start date </dd>
<dd>
ASN_AFTER_DATE_E Returned if the date is after the certificate expiration date </dd>
<dd>
ASN_BITSTR_E Returned if there is an error parsing a bit string from the certificate </dd>
<dd>
ECC_CURVE_OID_E Returned if there is an error parsing the ECC key from the certificate </dd>
<dd>
ASN_UNKNOWN_OID_E Returned if the certificate is using an unknown key object id </dd>
<dd>
ASN_VERSION_E Returned if the ALLOW_V1_EXTENSIONS option is not defined and the certificate is a V1 or V2 certificate </dd>
<dd>
BAD_FUNC_ARG Returned if there is an error processing the certificate extension </dd>
<dd>
ASN_CRIT_EXT_E Returned if an unfamiliar critical extension is encountered in processing the certificate </dd>
<dd>
ASN_SIG_OID_E Returned if the signature encryption type is not the same as the encryption type of the certificate in the provided file </dd>
<dd>
ASN_SIG_CONFIRM_E Returned if confirming the certification signature fails </dd>
<dd>
ASN_NAME_INVALID_E Returned if the certificate’s name is not permitted by the CA name constraints </dd>
<dd>
ASN_NO_SIGNER_E Returned if there is no CA signer to verify the certificate’s authenticity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>pointer to the cert for which to set the raw subject </td></tr>
    <tr><td class="paramname">der</td><td>pointer to the buffer containing the der formatted certificate from which to grab the subject </td></tr>
    <tr><td class="paramname">derSz</td><td>size of the buffer containing the der formatted certificate from which to grab the subject</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="comment">// initialize myCert</span></div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line">der = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize der</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gaac9a70c1061eae1a8ce862a4cf5be0d3">wc_SetSubjectRaw</a>(&amp;myCert, der, FOURK_BUF) != 0) {</div>
<div class="line">    <span class="comment">// error setting subject</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gaac9a70c1061eae1a8ce862a4cf5be0d3"><div class="ttname"><a href="#gaac9a70c1061eae1a8ce862a4cf5be0d3">wc_SetSubjectRaw</a></div><div class="ttdeci">int wc_SetSubjectRaw(Cert *cert, const byte *der, int derSz)</div><div class="ttdoc">This function sets the raw subject for a certificate from the subject in the provided der buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga0f986e1224380c77b2458010f432e832" title="This function sets the subject for a certificate to the subject in the provided pem subjectFile....">wc_SetSubject</a> </dd></dl>

</div>
</div>
<a id="ga01fcb66e496dae631b667608beb8229b" name="ga01fcb66e496dae631b667608beb8229b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01fcb66e496dae631b667608beb8229b">&#9670;&#160;</a></span>wc_SetTimeCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetTimeCb </td>
          <td>(</td>
          <td class="paramtype">wc_time_cb</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a time callback that will be used anytime wolfSSL needs to get the current time. The prototype of the callback should be the same as the "time" function from the C standard library. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function to register as the time callback.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="comment">// Time callback prototype</span></div>
<div class="line">time_t my_time_cb(time_t* t);</div>
<div class="line"><span class="comment">// Register it</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga01fcb66e496dae631b667608beb8229b">wc_SetTimeCb</a>(my_time_cb);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// failed to set time callback</span></div>
<div class="line">}</div>
<div class="line">time_t my_time_cb(time_t* t)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// custom time function</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga01fcb66e496dae631b667608beb8229b"><div class="ttname"><a href="#ga01fcb66e496dae631b667608beb8229b">wc_SetTimeCb</a></div><div class="ttdeci">int wc_SetTimeCb(wc_time_cb f)</div><div class="ttdoc">This function registers a time callback that will be used anytime wolfSSL needs to get the current ti...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga606ed4a08b474311d46273ce3b69b45d" title="This function gets the current time. By default, it uses the XTIME macro, which varies between platfo...">wc_Time</a> </dd></dl>

</div>
</div>
<a id="ga8d65aa447d6d58a49e20ecc1303e5bb2" name="ga8d65aa447d6d58a49e20ecc1303e5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d65aa447d6d58a49e20ecc1303e5bb2">&#9670;&#160;</a></span>wc_SetUnknownExtCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetUnknownExtCallback </td>
          <td>(</td>
          <td class="paramtype">DecodedCert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_UnknownExtCallback</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a callback that will be used anytime wolfSSL encounters an unknown X.509 extension in a certificate while parsing a certificate. The prototype of the callback should be: </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
Other negative values on failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>the DecodedCert struct that is to be associated with this callback. </td></tr>
    <tr><td class="paramname">cb</td><td>function to register as the time callback.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="comment">// Unknown extension callback prototype</span></div>
<div class="line"><span class="keywordtype">int</span> myUnknownExtCallback(<span class="keyword">const</span> word16* oid, word32 oidSz, <span class="keywordtype">int</span> crit,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* der, word32 derSz);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register it</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga8d65aa447d6d58a49e20ecc1303e5bb2">wc_SetUnknownExtCallback</a>(cert, myUnknownExtCallback);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// failed to set the callback</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// oid: Array of integers that are the dot separated values in an oid.</span></div>
<div class="line"><span class="comment">// oidSz: Number of values in oid.</span></div>
<div class="line"><span class="comment">// crit: Whether the extension was mark critical.</span></div>
<div class="line"><span class="comment">// der: The der encoding of the content of the extension.</span></div>
<div class="line"><span class="comment">// derSz: The size in bytes of the der encoding.</span></div>
<div class="line"><span class="keywordtype">int</span> myCustomExtCallback(<span class="keyword">const</span> word16* oid, word32 oidSz, <span class="keywordtype">int</span> crit,</div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* der, word32 derSz) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Logic to parse extension goes here.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// NOTE: by returning zero, we are accepting this extension and</span></div>
<div class="line">    <span class="comment">// informing wolfSSL that it is acceptable. If you find an extension</span></div>
<div class="line">    <span class="comment">// that you do not find acceptable, you should return an error. The</span></div>
<div class="line">    <span class="comment">// standard behavior upon encountering an unknown extension with the</span></div>
<div class="line">    <span class="comment">// critical flag set is to return ASN_CRIT_EXT_E. For the sake of</span></div>
<div class="line">    <span class="comment">// brevity, this example is always accepting every extension; you</span></div>
<div class="line">    <span class="comment">// should use different logic.</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_ga8d65aa447d6d58a49e20ecc1303e5bb2"><div class="ttname"><a href="#ga8d65aa447d6d58a49e20ecc1303e5bb2">wc_SetUnknownExtCallback</a></div><div class="ttdeci">int wc_SetUnknownExtCallback(DecodedCert *cert, wc_UnknownExtCallback cb)</div><div class="ttdoc">This function registers a callback that will be used anytime wolfSSL encounters an unknown X....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>ParseCert </dd>
<dd>
<a class="el" href="#gaa32299ffae69195d68f2020c582bc317" title="This function injects a custom extension in to an X.509 certificate. note: The content at the address...">wc_SetCustomExtension</a> </dd></dl>

</div>
</div>
<a id="ga6cb11be9830690899b9ae7f8e424c7cf" name="ga6cb11be9830690899b9ae7f8e424c7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb11be9830690899b9ae7f8e424c7cf">&#9670;&#160;</a></span>wc_SignCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SignCert </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>requestSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sigType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>derBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>derSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>rsaKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>eccKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs buffer and adds the signature to the end of buffer. It takes in a signature type. Must be called after <a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert()</a> or <a class="el" href="#ga1ab8dd06b7195bcfaae5fdf1d65a524e" title="This function makes a certificate signing request using the input certificate and writes the output t...">wc_MakeCertReq()</a> if creating a CA signed cert. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully signing the certificate, returns the new size of the cert (including signature). </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
BUFFER_E Returned if the provided buffer is too small to store the generated certificate </dd>
<dd>
Other Additional error messages may be returned if the cert generation is not successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestSz</td><td>the size of the certificate body we’re requesting to have signed </td></tr>
    <tr><td class="paramname">sType</td><td>Type of signature to create. Valid options are: CTC_MD5wRSA, CTC_SHAwRSA, CTC_SHAwECDSA, CTC_SHA256wECDSA, and CTC_SHA256wRSA </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to the buffer containing the certificate to be signed. On success: will hold the newly signed certificate </td></tr>
    <tr><td class="paramname">buffSz</td><td>the (total) size of the buffer in which to store the newly signed certificate </td></tr>
    <tr><td class="paramname">rsaKey</td><td>pointer to an RsaKey structure containing the rsa key to used to sign the certificate </td></tr>
    <tr><td class="paramname">eccKey</td><td>pointer to an EccKey structure containing the ecc key to used to sign the certificate </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to the random number generator used to sign the certificate</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert myCert;</div>
<div class="line"><span class="keywordtype">byte</span>* derCert = (<span class="keywordtype">byte</span>*)malloc(FOURK_BUF);</div>
<div class="line"><span class="comment">// initialize myCert, derCert</span></div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="comment">// initialize key;</span></div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="comment">// initialize rng</span></div>
<div class="line"> </div>
<div class="line">word32 certSz;</div>
<div class="line">certSz = <a class="code hl_function" href="#ga6cb11be9830690899b9ae7f8e424c7cf">wc_SignCert</a>(myCert.bodySz, myCert.sigType,derCert,FOURK_BUF,</div>
<div class="line">&amp;key, NULL,</div>
<div class="line">&amp;rng);</div>
<div class="ttc" id="agroup__ASN_html_ga6cb11be9830690899b9ae7f8e424c7cf"><div class="ttname"><a href="#ga6cb11be9830690899b9ae7f8e424c7cf">wc_SignCert</a></div><div class="ttdeci">int wc_SignCert(int requestSz, int sigType, byte *derBuffer, word32 derSz, RsaKey *rsaKey, ecc_key *eccKey, WC_RNG *rng)</div><div class="ttdoc">This function signs buffer and adds the signature to the end of buffer. It takes in a signature type....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#gaf5c9dd81eafddb0b911192d1a559865a" title="Used to make CA signed certs. Called after the subject information has been entered....">wc_MakeCert</a> </dd></dl>

</div>
</div>
<a id="ga606ed4a08b474311d46273ce3b69b45d" name="ga606ed4a08b474311d46273ce3b69b45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606ed4a08b474311d46273ce3b69b45d">&#9670;&#160;</a></span>wc_Time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t wc_Time </td>
          <td>(</td>
          <td class="paramtype">time_t *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current time. By default, it uses the XTIME macro, which varies between platforms. The user can use a function of their choosing instead via the wc_SetTimeCb function. </p>
<dl class="section return"><dt>Returns</dt><dd>Time Current time returned on success.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Optional time_t pointer to populate with current time.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">time_t currentTime = 0;</div>
<div class="line">currentTime = <a class="code hl_function" href="#ga606ed4a08b474311d46273ce3b69b45d">wc_Time</a>(NULL);</div>
<div class="line"><a class="code hl_function" href="#ga606ed4a08b474311d46273ce3b69b45d">wc_Time</a>(&amp;currentTime);</div>
<div class="ttc" id="agroup__ASN_html_ga606ed4a08b474311d46273ce3b69b45d"><div class="ttname"><a href="#ga606ed4a08b474311d46273ce3b69b45d">wc_Time</a></div><div class="ttdeci">time_t wc_Time(time_t *t)</div><div class="ttdoc">This function gets the current time. By default, it uses the XTIME macro, which varies between platfo...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga01fcb66e496dae631b667608beb8229b" title="This function registers a time callback that will be used anytime wolfSSL needs to get the current ti...">wc_SetTimeCb</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
