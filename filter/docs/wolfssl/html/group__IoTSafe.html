<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: IoT-Safe Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">IoT-Safe Module </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6eef6129679bffcce2eb294c8c075da7" id="r_ga6eef6129679bffcce2eb294c8c075da7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6eef6129679bffcce2eb294c8c075da7">wolfSSL_CTX_iotsafe_enable</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga6eef6129679bffcce2eb294c8c075da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the IoT-Safe support on the given context.  <br /></td></tr>
<tr class="memitem:ga70736338743dd73e0298461c521f150f" id="r_ga70736338743dd73e0298461c521f150f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga70736338743dd73e0298461c521f150f">wolfSSL_iotsafe_on</a> (WOLFSSL *ssl, byte privkey_id, byte ecdh_keypair_slot, byte peer_pubkey_slot, byte peer_cert_slot)</td></tr>
<tr class="memdesc:ga70736338743dd73e0298461c521f150f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function connects the IoT-Safe TLS callbacks to the given SSL session.  <br /></td></tr>
<tr class="memitem:ga3beca4356267e5c0442e89b0d29515fc" id="r_ga3beca4356267e5c0442e89b0d29515fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3beca4356267e5c0442e89b0d29515fc">wolfSSL_iotsafe_on_ex</a> (WOLFSSL *ssl, byte *privkey_id, byte *ecdh_keypair_slot, byte *peer_pubkey_slot, byte *peer_cert_slot, word16 id_size)</td></tr>
<tr class="memdesc:ga3beca4356267e5c0442e89b0d29515fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function connects the IoT-Safe TLS callbacks to the given SSL session. This is equivalent to <a class="el" href="#ga70736338743dd73e0298461c521f150f">wolfSSL_iotsafe_on</a> except that the IDs for the IoT-SAFE slots can be passed by reference, and the length of the ID fields can be specified via the parameter "id_size".  <br /></td></tr>
<tr class="memitem:ga44163df13fb7e31f998e9827cdd57894" id="r_ga44163df13fb7e31f998e9827cdd57894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga44163df13fb7e31f998e9827cdd57894">wolfIoTSafe_SetCSIM_read_cb</a> (wolfSSL_IOTSafe_CSIM_read_cb rf)</td></tr>
<tr class="memdesc:ga44163df13fb7e31f998e9827cdd57894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates a read callback for the AT+CSIM commands. This input function is usually associated to a read event of a UART channel communicating with the modem. The read callback associated is global and changes for all the contexts that use IoT-safe support at the same time.  <br /></td></tr>
<tr class="memitem:gaa8d75a901881864857d4b802e8a49ba3" id="r_gaa8d75a901881864857d4b802e8a49ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8d75a901881864857d4b802e8a49ba3">wolfIoTSafe_SetCSIM_write_cb</a> (wolfSSL_IOTSafe_CSIM_write_cb wf)</td></tr>
<tr class="memdesc:gaa8d75a901881864857d4b802e8a49ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates a write callback for the AT+CSIM commands. This output function is usually associated to a write event on a UART channel communicating with the modem. The write callback associated is global and changes for all the contexts that use IoT-safe support at the same time.  <br /></td></tr>
<tr class="memitem:gaecea4a8c6bd52af24caf937d7f71331c" id="r_gaecea4a8c6bd52af24caf937d7f71331c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaecea4a8c6bd52af24caf937d7f71331c">wolfIoTSafe_GetRandom</a> (unsigned char *out, word32 sz)</td></tr>
<tr class="memdesc:gaecea4a8c6bd52af24caf937d7f71331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random buffer of given size, using the IoT-Safe function GetRandom. This function is automatically used by the wolfCrypt RNG object.  <br /></td></tr>
<tr class="memitem:gaffd32db718dcc77934345c2413f4c35b" id="r_gaffd32db718dcc77934345c2413f4c35b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffd32db718dcc77934345c2413f4c35b">wolfIoTSafe_GetCert</a> (uint8_t id, unsigned char *output, unsigned long sz)</td></tr>
<tr class="memdesc:gaffd32db718dcc77934345c2413f4c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory. Works with one-byte file ID field.  <br /></td></tr>
<tr class="memitem:ga9806038ab5de14c824deae33bb8c01c8" id="r_ga9806038ab5de14c824deae33bb8c01c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9806038ab5de14c824deae33bb8c01c8">wolfIoTSafe_GetCert_ex</a> (uint8_t *id, uint16_t id_sz, unsigned char *output, unsigned long sz)</td></tr>
<tr class="memdesc:ga9806038ab5de14c824deae33bb8c01c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory. Equivalent to <a class="el" href="#gaffd32db718dcc77934345c2413f4c35b">wolfIoTSafe_GetCert</a>, except that it can be invoked with a file ID of two or more bytes.  <br /></td></tr>
<tr class="memitem:gab7e739d7ce0c943d1b615a42737b0c23" id="r_gab7e739d7ce0c943d1b615a42737b0c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23">wc_iotsafe_ecc_import_public</a> (ecc_key *key, byte key_id)</td></tr>
<tr class="memdesc:gab7e739d7ce0c943d1b615a42737b0c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import an ECC 256-bit public key, stored in the IoT-Safe applet, into an ecc_key object.  <br /></td></tr>
<tr class="memitem:ga86a293394d882a1226d744c114353b0c" id="r_ga86a293394d882a1226d744c114353b0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga86a293394d882a1226d744c114353b0c">wc_iotsafe_ecc_export_public</a> (ecc_key *key, byte key_id)</td></tr>
<tr class="memdesc:ga86a293394d882a1226d744c114353b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe applet.  <br /></td></tr>
<tr class="memitem:gaf4aaa4e97066a606092a4978b1a96122" id="r_gaf4aaa4e97066a606092a4978b1a96122"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4aaa4e97066a606092a4978b1a96122">wc_iotsafe_ecc_import_public_ex</a> (ecc_key *key, byte *key_id, word16 id_size)</td></tr>
<tr class="memdesc:gaf4aaa4e97066a606092a4978b1a96122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe applet. Equivalent to <a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23">wc_iotsafe_ecc_import_public</a>, except that it can be invoked with a key ID of two or more bytes.  <br /></td></tr>
<tr class="memitem:gac94250323984ce9d24fcc7dfe92905be" id="r_gac94250323984ce9d24fcc7dfe92905be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac94250323984ce9d24fcc7dfe92905be">wc_iotsafe_ecc_export_private</a> (ecc_key *key, byte key_id)</td></tr>
<tr class="memdesc:gac94250323984ce9d24fcc7dfe92905be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe applet.  <br /></td></tr>
<tr class="memitem:ga3c02c8dd0b44f96fe7198c4201ab7460" id="r_ga3c02c8dd0b44f96fe7198c4201ab7460"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c02c8dd0b44f96fe7198c4201ab7460">wc_iotsafe_ecc_export_private_ex</a> (ecc_key *key, byte *key_id, word16 id_size)</td></tr>
<tr class="memdesc:ga3c02c8dd0b44f96fe7198c4201ab7460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe applet. Equivalent to <a class="el" href="#gac94250323984ce9d24fcc7dfe92905be">wc_iotsafe_ecc_export_private</a>, except that it can be invoked with a key ID of two or more bytes.  <br /></td></tr>
<tr class="memitem:gaadd1681d49fe6e8ecf07fd7bd5b320e6" id="r_gaadd1681d49fe6e8ecf07fd7bd5b320e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6">wc_iotsafe_ecc_sign_hash</a> (byte *in, word32 inlen, byte *out, word32 *outlen, byte key_id)</td></tr>
<tr class="memdesc:gaadd1681d49fe6e8ecf07fd7bd5b320e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned, in the IoT-Safe applet.  <br /></td></tr>
<tr class="memitem:ga91fbd4d4022a37d9d3f694f5310356e0" id="r_ga91fbd4d4022a37d9d3f694f5310356e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91fbd4d4022a37d9d3f694f5310356e0">wc_iotsafe_ecc_sign_hash_ex</a> (byte *in, word32 inlen, byte *out, word32 *outlen, byte *key_id, word16 id_size)</td></tr>
<tr class="memdesc:ga91fbd4d4022a37d9d3f694f5310356e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned, in the IoT-Safe applet. Equivalent to <a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6">wc_iotsafe_ecc_sign_hash</a>, except that it can be invoked with a key ID of two or more bytes.  <br /></td></tr>
<tr class="memitem:ga6fd2aeede427f8df6d193f0a21dc614b" id="r_ga6fd2aeede427f8df6d193f0a21dc614b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b">wc_iotsafe_ecc_verify_hash</a> (byte *sig, word32 siglen, byte *hash, word32 hashlen, int *res, byte key_id)</td></tr>
<tr class="memdesc:ga6fd2aeede427f8df6d193f0a21dc614b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an ECC signature against a pre-computed HASH, using a public key previously stored, or pre-provisioned, in the IoT-Safe applet. Result is written to res. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use res.  <br /></td></tr>
<tr class="memitem:ga68e3fb2f5072122536ead39523370521" id="r_ga68e3fb2f5072122536ead39523370521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga68e3fb2f5072122536ead39523370521">wc_iotsafe_ecc_verify_hash_ex</a> (byte *sig, word32 siglen, byte *hash, word32 hashlen, int *res, byte *key_id, word16 id_size)</td></tr>
<tr class="memdesc:ga68e3fb2f5072122536ead39523370521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an ECC signature against a pre-computed HASH, using a public key previously stored, or pre-provisioned, in the IoT-Safe applet. Result is written to res. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use res. Equivalent to <a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b">wc_iotsafe_ecc_verify_hash</a>, except that it can be invoked with a key ID of two or more bytes.  <br /></td></tr>
<tr class="memitem:gac4ae5e67687a25a7419e43f9c2617249" id="r_gac4ae5e67687a25a7419e43f9c2617249"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249">wc_iotsafe_ecc_gen_k</a> (byte key_id)</td></tr>
<tr class="memdesc:gac4ae5e67687a25a7419e43f9c2617249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>IoT-Safe (IoT-SIM Applet For Secure End-2-End Communication) is a technology that leverage the SIM as robust, scalable and standardized hardware Root of Trust to protect data communication.</p>
<p>IoT-Safe SSL sessions use the SIM as Hardware Security Module, offloading all the crypto public key operations and reducing the attack surface by restricting access to certificate and keys to the SIM.</p>
<p>IoT-Safe support can be enabled on an existing WOLFSSL_CTX context, using <a class="el" href="#ga6eef6129679bffcce2eb294c8c075da7" title="This function enables the IoT-Safe support on the given context.">wolfSSL_CTX_iotsafe_enable()</a>.<br  />
Session created within the context can set the parameters for IoT-Safe key and files usage, and enable the public keys callback, with <a class="el" href="#ga70736338743dd73e0298461c521f150f" title="This function connects the IoT-Safe TLS callbacks to the given SSL session.">wolfSSL_iotsafe_on()</a>.</p>
<p>If compiled in, the module supports IoT-Safe random number generator as source of entropy for wolfCrypt. </p>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gac94250323984ce9d24fcc7dfe92905be" name="gac94250323984ce9d24fcc7dfe92905be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac94250323984ce9d24fcc7dfe92905be">&#9670;&#160;</a></span>wc_iotsafe_ecc_export_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_export_private </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe applet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the ecc_key object containing the key to be exported </td></tr>
    <tr><td class="paramname">id</td><td>The key id in the IoT-Safe applet where the private key will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3c02c8dd0b44f96fe7198c4201ab7460" title="Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe apple...">wc_iotsafe_ecc_export_private_ex</a> </dd>
<dd>
<a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23" title="Import an ECC 256-bit public key, stored in the IoT-Safe applet, into an ecc_key object.">wc_iotsafe_ecc_import_public</a> </dd>
<dd>
<a class="el" href="#ga86a293394d882a1226d744c114353b0c" title="Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe...">wc_iotsafe_ecc_export_public</a> </dd></dl>

</div>
</div>
<a id="ga3c02c8dd0b44f96fe7198c4201ab7460" name="ga3c02c8dd0b44f96fe7198c4201ab7460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c02c8dd0b44f96fe7198c4201ab7460">&#9670;&#160;</a></span>wc_iotsafe_ecc_export_private_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_export_private_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>id_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe applet. Equivalent to <a class="el" href="#gac94250323984ce9d24fcc7dfe92905be">wc_iotsafe_ecc_export_private</a>, except that it can be invoked with a key ID of two or more bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the ecc_key object containing the key to be exported </td></tr>
    <tr><td class="paramname">id</td><td>The pointer to the key id in the IoT-Safe applet where the private key will be stored </td></tr>
    <tr><td class="paramname">id_size</td><td>The key id size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac94250323984ce9d24fcc7dfe92905be" title="Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe apple...">wc_iotsafe_ecc_export_private</a> </dd>
<dd>
<a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23" title="Import an ECC 256-bit public key, stored in the IoT-Safe applet, into an ecc_key object.">wc_iotsafe_ecc_import_public</a> </dd>
<dd>
<a class="el" href="#ga86a293394d882a1226d744c114353b0c" title="Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe...">wc_iotsafe_ecc_export_public</a> </dd></dl>

</div>
</div>
<a id="ga86a293394d882a1226d744c114353b0c" name="ga86a293394d882a1226d744c114353b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a293394d882a1226d744c114353b0c">&#9670;&#160;</a></span>wc_iotsafe_ecc_export_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_export_public </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe applet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the ecc_key object containing the key to be exported </td></tr>
    <tr><td class="paramname">id</td><td>The key id in the IoT-Safe applet where the public key will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf4aaa4e97066a606092a4978b1a96122" title="Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe...">wc_iotsafe_ecc_import_public_ex</a> </dd>
<dd>
<a class="el" href="#gac94250323984ce9d24fcc7dfe92905be" title="Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe apple...">wc_iotsafe_ecc_export_private</a> </dd></dl>

</div>
</div>
<a id="gac4ae5e67687a25a7419e43f9c2617249" name="gac4ae5e67687a25a7419e43f9c2617249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ae5e67687a25a7419e43f9c2617249">&#9670;&#160;</a></span>wc_iotsafe_ecc_gen_k()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_gen_k </td>
          <td>(</td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet. </p>
<p>Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet. Equivalent to <a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249">wc_iotsafe_ecc_gen_k</a>, except that it can be invoked with a key ID of two or more bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_id</td><td>The id of the slot where the ECC key pair is stored in the IoT-Safe applet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>wc_iotsafe_ecc_gen_k_ex </dd>
<dd>
<a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_id</td><td>The id of the slot where the ECC key pair is stored in the IoT-Safe applet. </td></tr>
    <tr><td class="paramname">id_size</td><td>The key id size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249" title="Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.">wc_iotsafe_ecc_gen_k</a> </dd>
<dd>
<a class="el" href="#ga91fbd4d4022a37d9d3f694f5310356e0" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash_ex</a> </dd>
<dd>
<a class="el" href="#ga68e3fb2f5072122536ead39523370521" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash_ex</a> </dd></dl>

</div>
</div>
<a id="gab7e739d7ce0c943d1b615a42737b0c23" name="gab7e739d7ce0c943d1b615a42737b0c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e739d7ce0c943d1b615a42737b0c23">&#9670;&#160;</a></span>wc_iotsafe_ecc_import_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_import_public </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import an ECC 256-bit public key, stored in the IoT-Safe applet, into an ecc_key object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the ecc_key object that will contain the key imported from the IoT-Safe applet </td></tr>
    <tr><td class="paramname">id</td><td>The key id in the IoT-Safe applet where the public key is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga86a293394d882a1226d744c114353b0c" title="Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe...">wc_iotsafe_ecc_export_public</a> </dd>
<dd>
<a class="el" href="#gac94250323984ce9d24fcc7dfe92905be" title="Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe apple...">wc_iotsafe_ecc_export_private</a> </dd></dl>

</div>
</div>
<a id="gaf4aaa4e97066a606092a4978b1a96122" name="gaf4aaa4e97066a606092a4978b1a96122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4aaa4e97066a606092a4978b1a96122">&#9670;&#160;</a></span>wc_iotsafe_ecc_import_public_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_import_public_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>id_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export an ECC 256-bit public key, from ecc_key object to a writable public-key slot into the IoT-Safe applet. Equivalent to <a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23">wc_iotsafe_ecc_import_public</a>, except that it can be invoked with a key ID of two or more bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the ecc_key object containing the key to be exported </td></tr>
    <tr><td class="paramname">id</td><td>The pointer to the key id in the IoT-Safe applet where the public key will be stored </td></tr>
    <tr><td class="paramname">id_size</td><td>The key id size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab7e739d7ce0c943d1b615a42737b0c23" title="Import an ECC 256-bit public key, stored in the IoT-Safe applet, into an ecc_key object.">wc_iotsafe_ecc_import_public</a> </dd>
<dd>
<a class="el" href="#gac94250323984ce9d24fcc7dfe92905be" title="Export an ECC 256-bit key, from ecc_key object to a writable private-key slot into the IoT-Safe apple...">wc_iotsafe_ecc_export_private</a> </dd></dl>

</div>
</div>
<a id="gaadd1681d49fe6e8ecf07fd7bd5b320e6" name="gaadd1681d49fe6e8ecf07fd7bd5b320e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6">&#9670;&#160;</a></span>wc_iotsafe_ecc_sign_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_sign_hash </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned, in the IoT-Safe applet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the message hash to sign </td></tr>
    <tr><td class="paramname">inlen</td><td>length of the message hash to sign </td></tr>
    <tr><td class="paramname">out</td><td>buffer in which to store the generated signature </td></tr>
    <tr><td class="paramname">outlen</td><td>max length of the output buffer. Will store the bytes </td></tr>
    <tr><td class="paramname">id</td><td>key id in the IoT-Safe applet for the slot containing the private key to sign the payload written to out upon successfully generating a message signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga91fbd4d4022a37d9d3f694f5310356e0" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash_ex</a> </dd>
<dd>
<a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash</a> </dd>
<dd>
<a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249" title="Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.">wc_iotsafe_ecc_gen_k</a> </dd></dl>

</div>
</div>
<a id="ga91fbd4d4022a37d9d3f694f5310356e0" name="ga91fbd4d4022a37d9d3f694f5310356e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91fbd4d4022a37d9d3f694f5310356e0">&#9670;&#160;</a></span>wc_iotsafe_ecc_sign_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_sign_hash_ex </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>id_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned, in the IoT-Safe applet. Equivalent to <a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6">wc_iotsafe_ecc_sign_hash</a>, except that it can be invoked with a key ID of two or more bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the message hash to sign </td></tr>
    <tr><td class="paramname">inlen</td><td>length of the message hash to sign </td></tr>
    <tr><td class="paramname">out</td><td>buffer in which to store the generated signature </td></tr>
    <tr><td class="paramname">outlen</td><td>max length of the output buffer. Will store the bytes </td></tr>
    <tr><td class="paramname">id</td><td>pointer to a key id in the IoT-Safe applet for the slot containing the private key to sign the payload written to out upon successfully generating a message signature </td></tr>
    <tr><td class="paramname">id_size</td><td>The key id size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash</a> </dd>
<dd>
<a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249" title="Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.">wc_iotsafe_ecc_gen_k</a> </dd></dl>

</div>
</div>
<a id="ga6fd2aeede427f8df6d193f0a21dc614b" name="ga6fd2aeede427f8df6d193f0a21dc614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd2aeede427f8df6d193f0a21dc614b">&#9670;&#160;</a></span>wc_iotsafe_ecc_verify_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_verify_hash </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify an ECC signature against a pre-computed HASH, using a public key previously stored, or pre-provisioned, in the IoT-Safe applet. Result is written to res. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use res. </p>
<dl class="section return"><dt>Returns</dt><dd>0 upon success (even if the signature is not valid) </dd>
<dd>
&lt; 0 in case of failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>buffer containing the signature to verify </td></tr>
    <tr><td class="paramname">hash</td><td>The hash (message digest) that was signed </td></tr>
    <tr><td class="paramname">hashlen</td><td>The length of the hash (octets) </td></tr>
    <tr><td class="paramname">res</td><td>Result of signature, 1==valid, 0==invalid </td></tr>
    <tr><td class="paramname">key_id</td><td>The id of the slot where the public ECC key is stored in the IoT-Safe applet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga68e3fb2f5072122536ead39523370521" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash_ex</a> </dd>
<dd>
<a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249" title="Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.">wc_iotsafe_ecc_gen_k</a> </dd></dl>

</div>
</div>
<a id="ga68e3fb2f5072122536ead39523370521" name="ga68e3fb2f5072122536ead39523370521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e3fb2f5072122536ead39523370521">&#9670;&#160;</a></span>wc_iotsafe_ecc_verify_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_iotsafe_ecc_verify_hash_ex </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>key_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>id_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify an ECC signature against a pre-computed HASH, using a public key previously stored, or pre-provisioned, in the IoT-Safe applet. Result is written to res. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use res. Equivalent to <a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b">wc_iotsafe_ecc_verify_hash</a>, except that it can be invoked with a key ID of two or more bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>0 upon success (even if the signature is not valid) </dd>
<dd>
&lt; 0 in case of failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>buffer containing the signature to verify </td></tr>
    <tr><td class="paramname">hash</td><td>The hash (message digest) that was signed </td></tr>
    <tr><td class="paramname">hashlen</td><td>The length of the hash (octets) </td></tr>
    <tr><td class="paramname">res</td><td>Result of signature, 1==valid, 0==invalid </td></tr>
    <tr><td class="paramname">key_id</td><td>The id of the slot where the public ECC key is stored in the IoT-Safe applet </td></tr>
    <tr><td class="paramname">id_size</td><td>The key id size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6fd2aeede427f8df6d193f0a21dc614b" title="Verify an ECC signature against a pre-computed HASH, using a public key previously stored,...">wc_iotsafe_ecc_verify_hash</a> </dd>
<dd>
<a class="el" href="#gaadd1681d49fe6e8ecf07fd7bd5b320e6" title="Sign a pre-computed HASH, using a private key previously stored, or pre-provisioned,...">wc_iotsafe_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#gac4ae5e67687a25a7419e43f9c2617249" title="Generate an ECC 256-bit keypair and store it in a (writable) slot into the IoT-Safe applet.">wc_iotsafe_ecc_gen_k</a> </dd></dl>

</div>
</div>
<a id="gaffd32db718dcc77934345c2413f4c35b" name="gaffd32db718dcc77934345c2413f4c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd32db718dcc77934345c2413f4c35b">&#9670;&#160;</a></span>wolfIoTSafe_GetCert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfIoTSafe_GetCert </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory. Works with one-byte file ID field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The file id in the IoT-Safe applet where the certificate is stored </td></tr>
    <tr><td class="paramname">output</td><td>the buffer where the certificate will be imported </td></tr>
    <tr><td class="paramname">sz</td><td>the maximum size available in the buffer output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the certificate imported </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CRT_CLIENT_FILE_ID 0x03</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cert_buffer[2048];</div>
<div class="line"><span class="comment">// Get the certificate into the buffer</span></div>
<div class="line">cert_buffer_size = <a class="code hl_function" href="#gaffd32db718dcc77934345c2413f4c35b">wolfIoTSafe_GetCert</a>(CRT_CLIENT_FILE_ID, cert_buffer, 2048);</div>
<div class="line"><span class="keywordflow">if</span> (cert_buffer_size &lt; 1) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Bad cli cert\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;Loaded Client certificate from IoT-Safe, size = %lu\n&quot;</span>, cert_buffer_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the certificate buffer as identity for the TLS client context</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__CertsKeys.html#gae424b3a63756ab805de5c43b67f4df4f">wolfSSL_CTX_use_certificate_buffer</a>(cli_ctx, cert_buffer,</div>
<div class="line">            cert_buffer_size, SSL_FILETYPE_ASN1) != SSL_SUCCESS) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Cannot load client cert\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;Client certificate successfully imported.\n&quot;</span>);</div>
<div class="ttc" id="agroup__CertsKeys_html_gae424b3a63756ab805de5c43b67f4df4f"><div class="ttname"><a href="group__CertsKeys.html#gae424b3a63756ab805de5c43b67f4df4f">wolfSSL_CTX_use_certificate_buffer</a></div><div class="ttdeci">int wolfSSL_CTX_use_certificate_buffer(WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</div><div class="ttdoc">This function loads a certificate buffer into the WOLFSSL Context. It behaves like the non-buffered v...</div></div>
<div class="ttc" id="agroup__IoTSafe_html_gaffd32db718dcc77934345c2413f4c35b"><div class="ttname"><a href="#gaffd32db718dcc77934345c2413f4c35b">wolfIoTSafe_GetCert</a></div><div class="ttdeci">int wolfIoTSafe_GetCert(uint8_t id, unsigned char *output, unsigned long sz)</div><div class="ttdoc">Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory....</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9806038ab5de14c824deae33bb8c01c8" name="ga9806038ab5de14c824deae33bb8c01c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9806038ab5de14c824deae33bb8c01c8">&#9670;&#160;</a></span>wolfIoTSafe_GetCert_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfIoTSafe_GetCert_ex </td>
          <td>(</td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>id_sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory. Equivalent to <a class="el" href="#gaffd32db718dcc77934345c2413f4c35b">wolfIoTSafe_GetCert</a>, except that it can be invoked with a file ID of two or more bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Pointer to the file id in the IoT-Safe applet where the certificate is stored </td></tr>
    <tr><td class="paramname">id_sz</td><td>Size of the file id in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the buffer where the certificate will be imported </td></tr>
    <tr><td class="paramname">sz</td><td>the maximum size available in the buffer output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the certificate imported </dd>
<dd>
&lt; 0 in case of failure</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CRT_CLIENT_FILE_ID 0x0302</span></div>
<div class="line"><span class="preprocessor">#define ID_SIZE (sizeof(word16))</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cert_buffer[2048];</div>
<div class="line">word16 client_file_id = CRT_CLIENT_FILE_ID;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the certificate into the buffer</span></div>
<div class="line">cert_buffer_size = <a class="code hl_function" href="#ga9806038ab5de14c824deae33bb8c01c8">wolfIoTSafe_GetCert_ex</a>(&amp;client_file_id, ID_SIZE, cert_buffer, 2048);</div>
<div class="line"><span class="keywordflow">if</span> (cert_buffer_size &lt; 1) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Bad cli cert\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;Loaded Client certificate from IoT-Safe, size = %lu\n&quot;</span>, cert_buffer_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the certificate buffer as identity for the TLS client context</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__CertsKeys.html#gae424b3a63756ab805de5c43b67f4df4f">wolfSSL_CTX_use_certificate_buffer</a>(cli_ctx, cert_buffer,</div>
<div class="line">            cert_buffer_size, SSL_FILETYPE_ASN1) != SSL_SUCCESS) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Cannot load client cert\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">printf(<span class="stringliteral">&quot;Client certificate successfully imported.\n&quot;</span>);</div>
<div class="ttc" id="agroup__IoTSafe_html_ga9806038ab5de14c824deae33bb8c01c8"><div class="ttname"><a href="#ga9806038ab5de14c824deae33bb8c01c8">wolfIoTSafe_GetCert_ex</a></div><div class="ttdeci">int wolfIoTSafe_GetCert_ex(uint8_t *id, uint16_t id_sz, unsigned char *output, unsigned long sz)</div><div class="ttdoc">Import a certificate stored in a file on IoT-Safe applet, and store it locally in memory....</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaecea4a8c6bd52af24caf937d7f71331c" name="gaecea4a8c6bd52af24caf937d7f71331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecea4a8c6bd52af24caf937d7f71331c">&#9670;&#160;</a></span>wolfIoTSafe_GetRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfIoTSafe_GetRandom </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random buffer of given size, using the IoT-Safe function GetRandom. This function is automatically used by the wolfCrypt RNG object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the buffer where the random sequence of bytes is stored. </td></tr>
    <tr><td class="paramname">sz</td><td>the size of the random sequence to generate, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd></dl>

</div>
</div>
<a id="ga44163df13fb7e31f998e9827cdd57894" name="ga44163df13fb7e31f998e9827cdd57894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44163df13fb7e31f998e9827cdd57894">&#9670;&#160;</a></span>wolfIoTSafe_SetCSIM_read_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfIoTSafe_SetCSIM_read_cb </td>
          <td>(</td>
          <td class="paramtype">wolfSSL_IOTSafe_CSIM_read_cb</td>          <td class="paramname"><span class="paramname"><em>rf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates a read callback for the AT+CSIM commands. This input function is usually associated to a read event of a UART channel communicating with the modem. The read callback associated is global and changes for all the contexts that use IoT-safe support at the same time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Read callback associated to a UART read event. The callback function takes two arguments (buf, len) and return the number of characters read, up to len. When a newline is encountered, the callback should return the number of characters received so far, including the newline character.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// USART read function, defined elsewhere</span></div>
<div class="line"><span class="keywordtype">int</span> usart_read(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga44163df13fb7e31f998e9827cdd57894">wolfIoTSafe_SetCSIM_read_cb</a>(usart_read);</div>
<div class="ttc" id="agroup__IoTSafe_html_ga44163df13fb7e31f998e9827cdd57894"><div class="ttname"><a href="#ga44163df13fb7e31f998e9827cdd57894">wolfIoTSafe_SetCSIM_read_cb</a></div><div class="ttdeci">void wolfIoTSafe_SetCSIM_read_cb(wolfSSL_IOTSafe_CSIM_read_cb rf)</div><div class="ttdoc">Associates a read callback for the AT+CSIM commands. This input function is usually associated to a r...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa8d75a901881864857d4b802e8a49ba3" title="Associates a write callback for the AT+CSIM commands. This output function is usually associated to a...">wolfIoTSafe_SetCSIM_write_cb</a> </dd></dl>

</div>
</div>
<a id="gaa8d75a901881864857d4b802e8a49ba3" name="gaa8d75a901881864857d4b802e8a49ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d75a901881864857d4b802e8a49ba3">&#9670;&#160;</a></span>wolfIoTSafe_SetCSIM_write_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfIoTSafe_SetCSIM_write_cb </td>
          <td>(</td>
          <td class="paramtype">wolfSSL_IOTSafe_CSIM_write_cb</td>          <td class="paramname"><span class="paramname"><em>wf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates a write callback for the AT+CSIM commands. This output function is usually associated to a write event on a UART channel communicating with the modem. The write callback associated is global and changes for all the contexts that use IoT-safe support at the same time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rf</td><td>Write callback associated to a UART write event. The callback function takes two arguments (buf, len) and return the number of characters written, up to len.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// USART write function, defined elsewhere</span></div>
<div class="line"><span class="keywordtype">int</span> usart_write(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len);</div>
<div class="line"><a class="code hl_function" href="#gaa8d75a901881864857d4b802e8a49ba3">wolfIoTSafe_SetCSIM_write_cb</a>(usart_write);</div>
<div class="ttc" id="agroup__IoTSafe_html_gaa8d75a901881864857d4b802e8a49ba3"><div class="ttname"><a href="#gaa8d75a901881864857d4b802e8a49ba3">wolfIoTSafe_SetCSIM_write_cb</a></div><div class="ttdeci">void wolfIoTSafe_SetCSIM_write_cb(wolfSSL_IOTSafe_CSIM_write_cb wf)</div><div class="ttdoc">Associates a write callback for the AT+CSIM commands. This output function is usually associated to a...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga44163df13fb7e31f998e9827cdd57894" title="Associates a read callback for the AT+CSIM commands. This input function is usually associated to a r...">wolfIoTSafe_SetCSIM_read_cb</a> </dd></dl>

</div>
</div>
<a id="ga6eef6129679bffcce2eb294c8c075da7" name="ga6eef6129679bffcce2eb294c8c075da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eef6129679bffcce2eb294c8c075da7">&#9670;&#160;</a></span>wolfSSL_CTX_iotsafe_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_iotsafe_enable </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the IoT-Safe support on the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the WOLFSSL_CTX object on which the IoT-safe support must be enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
WC_HW_E on hardware error</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX *ctx;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(<a class="code hl_function" href="group__Setup.html#ga12fffeacc6aefd594f51c1dcb9d6c27d">wolfTLSv1_2_client_method</a>());</div>
<div class="line"><span class="keywordflow">if</span> (!ctx)</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a class="code hl_function" href="#ga6eef6129679bffcce2eb294c8c075da7">wolfSSL_CTX_iotsafe_enable</a>(ctx);</div>
<div class="ttc" id="agroup__IoTSafe_html_ga6eef6129679bffcce2eb294c8c075da7"><div class="ttname"><a href="#ga6eef6129679bffcce2eb294c8c075da7">wolfSSL_CTX_iotsafe_enable</a></div><div class="ttdeci">int wolfSSL_CTX_iotsafe_enable(WOLFSSL_CTX *ctx)</div><div class="ttdoc">This function enables the IoT-Safe support on the given context.</div></div>
<div class="ttc" id="agroup__Setup_html_ga12fffeacc6aefd594f51c1dcb9d6c27d"><div class="ttname"><a href="group__Setup.html#ga12fffeacc6aefd594f51c1dcb9d6c27d">wolfTLSv1_2_client_method</a></div><div class="ttdeci">WOLFSSL_METHOD * wolfTLSv1_2_client_method(void)</div><div class="ttdoc">The wolfTLSv1_2_client_method() function is used to indicate that the application is a client and wil...</div></div>
<div class="ttc" id="agroup__Setup_html_ga2bcaa81e9fd11074c6e504891370dd45"><div class="ttname"><a href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a></div><div class="ttdeci">WOLFSSL_CTX * wolfSSL_CTX_new(WOLFSSL_METHOD *)</div><div class="ttdoc">This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga70736338743dd73e0298461c521f150f" title="This function connects the IoT-Safe TLS callbacks to the given SSL session.">wolfSSL_iotsafe_on</a> </dd>
<dd>
<a class="el" href="#ga44163df13fb7e31f998e9827cdd57894" title="Associates a read callback for the AT+CSIM commands. This input function is usually associated to a r...">wolfIoTSafe_SetCSIM_read_cb</a> </dd>
<dd>
<a class="el" href="#gaa8d75a901881864857d4b802e8a49ba3" title="Associates a write callback for the AT+CSIM commands. This output function is usually associated to a...">wolfIoTSafe_SetCSIM_write_cb</a> </dd></dl>

</div>
</div>
<a id="ga70736338743dd73e0298461c521f150f" name="ga70736338743dd73e0298461c521f150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70736338743dd73e0298461c521f150f">&#9670;&#160;</a></span>wolfSSL_iotsafe_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_iotsafe_on </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>privkey_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>ecdh_keypair_slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>peer_pubkey_slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>peer_cert_slot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function connects the IoT-Safe TLS callbacks to the given SSL session. </p>
<p>This should be called to connect a SSL session to IoT-Safe applet when the ID of the slots are one-byte long. If IoT-SAFE slots have an ID of two or more bytes, <a class="el" href="#ga3beca4356267e5c0442e89b0d29515fc">wolfSSL_iotsafe_on_ex()</a> should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the WOLFSSL object where the callbacks will be enabled </td></tr>
    <tr><td class="paramname">privkey_id</td><td>id of the iot-safe applet slot containing the private key for the host </td></tr>
    <tr><td class="paramname">ecdh_keypair_slot</td><td>id of the iot-safe applet slot to store the ECDH keypair </td></tr>
    <tr><td class="paramname">peer_pubkey_slot</td><td>id of the iot-safe applet slot to store the other endpoint's public key for ECDH </td></tr>
    <tr><td class="paramname">peer_cert_slot</td><td>id of the iot-safe applet slot to store the other endpoint's public key for verification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
NOT_COMPILED_IN if HAVE_PK_CALLBACKS is disabled </dd>
<dd>
BAD_FUNC_ARG if the ssl pointer is invalid</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// Define key ids for IoT-Safe</span></div>
<div class="line"><span class="preprocessor">#define PRIVKEY_ID 0x02</span></div>
<div class="line"><span class="preprocessor">#define ECDH_KEYPAIR_ID 0x03</span></div>
<div class="line"><span class="preprocessor">#define PEER_PUBKEY_ID 0x04</span></div>
<div class="line"><span class="preprocessor">#define PEER_CERT_ID 0x05</span></div>
<div class="line"><span class="comment">// Create new ssl session</span></div>
<div class="line">WOLFSSL *ssl;</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (!ssl)</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="comment">// Enable IoT-Safe and associate key slots</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga6eef6129679bffcce2eb294c8c075da7">wolfSSL_CTX_iotsafe_enable</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#ga70736338743dd73e0298461c521f150f">wolfSSL_iotsafe_on</a>(ssl, PRIVKEY_ID, ECDH_KEYPAIR_ID, PEER_PUBKEY_ID, PEER_CERT_ID);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IoTSafe_html_ga70736338743dd73e0298461c521f150f"><div class="ttname"><a href="#ga70736338743dd73e0298461c521f150f">wolfSSL_iotsafe_on</a></div><div class="ttdeci">int wolfSSL_iotsafe_on(WOLFSSL *ssl, byte privkey_id, byte ecdh_keypair_slot, byte peer_pubkey_slot, byte peer_cert_slot)</div><div class="ttdoc">This function connects the IoT-Safe TLS callbacks to the given SSL session.</div></div>
<div class="ttc" id="agroup__Setup_html_gab6d54b7485d74962e57bc636008aa9a0"><div class="ttname"><a href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a></div><div class="ttdeci">WOLFSSL * wolfSSL_new(WOLFSSL_CTX *)</div><div class="ttdoc">This function creates a new SSL session, taking an already created SSL context as input.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3beca4356267e5c0442e89b0d29515fc" title="This function connects the IoT-Safe TLS callbacks to the given SSL session. This is equivalent to wol...">wolfSSL_iotsafe_on_ex</a> </dd>
<dd>
<a class="el" href="#ga6eef6129679bffcce2eb294c8c075da7" title="This function enables the IoT-Safe support on the given context.">wolfSSL_CTX_iotsafe_enable</a> </dd></dl>

</div>
</div>
<a id="ga3beca4356267e5c0442e89b0d29515fc" name="ga3beca4356267e5c0442e89b0d29515fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3beca4356267e5c0442e89b0d29515fc">&#9670;&#160;</a></span>wolfSSL_iotsafe_on_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_iotsafe_on_ex </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>privkey_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>ecdh_keypair_slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>peer_pubkey_slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>peer_cert_slot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>id_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function connects the IoT-Safe TLS callbacks to the given SSL session. This is equivalent to <a class="el" href="#ga70736338743dd73e0298461c521f150f">wolfSSL_iotsafe_on</a> except that the IDs for the IoT-SAFE slots can be passed by reference, and the length of the ID fields can be specified via the parameter "id_size". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the WOLFSSL object where the callbacks will be enabled </td></tr>
    <tr><td class="paramname">privkey_id</td><td>pointer to the id of the iot-safe applet slot containing the private key for the host </td></tr>
    <tr><td class="paramname">ecdh_keypair_slot</td><td>pointer to the id of the iot-safe applet slot to store the ECDH keypair </td></tr>
    <tr><td class="paramname">peer_pubkey_slot</td><td>pointer to the of id the iot-safe applet slot to store the other endpoint's public key for ECDH </td></tr>
    <tr><td class="paramname">peer_cert_slot</td><td>pointer to the id of the iot-safe applet slot to store the other endpoint's public key for verification </td></tr>
    <tr><td class="paramname">id_size</td><td>size of each slot ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success </dd>
<dd>
NOT_COMPILED_IN if HAVE_PK_CALLBACKS is disabled </dd>
<dd>
BAD_FUNC_ARG if the ssl pointer is invalid</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// Define key ids for IoT-Safe (16 bit, little endian)</span></div>
<div class="line"><span class="preprocessor">#define PRIVKEY_ID 0x0201</span></div>
<div class="line"><span class="preprocessor">#define ECDH_KEYPAIR_ID 0x0301</span></div>
<div class="line"><span class="preprocessor">#define PEER_PUBKEY_ID 0x0401</span></div>
<div class="line"><span class="preprocessor">#define PEER_CERT_ID 0x0501</span></div>
<div class="line"><span class="preprocessor">#define ID_SIZE (sizeof(word16))</span></div>
<div class="line"> </div>
<div class="line">word16 privkey = PRIVKEY_ID,</div>
<div class="line">         ecdh_keypair = ECDH_KEYPAIR_ID,</div>
<div class="line">         peer_pubkey = PEER_PUBKEY_ID,</div>
<div class="line">         peer_cert = PEER_CERT_ID;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create new ssl session</span></div>
<div class="line">WOLFSSL *ssl;</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (!ssl)</div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="comment">// Enable IoT-Safe and associate key slots</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga6eef6129679bffcce2eb294c8c075da7">wolfSSL_CTX_iotsafe_enable</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = wolfSSL_CTX_iotsafe_on_ex(ssl, &amp;privkey, &amp;ecdh_keypair, &amp;peer_pubkey, &amp;peer_cert, ID_SIZE);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga70736338743dd73e0298461c521f150f" title="This function connects the IoT-Safe TLS callbacks to the given SSL session.">wolfSSL_iotsafe_on</a> </dd>
<dd>
<a class="el" href="#ga6eef6129679bffcce2eb294c8c075da7" title="This function enables the IoT-Safe support on the given context.">wolfSSL_CTX_iotsafe_enable</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
