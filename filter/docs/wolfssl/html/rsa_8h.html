<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: dox_comments/header_files/rsa.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_82d3bead6ddd9c04b5e63bcd98737c37.html">dox_comments</a></li><li class="navelem"><a href="dir_7d9839bdafa3337ea612d454307fbf29.html">header_files</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rsa.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="rsa_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga02c9b34d405c5f1c24956ee84a843ef6" id="r_ga02c9b34d405c5f1c24956ee84a843ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a> (RsaKey *key, void *heap)</td></tr>
<tr class="memdesc:ga02c9b34d405c5f1c24956ee84a843ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC).  <br /></td></tr>
<tr class="memitem:gaba7b6eef17f80e711309f53f2c17dfc6" id="r_gaba7b6eef17f80e711309f53f2c17dfc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaba7b6eef17f80e711309f53f2c17dfc6">wc_InitRsaKey_Id</a> (RsaKey *key, unsigned char *id, int len, void *heap, int devId)</td></tr>
<tr class="memdesc:gaba7b6eef17f80e711309f53f2c17dfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a provided RsaKey struct. The id and len are used to identify the key on the device while the devId identifies the device. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC).  <br /></td></tr>
<tr class="memitem:gade0e7ccd93ec8c9e5ba5ded3e11b1226" id="r_gade0e7ccd93ec8c9e5ba5ded3e11b1226"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a> (RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:gade0e7ccd93ec8c9e5ba5ded3e11b1226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga0e5ef34d84c264a1affa8d3a6478b4ce" id="r_ga0e5ef34d84c264a1affa8d3a6478b4ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a> (RsaKey *key)</td></tr>
<tr class="memdesc:ga0e5ef34d84c264a1affa8d3a6478b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees a provided RsaKey struct using mp_clear.  <br /></td></tr>
<tr class="memitem:gae935cf0597a24a636b730a4c290b442c" id="r_gae935cf0597a24a636b730a4c290b442c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gae935cf0597a24a636b730a4c290b442c">wc_RsaDirect</a> (byte *in, word32 inLen, byte *out, word32 *outSz, RsaKey *key, int type, WC_RNG *rng)</td></tr>
<tr class="memdesc:gae935cf0597a24a636b730a4c290b442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that does the RSA operation directly with no padding. The input size must match key size. Typically this is used when padding is already done on the RSA input.  <br /></td></tr>
<tr class="memitem:ga72130d1043824f7e8a5df91fc6832539" id="r_ga72130d1043824f7e8a5df91fc6832539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga72130d1043824f7e8a5df91fc6832539">wc_RsaPublicEncrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga72130d1043824f7e8a5df91fc6832539"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts a message from in and stores the result in out. It requires an initialized public key and a random number generator. As a side effect, this function will return the bytes written to out in outLen.  <br /></td></tr>
<tr class="memitem:ga27ae50a0bc76cb4eea37fdbb565ae2a6" id="r_ga27ae50a0bc76cb4eea37fdbb565ae2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga27ae50a0bc76cb4eea37fdbb565ae2a6">wc_RsaPrivateDecryptInline</a> (byte *in, word32 inLen, byte **out, RsaKey *key)</td></tr>
<tr class="memdesc:ga27ae50a0bc76cb4eea37fdbb565ae2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting.  <br /></td></tr>
<tr class="memitem:ga674c968fd03a8b88931e412df8db7732" id="r_ga674c968fd03a8b88931e412df8db7732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga674c968fd03a8b88931e412df8db7732">wc_RsaPrivateDecrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga674c968fd03a8b88931e412df8db7732"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions provides private RSA decryption.  <br /></td></tr>
<tr class="memitem:ga8299328ea8ddff961b79038bc97a4044" id="r_ga8299328ea8ddff961b79038bc97a4044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga8299328ea8ddff961b79038bc97a4044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signs the provided array with the private key.  <br /></td></tr>
<tr class="memitem:ga192d864bacce51770e774e304a343585" id="r_ga192d864bacce51770e774e304a343585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga192d864bacce51770e774e304a343585">wc_RsaSSL_VerifyInline</a> (byte *in, word32 inLen, byte **out, RsaKey *key)</td></tr>
<tr class="memdesc:ga192d864bacce51770e774e304a343585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by RSA key. The output uses the same byte array as the input.  <br /></td></tr>
<tr class="memitem:ga1e996b7382fa0951cd5000d11fc4c0ea" id="r_ga1e996b7382fa0951cd5000d11fc4c0ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga1e996b7382fa0951cd5000d11fc4c0ea">wc_RsaSSL_Verify</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga1e996b7382fa0951cd5000d11fc4c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by key.  <br /></td></tr>
<tr class="memitem:gaaf1d180d5e8bcad38da35d34bef49e11" id="r_gaaf1d180d5e8bcad38da35d34bef49e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a> (const byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:gaaf1d180d5e8bcad38da35d34bef49e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signs the provided array with the private key.  <br /></td></tr>
<tr class="memitem:gac6e4d2ef764f65e53569508a0060818e" id="r_gac6e4d2ef764f65e53569508a0060818e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a> (byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gac6e4d2ef764f65e53569508a0060818e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt input signature to verify that the message was signed by key. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga3de78c85b8d5cf9d7b755292d6e75e3c" id="r_ga3de78c85b8d5cf9d7b755292d6e75e3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga3de78c85b8d5cf9d7b755292d6e75e3c">wc_RsaPSS_VerifyInline</a> (byte *in, word32 inLen, byte **out, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:ga3de78c85b8d5cf9d7b755292d6e75e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt input signature to verify that the message was signed by RSA key. The output uses the same byte array as the input. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gabc0162af195b6a97d58deaec89d62d10" id="r_gabc0162af195b6a97d58deaec89d62d10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gabc0162af195b6a97d58deaec89d62d10">wc_RsaPSS_VerifyCheck</a> (byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gabc0162af195b6a97d58deaec89d62d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga4beef229be508f04004789e1e51ac859" id="r_ga4beef229be508f04004789e1e51ac859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga4beef229be508f04004789e1e51ac859">wc_RsaPSS_VerifyCheck_ex</a> (byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga4beef229be508f04004789e1e51ac859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gaf11e0726a51dd4278346902c10d6f6b5" id="r_gaf11e0726a51dd4278346902c10d6f6b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaf11e0726a51dd4278346902c10d6f6b5">wc_RsaPSS_VerifyCheckInline</a> (byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gaf11e0726a51dd4278346902c10d6f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. Salt length is equal to hash length.  <br /></td></tr>
<tr class="memitem:gac6f0820cdf3b0189b01993814635fda3" id="r_gac6f0820cdf3b0189b01993814635fda3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gac6f0820cdf3b0189b01993814635fda3">wc_RsaPSS_VerifyCheckInline_ex</a> (byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</td></tr>
<tr class="memdesc:gac6f0820cdf3b0189b01993814635fda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gac32f035dce2d7765faf2bfc0289deeba" id="r_gac32f035dce2d7765faf2bfc0289deeba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gac32f035dce2d7765faf2bfc0289deeba">wc_RsaPSS_CheckPadding</a> (const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType)</td></tr>
<tr class="memdesc:gac32f035dce2d7765faf2bfc0289deeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga8149b3fea0859eb26d1dbcadba46cb4b" id="r_ga8149b3fea0859eb26d1dbcadba46cb4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga8149b3fea0859eb26d1dbcadba46cb4b">wc_RsaPSS_CheckPadding_ex</a> (const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType, int saltLen, int bits)</td></tr>
<tr class="memdesc:ga8149b3fea0859eb26d1dbcadba46cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.  <br /></td></tr>
<tr class="memitem:gaa4149b9e60fcc1eba1e7a263bb10a558" id="r_gaa4149b9e60fcc1eba1e7a263bb10a558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaa4149b9e60fcc1eba1e7a263bb10a558">wc_RsaEncryptSize</a> (RsaKey *key)</td></tr>
<tr class="memdesc:gaa4149b9e60fcc1eba1e7a263bb10a558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption size for the provided key structure.  <br /></td></tr>
<tr class="memitem:gac52250c3b5c69ff052dfa6605cf49837" id="r_gac52250c3b5c69ff052dfa6605cf49837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gac52250c3b5c69ff052dfa6605cf49837">wc_RsaPrivateKeyDecode</a> (const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</td></tr>
<tr class="memdesc:gac52250c3b5c69ff052dfa6605cf49837"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA private key, extracts the private key and stores it in the given RsaKey structure. It also sets the distance parsed in idx.  <br /></td></tr>
<tr class="memitem:ga2610326206b322f33f59e31a845e24b9" id="r_ga2610326206b322f33f59e31a845e24b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga2610326206b322f33f59e31a845e24b9">wc_RsaPublicKeyDecode</a> (const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</td></tr>
<tr class="memdesc:ga2610326206b322f33f59e31a845e24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA public key, extracts the public key and stores it in the given RsaKey structure. It also sets the distance parsed in idx.  <br /></td></tr>
<tr class="memitem:ga437b3432338f18022e9b62d109ce0518" id="r_ga437b3432338f18022e9b62d109ce0518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga437b3432338f18022e9b62d109ce0518">wc_RsaPublicKeyDecodeRaw</a> (const byte *n, word32 nSz, const byte *e, word32 eSz, RsaKey *key)</td></tr>
<tr class="memdesc:ga437b3432338f18022e9b62d109ce0518"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exponent (e). It stores these raw elements in the provided RsaKey structure, allowing one to use them in the encryption/decryption process.  <br /></td></tr>
<tr class="memitem:ga428f841fea0e37d3c855c31b32f39dbd" id="r_ga428f841fea0e37d3c855c31b32f39dbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga428f841fea0e37d3c855c31b32f39dbd">wc_RsaKeyToDer</a> (RsaKey *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga428f841fea0e37d3c855c31b32f39dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an RsaKey key to DER format. The result is written to output and it returns the number of bytes written.  <br /></td></tr>
<tr class="memitem:ga9c5787bc3306eb65bec0f018314d309c" id="r_ga9c5787bc3306eb65bec0f018314d309c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:ga9c5787bc3306eb65bec0f018314d309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs RSA encrypt while allowing the choice of which padding to use.  <br /></td></tr>
<tr class="memitem:gaa51e899f36d2429b30213b3374f76521" id="r_gaa51e899f36d2429b30213b3374f76521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gaa51e899f36d2429b30213b3374f76521">wc_RsaPrivateDecrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:gaa51e899f36d2429b30213b3374f76521"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message and gives the option of what padding type.  <br /></td></tr>
<tr class="memitem:ga66a1aded8d710cec00046029be411ecb" id="r_ga66a1aded8d710cec00046029be411ecb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga66a1aded8d710cec00046029be411ecb">wc_RsaPrivateDecryptInline_ex</a> (byte *in, word32 inLen, byte **out, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:ga66a1aded8d710cec00046029be411ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message inline and gives the option of what padding type. The in buffer will contain the decrypted message after being called and the out byte pointer will point to the location in the “in” buffer where the plain text is.  <br /></td></tr>
<tr class="memitem:ga65277ef2482b2a2af05c613b33cbf02a" id="r_ga65277ef2482b2a2af05c613b33cbf02a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga65277ef2482b2a2af05c613b33cbf02a">wc_RsaFlattenPublicKey</a> (RsaKey *key, byte *e, word32 *eSz, byte *n, word32 *nSz)</td></tr>
<tr class="memdesc:ga65277ef2482b2a2af05c613b33cbf02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the RsaKey structure into individual elements (e, n) used for the RSA algorithm.  <br /></td></tr>
<tr class="memitem:ga4a7ac764a306106a2d805de0ce03f78a" id="r_ga4a7ac764a306106a2d805de0ce03f78a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga4a7ac764a306106a2d805de0ce03f78a">wc_RsaKeyToPublicDer</a> (RsaKey *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga4a7ac764a306106a2d805de0ce03f78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.  <br /></td></tr>
<tr class="memitem:ga754534e6ddb9db7c55de5793d442f904" id="r_ga754534e6ddb9db7c55de5793d442f904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga754534e6ddb9db7c55de5793d442f904">wc_RsaKeyToPublicDer_ex</a> (RsaKey *key, byte *output, word32 inLen, int with_header)</td></tr>
<tr class="memdesc:ga754534e6ddb9db7c55de5793d442f904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert RSA Public key to DER format. Writes to output, and returns count of bytes written. If with_header is 0 then only the ( seq + n + e) is returned in ASN.1 DER format and will exclude the header.  <br /></td></tr>
<tr class="memitem:ga3f89eea8d56ae352730ffd49ec2fd68e" id="r_ga3f89eea8d56ae352730ffd49ec2fd68e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a> (RsaKey *key, int size, long e, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga3f89eea8d56ae352730ffd49ec2fd68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a RSA private key of length size (in bits) and given exponent (e). It then stores this key in the provided RsaKey structure, so that it may be used for encryption/decryption. A secure number to use for e is 65537. size is required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE. For this function to be available, the option WOLFSSL_KEY_GEN must be enabled at compile time. This can be accomplished with &ndash;enable-keygen if using ./configure.  <br /></td></tr>
<tr class="memitem:gab62eca8ad6726c5db562947e5e165a61" id="r_gab62eca8ad6726c5db562947e5e165a61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#gab62eca8ad6726c5db562947e5e165a61">wc_RsaSetNonBlock</a> (RsaKey *key, RsaNb *nb)</td></tr>
<tr class="memdesc:gab62eca8ad6726c5db562947e5e165a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the non-blocking RSA context. When a RsaNb context is set it enables fast math based non-blocking exptmod, which splits the RSA function into many smaller operations. Enabled when WC_RSA_NONBLOCK is defined.  <br /></td></tr>
<tr class="memitem:ga623ecefb5f932cbdab21f9b777fa8ea9" id="r_ga623ecefb5f932cbdab21f9b777fa8ea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RSA.html#ga623ecefb5f932cbdab21f9b777fa8ea9">wc_RsaSetNonBlockTime</a> (RsaKey *key, word32 maxBlockUs, word32 cpuMHz)</td></tr>
<tr class="memdesc:ga623ecefb5f932cbdab21f9b777fa8ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the maximum amount of blocking time in microseconds. It uses a pre-computed table (see tfm.c exptModNbInst) along with the CPU speed in megahertz to determine if the next operation can be completed within the maximum blocking time provided. Enabled when WC_RSA_NONBLOCK_TIME is defined.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
