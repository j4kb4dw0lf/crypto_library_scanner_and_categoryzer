<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: dox_comments/header_files/ssl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_82d3bead6ddd9c04b5e63bcd98737c37.html">dox_comments</a></li><li class="navelem"><a href="dir_7d9839bdafa3337ea612d454307fbf29.html">header_files</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ssl.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="ssl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1736540e27446e5c29b3845a0d76bebb" id="r_a1736540e27446e5c29b3845a0d76bebb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1736540e27446e5c29b3845a0d76bebb">wolfDTLSv1_2_client_method_ex</a> (void *heap)</td></tr>
<tr class="memdesc:a1736540e27446e5c29b3845a0d76bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the DTLS v1.2 client method.  <br /></td></tr>
<tr class="memitem:ga182f28c20ec6ef5b8986222bf8a01ccd" id="r_ga182f28c20ec6ef5b8986222bf8a01ccd"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga182f28c20ec6ef5b8986222bf8a01ccd">wolfSSLv23_method</a> (void)</td></tr>
<tr class="memdesc:ga182f28c20ec6ef5b8986222bf8a01ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a WOLFSSL_METHOD similar to wolfSSLv23_client_method except that it is not determined which side yet (server/client).  <br /></td></tr>
<tr class="memitem:gaa1524f1f5f78c97abe43ad40a5f68239" id="r_gaa1524f1f5f78c97abe43ad40a5f68239"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa1524f1f5f78c97abe43ad40a5f68239">wolfSSLv3_server_method</a> (void)</td></tr>
<tr class="memdesc:gaa1524f1f5f78c97abe43ad40a5f68239"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gaa1524f1f5f78c97abe43ad40a5f68239" title="The wolfSSLv3_server_method() function is used to indicate that the application is a server and will ...">wolfSSLv3_server_method()</a> function is used to indicate that the application is a server and will only support the SSL 3.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gacc346b11fc937176405fe00f002b7dfe" id="r_gacc346b11fc937176405fe00f002b7dfe"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gacc346b11fc937176405fe00f002b7dfe">wolfSSLv3_client_method</a> (void)</td></tr>
<tr class="memdesc:gacc346b11fc937176405fe00f002b7dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gacc346b11fc937176405fe00f002b7dfe" title="The wolfSSLv3_client_method() function is used to indicate that the application is a client and will ...">wolfSSLv3_client_method()</a> function is used to indicate that the application is a client and will only support the SSL 3.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga99647ac66aa0ab62bff80ae142bc2295" id="r_ga99647ac66aa0ab62bff80ae142bc2295"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga99647ac66aa0ab62bff80ae142bc2295">wolfTLSv1_server_method</a> (void)</td></tr>
<tr class="memdesc:ga99647ac66aa0ab62bff80ae142bc2295"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga99647ac66aa0ab62bff80ae142bc2295" title="The wolfTLSv1_server_method() function is used to indicate that the application is a server and will ...">wolfTLSv1_server_method()</a> function is used to indicate that the application is a server and will only support the TLS 1.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gafa926026a13de7a889b3524469e3292e" id="r_gafa926026a13de7a889b3524469e3292e"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gafa926026a13de7a889b3524469e3292e">wolfTLSv1_client_method</a> (void)</td></tr>
<tr class="memdesc:gafa926026a13de7a889b3524469e3292e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gafa926026a13de7a889b3524469e3292e" title="The wolfTLSv1_client_method() function is used to indicate that the application is a client and will ...">wolfTLSv1_client_method()</a> function is used to indicate that the application is a client and will only support the TLS 1.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gaf9a2f33e9579895f7517483afdfbcee8" id="r_gaf9a2f33e9579895f7517483afdfbcee8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf9a2f33e9579895f7517483afdfbcee8">wolfTLSv1_1_server_method</a> (void)</td></tr>
<tr class="memdesc:gaf9a2f33e9579895f7517483afdfbcee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gaf9a2f33e9579895f7517483afdfbcee8" title="The wolfTLSv1_1_server_method() function is used to indicate that the application is a server and wil...">wolfTLSv1_1_server_method()</a> function is used to indicate that the application is a server and will only support the TLS 1.1 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gaa1def0367d5d2d796f6c26bb3d08714d" id="r_gaa1def0367d5d2d796f6c26bb3d08714d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa1def0367d5d2d796f6c26bb3d08714d">wolfTLSv1_1_client_method</a> (void)</td></tr>
<tr class="memdesc:gaa1def0367d5d2d796f6c26bb3d08714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gaa1def0367d5d2d796f6c26bb3d08714d" title="The wolfTLSv1_1_client_method() function is used to indicate that the application is a client and wil...">wolfTLSv1_1_client_method()</a> function is used to indicate that the application is a client and will only support the TLS 1.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga49eca963f241cb313cd868be7c05d58f" id="r_ga49eca963f241cb313cd868be7c05d58f"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga49eca963f241cb313cd868be7c05d58f">wolfTLSv1_2_server_method</a> (void)</td></tr>
<tr class="memdesc:ga49eca963f241cb313cd868be7c05d58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga49eca963f241cb313cd868be7c05d58f" title="The wolfTLSv1_2_server_method() function is used to indicate that the application is a server and wil...">wolfTLSv1_2_server_method()</a> function is used to indicate that the application is a server and will only support the TLS 1.2 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga12fffeacc6aefd594f51c1dcb9d6c27d" id="r_ga12fffeacc6aefd594f51c1dcb9d6c27d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga12fffeacc6aefd594f51c1dcb9d6c27d">wolfTLSv1_2_client_method</a> (void)</td></tr>
<tr class="memdesc:ga12fffeacc6aefd594f51c1dcb9d6c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga12fffeacc6aefd594f51c1dcb9d6c27d" title="The wolfTLSv1_2_client_method() function is used to indicate that the application is a client and wil...">wolfTLSv1_2_client_method()</a> function is used to indicate that the application is a client and will only support the TLS 1.2 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gae7eb251d1239bcdc989fca842917f2cc" id="r_gae7eb251d1239bcdc989fca842917f2cc"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gae7eb251d1239bcdc989fca842917f2cc">wolfDTLSv1_client_method</a> (void)</td></tr>
<tr class="memdesc:gae7eb251d1239bcdc989fca842917f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gae7eb251d1239bcdc989fca842917f2cc" title="The wolfDTLSv1_client_method() function is used to indicate that the application is a client and will...">wolfDTLSv1_client_method()</a> function is used to indicate that the application is a client and will only support the DTLS 1.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLS support (&ndash;enable-dtls, or by defining wolfSSL_DTLS).  <br /></td></tr>
<tr class="memitem:ga75ecb0e715fca3e9f05ee46d5c05010a" id="r_ga75ecb0e715fca3e9f05ee46d5c05010a"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga75ecb0e715fca3e9f05ee46d5c05010a">wolfDTLSv1_server_method</a> (void)</td></tr>
<tr class="memdesc:ga75ecb0e715fca3e9f05ee46d5c05010a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga75ecb0e715fca3e9f05ee46d5c05010a" title="The wolfDTLSv1_server_method() function is used to indicate that the application is a server and will...">wolfDTLSv1_server_method()</a> function is used to indicate that the application is a server and will only support the DTLS 1.0 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLS support (&ndash;enable-dtls, or by defining wolfSSL_DTLS).  <br /></td></tr>
<tr class="memitem:ga023289e518ef23f1e2242c964e245400" id="r_ga023289e518ef23f1e2242c964e245400"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga023289e518ef23f1e2242c964e245400">wolfDTLSv1_3_server_method</a> (void)</td></tr>
<tr class="memdesc:ga023289e518ef23f1e2242c964e245400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga023289e518ef23f1e2242c964e245400" title="The wolfDTLSv1_3_server_method() function is used to indicate that the application is a server and wi...">wolfDTLSv1_3_server_method()</a> function is used to indicate that the application is a server and will only support the DTLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLSv1.3 support (&ndash;enable-dtls13, or by defining wolfSSL_DTLS13).  <br /></td></tr>
<tr class="memitem:ga24dc74048ede0163fa6a1db79ea57627" id="r_ga24dc74048ede0163fa6a1db79ea57627"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga24dc74048ede0163fa6a1db79ea57627">wolfDTLSv1_3_client_method</a> (void)</td></tr>
<tr class="memdesc:ga24dc74048ede0163fa6a1db79ea57627"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga24dc74048ede0163fa6a1db79ea57627" title="The wolfDTLSv1_3_client_method() function is used to indicate that the application is a client and wi...">wolfDTLSv1_3_client_method()</a> function is used to indicate that the application is a client and will only support the DTLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLSv1.3 support (&ndash;enable-dtls13, or by defining wolfSSL_DTLS13).  <br /></td></tr>
<tr class="memitem:gab40617bd87f97b511094136095308647" id="r_gab40617bd87f97b511094136095308647"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab40617bd87f97b511094136095308647">wolfDTLS_server_method</a> (void)</td></tr>
<tr class="memdesc:gab40617bd87f97b511094136095308647"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gab40617bd87f97b511094136095308647" title="The wolfDTLS_server_method() function is used to indicate that the application is a server and will s...">wolfDTLS_server_method()</a> function is used to indicate that the application is a server and will support the highest version of DTLS available and all the version up to the minimum version allowed. The default minimum version allowed is based on the define WOLFSSL_MIN_DTLS_DOWNGRADE and can be changed at runtime using <a class="el" href="group__TLS.html#ga019ccc78fa3e8c2c093288596b46ab67" title="This function sets the minimum downgrade version allowed. Applicable only when the connection allows ...">wolfSSL_SetMinVersion()</a>. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLS support (&ndash;enable-dtls, or by defining wolfSSL_DTLS).  <br /></td></tr>
<tr class="memitem:ga80d9d9c52e549716d6e252f977019cd2" id="r_ga80d9d9c52e549716d6e252f977019cd2"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga80d9d9c52e549716d6e252f977019cd2">wolfDTLS_client_method</a> (void)</td></tr>
<tr class="memdesc:ga80d9d9c52e549716d6e252f977019cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga80d9d9c52e549716d6e252f977019cd2" title="The wolfDTLS_client_method() function is used to indicate that the application is a client and will s...">wolfDTLS_client_method()</a> function is used to indicate that the application is a client and will support the highest version of DTLS available and all the version up to the minimum version allowed. The default minimum version allowed is based on the define WOLFSSL_MIN_DTLS_DOWNGRADE and can be changed at runtime using <a class="el" href="group__TLS.html#ga019ccc78fa3e8c2c093288596b46ab67" title="This function sets the minimum downgrade version allowed. Applicable only when the connection allows ...">wolfSSL_SetMinVersion()</a>. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is only available when wolfSSL has been compiled with DTLS support (&ndash;enable-dtls, or by defining wolfSSL_DTLS).  <br /></td></tr>
<tr class="memitem:a22fbd4add0987197fb393df285be7a30" id="r_a22fbd4add0987197fb393df285be7a30"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22fbd4add0987197fb393df285be7a30">wolfDTLSv1_2_server_method</a> (void)</td></tr>
<tr class="memdesc:a22fbd4add0987197fb393df285be7a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates and initializes a WOLFSSL_METHOD for the server side.  <br /></td></tr>
<tr class="memitem:ga340602d0391fe322896dcefe0fbe8c5b" id="r_ga340602d0391fe322896dcefe0fbe8c5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga340602d0391fe322896dcefe0fbe8c5b">wolfSSL_use_old_poly</a> (WOLFSSL *ssl, int value)</td></tr>
<tr class="memdesc:ga340602d0391fe322896dcefe0fbe8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since there is some differences between the first release and newer versions of chacha-poly AEAD construction we have added an option to communicate with servers/clients using the older version. By default wolfSSL uses the new version.  <br /></td></tr>
<tr class="memitem:a42edf8e49a9aee400c06cf6a2a2f04d8" id="r_a42edf8e49a9aee400c06cf6a2a2f04d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8">wolfSSL_dtls_import</a> (WOLFSSL *ssl, unsigned char *buf, unsigned int sz)</td></tr>
<tr class="memdesc:a42edf8e49a9aee400c06cf6a2a2f04d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8" title="The wolfSSL_dtls_import() function is used to parse in a serialized session state....">wolfSSL_dtls_import()</a> function is used to parse in a serialized session state. This allows for picking up the connection after the handshake has been completed.  <br /></td></tr>
<tr class="memitem:ab67ddb8c518619de3c8987f6a7064464" id="r_ab67ddb8c518619de3c8987f6a7064464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67ddb8c518619de3c8987f6a7064464">wolfSSL_tls_import</a> (WOLFSSL *ssl, const unsigned char *buf, unsigned int sz)</td></tr>
<tr class="memdesc:ab67ddb8c518619de3c8987f6a7064464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to import a serialized TLS session. This function is for importing the state of the connection. WARNING: buf contains sensitive information about the state and is best to be encrypted before storing if stored. Additional debug info can be displayed with the macro WOLFSSL_SESSION_EXPORT_DEBUG defined.  <br /></td></tr>
<tr class="memitem:a65e317e419b97b46fd287f6ddd2d8b04" id="r_a65e317e419b97b46fd287f6ddd2d8b04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04">wolfSSL_CTX_dtls_set_export</a> (WOLFSSL_CTX *ctx, wc_dtls_export func)</td></tr>
<tr class="memdesc:a65e317e419b97b46fd287f6ddd2d8b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04" title="The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...">wolfSSL_CTX_dtls_set_export()</a> function is used to set the callback function for exporting a session. It is allowed to pass in NULL as the parameter func to clear the export function previously stored. Used on the server side and is called immediately after handshake is completed.  <br /></td></tr>
<tr class="memitem:a515a17c2d7dd1b2f79d9849fcec38c4e" id="r_a515a17c2d7dd1b2f79d9849fcec38c4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515a17c2d7dd1b2f79d9849fcec38c4e">wolfSSL_dtls_set_export</a> (WOLFSSL *ssl, wc_dtls_export func)</td></tr>
<tr class="memdesc:a515a17c2d7dd1b2f79d9849fcec38c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="#a515a17c2d7dd1b2f79d9849fcec38c4e" title="The wolfSSL_dtls_set_export() function is used to set the callback function for exporting a session....">wolfSSL_dtls_set_export()</a> function is used to set the callback function for exporting a session. It is allowed to pass in NULL as the parameter func to clear the export function previously stored. Used on the server side and is called immediately after handshake is completed.  <br /></td></tr>
<tr class="memitem:af072e84c62c596bacd4026b4b0078aeb" id="r_af072e84c62c596bacd4026b4b0078aeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af072e84c62c596bacd4026b4b0078aeb">wolfSSL_dtls_export</a> (WOLFSSL *ssl, unsigned char *buf, unsigned int *sz)</td></tr>
<tr class="memdesc:af072e84c62c596bacd4026b4b0078aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="#af072e84c62c596bacd4026b4b0078aeb" title="The wolfSSL_dtls_export() function is used to serialize a WOLFSSL session into the provided buffer....">wolfSSL_dtls_export()</a> function is used to serialize a WOLFSSL session into the provided buffer. Allows for less memory overhead than using a function callback for sending a session and choice over when the session is serialized. If buffer is NULL when passed to function then sz will be set to the size of buffer needed for serializing the WOLFSSL session.  <br /></td></tr>
<tr class="memitem:af845f62f7fb9a03a829e273a847fd617" id="r_af845f62f7fb9a03a829e273a847fd617"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af845f62f7fb9a03a829e273a847fd617">wolfSSL_tls_export</a> (WOLFSSL *ssl, unsigned char *buf, unsigned int *sz)</td></tr>
<tr class="memdesc:af845f62f7fb9a03a829e273a847fd617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to export a serialized TLS session. This function is for exporting a serialized state of the connection. In most cases wolfSSL_get1_session should be used instead of wolfSSL_tls_export. Additional debug info can be displayed with the macro WOLFSSL_SESSION_EXPORT_DEBUG defined. WARNING: buf contains sensitive information about the state and is best to be encrypted before storing if stored.  <br /></td></tr>
<tr class="memitem:a75be1b403d25b61275655315f5f2abad" id="r_a75be1b403d25b61275655315f5f2abad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75be1b403d25b61275655315f5f2abad">wolfSSL_CTX_load_static_memory</a> (WOLFSSL_CTX **ctx, wolfSSL_method_func method, unsigned char *buf, unsigned int sz, int flag, int max)</td></tr>
<tr class="memdesc:a75be1b403d25b61275655315f5f2abad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set aside static memory for a CTX. Memory set aside is then used for the CTX’s lifetime and for any SSL objects created from the CTX. By passing in a NULL ctx pointer and a wolfSSL_method_func function the creation of the CTX itself will also use static memory. wolfSSL_method_func has the function signature of WOLFSSL_METHOD* (<em>wolfSSL_method_func)(void</em> heap);. Passing in 0 for max makes it behave as if not set and no max concurrent use restrictions is in place. The flag value passed in determines how the memory is used and behavior while operating. Available flags are the following: 0 - default general memory, WOLFMEM_IO_POOL - used for input/output buffer when sending receiving messages and overrides general memory, so all memory in buffer passed in is used for IO, WOLFMEM_IO_FIXED - same as WOLFMEM_IO_POOL but each SSL now keeps two buffers to themselves for their lifetime, WOLFMEM_TRACK_STATS - each SSL keeps track of memory stats while running.  <br /></td></tr>
<tr class="memitem:abfbe388005d1f6474e4a21131127369a" id="r_abfbe388005d1f6474e4a21131127369a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfbe388005d1f6474e4a21131127369a">wolfSSL_CTX_is_static_memory</a> (WOLFSSL_CTX *ctx, WOLFSSL_MEM_STATS *mem_stats)</td></tr>
<tr class="memdesc:abfbe388005d1f6474e4a21131127369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does not change any of the connections behavior and is used only for gathering information about the static memory usage.  <br /></td></tr>
<tr class="memitem:a82d11d0414fbd4b8e06f7ecbd2ac0295" id="r_a82d11d0414fbd4b8e06f7ecbd2ac0295"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82d11d0414fbd4b8e06f7ecbd2ac0295">wolfSSL_is_static_memory</a> (WOLFSSL *ssl, WOLFSSL_MEM_CONN_STATS *mem_stats)</td></tr>
<tr class="memdesc:a82d11d0414fbd4b8e06f7ecbd2ac0295"><td class="mdescLeft">&#160;</td><td class="mdescRight">wolfSSL_is_static_memory is used to gather information about a SSL’s static memory usage. The return value indicates if static memory is being used and WOLFSSL_MEM_CONN_STATS will be filled out if and only if the flag WOLFMEM_TRACK_STATS was passed to the parent CTX when loading in static memory.  <br /></td></tr>
<tr class="memitem:ga5a31292b75b4caa4462a3305d2615beb" id="r_ga5a31292b75b4caa4462a3305d2615beb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga5a31292b75b4caa4462a3305d2615beb">wolfSSL_CTX_use_certificate_file</a> (WOLFSSL_CTX *ctx, const char *file, int format)</td></tr>
<tr class="memdesc:ga5a31292b75b4caa4462a3305d2615beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate file into the SSL context (WOLFSSL_CTX). The file is provided by the file argument. The format argument specifies the format type of the file, either SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gab80ef18b3232ebd19acab106b52feeb0" id="r_gab80ef18b3232ebd19acab106b52feeb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gab80ef18b3232ebd19acab106b52feeb0">wolfSSL_CTX_use_PrivateKey_file</a> (WOLFSSL_CTX *ctx, const char *file, int format)</td></tr>
<tr class="memdesc:gab80ef18b3232ebd19acab106b52feeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a private key file into the SSL context (WOLFSSL_CTX). The file is provided by the file argument. The format argument specifies the format type of the file - SSL_FILETYPE_ASN1or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gaf592c652b5d7a599ee511a394dfc488e" id="r_gaf592c652b5d7a599ee511a394dfc488e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf592c652b5d7a599ee511a394dfc488e">wolfSSL_CTX_load_verify_locations</a> (WOLFSSL_CTX *ctx, const char *file, const char *path)</td></tr>
<tr class="memdesc:gaf592c652b5d7a599ee511a394dfc488e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads PEM-formatted CA certificate files into the SSL context (WOLFSSL_CTX). These certificates will be treated as trusted root certificates and used to verify certs received from peers during the SSL handshake. The root certificate file, provided by the file argument, may be a single certificate or a file containing multiple certificates. If multiple CA certs are included in the same file, wolfSSL will load them in the same order they are presented in the file. The path argument is a pointer to the name of a directory that contains certificates of trusted root CAs. If the value of file is not NULL, path may be specified as NULL if not needed. If path is specified and NO_WOLFSSL_DIR was not defined when building the library, wolfSSL will load all CA certificates located in the given directory. This function will attempt to load all files in the directory. This function expects PEM formatted CERT_TYPE file with header “--&mdash;BEGIN CERTIFICATE--&mdash;”.  <br /></td></tr>
<tr class="memitem:ga26c3575b6ae26cffd13c5243fc4af8da" id="r_ga26c3575b6ae26cffd13c5243fc4af8da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga26c3575b6ae26cffd13c5243fc4af8da">wolfSSL_CTX_load_verify_locations_ex</a> (WOLFSSL_CTX *ctx, const char *file, const char *path, unsigned int flags)</td></tr>
<tr class="memdesc:ga26c3575b6ae26cffd13c5243fc4af8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads PEM-formatted CA certificate files into the SSL context (WOLFSSL_CTX). These certificates will be treated as trusted root certificates and used to verify certs received from peers during the SSL handshake. The root certificate file, provided by the file argument, may be a single certificate or a file containing multiple certificates. If multiple CA certs are included in the same file, wolfSSL will load them in the same order they are presented in the file. The path argument is a pointer to the name of a directory that contains certificates of trusted root CAs. If the value of file is not NULL, path may be specified as NULL if not needed. If path is specified and NO_WOLFSSL_DIR was not defined when building the library, wolfSSL will load all CA certificates located in the given directory. This function will attempt to load all files in the directory based on flags specified. This function expects PEM formatted CERT_TYPE files with header “--&mdash;BEGIN CERTIFICATE--&mdash;”.  <br /></td></tr>
<tr class="memitem:ga28286958744a8bc907fdd9af643383b0" id="r_ga28286958744a8bc907fdd9af643383b0"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga28286958744a8bc907fdd9af643383b0">wolfSSL_get_system_CA_dirs</a> (word32 *num)</td></tr>
<tr class="memdesc:ga28286958744a8bc907fdd9af643383b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to an array of strings representing directories wolfSSL will search for system CA certs when wolfSSL_CTX_load_system_CA_certs is called. On systems that don't store certificates in an accessible system directory (such as Apple platforms), this function will always return NULL.  <br /></td></tr>
<tr class="memitem:gaa66006fab6369002eda43cb4f83c857d" id="r_gaa66006fab6369002eda43cb4f83c857d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaa66006fab6369002eda43cb4f83c857d">wolfSSL_CTX_load_system_CA_certs</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:gaa66006fab6369002eda43cb4f83c857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">On most platforms (including Linux and Windows), this function attempts to load CA certificates into a WOLFSSL_CTX from an OS-dependent CA certificate store. Loaded certificates will be trusted.  <br /></td></tr>
<tr class="memitem:ga410f1b67992cec4688c7de175ea1cfc9" id="r_ga410f1b67992cec4688c7de175ea1cfc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga410f1b67992cec4688c7de175ea1cfc9">wolfSSL_CTX_trust_peer_cert</a> (WOLFSSL_CTX *ctx, const char *file, int type)</td></tr>
<tr class="memdesc:ga410f1b67992cec4688c7de175ea1cfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate to use for verifying a peer when performing a TLS/SSL handshake. The peer certificate sent during the handshake is compared by using the SKID when available and the signature. If these two things do not match then any loaded CAs are used. Feature is enabled by defining the macro WOLFSSL_TRUST_PEER_CERT. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga833efbfe54c5ab598a351ab332e9500e" id="r_ga833efbfe54c5ab598a351ab332e9500e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga833efbfe54c5ab598a351ab332e9500e">wolfSSL_CTX_use_certificate_chain_file</a> (WOLFSSL_CTX *ctx, const char *file)</td></tr>
<tr class="memdesc:ga833efbfe54c5ab598a351ab332e9500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a chain of certificates into the SSL context (WOLFSSL_CTX). The file containing the certificate chain is provided by the file argument, and must contain PEM-formatted certificates. This function will process up to MAX_CHAIN_DEPTH (default = 9, defined in internal.h) certificates, plus the subject cert.  <br /></td></tr>
<tr class="memitem:ga5ac4ee334e34247e03b25a05f1b63f31" id="r_ga5ac4ee334e34247e03b25a05f1b63f31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga5ac4ee334e34247e03b25a05f1b63f31">wolfSSL_CTX_use_RSAPrivateKey_file</a> (WOLFSSL_CTX *ctx, const char *file, int format)</td></tr>
<tr class="memdesc:ga5ac4ee334e34247e03b25a05f1b63f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the private RSA key used in the SSL connection into the SSL context (WOLFSSL_CTX). This function is only available when wolfSSL has been compiled with the OpenSSL compatibility layer enabled (&ndash;enable-opensslExtra, #define OPENSSL_EXTRA), and is identical to the more-typically used <a class="el" href="group__CertsKeys.html#gab80ef18b3232ebd19acab106b52feeb0" title="This function loads a private key file into the SSL context (WOLFSSL_CTX). The file is provided by th...">wolfSSL_CTX_use_PrivateKey_file()</a> function. The file argument contains a pointer to the RSA private key file, in the format specified by format.  <br /></td></tr>
<tr class="memitem:ga762a42460ba55d5fc8265acc535573b9" id="r_ga762a42460ba55d5fc8265acc535573b9"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga762a42460ba55d5fc8265acc535573b9">wolfSSL_get_verify_depth</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga762a42460ba55d5fc8265acc535573b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the maximum chain depth allowed, which is 9 by default, for a valid session i.e. there is a non-null session object (ssl).  <br /></td></tr>
<tr class="memitem:ga5c8ab38f2c65aad78ac9dc9cb70416ba" id="r_ga5c8ab38f2c65aad78ac9dc9cb70416ba"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga5c8ab38f2c65aad78ac9dc9cb70416ba">wolfSSL_CTX_get_verify_depth</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga5c8ab38f2c65aad78ac9dc9cb70416ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the certificate chaining depth using the CTX structure.  <br /></td></tr>
<tr class="memitem:gabc3597e8f838c48740498196b3a9d61d" id="r_gabc3597e8f838c48740498196b3a9d61d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gabc3597e8f838c48740498196b3a9d61d">wolfSSL_use_certificate_file</a> (WOLFSSL *ssl, const char *file, int format)</td></tr>
<tr class="memdesc:gabc3597e8f838c48740498196b3a9d61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate file into the SSL session (WOLFSSL structure). The certificate file is provided by the file argument. The format argument specifies the format type of the file - either SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.  <br /></td></tr>
<tr class="memitem:ga99e95fd9a63e9784ccd22c494d3d5f48" id="r_ga99e95fd9a63e9784ccd22c494d3d5f48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga99e95fd9a63e9784ccd22c494d3d5f48">wolfSSL_use_PrivateKey_file</a> (WOLFSSL *ssl, const char *file, int format)</td></tr>
<tr class="memdesc:ga99e95fd9a63e9784ccd22c494d3d5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a private key file into the SSL session (WOLFSSL structure). The key file is provided by the file argument. The format argument specifies the format type of the file - SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.  <br /></td></tr>
<tr class="memitem:ga5c2fb9d299fe7522f2bc9249e333ae6a" id="r_ga5c2fb9d299fe7522f2bc9249e333ae6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga5c2fb9d299fe7522f2bc9249e333ae6a">wolfSSL_use_certificate_chain_file</a> (WOLFSSL *ssl, const char *file)</td></tr>
<tr class="memdesc:ga5c2fb9d299fe7522f2bc9249e333ae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a chain of certificates into the SSL session (WOLFSSL structure). The file containing the certificate chain is provided by the file argument, and must contain PEM-formatted certificates. This function will process up to MAX_CHAIN_DEPTH (default = 9, defined in internal.h) certificates, plus the subject certificate.  <br /></td></tr>
<tr class="memitem:ga4d441e98207dd84508fcf496e4d6ec08" id="r_ga4d441e98207dd84508fcf496e4d6ec08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga4d441e98207dd84508fcf496e4d6ec08">wolfSSL_use_RSAPrivateKey_file</a> (WOLFSSL *ssl, const char *file, int format)</td></tr>
<tr class="memdesc:ga4d441e98207dd84508fcf496e4d6ec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the private RSA key used in the SSL connection into the SSL session (WOLFSSL structure). This function is only available when wolfSSL has been compiled with the OpenSSL compatibility layer enabled (&ndash;enable-opensslExtra, #define OPENSSL_EXTRA), and is identical to the more-typically used <a class="el" href="group__openSSL.html#ga99e95fd9a63e9784ccd22c494d3d5f48" title="This function loads a private key file into the SSL session (WOLFSSL structure). The key file is prov...">wolfSSL_use_PrivateKey_file()</a> function. The file argument contains a pointer to the RSA private key file, in the format specified by format.  <br /></td></tr>
<tr class="memitem:gaca2daaf266393e5cd3a1d4bfdf48cf31" id="r_gaca2daaf266393e5cd3a1d4bfdf48cf31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaca2daaf266393e5cd3a1d4bfdf48cf31">wolfSSL_CTX_der_load_verify_locations</a> (WOLFSSL_CTX *ctx, const char *file, int format)</td></tr>
<tr class="memdesc:gaca2daaf266393e5cd3a1d4bfdf48cf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to wolfSSL_CTX_load_verify_locations, but allows the loading of DER-formatted CA files into the SSL context (WOLFSSL_CTX). It may still be used to load PEM-formatted CA files as well. These certificates will be treated as trusted root certificates and used to verify certs received from peers during the SSL handshake. The root certificate file, provided by the file argument, may be a single certificate or a file containing multiple certificates. If multiple CA certs are included in the same file, wolfSSL will load them in the same order they are presented in the file. The format argument specifies the format which the certificates are in either, SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1 (DER). Unlike wolfSSL_CTX_load_verify_locations, this function does not allow the loading of CA certificates from a given directory path. Note that this function is only available when the wolfSSL library was compiled with WOLFSSL_DER_LOAD defined.  <br /></td></tr>
<tr class="memitem:ga2bcaa81e9fd11074c6e504891370dd45" id="r_ga2bcaa81e9fd11074c6e504891370dd45"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CTX *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a> (WOLFSSL_METHOD *)</td></tr>
<tr class="memdesc:ga2bcaa81e9fd11074c6e504891370dd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.  <br /></td></tr>
<tr class="memitem:gab6d54b7485d74962e57bc636008aa9a0" id="r_gab6d54b7485d74962e57bc636008aa9a0"><td class="memItemLeft" align="right" valign="top">WOLFSSL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:gab6d54b7485d74962e57bc636008aa9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new SSL session, taking an already created SSL context as input.  <br /></td></tr>
<tr class="memitem:ga3fea7387eeb7c90feeff9ae4e523bda7" id="r_ga3fea7387eeb7c90feeff9ae4e523bda7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga3fea7387eeb7c90feeff9ae4e523bda7">wolfSSL_set_fd</a> (WOLFSSL *ssl, int fd)</td></tr>
<tr class="memdesc:ga3fea7387eeb7c90feeff9ae4e523bda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a file descriptor (fd) as the input/output facility for the SSL connection. Typically this will be a socket file descriptor.  <br /></td></tr>
<tr class="memitem:gad9984a960b13e12a6020e48f4c2aeb14" id="r_gad9984a960b13e12a6020e48f4c2aeb14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gad9984a960b13e12a6020e48f4c2aeb14">wolfSSL_set_dtls_fd_connected</a> (WOLFSSL *ssl, int fd)</td></tr>
<tr class="memdesc:gad9984a960b13e12a6020e48f4c2aeb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a file descriptor (fd) as the input/output facility for the SSL connection. Typically this will be a socket file descriptor. This is a DTLS specific API because it marks that the socket is connected. recvfrom and sendto calls on this fd will have the addr and addr_len parameters set to NULL.  <br /></td></tr>
<tr class="memitem:gaf87b731fd058eba73db8df6fc43abc88" id="r_gaf87b731fd058eba73db8df6fc43abc88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf87b731fd058eba73db8df6fc43abc88">wolfDTLS_SetChGoodCb</a> (WOLFSSL *ssl, ClientHelloGoodCb cb, void *user_ctx)</td></tr>
<tr class="memdesc:gaf87b731fd058eba73db8df6fc43abc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting a callback for a correctly processed and verified DTLS client hello. When using a cookie exchange mechanism (either the HelloVerifyRequest in DTLS 1.2 or the HelloRetryRequest with a cookie extension in DTLS 1.3) this callback is called after the cookie exchange has succeeded. This is useful to use one WOLFSSL object as the listener for new connections and being able to isolate the WOLFSSL object once the ClientHello is verified (either through a cookie exchange or just checking if the ClientHello had the correct format). DTLS 1.2: <a href="https://datatracker.ietf.org/doc/html/rfc6347#section-4.2.1">https://datatracker.ietf.org/doc/html/rfc6347#section-4.2.1</a> DTLS 1.3: <a href="https://www.rfc-editor.org/rfc/rfc8446#section-4.2.2">https://www.rfc-editor.org/rfc/rfc8446#section-4.2.2</a>.  <br /></td></tr>
<tr class="memitem:ga15a272d692a7cab4d991c5b1cf9d49cf" id="r_ga15a272d692a7cab4d991c5b1cf9d49cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga15a272d692a7cab4d991c5b1cf9d49cf">wolfSSL_get_cipher_list</a> (int priority)</td></tr>
<tr class="memdesc:ga15a272d692a7cab4d991c5b1cf9d49cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of cipher at priority level passed in.  <br /></td></tr>
<tr class="memitem:gadb0f97124908e6fa173259ccccc678da" id="r_gadb0f97124908e6fa173259ccccc678da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gadb0f97124908e6fa173259ccccc678da">wolfSSL_get_ciphers</a> (char *buf, int len)</td></tr>
<tr class="memdesc:gadb0f97124908e6fa173259ccccc678da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the ciphers enabled in wolfSSL.  <br /></td></tr>
<tr class="memitem:ga7d30914ff0d7476576faea4115228703" id="r_ga7d30914ff0d7476576faea4115228703"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga7d30914ff0d7476576faea4115228703">wolfSSL_get_cipher_name</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga7d30914ff0d7476576faea4115228703"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_cipher_name_internal.  <br /></td></tr>
<tr class="memitem:gacc9ea6f4b1ca94ebd240a0752a9600f8" id="r_gacc9ea6f4b1ca94ebd240a0752a9600f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gacc9ea6f4b1ca94ebd240a0752a9600f8">wolfSSL_get_fd</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:gacc9ea6f4b1ca94ebd240a0752a9600f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the read file descriptor (fd) used as the input facility for the SSL connection. Typically this will be a socket file descriptor.  <br /></td></tr>
<tr class="memitem:ga956eb1db5163203c2c5948cf2a7fe924" id="r_ga956eb1db5163203c2c5948cf2a7fe924"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga956eb1db5163203c2c5948cf2a7fe924">wolfSSL_get_wfd</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:ga956eb1db5163203c2c5948cf2a7fe924"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the write file descriptor (fd) used as the output facility for the SSL connection. Typically this will be a socket file descriptor.  <br /></td></tr>
<tr class="memitem:ga64025d60f962a3c1ea267dc195eab8e7" id="r_ga64025d60f962a3c1ea267dc195eab8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga64025d60f962a3c1ea267dc195eab8e7">wolfSSL_set_using_nonblock</a> (WOLFSSL *ssl, int nonblock)</td></tr>
<tr class="memdesc:ga64025d60f962a3c1ea267dc195eab8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function informs the WOLFSSL object that the underlying I/O is non-blocking. After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call <a class="el" href="group__Setup.html#ga64025d60f962a3c1ea267dc195eab8e7" title="This function informs the WOLFSSL object that the underlying I/O is non-blocking. After an applicatio...">wolfSSL_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.  <br /></td></tr>
<tr class="memitem:ga1b5127f98989a255a2d7aa346a677a12" id="r_ga1b5127f98989a255a2d7aa346a677a12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1b5127f98989a255a2d7aa346a677a12">wolfSSL_get_using_nonblock</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga1b5127f98989a255a2d7aa346a677a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the application to determine if wolfSSL is using non-blocking I/O. If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0. After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call <a class="el" href="group__Setup.html#ga64025d60f962a3c1ea267dc195eab8e7" title="This function informs the WOLFSSL object that the underlying I/O is non-blocking. After an applicatio...">wolfSSL_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.  <br /></td></tr>
<tr class="memitem:gad6cbb3cb90e4d606e9507e4ec06197df" id="r_gad6cbb3cb90e4d606e9507e4ec06197df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a> (WOLFSSL *ssl, const void *data, int sz)</td></tr>
<tr class="memdesc:gad6cbb3cb90e4d606e9507e4ec06197df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary, <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. When using (D)TLSv1.3 and early data feature is compiled in, this function progresses the handshake only up to the point when it is possible to send data. Next invocations of wolfSSL_Connect()/wolfSSL_Accept()/wolfSSL_read() will complete the handshake. <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will only return once the buffer data of size sz has been completely written or an error occurred.  <br /></td></tr>
<tr class="memitem:ga80c3ccd3c0441c77307df3afe88a5c35" id="r_ga80c3ccd3c0441c77307df3afe88a5c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a> (WOLFSSL *ssl, void *data, int sz)</td></tr>
<tr class="memdesc:ga80c3ccd3c0441c77307df3afe88a5c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data. The bytes read are removed from the internal receive buffer. If necessary <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_read() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:gaf7f748e1605c2d37119105d61a592290" id="r_gaf7f748e1605c2d37119105d61a592290"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaf7f748e1605c2d37119105d61a592290">wolfSSL_peek</a> (WOLFSSL *ssl, void *data, int sz)</td></tr>
<tr class="memdesc:gaf7f748e1605c2d37119105d61a592290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data. This function is identical to <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that the data in the internal SSL session receive buffer is not removed or modified. If necessary, like <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>, <a class="el" href="group__IO.html#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="group__IO.html#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="group__IO.html#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> / <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_peek() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="group__IO.html#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:gaf0cfc676947d7eabd67ec1a4661ed625" id="r_gaf0cfc676947d7eabd67ec1a4661ed625"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gaf0cfc676947d7eabd67ec1a4661ed625"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred.  <br /></td></tr>
<tr class="memitem:gaacf169259b58f3441614c6a992d89afd" id="r_gaacf169259b58f3441614c6a992d89afd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaacf169259b58f3441614c6a992d89afd">wolfDTLS_accept_stateless</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaacf169259b58f3441614c6a992d89afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and statelessly listens for an SSL client to initiate the DTLS handshake.  <br /></td></tr>
<tr class="memitem:gabe86939065276c9271a17d799860535d" id="r_gabe86939065276c9271a17d799860535d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gabe86939065276c9271a17d799860535d">wolfSSL_CTX_free</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:gabe86939065276c9271a17d799860535d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an allocated WOLFSSL_CTX object. This function decrements the CTX reference count and only frees the context when the reference count has reached 0.  <br /></td></tr>
<tr class="memitem:ga640f0a9e17f4727e996fc8bab4eee3c6" id="r_ga640f0a9e17f4727e996fc8bab4eee3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga640f0a9e17f4727e996fc8bab4eee3c6">wolfSSL_free</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga640f0a9e17f4727e996fc8bab4eee3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an allocated wolfSSL object.  <br /></td></tr>
<tr class="memitem:ga51f54ec99e4d87f4b25a92fe031439ae" id="r_ga51f54ec99e4d87f4b25a92fe031439ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae">wolfSSL_shutdown</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga51f54ec99e4d87f4b25a92fe031439ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will try to send a “close notify” alert to the peer. The calling application can choose to wait for the peer to send its “close notify” alert in response or just go ahead and shut down the underlying connection after directly calling wolfSSL_shutdown (to save resources). Either option is allowed by the TLS specification. If the underlying connection will be used again in the future, the complete two-directional shutdown procedure must be performed to keep synchronization intact between the peers. <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> will return an error if the underlying I/O could not satisfy the needs of <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> when the underlying I/O is ready.  <br /></td></tr>
<tr class="memitem:ga1eea65c61599bf523a87f1d8f82a4cef" id="r_ga1eea65c61599bf523a87f1d8f82a4cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef">wolfSSL_send</a> (WOLFSSL *ssl, const void *data, int sz, int flags)</td></tr>
<tr class="memdesc:ga1eea65c61599bf523a87f1d8f82a4cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified flags for the underlying write operation. If necessary <a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. <a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_send to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="group__IO.html#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will only return once the buffer data of size sz has been completely written or an error occurred.  <br /></td></tr>
<tr class="memitem:gaa47f91e3700231c0ac95d29663cb46d3" id="r_gaa47f91e3700231c0ac95d29663cb46d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa47f91e3700231c0ac95d29663cb46d3">wolfSSL_recv</a> (WOLFSSL *ssl, void *data, int sz, int flags)</td></tr>
<tr class="memdesc:gaa47f91e3700231c0ac95d29663cb46d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data using the specified flags for the underlying recv operation. The bytes read are removed from the internal receive buffer. This function is identical to <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that it allows the application to set the recv flags for the underlying read operation. If necessary <a class="el" href="group__IO.html#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="group__IO.html#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="group__IO.html#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_recv() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="group__IO.html#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:gaafd5671d443fa684913ba5955a4eb591" id="r_gaafd5671d443fa684913ba5955a4eb591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a> (WOLFSSL *ssl, int ret)</td></tr>
<tr class="memdesc:gaafd5671d443fa684913ba5955a4eb591"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a unique error code describing why the previous API function call (wolfSSL_connect, wolfSSL_accept, wolfSSL_read, wolfSSL_write, etc.) resulted in an error return code (SSL_FAILURE). The return value of the previous function is passed to wolfSSL_get_error through ret. After wolfSSL_get_error is called and returns the unique error code, <a class="el" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610" title="This function converts an error code returned by wolfSSL_get_error() into a more human-readable error...">wolfSSL_ERR_error_string()</a> may be called to get a human-readable error string. See <a class="el" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610" title="This function converts an error code returned by wolfSSL_get_error() into a more human-readable error...">wolfSSL_ERR_error_string()</a> for more information.  <br /></td></tr>
<tr class="memitem:ga29e520b2f3fbc6b9c2fbe774b5516b83" id="r_ga29e520b2f3fbc6b9c2fbe774b5516b83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga29e520b2f3fbc6b9c2fbe774b5516b83">wolfSSL_get_alert_history</a> (WOLFSSL *ssl, WOLFSSL_ALERT_HISTORY *h)</td></tr>
<tr class="memdesc:ga29e520b2f3fbc6b9c2fbe774b5516b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the alert history.  <br /></td></tr>
<tr class="memitem:ga7dec51eac167358e439747b5050d5acd" id="r_ga7dec51eac167358e439747b5050d5acd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd">wolfSSL_set_session</a> (WOLFSSL *ssl, WOLFSSL_SESSION *session)</td></tr>
<tr class="memdesc:ga7dec51eac167358e439747b5050d5acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS connection. For session resumption, before calling <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> with your session object, an application should save the session ID from the object with a call to <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a>, which returns a pointer to the session. Later, the application should create a new WOLFSSL object and assign the saved session with <a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session()</a>. At this point, the application may call <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> and wolfSSL will try to resume the session. The wolfSSL server code allows session resumption by default. The object returned by <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a> needs to be freed after the application is done with it by calling wolfSSL_SESSION_free() on it.  <br /></td></tr>
<tr class="memitem:gaad042d5e0b1e7c2635b6caa12619e0f1" id="r_gaad042d5e0b1e7c2635b6caa12619e0f1"><td class="memItemLeft" align="right" valign="top">WOLFSSL_SESSION *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaad042d5e0b1e7c2635b6caa12619e0f1">wolfSSL_get_session</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaad042d5e0b1e7c2635b6caa12619e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">When NO_SESSION_CACHE_REF is defined this function returns a pointer to the current session (WOLFSSL_SESSION) used in ssl. This function returns a non-persistent pointer to the WOLFSSL_SESSION object. The pointer returned will be freed when wolfSSL_free is called. This call should only be used to inspect or modify the current session. For session resumption it is recommended to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a>. For backwards compatibility when NO_SESSION_CACHE_REF is not defined this function returns a persistent session object pointer that is stored in the local cache. The cache size is finite and there is a risk that the session object will be overwritten by another ssl connection by the time the application calls <a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session()</a> on it. It is recommended to define NO_SESSION_CACHE_REF in your application and to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a> for session resumption.  <br /></td></tr>
<tr class="memitem:ga4a1a3b8e4350d41d9f5e485e315bccc9" id="r_ga4a1a3b8e4350d41d9f5e485e315bccc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga4a1a3b8e4350d41d9f5e485e315bccc9">wolfSSL_flush_sessions</a> (WOLFSSL_CTX *ctx, long tm)</td></tr>
<tr class="memdesc:ga4a1a3b8e4350d41d9f5e485e315bccc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function flushes session from the session cache which have expired. The time, tm, is used for the time comparison. Note that wolfSSL currently uses a static table for sessions, so no flushing is needed. As such, this function is currently just a stub. This function provides OpenSSL compatibility (SSL_flush_sessions) when wolfSSL is compiled with the OpenSSL compatibility layer.  <br /></td></tr>
<tr class="memitem:ga8aec710d0abb45c5f0ddcbfd635335ef" id="r_ga8aec710d0abb45c5f0ddcbfd635335ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga8aec710d0abb45c5f0ddcbfd635335ef">wolfSSL_SetServerID</a> (WOLFSSL *ssl, const unsigned char *id, int len, int newSession)</td></tr>
<tr class="memdesc:ga8aec710d0abb45c5f0ddcbfd635335ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function associates the client session with the server id. If the newSession flag is on, an existing session won’t be reused.  <br /></td></tr>
<tr class="memitem:ga54930dd8cf9ac220eb44ad274d341795" id="r_ga54930dd8cf9ac220eb44ad274d341795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga54930dd8cf9ac220eb44ad274d341795">wolfSSL_GetSessionIndex</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga54930dd8cf9ac220eb44ad274d341795"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the session index of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gab4a7dcdbfd357dced461795383b04bf2" id="r_gab4a7dcdbfd357dced461795383b04bf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gab4a7dcdbfd357dced461795383b04bf2">wolfSSL_GetSessionAtIndex</a> (int idx, WOLFSSL_SESSION *session)</td></tr>
<tr class="memdesc:gab4a7dcdbfd357dced461795383b04bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the session at specified index of the session cache and copies it into memory. The WOLFSSL_SESSION structure holds the session information.  <br /></td></tr>
<tr class="memitem:ga0115589990495d8f79c18bda0363d84c" id="r_ga0115589990495d8f79c18bda0363d84c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_CHAIN *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga0115589990495d8f79c18bda0363d84c">wolfSSL_SESSION_get_peer_chain</a> (WOLFSSL_SESSION *session)</td></tr>
<tr class="memdesc:ga0115589990495d8f79c18bda0363d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the peer certificate chain from the WOLFSSL_SESSION struct.  <br /></td></tr>
<tr class="memitem:ga26c623e093cf15f81cdfc3bb26682089" id="r_ga26c623e093cf15f81cdfc3bb26682089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga26c623e093cf15f81cdfc3bb26682089">wolfSSL_CTX_set_verify</a> (WOLFSSL_CTX *ctx, int mode, VerifyCallback verify_callback)</td></tr>
<tr class="memdesc:ga26c623e093cf15f81cdfc3bb26682089"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the verification method for remote peers and also allows a verify callback to be registered with the SSL context. The verify callback will be called only when a verification failure has occurred. If no verify callback is desired, the NULL pointer can be used for verify_callback. The verification mode of peer certificates is a logically OR’d list of flags. The possible flag values include: SSL_VERIFY_NONE Client mode: the client will not verify the certificate received from the server and the handshake will continue as normal. Server mode: the server will not send a certificate request to the client. As such, client verification will not be enabled. SSL_VERIFY_PEER Client mode: the client will verify the certificate received from the server during the handshake. This is turned on by default in wolfSSL, therefore, using this option has no effect. Server mode: the server will send a certificate request to the client and verify the client certificate received. SSL_VERIFY_FAIL_IF_NO_PEER_CERT Client mode: no effect when used on the client side. Server mode: the verification will fail on the server side if the client fails to send a certificate when requested to do so (when using SSL_VERIFY_PEER on the SSL server). SSL_VERIFY_FAIL_EXCEPT_PSK Client mode: no effect when used on the client side. Server mode: the verification is the same as SSL_VERIFY_FAIL_IF_NO_PEER_CERT except in the case of a PSK connection. If a PSK connection is being made then the connection will go through without a peer cert.  <br /></td></tr>
<tr class="memitem:gaf9198658e31dd291088be18262ef2354" id="r_gaf9198658e31dd291088be18262ef2354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf9198658e31dd291088be18262ef2354">wolfSSL_set_verify</a> (WOLFSSL *ssl, int mode, VerifyCallback verify_callback)</td></tr>
<tr class="memdesc:gaf9198658e31dd291088be18262ef2354"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the verification method for remote peers and also allows a verify callback to be registered with the SSL session. The verify callback will be called only when a verification failure has occurred. If no verify callback is desired, the NULL pointer can be used for verify_callback. The verification mode of peer certificates is a logically OR’d list of flags. The possible flag values include: SSL_VERIFY_NONE Client mode: the client will not verify the certificate received from the server and the handshake will continue as normal. Server mode: the server will not send a certificate request to the client. As such, client verification will not be enabled. SSL_VERIFY_PEER Client mode: the client will verify the certificate received from the server during the handshake. This is turned on by default in wolfSSL, therefore, using this option has no effect. Server mode: the server will send a certificate request to the client and verify the client certificate received. SSL_VERIFY_FAIL_IF_NO_PEER_CERT Client mode: no effect when used on the client side. Server mode: the verification will fail on the server side if the client fails to send a certificate when requested to do so (when using SSL_VERIFY_PEER on the SSL server). SSL_VERIFY_FAIL_EXCEPT_PSK Client mode: no effect when used on the client side. Server mode: the verification is the same as SSL_VERIFY_FAIL_IF_NO_PEER_CERT except in the case of a PSK connection. If a PSK connection is being made then the connection will go through without a peer cert.  <br /></td></tr>
<tr class="memitem:gaf49bce67bef33a0b4b91c2259d389ca9" id="r_gaf49bce67bef33a0b4b91c2259d389ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf49bce67bef33a0b4b91c2259d389ca9">wolfSSL_SetCertCbCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:gaf49bce67bef33a0b4b91c2259d389ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores user CTX object information for verify callback.  <br /></td></tr>
<tr class="memitem:ga421a2372fb9887055404f014ced9a795" id="r_ga421a2372fb9887055404f014ced9a795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga421a2372fb9887055404f014ced9a795">wolfSSL_CTX_SetCertCbCtx</a> (WOLFSSL_CTX *ctx, void *userCtx)</td></tr>
<tr class="memdesc:ga421a2372fb9887055404f014ced9a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores user CTX object information for verify callback.  <br /></td></tr>
<tr class="memitem:ga423dba3e8ffd23f2a3eb38555368792b" id="r_ga423dba3e8ffd23f2a3eb38555368792b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga423dba3e8ffd23f2a3eb38555368792b">wolfSSL_pending</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga423dba3e8ffd23f2a3eb38555368792b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of bytes which are buffered and available in the SSL object to be read by <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>.  <br /></td></tr>
<tr class="memitem:ga688146c77e8d4b693d81c4a1f295b126" id="r_ga688146c77e8d4b693d81c4a1f295b126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga688146c77e8d4b693d81c4a1f295b126">wolfSSL_load_error_strings</a> (void)</td></tr>
<tr class="memdesc:ga688146c77e8d4b693d81c4a1f295b126"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is for OpenSSL compatibility (SSL_load_error_string) only and takes no action.  <br /></td></tr>
<tr class="memitem:ga5dd6220863840b6c1476a6f1f67cfc95" id="r_ga5dd6220863840b6c1476a6f1f67cfc95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga5dd6220863840b6c1476a6f1f67cfc95">wolfSSL_library_init</a> (void)</td></tr>
<tr class="memdesc:ga5dd6220863840b6c1476a6f1f67cfc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called internally in <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. This function is a wrapper around <a class="el" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737" title="Initializes the wolfSSL library for use. Must be called once per application and before any other cal...">wolfSSL_Init()</a> and exists for OpenSSL compatibility (SSL_library_init) when wolfSSL has been compiled with OpenSSL compatibility layer. <a class="el" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737" title="Initializes the wolfSSL library for use. Must be called once per application and before any other cal...">wolfSSL_Init()</a> is the more typically-used wolfSSL initialization function.  <br /></td></tr>
<tr class="memitem:a706356ae2ac664740d36b2a53abe5c36" id="r_a706356ae2ac664740d36b2a53abe5c36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706356ae2ac664740d36b2a53abe5c36">wolfSSL_SetDevId</a> (WOLFSSL *ssl, int devId)</td></tr>
<tr class="memdesc:a706356ae2ac664740d36b2a53abe5c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Device Id at the WOLFSSL session level.  <br /></td></tr>
<tr class="memitem:a4eb1f02e6f8e0d20e7739c81478f0930" id="r_a4eb1f02e6f8e0d20e7739c81478f0930"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb1f02e6f8e0d20e7739c81478f0930">wolfSSL_CTX_SetDevId</a> (WOLFSSL_CTX *ctx, int devId)</td></tr>
<tr class="memdesc:a4eb1f02e6f8e0d20e7739c81478f0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Device Id at the WOLFSSL_CTX context level.  <br /></td></tr>
<tr class="memitem:a0950b92f3358093047d4e2a7bd744b9e" id="r_a0950b92f3358093047d4e2a7bd744b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0950b92f3358093047d4e2a7bd744b9e">wolfSSL_CTX_GetDevId</a> (WOLFSSL_CTX *ctx, WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a0950b92f3358093047d4e2a7bd744b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the Device Id.  <br /></td></tr>
<tr class="memitem:ga2f1ca30a703bfe71219f97bc440c34cf" id="r_ga2f1ca30a703bfe71219f97bc440c34cf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga2f1ca30a703bfe71219f97bc440c34cf">wolfSSL_CTX_set_session_cache_mode</a> (WOLFSSL_CTX *ctx, long mode)</td></tr>
<tr class="memdesc:ga2f1ca30a703bfe71219f97bc440c34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disables SSL session caching. Behavior depends on the value used for mode. The following values for mode are available: SSL_SESS_CACHE_OFF- disable session caching. Session caching is turned on by default. SSL_SESS_CACHE_NO_AUTO_CLEAR - Disable auto-flushing of the session cache. Auto-flushing is turned on by default.  <br /></td></tr>
<tr class="memitem:a1b29e3dd5cd00ad2802f081109cb3da1" id="r_a1b29e3dd5cd00ad2802f081109cb3da1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b29e3dd5cd00ad2802f081109cb3da1">wolfSSL_set_session_secret_cb</a> (WOLFSSL *ssl, SessionSecretCb cb, void *ctx)</td></tr>
<tr class="memdesc:a1b29e3dd5cd00ad2802f081109cb3da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session secret callback function. The SessionSecretCb type has the signature: int (<em>SessionSecretCb)(WOLFSSL</em> ssl, void* secret, int* secretSz, void* ctx). The sessionSecretCb member of the WOLFSSL struct is set to the parameter cb.  <br /></td></tr>
<tr class="memitem:ga20fc275712951d213a148883ecdf285e" id="r_ga20fc275712951d213a148883ecdf285e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga20fc275712951d213a148883ecdf285e">wolfSSL_save_session_cache</a> (const char *fname)</td></tr>
<tr class="memdesc:ga20fc275712951d213a148883ecdf285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persists the session cache to file. It doesn’t use memsave because of additional memory use.  <br /></td></tr>
<tr class="memitem:ga12e7e6b57f8b1edb62a37e2ea63eb056" id="r_ga12e7e6b57f8b1edb62a37e2ea63eb056"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga12e7e6b57f8b1edb62a37e2ea63eb056">wolfSSL_restore_session_cache</a> (const char *fname)</td></tr>
<tr class="memdesc:ga12e7e6b57f8b1edb62a37e2ea63eb056"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the persistent session cache from file. It does not use memstore because of additional memory use.  <br /></td></tr>
<tr class="memitem:ga184b8366465a5cf8d477d2a45e89eaf9" id="r_ga184b8366465a5cf8d477d2a45e89eaf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga184b8366465a5cf8d477d2a45e89eaf9">wolfSSL_memsave_session_cache</a> (void *mem, int sz)</td></tr>
<tr class="memdesc:ga184b8366465a5cf8d477d2a45e89eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persists session cache to memory.  <br /></td></tr>
<tr class="memitem:ga1d2b0be768745cb1383ad126e7af2576" id="r_ga1d2b0be768745cb1383ad126e7af2576"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1d2b0be768745cb1383ad126e7af2576">wolfSSL_memrestore_session_cache</a> (const void *mem, int sz)</td></tr>
<tr class="memdesc:ga1d2b0be768745cb1383ad126e7af2576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the persistent session cache from memory.  <br /></td></tr>
<tr class="memitem:ga788f4e18e0e6ed15480c857e90def619" id="r_ga788f4e18e0e6ed15480c857e90def619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga788f4e18e0e6ed15480c857e90def619">wolfSSL_get_session_cache_memsize</a> (void)</td></tr>
<tr class="memdesc:ga788f4e18e0e6ed15480c857e90def619"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns how large the session cache save buffer should be.  <br /></td></tr>
<tr class="memitem:gaa036058d2437cc005fc36d4f0ea30dec" id="r_gaa036058d2437cc005fc36d4f0ea30dec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaa036058d2437cc005fc36d4f0ea30dec">wolfSSL_CTX_save_cert_cache</a> (WOLFSSL_CTX *ctx, const char *fname)</td></tr>
<tr class="memdesc:gaa036058d2437cc005fc36d4f0ea30dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the cert cache from memory to file.  <br /></td></tr>
<tr class="memitem:gaef51ed628032e3a51c044d20c6482b5c" id="r_gaef51ed628032e3a51c044d20c6482b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaef51ed628032e3a51c044d20c6482b5c">wolfSSL_CTX_restore_cert_cache</a> (WOLFSSL_CTX *ctx, const char *fname)</td></tr>
<tr class="memdesc:gaef51ed628032e3a51c044d20c6482b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persistes certificate cache from a file.  <br /></td></tr>
<tr class="memitem:ga0085cb1b6a88cd70103fba659aa66dca" id="r_ga0085cb1b6a88cd70103fba659aa66dca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga0085cb1b6a88cd70103fba659aa66dca">wolfSSL_CTX_memsave_cert_cache</a> (WOLFSSL_CTX *ctx, void *mem, int sz, int *used)</td></tr>
<tr class="memdesc:ga0085cb1b6a88cd70103fba659aa66dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persists the certificate cache to memory.  <br /></td></tr>
<tr class="memitem:gaef5e874745a560f5e32be8bb4609fe62" id="r_gaef5e874745a560f5e32be8bb4609fe62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaef5e874745a560f5e32be8bb4609fe62">wolfSSL_CTX_memrestore_cert_cache</a> (WOLFSSL_CTX *ctx, const void *mem, int sz)</td></tr>
<tr class="memdesc:gaef5e874745a560f5e32be8bb4609fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the certificate cache from memory.  <br /></td></tr>
<tr class="memitem:ga5f33bcf23cf35fdb225a4d7682fc00d5" id="r_ga5f33bcf23cf35fdb225a4d7682fc00d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga5f33bcf23cf35fdb225a4d7682fc00d5">wolfSSL_CTX_get_cert_cache_memsize</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga5f33bcf23cf35fdb225a4d7682fc00d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size the certificate cache save buffer needs to be.  <br /></td></tr>
<tr class="memitem:gafa55814f56bd7a36f4035d71b2b31832" id="r_gafa55814f56bd7a36f4035d71b2b31832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gafa55814f56bd7a36f4035d71b2b31832">wolfSSL_CTX_set_cipher_list</a> (WOLFSSL_CTX *ctx, const char *list)</td></tr>
<tr class="memdesc:gafa55814f56bd7a36f4035d71b2b31832"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets cipher suite list for a given WOLFSSL_CTX. This cipher suite list becomes the default list for any new SSL sessions (WOLFSSL) created using this context. The ciphers in the list should be sorted in order of preference from highest to lowest. Each call to <a class="el" href="group__Setup.html#gafa55814f56bd7a36f4035d71b2b31832" title="This function sets cipher suite list for a given WOLFSSL_CTX. This cipher suite list becomes the defa...">wolfSSL_CTX_set_cipher_list()</a> resets the cipher suite list for the specific SSL context to the provided list each time the function is called. The cipher suite list, list, is a null-terminated text string, and a colon-delimited list. For example, one value for list may be "DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256" Valid cipher values are the full name values from the cipher_names[] array in src/internal.c (for a definite list of valid cipher values check src/internal.c)  <br /></td></tr>
<tr class="memitem:ga8b0fe7cffe105b98d3e570a837797a18" id="r_ga8b0fe7cffe105b98d3e570a837797a18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga8b0fe7cffe105b98d3e570a837797a18">wolfSSL_set_cipher_list</a> (WOLFSSL *ssl, const char *list)</td></tr>
<tr class="memdesc:ga8b0fe7cffe105b98d3e570a837797a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets cipher suite list for a given WOLFSSL object (SSL session). The ciphers in the list should be sorted in order of preference from highest to lowest. Each call to <a class="el" href="group__Setup.html#ga8b0fe7cffe105b98d3e570a837797a18" title="This function sets cipher suite list for a given WOLFSSL object (SSL session). The ciphers in the lis...">wolfSSL_set_cipher_list()</a> resets the cipher suite list for the specific SSL session to the provided list each time the function is called. The cipher suite list, list, is a null-terminated text string, and a colon-delimited list. For example, one value for list may be "DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256". Valid cipher values are the full name values from the cipher_names[] array in src/internal.c (for a definite list of valid cipher values check src/internal.c)  <br /></td></tr>
<tr class="memitem:a585412eb9473686f4d65b971c8afc223" id="r_a585412eb9473686f4d65b971c8afc223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a585412eb9473686f4d65b971c8afc223">wolfSSL_dtls_set_using_nonblock</a> (WOLFSSL *ssl, int nonblock)</td></tr>
<tr class="memdesc:a585412eb9473686f4d65b971c8afc223"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking. After an application creates a WOLFSSL object, if it will be used with a non-blocking UDP socket, call <a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.  <br /></td></tr>
<tr class="memitem:a31d2641262d1f25e110033fb0c40cc59" id="r_a31d2641262d1f25e110033fb0c40cc59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31d2641262d1f25e110033fb0c40cc59">wolfSSL_dtls_get_using_nonblock</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a31d2641262d1f25e110033fb0c40cc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the application to determine if wolfSSL is using non-blocking I/O with UDP. If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0. After an application creates a WOLFSSL object, if it will be used with a non-blocking UDP socket, call <a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out. This function is only meaningful to DTLS sessions.  <br /></td></tr>
<tr class="memitem:a07da5ada53a2a68ee8e7a6dab9b5f429" id="r_a07da5ada53a2a68ee8e7a6dab9b5f429"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429">wolfSSL_dtls_get_current_timeout</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a07da5ada53a2a68ee8e7a6dab9b5f429"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current timeout value in seconds for the WOLFSSL object. When using non-blocking sockets, something in the user code needs to decide when to check for available recv data and how long it has been waiting. The value returned by this function indicates how long the application should wait.  <br /></td></tr>
<tr class="memitem:a61f3b53cb0397dd1debc8b8daaa490c2" id="r_a61f3b53cb0397dd1debc8b8daaa490c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f3b53cb0397dd1debc8b8daaa490c2">wolfSSL_dtls13_use_quick_timeout</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a61f3b53cb0397dd1debc8b8daaa490c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns true if the application should setup a quicker timeout. When using non-blocking sockets, something in the user code needs to decide when to check for available data and how long it needs to wait. If this function returns true, it means that the library already detected some disruption in the communication, but it wants to wait for a little longer in case some messages from the other peers are still in flight. Is up to the application to fine tune the value of this timer, a good one may be dtls_get_current_timeout() / 4.  <br /></td></tr>
<tr class="memitem:gab631873fe556faaa4aa7cddda1534391" id="r_gab631873fe556faaa4aa7cddda1534391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab631873fe556faaa4aa7cddda1534391">wolfSSL_dtls13_set_send_more_acks</a> (WOLFSSL *ssl, int value)</td></tr>
<tr class="memdesc:gab631873fe556faaa4aa7cddda1534391"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets whether the library should send ACKs to the other peer immediately when detecting disruption or not. Sending ACKs immediately assures minimum latency but it may consume more bandwidth than necessary. If the application manages the timer by itself and this option is set to 0 then application code can use <a class="el" href="#a61f3b53cb0397dd1debc8b8daaa490c2" title="This function returns true if the application should setup a quicker timeout. When using non-blocking...">wolfSSL_dtls13_use_quick_timeout()</a> to determine if it should setup a quicker timeout to send those delayed ACKs.  <br /></td></tr>
<tr class="memitem:ga1dd3c408c996a80b9abfae8f74645d21" id="r_ga1dd3c408c996a80b9abfae8f74645d21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga1dd3c408c996a80b9abfae8f74645d21">wolfSSL_dtls_set_timeout_init</a> (WOLFSSL *ssl, int)</td></tr>
<tr class="memdesc:ga1dd3c408c996a80b9abfae8f74645d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the dtls timeout.  <br /></td></tr>
<tr class="memitem:a10d57d8c34afabdf6242b9cb164485be" id="r_a10d57d8c34afabdf6242b9cb164485be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d57d8c34afabdf6242b9cb164485be">wolfSSL_dtls_set_timeout_max</a> (WOLFSSL *ssl, int)</td></tr>
<tr class="memdesc:a10d57d8c34afabdf6242b9cb164485be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the maximum dtls timeout.  <br /></td></tr>
<tr class="memitem:a86c630a78e966b768332c5b19e485a51" id="r_a86c630a78e966b768332c5b19e485a51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c630a78e966b768332c5b19e485a51">wolfSSL_dtls_got_timeout</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a86c630a78e966b768332c5b19e485a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when the controlling code thinks the transmission has timed out. It performs the actions needed to retry the last transmit, including adjusting the timeout value. If it has been too long, this will return a failure.  <br /></td></tr>
<tr class="memitem:a4646c73f068c7949cc61a7d16e48843b" id="r_a4646c73f068c7949cc61a7d16e48843b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4646c73f068c7949cc61a7d16e48843b">wolfSSL_dtls_retransmit</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a4646c73f068c7949cc61a7d16e48843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using non-blocking sockets with DTLS, this function retransmits the last handshake flight ignoring the expected timeout value and retransmit count. It is useful for applications that are using DTLS and need to manage even the timeout and retry count.  <br /></td></tr>
<tr class="memitem:a298a34e67ad57069d88f6e626df139a1" id="r_a298a34e67ad57069d88f6e626df139a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a298a34e67ad57069d88f6e626df139a1">wolfSSL_dtls</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a298a34e67ad57069d88f6e626df139a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to determine if the SSL session has been configured to use DTLS.  <br /></td></tr>
<tr class="memitem:a7d0dd41cc5166c33b952e0091f38d088" id="r_a7d0dd41cc5166c33b952e0091f38d088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088">wolfSSL_dtls_set_peer</a> (WOLFSSL *ssl, void *peer, unsigned int peerSz)</td></tr>
<tr class="memdesc:a7d0dd41cc5166c33b952e0091f38d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.  <br /></td></tr>
<tr class="memitem:af4b8699cfb0d882047a38441380ad92d" id="r_af4b8699cfb0d882047a38441380ad92d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4b8699cfb0d882047a38441380ad92d">wolfSSL_dtls_set_pending_peer</a> (WOLFSSL *ssl, void *peer, unsigned int peerSz)</td></tr>
<tr class="memdesc:af4b8699cfb0d882047a38441380ad92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the pending DTLS peer, peer (sockaddr_in) with size of peerSz. This sets the pending peer that will be upgraded to a regular peer when we successfully de-protect the next record. This is useful in scenarios where the peer's address can change to avoid off-path attackers from changing the peer address. This should be used with Connection ID's to allow seamless and safe transition to a new peer address.  <br /></td></tr>
<tr class="memitem:a98b070301e0424c878c8177789700830" id="r_a98b070301e0424c878c8177789700830"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b070301e0424c878c8177789700830">wolfSSL_dtls_get_peer</a> (WOLFSSL *ssl, void *peer, unsigned int *peerSz)</td></tr>
<tr class="memdesc:a98b070301e0424c878c8177789700830"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compare peerSz to the actual DTLS peer size stored in the SSL session. If the peer will fit into peer, the peer’s sockaddr_in will be copied into peer, with peerSz set to the size of peer.  <br /></td></tr>
<tr class="memitem:affc102e6ba1e2eee0ab8ab24ddc7d34d" id="r_affc102e6ba1e2eee0ab8ab24ddc7d34d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affc102e6ba1e2eee0ab8ab24ddc7d34d">wolfSSL_dtls_get0_peer</a> (WOLFSSL *ssl, const void **peer, unsigned int *peerSz)</td></tr>
<tr class="memdesc:affc102e6ba1e2eee0ab8ab24ddc7d34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. This is a zero-copy alternative to <a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer()</a>.  <br /></td></tr>
<tr class="memitem:ga1bf9410113a0a1808c2c970b5a972610" id="r_ga1bf9410113a0a1808c2c970b5a972610"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a> (unsigned long errNumber, char *data)</td></tr>
<tr class="memdesc:ga1bf9410113a0a1808c2c970b5a972610"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an error code returned by <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> into a more human-readable error string. errNumber is the error code returned by <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> and data is the storage buffer which the error string will be placed in. The maximum length of data is 80 characters by default, as defined by MAX_ERROR_SZ is wolfssl/wolfcrypt/error.h.  <br /></td></tr>
<tr class="memitem:ga1146c416f8c5cf91b43fdd56cebd846e" id="r_ga1146c416f8c5cf91b43fdd56cebd846e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga1146c416f8c5cf91b43fdd56cebd846e">wolfSSL_ERR_error_string_n</a> (unsigned long e, char *buf, unsigned long len)</td></tr>
<tr class="memdesc:ga1146c416f8c5cf91b43fdd56cebd846e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a version of <a class="el" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610" title="This function converts an error code returned by wolfSSL_get_error() into a more human-readable error...">wolfSSL_ERR_error_string()</a> where len specifies the maximum number of characters that may be written to buf. Like <a class="el" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610" title="This function converts an error code returned by wolfSSL_get_error() into a more human-readable error...">wolfSSL_ERR_error_string()</a>, this function converts an error code returned from <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> into a more human-readable error string. The human-readable string is placed in buf.  <br /></td></tr>
<tr class="memitem:gade576f68e07b5046f69acb0220b8ec45" id="r_gade576f68e07b5046f69acb0220b8ec45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#gade576f68e07b5046f69acb0220b8ec45">wolfSSL_get_shutdown</a> (const WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gade576f68e07b5046f69acb0220b8ec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the shutdown conditions in closeNotify or connReset or sentNotify members of the Options structure. The Options structure is within the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gaa432304c3c7019ccbe6d98ee89d0c839" id="r_gaa432304c3c7019ccbe6d98ee89d0c839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa432304c3c7019ccbe6d98ee89d0c839">wolfSSL_session_reused</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaa432304c3c7019ccbe6d98ee89d0c839"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the resuming member of the options struct. The flag indicates whether or not to reuse a session. If not, a new session must be established.  <br /></td></tr>
<tr class="memitem:gaa0bd0ae911e350d1e64b0cc9d3c8292b" id="r_gaa0bd0ae911e350d1e64b0cc9d3c8292b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b">wolfSSL_is_init_finished</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaa0bd0ae911e350d1e64b0cc9d3c8292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if the connection is established.  <br /></td></tr>
<tr class="memitem:gaf9c570fbc6f9556a10b593ca21799000" id="r_gaf9c570fbc6f9556a10b593ca21799000"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaf9c570fbc6f9556a10b593ca21799000">wolfSSL_get_version</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaf9c570fbc6f9556a10b593ca21799000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SSL version being used as a string.  <br /></td></tr>
<tr class="memitem:ga62ba4ad3eec03f749e1613b9c1f67538" id="r_ga62ba4ad3eec03f749e1613b9c1f67538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga62ba4ad3eec03f749e1613b9c1f67538">wolfSSL_get_current_cipher_suite</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga62ba4ad3eec03f749e1613b9c1f67538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current cipher suit an ssl session is using.  <br /></td></tr>
<tr class="memitem:ga51203855db9824ea018e24386498eddb" id="r_ga51203855db9824ea018e24386498eddb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CIPHER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga51203855db9824ea018e24386498eddb">wolfSSL_get_current_cipher</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga51203855db9824ea018e24386498eddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to the current cipher in the ssl session.  <br /></td></tr>
<tr class="memitem:ga8529c4da0a7bd779ab3c72f846b3b208" id="r_ga8529c4da0a7bd779ab3c72f846b3b208"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8529c4da0a7bd779ab3c72f846b3b208">wolfSSL_CIPHER_get_name</a> (const WOLFSSL_CIPHER *cipher)</td></tr>
<tr class="memdesc:ga8529c4da0a7bd779ab3c72f846b3b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function matches the cipher suite in the SSL object with the available suites and returns the string representation.  <br /></td></tr>
<tr class="memitem:ga21ac3732347588a968b7dad64719afdc" id="r_ga21ac3732347588a968b7dad64719afdc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga21ac3732347588a968b7dad64719afdc">wolfSSL_get_cipher</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga21ac3732347588a968b7dad64719afdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function matches the cipher suite in the SSL object with the available suites.  <br /></td></tr>
<tr class="memitem:ga99e714f7d0a93b81c667f787750e1994" id="r_ga99e714f7d0a93b81c667f787750e1994"><td class="memItemLeft" align="right" valign="top">WOLFSSL_SESSION *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994">wolfSSL_get1_session</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga99e714f7d0a93b81c667f787750e1994"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type. This requires calling wolfSSL_SESSION_free to release the session reference. The WOLFSSL_SESSION pointed to contains all the necessary information required to perform a session resumption and reestablish the connection without a new handshake. For session resumption, before calling <a class="el" href="group__TLS.html#ga51f54ec99e4d87f4b25a92fe031439ae" title="This function shuts down an active SSL/TLS connection using the SSL session, ssl. This function will ...">wolfSSL_shutdown()</a> with your session object, an application should save the session ID from the object with a call to <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a>, which returns a pointer to the session. Later, the application should create a new WOLFSSL object and assign the saved session with <a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session()</a>. At this point, the application may call <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> and wolfSSL will try to resume the session. The wolfSSL server code allows session resumption by default. The object returned by <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a> needs to be freed after the application is done with it by calling wolfSSL_SESSION_free() on it.  <br /></td></tr>
<tr class="memitem:gaa08eddc0cf72292ec7c18488696b76bc" id="r_gaa08eddc0cf72292ec7c18488696b76bc"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa08eddc0cf72292ec7c18488696b76bc">wolfSSLv23_client_method</a> (void)</td></tr>
<tr class="memdesc:gaa08eddc0cf72292ec7c18488696b76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#gaa08eddc0cf72292ec7c18488696b76bc" title="The wolfSSLv23_client_method() function is used to indicate that the application is a client and will...">wolfSSLv23_client_method()</a> function is used to indicate that the application is a client and will support the highest protocol version supported by the server between SSL 3.0 - TLS 1.3. This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. Both wolfSSL clients and servers have robust version downgrade capability. If a specific protocol version method is used on either side, then only that version will be negotiated or an error will be returned. For example, a client that uses TLSv1 and tries to connect to a SSLv3 only server will fail, likewise connecting to a TLSv1.1 will fail as well. To resolve this issue, a client that uses the <a class="el" href="group__Setup.html#gaa08eddc0cf72292ec7c18488696b76bc" title="The wolfSSLv23_client_method() function is used to indicate that the application is a client and will...">wolfSSLv23_client_method()</a> function will use the highest protocol version supported by the server and downgrade to SSLv3 if needed. In this case, the client will be able to connect to a server running SSLv3 - TLSv1.3.  <br /></td></tr>
<tr class="memitem:ga47aba7e83d2d12a6c39c4e9204b406b2" id="r_ga47aba7e83d2d12a6c39c4e9204b406b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga47aba7e83d2d12a6c39c4e9204b406b2">wolfSSL_BIO_get_mem_data</a> (WOLFSSL_BIO *bio, void *p)</td></tr>
<tr class="memdesc:ga47aba7e83d2d12a6c39c4e9204b406b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set a byte pointer to the start of the internal memory buffer.  <br /></td></tr>
<tr class="memitem:gab635da3ded1fc28fd481534d19973aa1" id="r_gab635da3ded1fc28fd481534d19973aa1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gab635da3ded1fc28fd481534d19973aa1">wolfSSL_BIO_set_fd</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, int fd, int flag)</td></tr>
<tr class="memdesc:gab635da3ded1fc28fd481534d19973aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file descriptor for bio to use.  <br /></td></tr>
<tr class="memitem:gae7056bcc5de43dbb8fa46756e076204c" id="r_gae7056bcc5de43dbb8fa46756e076204c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gae7056bcc5de43dbb8fa46756e076204c">wolfSSL_BIO_set_close</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long flag)</td></tr>
<tr class="memdesc:gae7056bcc5de43dbb8fa46756e076204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the close flag, used to indicate that the i/o stream should be closed when the BIO is freed.  <br /></td></tr>
<tr class="memitem:ga3d82acbf5d99c8fbd2f86faed1061fa8" id="r_ga3d82acbf5d99c8fbd2f86faed1061fa8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_BIO_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga3d82acbf5d99c8fbd2f86faed1061fa8">wolfSSL_BIO_s_socket</a> (void)</td></tr>
<tr class="memdesc:ga3d82acbf5d99c8fbd2f86faed1061fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a BIO_SOCKET type WOLFSSL_BIO_METHOD.  <br /></td></tr>
<tr class="memitem:ga435ac1cfd706cd6a0fe0a3f1e93f312b" id="r_ga435ac1cfd706cd6a0fe0a3f1e93f312b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga435ac1cfd706cd6a0fe0a3f1e93f312b">wolfSSL_BIO_set_write_buf_size</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long size)</td></tr>
<tr class="memdesc:ga435ac1cfd706cd6a0fe0a3f1e93f312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the size of write buffer for a WOLFSSL_BIO. If write buffer has been previously set this function will free it when resetting the size. It is similar to wolfSSL_BIO_reset in that it resets read and write indexes to 0.  <br /></td></tr>
<tr class="memitem:ga4cb35fa0dce83567376cae66fa729ec2" id="r_ga4cb35fa0dce83567376cae66fa729ec2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga4cb35fa0dce83567376cae66fa729ec2">wolfSSL_BIO_make_bio_pair</a> (WOLFSSL_BIO *b1, WOLFSSL_BIO *b2)</td></tr>
<tr class="memdesc:ga4cb35fa0dce83567376cae66fa729ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to pair two bios together. A pair of bios acts similar to a two way pipe writing to one can be read by the other and vice versa. It is expected that both bios be in the same thread, this function is not thread safe. Freeing one of the two bios removes both from being paired. If a write buffer size was not previously set for either of the bios it is set to a default size of 17000 (WOLFSSL_BIO_SIZE) before being paired.  <br /></td></tr>
<tr class="memitem:ga25b97c0b11e93443ed2993a8150f687b" id="r_ga25b97c0b11e93443ed2993a8150f687b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga25b97c0b11e93443ed2993a8150f687b">wolfSSL_BIO_ctrl_reset_read_request</a> (WOLFSSL_BIO *bio)</td></tr>
<tr class="memdesc:ga25b97c0b11e93443ed2993a8150f687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the read request flag back to 0.  <br /></td></tr>
<tr class="memitem:ga2c24a537e06600eceb84aa4aa06ce120" id="r_ga2c24a537e06600eceb84aa4aa06ce120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2c24a537e06600eceb84aa4aa06ce120">wolfSSL_BIO_nread0</a> (WOLFSSL_BIO *bio, char **buf)</td></tr>
<tr class="memdesc:ga2c24a537e06600eceb84aa4aa06ce120"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a buffer pointer for reading from. Unlike wolfSSL_BIO_nread the internal read index is not advanced by the number returned from the function call. Reading past the value returned can result in reading out of array bounds.  <br /></td></tr>
<tr class="memitem:gacc6c4298d00869eac022d26aa5c4f102" id="r_gacc6c4298d00869eac022d26aa5c4f102"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gacc6c4298d00869eac022d26aa5c4f102">wolfSSL_BIO_nread</a> (WOLFSSL_BIO *bio, char **buf, int num)</td></tr>
<tr class="memdesc:gacc6c4298d00869eac022d26aa5c4f102"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a buffer pointer for reading from. The internal read index is advanced by the number returned from the function call with buf being pointed to the beginning of the buffer to read from. In the case that less bytes are in the read buffer than the value requested with num the lesser value is returned. Reading past the value returned can result in reading out of array bounds.  <br /></td></tr>
<tr class="memitem:ga8c34600ab60aba3073f8fccd10f20acd" id="r_ga8c34600ab60aba3073f8fccd10f20acd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8c34600ab60aba3073f8fccd10f20acd">wolfSSL_BIO_nwrite</a> (WOLFSSL_BIO *bio, char **buf, int num)</td></tr>
<tr class="memdesc:ga8c34600ab60aba3073f8fccd10f20acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the buffer for writing as many bytes as returned by the function. Writing more bytes to the pointer returned then the value returned can result in writing out of bounds.  <br /></td></tr>
<tr class="memitem:ga87c06554b6c8af8870bee7e4a0b6165a" id="r_ga87c06554b6c8af8870bee7e4a0b6165a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga87c06554b6c8af8870bee7e4a0b6165a">wolfSSL_BIO_reset</a> (WOLFSSL_BIO *bio)</td></tr>
<tr class="memdesc:ga87c06554b6c8af8870bee7e4a0b6165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets bio to an initial state. As an example for type BIO_BIO this resets the read and write index.  <br /></td></tr>
<tr class="memitem:ga8908842d47bd3cbc996e77fd7c1e0ba4" id="r_ga8908842d47bd3cbc996e77fd7c1e0ba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8908842d47bd3cbc996e77fd7c1e0ba4">wolfSSL_BIO_seek</a> (WOLFSSL_BIO *bio, int ofs)</td></tr>
<tr class="memdesc:ga8908842d47bd3cbc996e77fd7c1e0ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adjusts the file pointer to the offset given. This is the offset from the head of the file.  <br /></td></tr>
<tr class="memitem:ga5debc444a59805b60dfaf575710c3605" id="r_ga5debc444a59805b60dfaf575710c3605"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5debc444a59805b60dfaf575710c3605">wolfSSL_BIO_write_filename</a> (WOLFSSL_BIO *bio, char *name)</td></tr>
<tr class="memdesc:ga5debc444a59805b60dfaf575710c3605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set and write to a file. WIll overwrite any data currently in the file and is set to close the file when the bio is freed.  <br /></td></tr>
<tr class="memitem:ga1be0050703a8b74913831481b90e45cc" id="r_ga1be0050703a8b74913831481b90e45cc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga1be0050703a8b74913831481b90e45cc">wolfSSL_BIO_set_mem_eof_return</a> (WOLFSSL_BIO *bio, int v)</td></tr>
<tr class="memdesc:ga1be0050703a8b74913831481b90e45cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the end of file value. Common value is -1 so as not to get confused with expected positive values.  <br /></td></tr>
<tr class="memitem:ga349b08d62d70fd03153237c8dd658479" id="r_ga349b08d62d70fd03153237c8dd658479"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga349b08d62d70fd03153237c8dd658479">wolfSSL_BIO_get_mem_ptr</a> (WOLFSSL_BIO *bio, WOLFSSL_BUF_MEM **m)</td></tr>
<tr class="memdesc:ga349b08d62d70fd03153237c8dd658479"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a getter function for WOLFSSL_BIO memory pointer.  <br /></td></tr>
<tr class="memitem:ga9c4780e57f0de43e275ab23431333aa7" id="r_ga9c4780e57f0de43e275ab23431333aa7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga9c4780e57f0de43e275ab23431333aa7">wolfSSL_X509_NAME_oneline</a> (WOLFSSL_X509_NAME *name, char *in, int sz)</td></tr>
<tr class="memdesc:ga9c4780e57f0de43e275ab23431333aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the name of the x509 into a buffer.  <br /></td></tr>
<tr class="memitem:ga52c36f3b55709e41be19c939e3bb5f39" id="r_ga52c36f3b55709e41be19c939e3bb5f39"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_NAME *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga52c36f3b55709e41be19c939e3bb5f39">wolfSSL_X509_get_issuer_name</a> (WOLFSSL_X509 *cert)</td></tr>
<tr class="memdesc:ga52c36f3b55709e41be19c939e3bb5f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the name of the certificate issuer.  <br /></td></tr>
<tr class="memitem:ga1a54f60fae9e1d8e5b7b6d00ddb942cb" id="r_ga1a54f60fae9e1d8e5b7b6d00ddb942cb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_NAME *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga1a54f60fae9e1d8e5b7b6d00ddb942cb">wolfSSL_X509_get_subject_name</a> (WOLFSSL_X509 *cert)</td></tr>
<tr class="memdesc:ga1a54f60fae9e1d8e5b7b6d00ddb942cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the subject member of the WOLFSSL_X509 structure.  <br /></td></tr>
<tr class="memitem:ga4ca2e3cfe047c6a53bfc4e60ba6163dd" id="r_ga4ca2e3cfe047c6a53bfc4e60ba6163dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga4ca2e3cfe047c6a53bfc4e60ba6163dd">wolfSSL_X509_get_isCA</a> (WOLFSSL_X509 *cert)</td></tr>
<tr class="memdesc:ga4ca2e3cfe047c6a53bfc4e60ba6163dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the isCa member of the WOLFSSL_X509 structure and returns the value.  <br /></td></tr>
<tr class="memitem:ga0b0a4e35eb43c00c0be0095f91b959ae" id="r_ga0b0a4e35eb43c00c0be0095f91b959ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga0b0a4e35eb43c00c0be0095f91b959ae">wolfSSL_X509_NAME_get_text_by_NID</a> (WOLFSSL_X509_NAME *name, int nid, char *buf, int len)</td></tr>
<tr class="memdesc:ga0b0a4e35eb43c00c0be0095f91b959ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the text related to the passed in NID value.  <br /></td></tr>
<tr class="memitem:gadfb67062c2d15a0a1cdbae29441a423a" id="r_gadfb67062c2d15a0a1cdbae29441a423a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gadfb67062c2d15a0a1cdbae29441a423a">wolfSSL_X509_get_signature_type</a> (WOLFSSL_X509 *cert)</td></tr>
<tr class="memdesc:gadfb67062c2d15a0a1cdbae29441a423a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the value stored in the sigOID member of the WOLFSSL_X509 structure.  <br /></td></tr>
<tr class="memitem:ac98ca659773439f65dc8be41761cf9a7" id="r_ac98ca659773439f65dc8be41761cf9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98ca659773439f65dc8be41761cf9a7">wolfSSL_X509_free</a> (WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:ac98ca659773439f65dc8be41761cf9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees a WOLFSSL_X509 structure.  <br /></td></tr>
<tr class="memitem:ga094e24903d9b63818ebdb64f63e8c737" id="r_ga094e24903d9b63818ebdb64f63e8c737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga094e24903d9b63818ebdb64f63e8c737">wolfSSL_X509_get_signature</a> (WOLFSSL_X509 *x509, unsigned char *buf, int *bufSz)</td></tr>
<tr class="memdesc:ga094e24903d9b63818ebdb64f63e8c737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the X509 signature and stores it in the buffer.  <br /></td></tr>
<tr class="memitem:ga08534f4744d8f949ea1be347bbead2cd" id="r_ga08534f4744d8f949ea1be347bbead2cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga08534f4744d8f949ea1be347bbead2cd">wolfSSL_X509_STORE_add_cert</a> (WOLFSSL_X509_STORE *store, WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:ga08534f4744d8f949ea1be347bbead2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds a certificate to the WOLFSSL_X509_STRE structure.  <br /></td></tr>
<tr class="memitem:gad567436ecdf66b29eeb61d5dec8adb41" id="r_gad567436ecdf66b29eeb61d5dec8adb41"><td class="memItemLeft" align="right" valign="top">WOLFSSL_STACK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad567436ecdf66b29eeb61d5dec8adb41">wolfSSL_X509_STORE_CTX_get_chain</a> (WOLFSSL_X509_STORE_CTX *ctx)</td></tr>
<tr class="memdesc:gad567436ecdf66b29eeb61d5dec8adb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a getter function for chain variable in WOLFSSL_X509_STORE_CTX structure. Currently chain is not populated.  <br /></td></tr>
<tr class="memitem:gad2526331220eb8af233b727d3e1a880c" id="r_gad2526331220eb8af233b727d3e1a880c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad2526331220eb8af233b727d3e1a880c">wolfSSL_X509_STORE_set_flags</a> (WOLFSSL_X509_STORE *store, unsigned long flag)</td></tr>
<tr class="memdesc:gad2526331220eb8af233b727d3e1a880c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes in a flag to change the behavior of the WOLFSSL_X509_STORE structure passed in. An example of a flag used is WOLFSSL_CRL_CHECK.  <br /></td></tr>
<tr class="memitem:gab1e237c4e59d8a0b73b9fc0d733bd8cf" id="r_gab1e237c4e59d8a0b73b9fc0d733bd8cf"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gab1e237c4e59d8a0b73b9fc0d733bd8cf">wolfSSL_X509_notBefore</a> (WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:gab1e237c4e59d8a0b73b9fc0d733bd8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function the certificate "not before" validity encoded as a byte array.  <br /></td></tr>
<tr class="memitem:ga35ade256eac252caa7f42d4c2dbe9ae3" id="r_ga35ade256eac252caa7f42d4c2dbe9ae3"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga35ade256eac252caa7f42d4c2dbe9ae3">wolfSSL_X509_notAfter</a> (WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:ga35ade256eac252caa7f42d4c2dbe9ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function the certificate "not after" validity encoded as a byte array.  <br /></td></tr>
<tr class="memitem:ga5ff6beea23088670d0a8774711355e48" id="r_ga5ff6beea23088670d0a8774711355e48"><td class="memItemLeft" align="right" valign="top">WOLFSSL_BIGNUM *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga5ff6beea23088670d0a8774711355e48">wolfSSL_ASN1_INTEGER_to_BN</a> (const WOLFSSL_ASN1_INTEGER *ai, WOLFSSL_BIGNUM *bn)</td></tr>
<tr class="memdesc:ga5ff6beea23088670d0a8774711355e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to copy a WOLFSSL_ASN1_INTEGER value to a WOLFSSL_BIGNUM structure.  <br /></td></tr>
<tr class="memitem:ga459ca4b5c70969891fff5d34d93c1a33" id="r_ga459ca4b5c70969891fff5d34d93c1a33"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga459ca4b5c70969891fff5d34d93c1a33">wolfSSL_CTX_add_extra_chain_cert</a> (WOLFSSL_CTX *ctx, WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:ga459ca4b5c70969891fff5d34d93c1a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds the certificate to the internal chain being built in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:ga3b9db2e09118ba92f40572e2f71c36b1" id="r_ga3b9db2e09118ba92f40572e2f71c36b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga3b9db2e09118ba92f40572e2f71c36b1">wolfSSL_CTX_get_read_ahead</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga3b9db2e09118ba92f40572e2f71c36b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the get read ahead flag from a WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:ga1c52f521391ef291d092343e26b8ebc6" id="r_ga1c52f521391ef291d092343e26b8ebc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga1c52f521391ef291d092343e26b8ebc6">wolfSSL_CTX_set_read_ahead</a> (WOLFSSL_CTX *ctx, int v)</td></tr>
<tr class="memdesc:ga1c52f521391ef291d092343e26b8ebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the read ahead flag in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:gac5fe409f6a06a1abc866e9db0dc93eee" id="r_gac5fe409f6a06a1abc866e9db0dc93eee"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gac5fe409f6a06a1abc866e9db0dc93eee">wolfSSL_CTX_set_tlsext_status_arg</a> (WOLFSSL_CTX *ctx, void *arg)</td></tr>
<tr class="memdesc:gac5fe409f6a06a1abc866e9db0dc93eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the options argument to use with OCSP.  <br /></td></tr>
<tr class="memitem:ga20ec92fb1ed1da638896c511076cf96a" id="r_ga20ec92fb1ed1da638896c511076cf96a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga20ec92fb1ed1da638896c511076cf96a">wolfSSL_CTX_set_tlsext_opaque_prf_input_callback_arg</a> (WOLFSSL_CTX *ctx, void *arg)</td></tr>
<tr class="memdesc:ga20ec92fb1ed1da638896c511076cf96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the optional argument to be passed to the PRF callback.  <br /></td></tr>
<tr class="memitem:gaf2918c53010c1fbec39aa014c6e313c1" id="r_gaf2918c53010c1fbec39aa014c6e313c1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf2918c53010c1fbec39aa014c6e313c1">wolfSSL_set_options</a> (WOLFSSL *s, long op)</td></tr>
<tr class="memdesc:gaf2918c53010c1fbec39aa014c6e313c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the options mask in the ssl. Some valid options are, SSL_OP_ALL, SSL_OP_COOKIE_EXCHANGE, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_COMPRESSION.  <br /></td></tr>
<tr class="memitem:ga60441b92b96f0fc519e5a5f37689ca33" id="r_ga60441b92b96f0fc519e5a5f37689ca33"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga60441b92b96f0fc519e5a5f37689ca33">wolfSSL_get_options</a> (const WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga60441b92b96f0fc519e5a5f37689ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current options mask.  <br /></td></tr>
<tr class="memitem:gacae17593ac57c6fc399164ba1f55d300" id="r_gacae17593ac57c6fc399164ba1f55d300"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gacae17593ac57c6fc399164ba1f55d300">wolfSSL_set_tlsext_debug_arg</a> (WOLFSSL *ssl, void *arg)</td></tr>
<tr class="memdesc:gacae17593ac57c6fc399164ba1f55d300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the debug argument passed around.  <br /></td></tr>
<tr class="memitem:gaec133503dcd6c3b5ece78702932b59a8" id="r_gaec133503dcd6c3b5ece78702932b59a8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gaec133503dcd6c3b5ece78702932b59a8">wolfSSL_set_tlsext_status_type</a> (WOLFSSL *s, int type)</td></tr>
<tr class="memdesc:gaec133503dcd6c3b5ece78702932b59a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when the client application request that a server send back an OCSP status response (also known as OCSP stapling).Currently, the only supported type is TLSEXT_STATUSTYPE_ocsp.  <br /></td></tr>
<tr class="memitem:ga4ab97584bbc4bd6c7eedbfd44cc2a36b" id="r_ga4ab97584bbc4bd6c7eedbfd44cc2a36b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga4ab97584bbc4bd6c7eedbfd44cc2a36b">wolfSSL_get_verify_result</a> (const WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga4ab97584bbc4bd6c7eedbfd44cc2a36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the results after trying to verify the peer's certificate.  <br /></td></tr>
<tr class="memitem:ga3f82460752b93314b1ad70acc623135c" id="r_ga3f82460752b93314b1ad70acc623135c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga3f82460752b93314b1ad70acc623135c">wolfSSL_ERR_print_errors_fp</a> (XFILE fp, int err)</td></tr>
<tr class="memdesc:ga3f82460752b93314b1ad70acc623135c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an error code returned by <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> into a more human-readable error string and prints that string to the output file - fp. err is the error code returned by <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> and fp is the file which the error string will be placed in.  <br /></td></tr>
<tr class="memitem:ga42fb87f2b1eb9f76603fc09b03ce94c4" id="r_ga42fb87f2b1eb9f76603fc09b03ce94c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga42fb87f2b1eb9f76603fc09b03ce94c4">wolfSSL_ERR_print_errors_cb</a> (int(*cb)(const char *str, size_t len, void *u), void *u)</td></tr>
<tr class="memdesc:ga42fb87f2b1eb9f76603fc09b03ce94c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses the provided callback to handle error reporting. The callback function is executed for each error line. The string, length, and userdata are passed into the callback parameters.  <br /></td></tr>
<tr class="memitem:afb48159280dafa4a58a0f9f7da96cb65" id="r_afb48159280dafa4a58a0f9f7da96cb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb48159280dafa4a58a0f9f7da96cb65">wolfSSL_CTX_set_psk_client_callback</a> (WOLFSSL_CTX *ctx, wc_psk_client_callback cb)</td></tr>
<tr class="memdesc:afb48159280dafa4a58a0f9f7da96cb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the client_psk_cb member of the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:a7eccdf80887061a222c904e0531bf516" id="r_a7eccdf80887061a222c904e0531bf516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eccdf80887061a222c904e0531bf516">wolfSSL_set_psk_client_callback</a> (WOLFSSL *ssl, wc_psk_client_callback)</td></tr>
<tr class="memdesc:a7eccdf80887061a222c904e0531bf516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PSK client side callback.  <br /></td></tr>
<tr class="memitem:ga4dba2642424095dff3b5c6df7ddec52d" id="r_ga4dba2642424095dff3b5c6df7ddec52d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga4dba2642424095dff3b5c6df7ddec52d">wolfSSL_get_psk_identity_hint</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:ga4dba2642424095dff3b5c6df7ddec52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the psk identity hint.  <br /></td></tr>
<tr class="memitem:ga275c386bda237733ff5d7843d7fe3164" id="r_ga275c386bda237733ff5d7843d7fe3164"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga275c386bda237733ff5d7843d7fe3164">wolfSSL_get_psk_identity</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:ga275c386bda237733ff5d7843d7fe3164"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns a constant pointer to the client_identity member of the Arrays structure.  <br /></td></tr>
<tr class="memitem:gad97c05aea87ffdcca97b9d48705eff30" id="r_gad97c05aea87ffdcca97b9d48705eff30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad97c05aea87ffdcca97b9d48705eff30">wolfSSL_CTX_use_psk_identity_hint</a> (WOLFSSL_CTX *ctx, const char *hint)</td></tr>
<tr class="memdesc:gad97c05aea87ffdcca97b9d48705eff30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the hint argument in the server_hint member of the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:ga418cdb6a65964f89a44c84143b354a31" id="r_ga418cdb6a65964f89a44c84143b354a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga418cdb6a65964f89a44c84143b354a31">wolfSSL_use_psk_identity_hint</a> (WOLFSSL *ssl, const char *hint)</td></tr>
<tr class="memdesc:ga418cdb6a65964f89a44c84143b354a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the hint argument in the server_hint member of the Arrays structure within the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:aa22b4232a9bc1e4f2d4ea10c71af8521" id="r_aa22b4232a9bc1e4f2d4ea10c71af8521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa22b4232a9bc1e4f2d4ea10c71af8521">wolfSSL_CTX_set_psk_server_callback</a> (WOLFSSL_CTX *ctx, wc_psk_server_callback cb)</td></tr>
<tr class="memdesc:aa22b4232a9bc1e4f2d4ea10c71af8521"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the psk callback for the server side in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:a2fb471b8b706f1c85fa53c46220c9d5d" id="r_a2fb471b8b706f1c85fa53c46220c9d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb471b8b706f1c85fa53c46220c9d5d">wolfSSL_set_psk_server_callback</a> (WOLFSSL *ssl, wc_psk_server_callback cb)</td></tr>
<tr class="memdesc:a2fb471b8b706f1c85fa53c46220c9d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the psk callback for the server side by setting the WOLFSSL structure options members.  <br /></td></tr>
<tr class="memitem:a25324f17616aca4bf3b70fd872a83031" id="r_a25324f17616aca4bf3b70fd872a83031"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25324f17616aca4bf3b70fd872a83031">wolfSSL_set_psk_callback_ctx</a> (WOLFSSL *ssl, void *psk_ctx)</td></tr>
<tr class="memdesc:a25324f17616aca4bf3b70fd872a83031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a PSK user context in the WOLFSSL structure options member.  <br /></td></tr>
<tr class="memitem:ac8862b6583b25e63d7279929f9f96ffc" id="r_ac8862b6583b25e63d7279929f9f96ffc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8862b6583b25e63d7279929f9f96ffc">wolfSSL_CTX_set_psk_callback_ctx</a> (WOLFSSL_CTX *ctx, void *psk_ctx)</td></tr>
<tr class="memdesc:ac8862b6583b25e63d7279929f9f96ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a PSK user context in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:a22d011e8be92a7e5c025fd0da355c12e" id="r_a22d011e8be92a7e5c025fd0da355c12e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d011e8be92a7e5c025fd0da355c12e">wolfSSL_get_psk_callback_ctx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a22d011e8be92a7e5c025fd0da355c12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a PSK user context in the WOLFSSL structure options member.  <br /></td></tr>
<tr class="memitem:a579ed69665d9aa441c281b5716198ca4" id="r_a579ed69665d9aa441c281b5716198ca4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579ed69665d9aa441c281b5716198ca4">wolfSSL_CTX_get_psk_callback_ctx</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:a579ed69665d9aa441c281b5716198ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a PSK user context in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:ga0fdd853521928481250f89095b7ae7c9" id="r_ga0fdd853521928481250f89095b7ae7c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga0fdd853521928481250f89095b7ae7c9">wolfSSL_CTX_allow_anon_cipher</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:ga0fdd853521928481250f89095b7ae7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the havAnon member of the CTX structure if HAVE_ANON is defined during compilation.  <br /></td></tr>
<tr class="memitem:ga1a4d65e316938d9b925796a73f48f28d" id="r_ga1a4d65e316938d9b925796a73f48f28d"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga1a4d65e316938d9b925796a73f48f28d">wolfSSLv23_server_method</a> (void)</td></tr>
<tr class="memdesc:ga1a4d65e316938d9b925796a73f48f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__Setup.html#ga1a4d65e316938d9b925796a73f48f28d" title="The wolfSSLv23_server_method() function is used to indicate that the application is a server and will...">wolfSSLv23_server_method()</a> function is used to indicate that the application is a server and will support clients connecting with protocol version from SSL 3.0 - TLS 1.3. This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga575c6434d5809831f91897876077f5d3" id="r_ga575c6434d5809831f91897876077f5d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga575c6434d5809831f91897876077f5d3">wolfSSL_state</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga575c6434d5809831f91897876077f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the internal error state of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gac4922168b7d2c01c0e6b0ab663ecdefe" id="r_gac4922168b7d2c01c0e6b0ab663ecdefe"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gac4922168b7d2c01c0e6b0ab663ecdefe">wolfSSL_get_peer_certificate</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gac4922168b7d2c01c0e6b0ab663ecdefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the peer’s certificate.  <br /></td></tr>
<tr class="memitem:gaa2bce46756f25c57485ba506d86b6c8d" id="r_gaa2bce46756f25c57485ba506d86b6c8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#gaa2bce46756f25c57485ba506d86b6c8d">wolfSSL_want_read</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gaa2bce46756f25c57485ba506d86b6c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to calling <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> and getting SSL_ERROR_WANT_READ in return. If the underlying error state is SSL_ERROR_WANT_READ, this function will return 1, otherwise, 0.  <br /></td></tr>
<tr class="memitem:ga53f6395eeed548747a2e989f19ab782f" id="r_ga53f6395eeed548747a2e989f19ab782f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga53f6395eeed548747a2e989f19ab782f">wolfSSL_want_write</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga53f6395eeed548747a2e989f19ab782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to calling <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> and getting SSL_ERROR_WANT_WRITE in return. If the underlying error state is SSL_ERROR_WANT_WRITE, this function will return 1, otherwise, 0.  <br /></td></tr>
<tr class="memitem:gab9b75f5fb10ce88f0026c57716858074" id="r_gab9b75f5fb10ce88f0026c57716858074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab9b75f5fb10ce88f0026c57716858074">wolfSSL_check_domain_name</a> (WOLFSSL *ssl, const char *dn)</td></tr>
<tr class="memdesc:gab9b75f5fb10ce88f0026c57716858074"><td class="mdescLeft">&#160;</td><td class="mdescRight">wolfSSL by default checks the peer certificate for a valid date range and a verified signature. Calling this function before <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will add a domain name check to the list of checks to perform. dn holds the domain name to check against the peer certificate when it’s received.  <br /></td></tr>
<tr class="memitem:ga789ef74e34df659a62f06da2ea709737" id="r_ga789ef74e34df659a62f06da2ea709737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a> (void)</td></tr>
<tr class="memdesc:ga789ef74e34df659a62f06da2ea709737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the wolfSSL library for use. Must be called once per application and before any other call to the library.  <br /></td></tr>
<tr class="memitem:gab9c917bd9f4e75b07a6538899e493899" id="r_gab9c917bd9f4e75b07a6538899e493899"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#gab9c917bd9f4e75b07a6538899e493899">wolfSSL_Cleanup</a> (void)</td></tr>
<tr class="memdesc:gab9c917bd9f4e75b07a6538899e493899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-initializes the wolfSSL library from further use. Doesn’t have to be called, though it will free any resources used by the library.  <br /></td></tr>
<tr class="memitem:gaa3b1592df3acdace68187bd21c92554e" id="r_gaa3b1592df3acdace68187bd21c92554e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaa3b1592df3acdace68187bd21c92554e">wolfSSL_lib_version</a> (void)</td></tr>
<tr class="memdesc:gaa3b1592df3acdace68187bd21c92554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current library version.  <br /></td></tr>
<tr class="memitem:ga19621cde181fbc016432c221169a476c" id="r_ga19621cde181fbc016432c221169a476c"><td class="memItemLeft" align="right" valign="top">word32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga19621cde181fbc016432c221169a476c">wolfSSL_lib_version_hex</a> (void)</td></tr>
<tr class="memdesc:ga19621cde181fbc016432c221169a476c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current library version in hexadecimal notation.  <br /></td></tr>
<tr class="memitem:gaf6780235ee9a7abe3f704a585eb77849" id="r_gaf6780235ee9a7abe3f704a585eb77849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaf6780235ee9a7abe3f704a585eb77849">wolfSSL_negotiate</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaf6780235ee9a7abe3f704a585eb77849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the actual connect or accept based on the side of the SSL method. If called from the client side then an <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> is done while a <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> is performed if called from the server side.  <br /></td></tr>
<tr class="memitem:ga2e807c14756b8b27a9ac8a2e8676e3ee" id="r_ga2e807c14756b8b27a9ac8a2e8676e3ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga2e807c14756b8b27a9ac8a2e8676e3ee">wolfSSL_set_compression</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga2e807c14756b8b27a9ac8a2e8676e3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on the ability to use compression for the SSL connection. Both sides must have compression turned on otherwise compression will not be used. The zlib library performs the actual data compression. To compile into the library use &ndash;with-libz for the configure system and define HAVE_LIBZ otherwise. Keep in mind that while compressing data before sending decreases the actual size of the messages being sent and received, the amount of data saved by compression usually takes longer in time to analyze than it does to send it raw on all but the slowest of networks.  <br /></td></tr>
<tr class="memitem:ga470ef92189475a40e003d84406f5e278" id="r_ga470ef92189475a40e003d84406f5e278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga470ef92189475a40e003d84406f5e278">wolfSSL_set_timeout</a> (WOLFSSL *ssl, unsigned int to)</td></tr>
<tr class="memdesc:ga470ef92189475a40e003d84406f5e278"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the SSL session timeout value in seconds.  <br /></td></tr>
<tr class="memitem:gaf1a98bef503f45a24ec7617d3221ca8e" id="r_gaf1a98bef503f45a24ec7617d3221ca8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf1a98bef503f45a24ec7617d3221ca8e">wolfSSL_CTX_set_timeout</a> (WOLFSSL_CTX *ctx, unsigned int to)</td></tr>
<tr class="memdesc:gaf1a98bef503f45a24ec7617d3221ca8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the timeout value for SSL sessions, in seconds, for the specified SSL context.  <br /></td></tr>
<tr class="memitem:ga0f4bc0953a9f638b77dfb3d0be6403c6" id="r_ga0f4bc0953a9f638b77dfb3d0be6403c6"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_CHAIN *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga0f4bc0953a9f638b77dfb3d0be6403c6">wolfSSL_get_peer_chain</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga0f4bc0953a9f638b77dfb3d0be6403c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the peer’s certificate chain.  <br /></td></tr>
<tr class="memitem:gaaf50df2b3aaf1066fd48acb1c3d8040f" id="r_gaaf50df2b3aaf1066fd48acb1c3d8040f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gaaf50df2b3aaf1066fd48acb1c3d8040f">wolfSSL_get_chain_count</a> (WOLFSSL_X509_CHAIN *chain)</td></tr>
<tr class="memdesc:gaaf50df2b3aaf1066fd48acb1c3d8040f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve's the peers certificate chain count.  <br /></td></tr>
<tr class="memitem:gac9c428d8efd878074bbef090a7037274" id="r_gac9c428d8efd878074bbef090a7037274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gac9c428d8efd878074bbef090a7037274">wolfSSL_get_chain_length</a> (WOLFSSL_X509_CHAIN *chain, int idx)</td></tr>
<tr class="memdesc:gac9c428d8efd878074bbef090a7037274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the peer’s ASN1.DER certificate length in bytes at index (idx).  <br /></td></tr>
<tr class="memitem:ga26acb3645badfc72a6e6b92402256ce2" id="r_ga26acb3645badfc72a6e6b92402256ce2"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga26acb3645badfc72a6e6b92402256ce2">wolfSSL_get_chain_cert</a> (WOLFSSL_X509_CHAIN *chain, int idx)</td></tr>
<tr class="memdesc:ga26acb3645badfc72a6e6b92402256ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the peer’s ASN1.DER certificate at index (idx).  <br /></td></tr>
<tr class="memitem:ga93a196f40a1daf4ef13e24032ed3c923" id="r_ga93a196f40a1daf4ef13e24032ed3c923"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga93a196f40a1daf4ef13e24032ed3c923">wolfSSL_get_chain_X509</a> (WOLFSSL_X509_CHAIN *chain, int idx)</td></tr>
<tr class="memdesc:ga93a196f40a1daf4ef13e24032ed3c923"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the peer’s wolfSSL_X509_certificate at index (idx) from the chain of certificates.  <br /></td></tr>
<tr class="memitem:gaba8bfa60c7f55fe3a510608f5d05932e" id="r_gaba8bfa60c7f55fe3a510608f5d05932e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gaba8bfa60c7f55fe3a510608f5d05932e">wolfSSL_get_chain_cert_pem</a> (WOLFSSL_X509_CHAIN *chain, int idx, unsigned char *buf, int inLen, int *outLen)</td></tr>
<tr class="memdesc:gaba8bfa60c7f55fe3a510608f5d05932e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the peer’s PEM certificate at index (idx).  <br /></td></tr>
<tr class="memitem:gae623573087e09af10316cc20fd6d63f9" id="r_gae623573087e09af10316cc20fd6d63f9"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gae623573087e09af10316cc20fd6d63f9">wolfSSL_get_sessionID</a> (const WOLFSSL_SESSION *s)</td></tr>
<tr class="memdesc:gae623573087e09af10316cc20fd6d63f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the session’s ID. The session ID is always 32 bytes long.  <br /></td></tr>
<tr class="memitem:gaf28dd542c2da23d9c2a9346e6a22ea52" id="r_gaf28dd542c2da23d9c2a9346e6a22ea52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#gaf28dd542c2da23d9c2a9346e6a22ea52">wolfSSL_X509_get_serial_number</a> (WOLFSSL_X509 *x509, unsigned char *in, int *inOutSz)</td></tr>
<tr class="memdesc:gaf28dd542c2da23d9c2a9346e6a22ea52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the peer’s certificate serial number. The serial number buffer (in) should be at least 32 bytes long and be provided as the *inOutSz argument as input. After calling the function *inOutSz will hold the actual length in bytes written to the in buffer.  <br /></td></tr>
<tr class="memitem:gae3fa829ef7a8867441d5e318e5c0a214" id="r_gae3fa829ef7a8867441d5e318e5c0a214"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gae3fa829ef7a8867441d5e318e5c0a214">wolfSSL_X509_get_subjectCN</a> (WOLFSSL_X509 *)</td></tr>
<tr class="memdesc:gae3fa829ef7a8867441d5e318e5c0a214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the common name of the subject from the certificate.  <br /></td></tr>
<tr class="memitem:ga79f67a09528310251b65329bca9fe832" id="r_ga79f67a09528310251b65329bca9fe832"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga79f67a09528310251b65329bca9fe832">wolfSSL_X509_get_der</a> (WOLFSSL_X509 *x509, int *outSz)</td></tr>
<tr class="memdesc:ga79f67a09528310251b65329bca9fe832"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the DER encoded certificate in the WOLFSSL_X509 struct.  <br /></td></tr>
<tr class="memitem:ga65afb2cdac7ce13838539047dc5fbc14" id="r_ga65afb2cdac7ce13838539047dc5fbc14"><td class="memItemLeft" align="right" valign="top">WOLFSSL_ASN1_TIME *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga65afb2cdac7ce13838539047dc5fbc14">wolfSSL_X509_get_notAfter</a> (WOLFSSL_X509 *)</td></tr>
<tr class="memdesc:ga65afb2cdac7ce13838539047dc5fbc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if x509 is NULL and if it’s not, it returns the notAfter member of the x509 struct.  <br /></td></tr>
<tr class="memitem:ga04d06491c573578766b8de240192b3fa" id="r_ga04d06491c573578766b8de240192b3fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga04d06491c573578766b8de240192b3fa">wolfSSL_X509_version</a> (WOLFSSL_X509 *)</td></tr>
<tr class="memdesc:ga04d06491c573578766b8de240192b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the version of the X509 certificate.  <br /></td></tr>
<tr class="memitem:ga998f3d297cbc53f11ba38f8ffde1b356" id="r_ga998f3d297cbc53f11ba38f8ffde1b356"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga998f3d297cbc53f11ba38f8ffde1b356">wolfSSL_X509_d2i_fp</a> (WOLFSSL_X509 **x509, FILE *file)</td></tr>
<tr class="memdesc:ga998f3d297cbc53f11ba38f8ffde1b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">If NO_STDIO_FILESYSTEM is defined this function will allocate heap memory, initialize a WOLFSSL_X509 structure and return a pointer to it.  <br /></td></tr>
<tr class="memitem:ga129df2470af7336e0c6389548b5a1275" id="r_ga129df2470af7336e0c6389548b5a1275"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga129df2470af7336e0c6389548b5a1275">wolfSSL_X509_load_certificate_file</a> (const char *fname, int format)</td></tr>
<tr class="memdesc:ga129df2470af7336e0c6389548b5a1275"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function loads the x509 certificate into memory.  <br /></td></tr>
<tr class="memitem:ga2f0a0a86b06c94d27fb3dec04a9cb11f" id="r_ga2f0a0a86b06c94d27fb3dec04a9cb11f"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga2f0a0a86b06c94d27fb3dec04a9cb11f">wolfSSL_X509_get_device_type</a> (WOLFSSL_X509 *x509, unsigned char *in, int *inOutSz)</td></tr>
<tr class="memdesc:ga2f0a0a86b06c94d27fb3dec04a9cb11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the device type from the x509 structure to the buffer.  <br /></td></tr>
<tr class="memitem:ga96cec756bad0a2c5e9a82e5f6076c885" id="r_ga96cec756bad0a2c5e9a82e5f6076c885"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga96cec756bad0a2c5e9a82e5f6076c885">wolfSSL_X509_get_hw_type</a> (WOLFSSL_X509 *x509, unsigned char *in, int *inOutSz)</td></tr>
<tr class="memdesc:ga96cec756bad0a2c5e9a82e5f6076c885"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function copies the hwType member of the WOLFSSL_X509 structure to the buffer.  <br /></td></tr>
<tr class="memitem:gad0702bf867b15b7d7bef0fb6ad8cd518" id="r_gad0702bf867b15b7d7bef0fb6ad8cd518"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad0702bf867b15b7d7bef0fb6ad8cd518">wolfSSL_X509_get_hw_serial_number</a> (WOLFSSL_X509 *x509, unsigned char *in, int *inOutSz)</td></tr>
<tr class="memdesc:gad0702bf867b15b7d7bef0fb6ad8cd518"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the hwSerialNum member of the x509 object.  <br /></td></tr>
<tr class="memitem:ga5c2a07e4372fea5b1f5fe8ad32186dd3" id="r_ga5c2a07e4372fea5b1f5fe8ad32186dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3">wolfSSL_connect_cert</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5c2a07e4372fea5b1f5fe8ad32186dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates an SSL/TLS handshake with a server only long enough to get the peer’s certificate chain. When this function is called, the underlying communication channel has already been set up. <a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="group__IO.html#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will only return once the peer’s certificate chain has been received.  <br /></td></tr>
<tr class="memitem:ga560c154d5cc0c9ee48ee00aec7e2ca56" id="r_ga560c154d5cc0c9ee48ee00aec7e2ca56"><td class="memItemLeft" align="right" valign="top">WC_PKCS12 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga560c154d5cc0c9ee48ee00aec7e2ca56">wolfSSL_d2i_PKCS12_bio</a> (WOLFSSL_BIO *bio, WC_PKCS12 **pkcs12)</td></tr>
<tr class="memdesc:ga560c154d5cc0c9ee48ee00aec7e2ca56"><td class="mdescLeft">&#160;</td><td class="mdescRight">wolfSSL_d2i_PKCS12_bio (d2i_PKCS12_bio) copies in the PKCS12 information from WOLFSSL_BIO to the structure WC_PKCS12. The information is divided up in the structure as a list of Content Infos along with a structure to hold optional MAC information. After the information has been divided into chunks (but not decrypted) in the structure WC_PKCS12, it can then be parsed and decrypted by calling.  <br /></td></tr>
<tr class="memitem:ga12a977d5aa756bbdacc4b30686f2dc0e" id="r_ga12a977d5aa756bbdacc4b30686f2dc0e"><td class="memItemLeft" align="right" valign="top">WC_PKCS12 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga12a977d5aa756bbdacc4b30686f2dc0e">wolfSSL_i2d_PKCS12_bio</a> (WOLFSSL_BIO *bio, WC_PKCS12 *pkcs12)</td></tr>
<tr class="memdesc:ga12a977d5aa756bbdacc4b30686f2dc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">wolfSSL_i2d_PKCS12_bio (i2d_PKCS12_bio) copies in the cert information from the structure WC_PKCS12 to WOLFSSL_BIO.  <br /></td></tr>
<tr class="memitem:ga9bde570fabcb5436c246e1e45707558b" id="r_ga9bde570fabcb5436c246e1e45707558b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__openSSL.html#ga9bde570fabcb5436c246e1e45707558b">wolfSSL_PKCS12_parse</a> (WC_PKCS12 *pkcs12, const char *psw, WOLFSSL_EVP_PKEY **pkey, WOLFSSL_X509 **cert, <a class="el" href="group__CertsKeys.html#ga9aa6e326195805ad0782cc7d70d49691">WOLF_STACK_OF</a>(WOLFSSL_X509) **ca)</td></tr>
<tr class="memdesc:ga9bde570fabcb5436c246e1e45707558b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PKCS12 can be enabled with adding –enable-opensslextra to the configure command. It can use triple DES and RC4 for decryption so would recommend also enabling these features when enabling opensslextra (&ndash;enable-des3 –enable-arc4). wolfSSL does not currently support RC2 so decryption with RC2 is currently not available. This may be noticeable with default encryption schemes used by OpenSSL command line to create .p12 files. wolfSSL_PKCS12_parse (PKCS12_parse). The first thing this function does is check the MAC is correct if present. If the MAC fails then the function returns and does not try to decrypt any of the stored Content Infos. This function then parses through each Content Info looking for a bag type, if the bag type is known it is decrypted as needed and either stored in the list of certificates being built or as a key found. After parsing through all bags the key found is then compared with the certificate list until a matching pair is found. This matching pair is then returned as the key and certificate, optionally the certificate list found is returned as a STACK_OF certificates. At the moment a CRL, Secret or SafeContents bag will be skipped over and not parsed. It can be seen if these or other “Unknown” bags are skipped over by viewing the debug print out. Additional attributes such as friendly name are skipped over when parsing a PKCS12 file.  <br /></td></tr>
<tr class="memitem:ga2b71b223ea553324b5da0844d308cc68" id="r_ga2b71b223ea553324b5da0844d308cc68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga2b71b223ea553324b5da0844d308cc68">wolfSSL_SetTmpDH</a> (WOLFSSL *ssl, const unsigned char *p, int pSz, const unsigned char *g, int gSz)</td></tr>
<tr class="memdesc:ga2b71b223ea553324b5da0844d308cc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server Diffie-Hellman Ephemeral parameters setting. This function sets up the group parameters to be used if the server negotiates a cipher suite that uses DHE.  <br /></td></tr>
<tr class="memitem:ga2a7ba68e7087f73262257bff11793d31" id="r_ga2a7ba68e7087f73262257bff11793d31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga2a7ba68e7087f73262257bff11793d31">wolfSSL_SetTmpDH_buffer</a> (WOLFSSL *ssl, const unsigned char *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long sz, int format)</td></tr>
<tr class="memdesc:ga2a7ba68e7087f73262257bff11793d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calls the wolfSSL_SetTMpDH_buffer_wrapper, which is a wrapper for Diffie-Hellman parameters.  <br /></td></tr>
<tr class="memitem:ga58d15e18e9493a6aa96f0620eb8e6729" id="r_ga58d15e18e9493a6aa96f0620eb8e6729"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga58d15e18e9493a6aa96f0620eb8e6729">wolfSSL_SetTmpDH_file</a> (WOLFSSL *ssl, const char *f, int format)</td></tr>
<tr class="memdesc:ga58d15e18e9493a6aa96f0620eb8e6729"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls wolfSSL_SetTmpDH_file_wrapper to set server Diffie-Hellman parameters.  <br /></td></tr>
<tr class="memitem:ga83b872ae5c86b9b8de8176d06b783a7d" id="r_ga83b872ae5c86b9b8de8176d06b783a7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga83b872ae5c86b9b8de8176d06b783a7d">wolfSSL_CTX_SetTmpDH</a> (WOLFSSL_CTX *ctx, const unsigned char *p, int pSz, const unsigned char *g, int gSz)</td></tr>
<tr class="memdesc:ga83b872ae5c86b9b8de8176d06b783a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameters for the server CTX Diffie-Hellman.  <br /></td></tr>
<tr class="memitem:gac8289440323ec6bc027aaf6f17a64de0" id="r_gac8289440323ec6bc027aaf6f17a64de0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gac8289440323ec6bc027aaf6f17a64de0">wolfSSL_CTX_SetTmpDH_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long sz, int format)</td></tr>
<tr class="memdesc:gac8289440323ec6bc027aaf6f17a64de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function that calls wolfSSL_SetTmpDH_buffer_wrapper.  <br /></td></tr>
<tr class="memitem:ga9fe812176dde3f1fa1e9e0fec5cf0b6c" id="r_ga9fe812176dde3f1fa1e9e0fec5cf0b6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga9fe812176dde3f1fa1e9e0fec5cf0b6c">wolfSSL_CTX_SetTmpDH_file</a> (WOLFSSL_CTX *ctx, const char *f, int format)</td></tr>
<tr class="memdesc:ga9fe812176dde3f1fa1e9e0fec5cf0b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calls wolfSSL_SetTmpDH_file_wrapper to set the server Diffie-Hellman parameters.  <br /></td></tr>
<tr class="memitem:ga839bb78c10bdabd7d600f4e210e199a8" id="r_ga839bb78c10bdabd7d600f4e210e199a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga839bb78c10bdabd7d600f4e210e199a8">wolfSSL_CTX_SetMinDhKey_Sz</a> (WOLFSSL_CTX *ctx, word16)</td></tr>
<tr class="memdesc:ga839bb78c10bdabd7d600f4e210e199a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the minimum size (in bits) of the Diffie Hellman key size by accessing the minDhKeySz member in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:gad340064953980f82d82774a87c01c0e4" id="r_gad340064953980f82d82774a87c01c0e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad340064953980f82d82774a87c01c0e4">wolfSSL_SetMinDhKey_Sz</a> (WOLFSSL *ssl, word16 keySz_bits)</td></tr>
<tr class="memdesc:gad340064953980f82d82774a87c01c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum size (in bits) for a Diffie-Hellman key in the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gafbd5b0c62e79c2decb8776c9ed798613" id="r_gafbd5b0c62e79c2decb8776c9ed798613"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gafbd5b0c62e79c2decb8776c9ed798613">wolfSSL_CTX_SetMaxDhKey_Sz</a> (WOLFSSL_CTX *ctx, word16 keySz_bits)</td></tr>
<tr class="memdesc:gafbd5b0c62e79c2decb8776c9ed798613"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the maximum size (in bits) of the Diffie Hellman key size by accessing the maxDhKeySz member in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:gac7ed6270a1377e007d0be9f3c3fb85a9" id="r_gac7ed6270a1377e007d0be9f3c3fb85a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gac7ed6270a1377e007d0be9f3c3fb85a9">wolfSSL_SetMaxDhKey_Sz</a> (WOLFSSL *ssl, word16 keySz_bits)</td></tr>
<tr class="memdesc:gac7ed6270a1377e007d0be9f3c3fb85a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum size (in bits) for a Diffie-Hellman key in the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga5302f3521c346738867f1fae5d3e497a" id="r_ga5302f3521c346738867f1fae5d3e497a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga5302f3521c346738867f1fae5d3e497a">wolfSSL_GetDhKey_Sz</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga5302f3521c346738867f1fae5d3e497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of dhKeySz (in bits) that is a member of the options structure. This value represents the Diffie-Hellman key size in bytes.  <br /></td></tr>
<tr class="memitem:ga328f481ca676049c485d86e583c7f08a" id="r_ga328f481ca676049c485d86e583c7f08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga328f481ca676049c485d86e583c7f08a">wolfSSL_CTX_SetMinRsaKey_Sz</a> (WOLFSSL_CTX *ctx, short keySz)</td></tr>
<tr class="memdesc:ga328f481ca676049c485d86e583c7f08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum RSA key size in both the WOLFSSL_CTX structure and the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:ga41a4a7901f7ec5f1ddc91a2afcee4a1f" id="r_ga41a4a7901f7ec5f1ddc91a2afcee4a1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga41a4a7901f7ec5f1ddc91a2afcee4a1f">wolfSSL_SetMinRsaKey_Sz</a> (WOLFSSL *ssl, short keySz)</td></tr>
<tr class="memdesc:ga41a4a7901f7ec5f1ddc91a2afcee4a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum allowable key size in bits for RSA located in the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga6a546a4f53d1e3a5c15f427d6ccb8552" id="r_ga6a546a4f53d1e3a5c15f427d6ccb8552"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga6a546a4f53d1e3a5c15f427d6ccb8552">wolfSSL_CTX_SetMinEccKey_Sz</a> (WOLFSSL_CTX *ssl, short keySz)</td></tr>
<tr class="memdesc:ga6a546a4f53d1e3a5c15f427d6ccb8552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum size in bits for the ECC key in the WOLF_CTX structure and the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:gaf160fdd745c2b683e34ff594af982904" id="r_gaf160fdd745c2b683e34ff594af982904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf160fdd745c2b683e34ff594af982904">wolfSSL_SetMinEccKey_Sz</a> (WOLFSSL *ssl, short keySz)</td></tr>
<tr class="memdesc:gaf160fdd745c2b683e34ff594af982904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the minEccKeySz member of the options structure. The options struct is a member of the WOLFSSL structure and is accessed through the ssl parameter.  <br /></td></tr>
<tr class="memitem:ga3afa63fd5c9fa968085374b7fc743d87" id="r_ga3afa63fd5c9fa968085374b7fc743d87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga3afa63fd5c9fa968085374b7fc743d87">wolfSSL_make_eap_keys</a> (WOLFSSL *ssl, void *key, unsigned int len, const char *label)</td></tr>
<tr class="memdesc:ga3afa63fd5c9fa968085374b7fc743d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used by EAP_TLS and EAP-TTLS to derive keying material from the master secret.  <br /></td></tr>
<tr class="memitem:ga0a34c427432d689f5d99f134b2865b90" id="r_ga0a34c427432d689f5d99f134b2865b90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga0a34c427432d689f5d99f134b2865b90">wolfSSL_writev</a> (WOLFSSL *ssl, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ga0a34c427432d689f5d99f134b2865b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates writev semantics but doesn’t actually do block at a time because of SSL_write() behavior and because front adds may be small. Makes porting into software that uses writev easier.  <br /></td></tr>
<tr class="memitem:ga36f933d7df4f64a0beb8c1bc39ddecb5" id="r_ga36f933d7df4f64a0beb8c1bc39ddecb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga36f933d7df4f64a0beb8c1bc39ddecb5">wolfSSL_CTX_UnloadCAs</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:ga36f933d7df4f64a0beb8c1bc39ddecb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unloads the CA signer list and frees the whole signer table.  <br /></td></tr>
<tr class="memitem:ga8c8a4c139255bc994a902eff2c735955" id="r_ga8c8a4c139255bc994a902eff2c735955"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga8c8a4c139255bc994a902eff2c735955">wolfSSL_CTX_UnloadIntermediateCerts</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga8c8a4c139255bc994a902eff2c735955"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unloads intermediate certificates added to the CA signer list and frees them.  <br /></td></tr>
<tr class="memitem:gaf630b2fa19cba7e5451321cf4816210c" id="r_gaf630b2fa19cba7e5451321cf4816210c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaf630b2fa19cba7e5451321cf4816210c">wolfSSL_CTX_Unload_trust_peers</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:gaf630b2fa19cba7e5451321cf4816210c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to unload all previously loaded trusted peer certificates. Feature is enabled by defining the macro WOLFSSL_TRUST_PEER_CERT.  <br /></td></tr>
<tr class="memitem:gabf29fb376c82e819256ed54ee35204bb" id="r_gabf29fb376c82e819256ed54ee35204bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gabf29fb376c82e819256ed54ee35204bb">wolfSSL_CTX_trust_peer_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:gabf29fb376c82e819256ed54ee35204bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate to use for verifying a peer when performing a TLS/SSL handshake. The peer certificate sent during the handshake is compared by using the SKID when available and the signature. If these two things do not match then any loaded CAs are used. Is the same functionality as wolfSSL_CTX_trust_peer_cert except is from a buffer instead of a file. Feature is enabled by defining the macro WOLFSSL_TRUST_PEER_CERT Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gaa5a28f0ac25d9abeb72fcee81bbf647b" id="r_gaa5a28f0ac25d9abeb72fcee81bbf647b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaa5a28f0ac25d9abeb72fcee81bbf647b">wolfSSL_CTX_load_verify_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:gaa5a28f0ac25d9abeb72fcee81bbf647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a CA certificate buffer into the WOLFSSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. More than one CA certificate may be loaded per buffer as long as the format is in PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga84061f8015bf31d9eefb7241b6757c9a" id="r_ga84061f8015bf31d9eefb7241b6757c9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga84061f8015bf31d9eefb7241b6757c9a">wolfSSL_CTX_load_verify_buffer_ex</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format, int userChain, word32 flags)</td></tr>
<tr class="memdesc:ga84061f8015bf31d9eefb7241b6757c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a CA certificate buffer into the WOLFSSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. More than one CA certificate may be loaded per buffer as long as the format is in PEM. The _ex version was added in PR 2413 and supports additional arguments for userChain and flags.  <br /></td></tr>
<tr class="memitem:ga813711f224013ef2d5338038feb6e7bf" id="r_ga813711f224013ef2d5338038feb6e7bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga813711f224013ef2d5338038feb6e7bf">wolfSSL_CTX_load_verify_chain_buffer_format</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:ga813711f224013ef2d5338038feb6e7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a CA certificate chain buffer into the WOLFSSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. More than one CA certificate may be loaded per buffer as long as the format is in PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gae424b3a63756ab805de5c43b67f4df4f" id="r_gae424b3a63756ab805de5c43b67f4df4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gae424b3a63756ab805de5c43b67f4df4f">wolfSSL_CTX_use_certificate_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:gae424b3a63756ab805de5c43b67f4df4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate buffer into the WOLFSSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gaf88bd3ade7faefb028679f48ef64a237" id="r_gaf88bd3ade7faefb028679f48ef64a237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf88bd3ade7faefb028679f48ef64a237">wolfSSL_CTX_use_PrivateKey_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:gaf88bd3ade7faefb028679f48ef64a237"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a private key buffer into the SSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:gae08af065814c816d79c6c4279297a769" id="r_gae08af065814c816d79c6c4279297a769"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gae08af065814c816d79c6c4279297a769">wolfSSL_CTX_use_certificate_chain_buffer</a> (WOLFSSL_CTX *ctx, const unsigned char *in, long sz)</td></tr>
<tr class="memdesc:gae08af065814c816d79c6c4279297a769"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate chain buffer into the WOLFSSL Context. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. The buffer must be in PEM format and start with the subject’s certificate, ending with the root certificate. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga0027df230fa26421b3bb940525b3d330" id="r_ga0027df230fa26421b3bb940525b3d330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga0027df230fa26421b3bb940525b3d330">wolfSSL_use_certificate_buffer</a> (WOLFSSL *ssl, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:ga0027df230fa26421b3bb940525b3d330"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate buffer into the WOLFSSL object. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga3fb351ed993396e8b3ef3e0c49ebdfe9" id="r_ga3fb351ed993396e8b3ef3e0c49ebdfe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga3fb351ed993396e8b3ef3e0c49ebdfe9">wolfSSL_use_PrivateKey_buffer</a> (WOLFSSL *ssl, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:ga3fb351ed993396e8b3ef3e0c49ebdfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a private key buffer into the WOLFSSL object. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. format specifies the format type of the buffer; SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga5ba0212a7137e70748e52112c4368067" id="r_ga5ba0212a7137e70748e52112c4368067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga5ba0212a7137e70748e52112c4368067">wolfSSL_use_certificate_chain_buffer</a> (WOLFSSL *ssl, const unsigned char *in, long sz)</td></tr>
<tr class="memdesc:ga5ba0212a7137e70748e52112c4368067"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads a certificate chain buffer into the WOLFSSL object. It behaves like the non-buffered version, only differing in its ability to be called with a buffer as input instead of a file. The buffer is provided by the in argument of size sz. The buffer must be in PEM format and start with the subject’s certificate, ending with the root certificate. Please see the examples for proper usage.  <br /></td></tr>
<tr class="memitem:ga2b3e7dc477e9228ebc40bbee8194682f" id="r_ga2b3e7dc477e9228ebc40bbee8194682f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga2b3e7dc477e9228ebc40bbee8194682f">wolfSSL_UnloadCertsKeys</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga2b3e7dc477e9228ebc40bbee8194682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unloads any certificates or keys that SSL owns.  <br /></td></tr>
<tr class="memitem:gaa7940a96acc867bdda3ad79ebaa8667e" id="r_gaa7940a96acc867bdda3ad79ebaa8667e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa7940a96acc867bdda3ad79ebaa8667e">wolfSSL_CTX_set_group_messages</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:gaa7940a96acc867bdda3ad79ebaa8667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns on grouping of handshake messages where possible.  <br /></td></tr>
<tr class="memitem:ga3a41e044156047970c6bd96d1962764e" id="r_ga3a41e044156047970c6bd96d1962764e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga3a41e044156047970c6bd96d1962764e">wolfSSL_set_group_messages</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga3a41e044156047970c6bd96d1962764e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns on grouping of handshake messages where possible.  <br /></td></tr>
<tr class="memitem:a15e9a047ad453f7c4bd66177fb2fe9dd" id="r_a15e9a047ad453f7c4bd66177fb2fe9dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15e9a047ad453f7c4bd66177fb2fe9dd">wolfSSL_SetFuzzerCb</a> (WOLFSSL *ssl, CallbackFuzzer cbf, void *fCtx)</td></tr>
<tr class="memdesc:a15e9a047ad453f7c4bd66177fb2fe9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the fuzzer callback.  <br /></td></tr>
<tr class="memitem:a5b8b3f5e2ece0d4dfb06480a67ebb4e1" id="r_a5b8b3f5e2ece0d4dfb06480a67ebb4e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b8b3f5e2ece0d4dfb06480a67ebb4e1">wolfSSL_DTLS_SetCookieSecret</a> (WOLFSSL *ssl, const unsigned char *secret, unsigned int secretSz)</td></tr>
<tr class="memdesc:a5b8b3f5e2ece0d4dfb06480a67ebb4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a new dtls cookie secret.  <br /></td></tr>
<tr class="memitem:af53698613a37216625d15568d2035f0a" id="r_af53698613a37216625d15568d2035f0a"><td class="memItemLeft" align="right" valign="top">WC_RNG *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af53698613a37216625d15568d2035f0a">wolfSSL_GetRNG</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:af53698613a37216625d15568d2035f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the random number.  <br /></td></tr>
<tr class="memitem:ga3ea68d6110a0a5389864a9b81e9f3425" id="r_ga3ea68d6110a0a5389864a9b81e9f3425"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga3ea68d6110a0a5389864a9b81e9f3425">wolfSSL_CTX_SetMinVersion</a> (WOLFSSL_CTX *ctx, int version)</td></tr>
<tr class="memdesc:ga3ea68d6110a0a5389864a9b81e9f3425"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the minimum downgrade version allowed. Applicable only when the connection allows downgrade using (wolfSSLv23_client_method or wolfSSLv23_server_method).  <br /></td></tr>
<tr class="memitem:ga019ccc78fa3e8c2c093288596b46ab67" id="r_ga019ccc78fa3e8c2c093288596b46ab67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga019ccc78fa3e8c2c093288596b46ab67">wolfSSL_SetMinVersion</a> (WOLFSSL *ssl, int version)</td></tr>
<tr class="memdesc:ga019ccc78fa3e8c2c093288596b46ab67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the minimum downgrade version allowed. Applicable only when the connection allows downgrade using (wolfSSLv23_client_method or wolfSSLv23_server_method).  <br /></td></tr>
<tr class="memitem:a9c180621143adc0d002e51e5626d9820" id="r_a9c180621143adc0d002e51e5626d9820"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c180621143adc0d002e51e5626d9820">wolfSSL_GetObjectSize</a> (void)</td></tr>
<tr class="memdesc:a9c180621143adc0d002e51e5626d9820"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the size of the WOLFSSL object and will be dependent on build options and settings. If SHOW_SIZES has been defined when building wolfSSL, this function will also print the sizes of individual objects within the WOLFSSL object (Suites, Ciphers, etc.) to stdout.  <br /></td></tr>
<tr class="memitem:ac79dd3857ce4c179fcd1c449e4ec9b15" id="r_ac79dd3857ce4c179fcd1c449e4ec9b15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac79dd3857ce4c179fcd1c449e4ec9b15">wolfSSL_GetOutputSize</a> (WOLFSSL *ssl, int inSz)</td></tr>
<tr class="memdesc:ac79dd3857ce4c179fcd1c449e4ec9b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the record layer size of the plaintext input. This is helpful when an application wants to know how many bytes will be sent across the Transport layer, given a specified plaintext input size. This function must be called after the SSL/TLS handshake has been completed.  <br /></td></tr>
<tr class="memitem:a9ff204f2e651c5b998351a2cbb2ee1ff" id="r_a9ff204f2e651c5b998351a2cbb2ee1ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff204f2e651c5b998351a2cbb2ee1ff">wolfSSL_GetMaxOutputSize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a9ff204f2e651c5b998351a2cbb2ee1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum record layer size for plaintext data. This will correspond to either the maximum SSL/TLS record size as specified by the protocol standard, the maximum TLS fragment size as set by the TLS Max Fragment Length extension. This function is helpful when the application has called <a class="el" href="#ac79dd3857ce4c179fcd1c449e4ec9b15" title="Returns the record layer size of the plaintext input. This is helpful when an application wants to kn...">wolfSSL_GetOutputSize()</a> and received a INPUT_SIZE_E error. This function must be called after the SSL/TLS handshake has been completed.  <br /></td></tr>
<tr class="memitem:gaec07fda2e617787a3775c02062ac24dc" id="r_gaec07fda2e617787a3775c02062ac24dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaec07fda2e617787a3775c02062ac24dc">wolfSSL_SetVersion</a> (WOLFSSL *ssl, int version)</td></tr>
<tr class="memdesc:gaec07fda2e617787a3775c02062ac24dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the SSL/TLS protocol version for the specified SSL session (WOLFSSL object) using the version as specified by version. This will override the protocol setting for the SSL session (ssl) - originally defined and set by the SSL context (<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>) method type.  <br /></td></tr>
<tr class="memitem:ac48d6f657d683557e23f9ce388488039" id="r_ac48d6f657d683557e23f9ce388488039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac48d6f657d683557e23f9ce388488039">wolfSSL_CTX_SetMacEncryptCb</a> (WOLFSSL_CTX *ctx, CallbackMacEncrypti cb)</td></tr>
<tr class="memdesc:ac48d6f657d683557e23f9ce388488039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. macOut is the output buffer where the result of the mac should be stored. macIn is the mac input buffer and macInSz notes the size of the buffer. macContent and macVerify are needed for <a class="el" href="#acdba6b6ac9c948dd82c3d3a8ed256595" title="Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to in...">wolfSSL_SetTlsHmacInner()</a> and be passed along as is. encOut is the output buffer where the result on the encryption should be stored. encIn is the input buffer to encrypt while encSz is the size of the input. An example callback can be found wolfssl/test.h myMacEncryptCb().  <br /></td></tr>
<tr class="memitem:abf7ef9ed1a7b36f3c98447a28cd075c4" id="r_abf7ef9ed1a7b36f3c98447a28cd075c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4">wolfSSL_SetMacEncryptCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:abf7ef9ed1a7b36f3c98447a28cd075c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:a84e59d1c4a3f24ff5ece668e922d7548" id="r_a84e59d1c4a3f24ff5ece668e922d7548"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e59d1c4a3f24ff5ece668e922d7548">wolfSSL_GetMacEncryptCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a84e59d1c4a3f24ff5ece668e922d7548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously stored with <a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.">wolfSSL_SetMacEncryptCtx()</a>.  <br /></td></tr>
<tr class="memitem:a5f636c2e3517c2bb054d5bb50924b352" id="r_a5f636c2e3517c2bb054d5bb50924b352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f636c2e3517c2bb054d5bb50924b352">wolfSSL_CTX_SetDecryptVerifyCb</a> (WOLFSSL_CTX *ctx, CallbackDecryptVerify cb)</td></tr>
<tr class="memdesc:a5f636c2e3517c2bb054d5bb50924b352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. decOut is the output buffer where the result of the decryption should be stored. decIn is the encrypted input buffer and decInSz notes the size of the buffer. content and verify are needed for <a class="el" href="#acdba6b6ac9c948dd82c3d3a8ed256595" title="Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to in...">wolfSSL_SetTlsHmacInner()</a> and be passed along as is. padSz is an output variable that should be set with the total value of the padding. That is, the mac size plus any padding and pad bytes. An example callback can be found wolfssl/test.h myDecryptVerifyCb().  <br /></td></tr>
<tr class="memitem:a93021a9151fd3af1121b0380e87403d1" id="r_a93021a9151fd3af1121b0380e87403d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93021a9151fd3af1121b0380e87403d1">wolfSSL_SetDecryptVerifyCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:a93021a9151fd3af1121b0380e87403d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:a9cb89582080d65c25d65e70d9cec646c" id="r_a9cb89582080d65c25d65e70d9cec646c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb89582080d65c25d65e70d9cec646c">wolfSSL_GetDecryptVerifyCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a9cb89582080d65c25d65e70d9cec646c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Atomic User Record Processing Decrypt/Verify Callback Context previously stored with <a class="el" href="#a93021a9151fd3af1121b0380e87403d1" title="Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to ctx.">wolfSSL_SetDecryptVerifyCtx()</a>.  <br /></td></tr>
<tr class="memitem:ad75c66c5d37687c682db42754e3b4404" id="r_ad75c66c5d37687c682db42754e3b4404"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad75c66c5d37687c682db42754e3b4404">wolfSSL_GetMacSecret</a> (WOLFSSL *ssl, int verify)</td></tr>
<tr class="memdesc:ad75c66c5d37687c682db42754e3b4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the Hmac/Mac secret from the handshake process. The verify parameter specifies whether this is for verification of a peer message.  <br /></td></tr>
<tr class="memitem:a7ac2b35288c4437dec64fdea3c1bcae0" id="r_a7ac2b35288c4437dec64fdea3c1bcae0"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac2b35288c4437dec64fdea3c1bcae0">wolfSSL_GetClientWriteKey</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a7ac2b35288c4437dec64fdea3c1bcae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the client write key from the handshake process.  <br /></td></tr>
<tr class="memitem:a9e777589542c2074cd63353478b3ced7" id="r_a9e777589542c2074cd63353478b3ced7"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e777589542c2074cd63353478b3ced7">wolfSSL_GetClientWriteIV</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a9e777589542c2074cd63353478b3ced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the client write IV (initialization vector) from the handshake process.  <br /></td></tr>
<tr class="memitem:ab37a6477e56341a08aa1d45cff857904" id="r_ab37a6477e56341a08aa1d45cff857904"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37a6477e56341a08aa1d45cff857904">wolfSSL_GetServerWriteKey</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ab37a6477e56341a08aa1d45cff857904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the server write key from the handshake process.  <br /></td></tr>
<tr class="memitem:a77b2ad773cf98838d102cadfe6dee0e6" id="r_a77b2ad773cf98838d102cadfe6dee0e6"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b2ad773cf98838d102cadfe6dee0e6">wolfSSL_GetServerWriteIV</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a77b2ad773cf98838d102cadfe6dee0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the server write IV (initialization vector) from the handshake process.  <br /></td></tr>
<tr class="memitem:a6bcf1af4dd68c8f611fd18a21bca320f" id="r_a6bcf1af4dd68c8f611fd18a21bca320f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f">wolfSSL_GetKeySize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a6bcf1af4dd68c8f611fd18a21bca320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the key size from the handshake process.  <br /></td></tr>
<tr class="memitem:gaf41b6226db23c3e42a92b873bb87de5c" id="r_gaf41b6226db23c3e42a92b873bb87de5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf41b6226db23c3e42a92b873bb87de5c">wolfSSL_GetIVSize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gaf41b6226db23c3e42a92b873bb87de5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iv_size member of the specs structure held in the WOLFSSL struct.  <br /></td></tr>
<tr class="memitem:a2eee66c89a1e3288a75068faf329e47c" id="r_a2eee66c89a1e3288a75068faf329e47c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eee66c89a1e3288a75068faf329e47c">wolfSSL_GetSide</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a2eee66c89a1e3288a75068faf329e47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows retrieval of the side of this WOLFSSL connection.  <br /></td></tr>
<tr class="memitem:a100e012b65e6f52ff52498aca3ca9828" id="r_a100e012b65e6f52ff52498aca3ca9828"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a100e012b65e6f52ff52498aca3ca9828">wolfSSL_IsTLSv1_1</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a100e012b65e6f52ff52498aca3ca9828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine if the negotiated protocol version is at least TLS version 1.1 or greater.  <br /></td></tr>
<tr class="memitem:a36b767ad63997d29a4d209f6e2c9560e" id="r_a36b767ad63997d29a4d209f6e2c9560e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e">wolfSSL_GetBulkCipher</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a36b767ad63997d29a4d209f6e2c9560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated bulk cipher algorithm from the handshake.  <br /></td></tr>
<tr class="memitem:a96a5d42c23ca6f18d8abb3440c986666" id="r_a96a5d42c23ca6f18d8abb3440c986666"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666">wolfSSL_GetCipherBlockSize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a96a5d42c23ca6f18d8abb3440c986666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated cipher block size from the handshake.  <br /></td></tr>
<tr class="memitem:a04528c30cd8cedcdddea74cddd3694f8" id="r_a04528c30cd8cedcdddea74cddd3694f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04528c30cd8cedcdddea74cddd3694f8">wolfSSL_GetAeadMacSize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a04528c30cd8cedcdddea74cddd3694f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated aead mac size from the handshake. For cipher type WOLFSSL_AEAD_TYPE.  <br /></td></tr>
<tr class="memitem:aa551e5b8c1a784fef36bff7c436ff9e2" id="r_aa551e5b8c1a784fef36bff7c436ff9e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2">wolfSSL_GetHmacSize</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:aa551e5b8c1a784fef36bff7c436ff9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOLFSSL_AEAD_TYPE.  <br /></td></tr>
<tr class="memitem:a081b82271e2a276bef3434b15f65f5dc" id="r_a081b82271e2a276bef3434b15f65f5dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081b82271e2a276bef3434b15f65f5dc">wolfSSL_GetHmacType</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a081b82271e2a276bef3434b15f65f5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated (h)mac type from the handshake. For cipher types except WOLFSSL_AEAD_TYPE.  <br /></td></tr>
<tr class="memitem:a8d1d6965af541819903d254759433043" id="r_a8d1d6965af541819903d254759433043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d1d6965af541819903d254759433043">wolfSSL_GetCipherType</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:a8d1d6965af541819903d254759433043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to determine the negotiated cipher type from the handshake.  <br /></td></tr>
<tr class="memitem:acdba6b6ac9c948dd82c3d3a8ed256595" id="r_acdba6b6ac9c948dd82c3d3a8ed256595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdba6b6ac9c948dd82c3d3a8ed256595">wolfSSL_SetTlsHmacInner</a> (WOLFSSL *ssl, byte *inner, word32 sz, int content, int verify)</td></tr>
<tr class="memdesc:acdba6b6ac9c948dd82c3d3a8ed256595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to inner which should be at least <a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2" title="Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOL...">wolfSSL_GetHmacSize()</a> bytes. The size of the message is specified by sz, content is the type of message, and verify specifies whether this is a verification of a peer message. Valid for cipher types excluding WOLFSSL_AEAD_TYPE.  <br /></td></tr>
<tr class="memitem:aee3ccfce4e8b5aa1a2ccfbb447365dfb" id="r_aee3ccfce4e8b5aa1a2ccfbb447365dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb">wolfSSL_CTX_SetEccSignCb</a> (WOLFSSL_CTX *ctx, CallbackEccSign cb)</td></tr>
<tr class="memdesc:aee3ccfce4e8b5aa1a2ccfbb447365dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to sign while inSz denotes the length of the input. out is the output buffer where the result of the signature should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. keyDer is the ECC Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myEccSign().  <br /></td></tr>
<tr class="memitem:a3f65634376fab1d6d61c6d998b2cc3ab" id="r_a3f65634376fab1d6d61c6d998b2cc3ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab">wolfSSL_SetEccSignCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:a3f65634376fab1d6d61c6d998b2cc3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Ecc Signing Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:ac731df86e30f87e7823a7da59b461adb" id="r_ac731df86e30f87e7823a7da59b461adb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac731df86e30f87e7823a7da59b461adb">wolfSSL_GetEccSignCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ac731df86e30f87e7823a7da59b461adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with <a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx()</a>.  <br /></td></tr>
<tr class="memitem:a930c2e720e3ca1f998cf61c4b537ffe1" id="r_a930c2e720e3ca1f998cf61c4b537ffe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930c2e720e3ca1f998cf61c4b537ffe1">wolfSSL_CTX_SetEccSignCtx</a> (WOLFSSL_CTX *ctx, void *userCtx)</td></tr>
<tr class="memdesc:a930c2e720e3ca1f998cf61c4b537ffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Ecc Signing Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:ad478677f213dad5e6c6e60cc636705e1" id="r_ad478677f213dad5e6c6e60cc636705e1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad478677f213dad5e6c6e60cc636705e1">wolfSSL_CTX_GetEccSignCtx</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ad478677f213dad5e6c6e60cc636705e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with <a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx()</a>.  <br /></td></tr>
<tr class="memitem:ab58ec34fc70378f3be1a8035637091eb" id="r_ab58ec34fc70378f3be1a8035637091eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab58ec34fc70378f3be1a8035637091eb">wolfSSL_CTX_SetEccVerifyCb</a> (WOLFSSL_CTX *ctx, CallbackEccVerify cb)</td></tr>
<tr class="memdesc:ab58ec34fc70378f3be1a8035637091eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for ECC Verification. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. sig is the signature to verify and sigSz denotes the length of the signature. hash is an input buffer containing the digest of the message and hashSz denotes the length in bytes of the hash. result is an output variable where the result of the verification should be stored, 1 for success and 0 for failure. keyDer is the ECC Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myEccVerify().  <br /></td></tr>
<tr class="memitem:a1c89bf6fc378bfbf8c0559b4e6c820e1" id="r_a1c89bf6fc378bfbf8c0559b4e6c820e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c89bf6fc378bfbf8c0559b4e6c820e1">wolfSSL_SetEccVerifyCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:a1c89bf6fc378bfbf8c0559b4e6c820e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Ecc Verification Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:ace78694804dc9bc862904b78ef73d40d" id="r_ace78694804dc9bc862904b78ef73d40d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace78694804dc9bc862904b78ef73d40d">wolfSSL_GetEccVerifyCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ace78694804dc9bc862904b78ef73d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key Ecc Verification Callback Context previously stored with <a class="el" href="#a1c89bf6fc378bfbf8c0559b4e6c820e1" title="Allows caller to set the Public Key Ecc Verification Callback Context to ctx.">wolfSSL_SetEccVerifyCtx()</a>.  <br /></td></tr>
<tr class="memitem:a456c256848365be4a742b99b5a5cb84b" id="r_a456c256848365be4a742b99b5a5cb84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456c256848365be4a742b99b5a5cb84b">wolfSSL_CTX_SetRsaSignCb</a> (WOLFSSL_CTX *ctx, CallbackRsaSign cb)</td></tr>
<tr class="memdesc:a456c256848365be4a742b99b5a5cb84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for RSA Signing. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to sign while inSz denotes the length of the input. out is the output buffer where the result of the signature should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. keyDer is the RSA Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaSign().  <br /></td></tr>
<tr class="memitem:aff1829c6e4c7ed720774ed3a92881f1c" id="r_aff1829c6e4c7ed720774ed3a92881f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff1829c6e4c7ed720774ed3a92881f1c">wolfSSL_SetRsaSignCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:aff1829c6e4c7ed720774ed3a92881f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key RSA Signing Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:a02c1b4c6be145f901e7abb2c3910b93c" id="r_a02c1b4c6be145f901e7abb2c3910b93c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c1b4c6be145f901e7abb2c3910b93c">wolfSSL_GetRsaSignCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a02c1b4c6be145f901e7abb2c3910b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key RSA Signing Callback Context previously stored with <a class="el" href="#aff1829c6e4c7ed720774ed3a92881f1c" title="Allows caller to set the Public Key RSA Signing Callback Context to ctx.">wolfSSL_SetRsaSignCtx()</a>.  <br /></td></tr>
<tr class="memitem:a50a079dcac754ad333f983b943a9f587" id="r_a50a079dcac754ad333f983b943a9f587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a079dcac754ad333f983b943a9f587">wolfSSL_CTX_SetRsaVerifyCb</a> (WOLFSSL_CTX *ctx, CallbackRsaVerify cb)</td></tr>
<tr class="memdesc:a50a079dcac754ad333f983b943a9f587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for RSA Verification. The callback should return the number of plaintext bytes for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. sig is the signature to verify and sigSz denotes the length of the signature. out should be set to the beginning of the verification buffer after the decryption process and any padding. keyDer is the RSA Public key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaVerify().  <br /></td></tr>
<tr class="memitem:ae85c95865fb414c3f38d76cd2ac23606" id="r_ae85c95865fb414c3f38d76cd2ac23606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae85c95865fb414c3f38d76cd2ac23606">wolfSSL_SetRsaVerifyCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:ae85c95865fb414c3f38d76cd2ac23606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key RSA Verification Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:a0b3febe7a64aeb29f35674bcb32a3e8d" id="r_a0b3febe7a64aeb29f35674bcb32a3e8d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b3febe7a64aeb29f35674bcb32a3e8d">wolfSSL_GetRsaVerifyCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a0b3febe7a64aeb29f35674bcb32a3e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key RSA Verification Callback Context previously stored with <a class="el" href="#ae85c95865fb414c3f38d76cd2ac23606" title="Allows caller to set the Public Key RSA Verification Callback Context to ctx.">wolfSSL_SetRsaVerifyCtx()</a>.  <br /></td></tr>
<tr class="memitem:a8669fb775ff5541e6e4713ebb5e56f42" id="r_a8669fb775ff5541e6e4713ebb5e56f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8669fb775ff5541e6e4713ebb5e56f42">wolfSSL_CTX_SetRsaEncCb</a> (WOLFSSL_CTX *ctx, CallbackRsaEnc cb)</td></tr>
<tr class="memdesc:a8669fb775ff5541e6e4713ebb5e56f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for RSA Public Encrypt. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to encrypt while inSz denotes the length of the input. out is the output buffer where the result of the encryption should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the encryption should be stored there before returning. keyDer is the RSA Public key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaEnc().  <br /></td></tr>
<tr class="memitem:a1ffa93301f06d864f5e41f99104a4a2e" id="r_a1ffa93301f06d864f5e41f99104a4a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ffa93301f06d864f5e41f99104a4a2e">wolfSSL_SetRsaEncCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:a1ffa93301f06d864f5e41f99104a4a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:abce00333fd98f987d37b2ea6bc391c33" id="r_abce00333fd98f987d37b2ea6bc391c33"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce00333fd98f987d37b2ea6bc391c33">wolfSSL_GetRsaEncCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:abce00333fd98f987d37b2ea6bc391c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key RSA Public Encrypt Callback Context previously stored with <a class="el" href="#a1ffa93301f06d864f5e41f99104a4a2e" title="Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx.">wolfSSL_SetRsaEncCtx()</a>.  <br /></td></tr>
<tr class="memitem:af2d8a09019d57278c2f2079df3a9112d" id="r_af2d8a09019d57278c2f2079df3a9112d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2d8a09019d57278c2f2079df3a9112d">wolfSSL_CTX_SetRsaDecCb</a> (WOLFSSL_CTX *ctx, CallbackRsaDec cb)</td></tr>
<tr class="memdesc:af2d8a09019d57278c2f2079df3a9112d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key Callback for RSA Private Decrypt. The callback should return the number of plaintext bytes for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to decrypt and inSz denotes the length of the input. out should be set to the beginning of the decryption buffer after the decryption process and any padding. keyDer is the RSA Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaDec().  <br /></td></tr>
<tr class="memitem:a5e7d5db6deee59da336e3d399a62fb8f" id="r_a5e7d5db6deee59da336e3d399a62fb8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e7d5db6deee59da336e3d399a62fb8f">wolfSSL_SetRsaDecCtx</a> (WOLFSSL *ssl, void *ctx)</td></tr>
<tr class="memdesc:a5e7d5db6deee59da336e3d399a62fb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx.  <br /></td></tr>
<tr class="memitem:a6610b35607255d7cdaf911e681f8559a" id="r_a6610b35607255d7cdaf911e681f8559a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6610b35607255d7cdaf911e681f8559a">wolfSSL_GetRsaDecCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a6610b35607255d7cdaf911e681f8559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows caller to retrieve the Public Key RSA Private Decrypt Callback Context previously stored with <a class="el" href="#a5e7d5db6deee59da336e3d399a62fb8f" title="Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx.">wolfSSL_SetRsaDecCtx()</a>.  <br /></td></tr>
<tr class="memitem:ab926a750284cd59ed7cd71b708852404" id="r_ab926a750284cd59ed7cd71b708852404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab926a750284cd59ed7cd71b708852404">wolfSSL_CTX_SetCACb</a> (WOLFSSL_CTX *ctx, CallbackCACache cb)</td></tr>
<tr class="memdesc:ab926a750284cd59ed7cd71b708852404"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a callback with the SSL context (WOLFSSL_CTX) to be called when a new CA certificate is loaded into wolfSSL. The callback is given a buffer with the DER-encoded certificate.  <br /></td></tr>
<tr class="memitem:ga7c003b945a105247fe5baf0ecb93fedf" id="r_ga7c003b945a105247fe5baf0ecb93fedf"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CERT_MANAGER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga7c003b945a105247fe5baf0ecb93fedf">wolfSSL_CertManagerNew_ex</a> (void *heap)</td></tr>
<tr class="memdesc:ga7c003b945a105247fe5baf0ecb93fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes a new Certificate Manager context. This context may be used independent of SSL needs. It may be used to load certificates, verify certificates, and check the revocation status.  <br /></td></tr>
<tr class="memitem:ga654752c1994c9e87fe5e97af0c16ea63" id="r_ga654752c1994c9e87fe5e97af0c16ea63"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CERT_MANAGER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga654752c1994c9e87fe5e97af0c16ea63">wolfSSL_CertManagerNew</a> (void)</td></tr>
<tr class="memdesc:ga654752c1994c9e87fe5e97af0c16ea63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes a new Certificate Manager context. This context may be used independent of SSL needs. It may be used to load certificates, verify certificates, and check the revocation status.  <br /></td></tr>
<tr class="memitem:ga57ba8168c6b468eef0978ad60b8bf092" id="r_ga57ba8168c6b468eef0978ad60b8bf092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga57ba8168c6b468eef0978ad60b8bf092">wolfSSL_CertManagerFree</a> (WOLFSSL_CERT_MANAGER *)</td></tr>
<tr class="memdesc:ga57ba8168c6b468eef0978ad60b8bf092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all resources associated with the Certificate Manager context. Call this when you no longer need to use the Certificate Manager.  <br /></td></tr>
<tr class="memitem:ga548767c9d7da9a197a746a148f1bda3b" id="r_ga548767c9d7da9a197a746a148f1bda3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga548767c9d7da9a197a746a148f1bda3b">wolfSSL_CertManagerLoadCA</a> (WOLFSSL_CERT_MANAGER *cm, const char *f, const char *d)</td></tr>
<tr class="memdesc:ga548767c9d7da9a197a746a148f1bda3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the locations for CA certificate loading into the manager context. The PEM certificate CAfile may contain several trusted CA certificates. If CApath is not NULL it specifies a directory containing CA certificates in PEM format.  <br /></td></tr>
<tr class="memitem:gae8385826f3feb6c68f239b91ab613e1b" id="r_gae8385826f3feb6c68f239b91ab613e1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gae8385826f3feb6c68f239b91ab613e1b">wolfSSL_CertManagerLoadCABuffer</a> (WOLFSSL_CERT_MANAGER *cm, const unsigned char *in, long sz, int format)</td></tr>
<tr class="memdesc:gae8385826f3feb6c68f239b91ab613e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the CA Buffer by calling wolfSSL_CTX_load_verify_buffer and returning that result using a temporary cm so as not to lose the information in the cm passed into the function.  <br /></td></tr>
<tr class="memitem:ga6435f45bfaeb5a5e282a73df2f160475" id="r_ga6435f45bfaeb5a5e282a73df2f160475"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga6435f45bfaeb5a5e282a73df2f160475">wolfSSL_CertManagerUnloadCAs</a> (WOLFSSL_CERT_MANAGER *cm)</td></tr>
<tr class="memdesc:ga6435f45bfaeb5a5e282a73df2f160475"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unloads the CA signer list.  <br /></td></tr>
<tr class="memitem:ga80cf4ee881a11c5f973aa6971ed01373" id="r_ga80cf4ee881a11c5f973aa6971ed01373"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga80cf4ee881a11c5f973aa6971ed01373">wolfSSL_CertManagerUnloadIntermediateCerts</a> (WOLFSSL_CERT_MANAGER *cm)</td></tr>
<tr class="memdesc:ga80cf4ee881a11c5f973aa6971ed01373"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unloads intermediate certificates add to the CA signer list.  <br /></td></tr>
<tr class="memitem:ga4ac407be88acf2b8c329fbca68bd4163" id="r_ga4ac407be88acf2b8c329fbca68bd4163"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga4ac407be88acf2b8c329fbca68bd4163">wolfSSL_CertManagerUnload_trust_peers</a> (WOLFSSL_CERT_MANAGER *cm)</td></tr>
<tr class="memdesc:ga4ac407be88acf2b8c329fbca68bd4163"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function will free the Trusted Peer linked list and unlocks the trusted peer list.  <br /></td></tr>
<tr class="memitem:ga02a2f8451f6b5583f84e30ed9b192839" id="r_ga02a2f8451f6b5583f84e30ed9b192839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga02a2f8451f6b5583f84e30ed9b192839">wolfSSL_CertManagerVerify</a> (WOLFSSL_CERT_MANAGER *cm, const char *f, int format)</td></tr>
<tr class="memdesc:ga02a2f8451f6b5583f84e30ed9b192839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the certificate to verify with the Certificate Manager context. The format can be SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1.  <br /></td></tr>
<tr class="memitem:ga33fb6d3ecbea2b276f0cbef1e179fb07" id="r_ga33fb6d3ecbea2b276f0cbef1e179fb07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga33fb6d3ecbea2b276f0cbef1e179fb07">wolfSSL_CertManagerVerifyBuffer</a> (WOLFSSL_CERT_MANAGER *cm, const unsigned char *buff, long sz, int format)</td></tr>
<tr class="memdesc:ga33fb6d3ecbea2b276f0cbef1e179fb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the certificate buffer to verify with the Certificate Manager context. The format can be SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1.  <br /></td></tr>
<tr class="memitem:gaae21fa2f6d4b04512bee2bc17ef0fcef" id="r_gaae21fa2f6d4b04512bee2bc17ef0fcef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gaae21fa2f6d4b04512bee2bc17ef0fcef">wolfSSL_CertManagerSetVerify</a> (WOLFSSL_CERT_MANAGER *cm, VerifyCallback verify_callback)</td></tr>
<tr class="memdesc:gaae21fa2f6d4b04512bee2bc17ef0fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the verifyCallback function in the Certificate Manager. If present, it will be called for each cert loaded. If there is a verification error, the verify callback can be used to over-ride the error.  <br /></td></tr>
<tr class="memitem:aa28e1637d83269c0f9f37912b3c06a46" id="r_aa28e1637d83269c0f9f37912b3c06a46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28e1637d83269c0f9f37912b3c06a46">wolfSSL_CertManagerCheckCRL</a> (WOLFSSL_CERT_MANAGER *cm, unsigned char *der, int sz)</td></tr>
<tr class="memdesc:aa28e1637d83269c0f9f37912b3c06a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check CRL if the option is enabled and compares the cert to the CRL list.  <br /></td></tr>
<tr class="memitem:gaa0caa567b553f8417bca591cd18c9a25" id="r_gaa0caa567b553f8417bca591cd18c9a25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gaa0caa567b553f8417bca591cd18c9a25">wolfSSL_CertManagerEnableCRL</a> (WOLFSSL_CERT_MANAGER *cm, int options)</td></tr>
<tr class="memdesc:gaa0caa567b553f8417bca591cd18c9a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on Certificate Revocation List checking when verifying certificates with the Certificate Manager. By default, CRL checking is off. options include WOLFSSL_CRL_CHECKALL which performs CRL checking on each certificate in the chain versus the Leaf certificate only which is the default.  <br /></td></tr>
<tr class="memitem:ga9e8cc5c00936adde105e64dbf1e8d403" id="r_ga9e8cc5c00936adde105e64dbf1e8d403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga9e8cc5c00936adde105e64dbf1e8d403">wolfSSL_CertManagerDisableCRL</a> (WOLFSSL_CERT_MANAGER *)</td></tr>
<tr class="memdesc:ga9e8cc5c00936adde105e64dbf1e8d403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off Certificate Revocation List checking when verifying certificates with the Certificate Manager. By default, CRL checking is off. You can use this function to temporarily or permanently disable CRL checking with this Certificate Manager context that previously had CRL checking enabled.  <br /></td></tr>
<tr class="memitem:ga407833060925d7dd8366db3ca557ce8e" id="r_ga407833060925d7dd8366db3ca557ce8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga407833060925d7dd8366db3ca557ce8e">wolfSSL_CertManagerLoadCRL</a> (WOLFSSL_CERT_MANAGER *cm, const char *path, int type, int monitor)</td></tr>
<tr class="memdesc:ga407833060925d7dd8366db3ca557ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error checks and passes through to LoadCRL() in order to load the cert into the CRL for revocation checking. An updated CRL can be loaded by first calling wolfSSL_CertManagerFreeCRL, then loading the new CRL.  <br /></td></tr>
<tr class="memitem:ga2db6e5f4ed5fa7d41ecc6c7ca7a04aec" id="r_ga2db6e5f4ed5fa7d41ecc6c7ca7a04aec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga2db6e5f4ed5fa7d41ecc6c7ca7a04aec">wolfSSL_CertManagerLoadCRLBuffer</a> (WOLFSSL_CERT_MANAGER *cm, const unsigned char *buff, long sz, int type)</td></tr>
<tr class="memdesc:ga2db6e5f4ed5fa7d41ecc6c7ca7a04aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function loads the CRL file by calling BufferLoadCRL.  <br /></td></tr>
<tr class="memitem:ga4929fe270fdc7cf0bdfca82d2c8a88ef" id="r_ga4929fe270fdc7cf0bdfca82d2c8a88ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga4929fe270fdc7cf0bdfca82d2c8a88ef">wolfSSL_CertManagerSetCRL_Cb</a> (WOLFSSL_CERT_MANAGER *cm, CbMissingCRL cb)</td></tr>
<tr class="memdesc:ga4929fe270fdc7cf0bdfca82d2c8a88ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the CRL Certificate Manager callback. If HAVE_CRL is defined and a matching CRL record is not found then the cbMissingCRL is called (set via wolfSSL_CertManagerSetCRL_Cb). This allows you to externally retrieve the CRL and load it.  <br /></td></tr>
<tr class="memitem:gab2481c2d71595eccaf7955ca4f3c0312" id="r_gab2481c2d71595eccaf7955ca4f3c0312"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gab2481c2d71595eccaf7955ca4f3c0312">wolfSSL_CertManagerSetCRLUpdate_Cb</a> (WOLFSSL_CERT_MANAGER *cm, CbUpdateCRL cb)</td></tr>
<tr class="memdesc:gab2481c2d71595eccaf7955ca4f3c0312"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the CRL Update callback. If HAVE_CRL and HAVE_CRL_UPDATE_CB is defined , and an entry with the same issuer and a lower CRL number exists when a CRL is added, then the CbUpdateCRL is called with the details of the existing entry and the new one replacing it.  <br /></td></tr>
<tr class="memitem:ga4866ca759a4b64b78938b1358b378416" id="r_ga4866ca759a4b64b78938b1358b378416"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga4866ca759a4b64b78938b1358b378416">wolfSSL_CertManagerGetCRLInfo</a> (WOLFSSL_CERT_MANAGER *cm, CrlInfo *info, const byte *buff, long sz, int type) int wolfSSL_CertManagerFreeCRL(WOLFSSL_CERT_MANAGER *cm)</td></tr>
<tr class="memdesc:ga4866ca759a4b64b78938b1358b378416"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function yields a structure with parsed CRL information from an encoded CRL buffer.  <br /></td></tr>
<tr class="memitem:ga53ff0bfe288d67722d794facebc09543" id="r_ga53ff0bfe288d67722d794facebc09543"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga53ff0bfe288d67722d794facebc09543">wolfSSL_CertManagerCheckOCSP</a> (WOLFSSL_CERT_MANAGER *cm, unsigned char *der, int sz)</td></tr>
<tr class="memdesc:ga53ff0bfe288d67722d794facebc09543"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the WOLFSSL_CERT_MANAGER’s member, ocspEnabled to signify that the OCSP check option is enabled.  <br /></td></tr>
<tr class="memitem:ga05b1f36d81c5cf5316336a2f54d53e68" id="r_ga05b1f36d81c5cf5316336a2f54d53e68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga05b1f36d81c5cf5316336a2f54d53e68">wolfSSL_CertManagerEnableOCSP</a> (WOLFSSL_CERT_MANAGER *cm, int options)</td></tr>
<tr class="memdesc:ga05b1f36d81c5cf5316336a2f54d53e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on OCSP if it’s turned off and if compiled with the set option available.  <br /></td></tr>
<tr class="memitem:ga31367a0d315f0342113ce827128727f9" id="r_ga31367a0d315f0342113ce827128727f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga31367a0d315f0342113ce827128727f9">wolfSSL_CertManagerDisableOCSP</a> (WOLFSSL_CERT_MANAGER *)</td></tr>
<tr class="memdesc:ga31367a0d315f0342113ce827128727f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables OCSP certificate revocation.  <br /></td></tr>
<tr class="memitem:gaae16a6566a0a4ac899ca94e8b9869158" id="r_gaae16a6566a0a4ac899ca94e8b9869158"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gaae16a6566a0a4ac899ca94e8b9869158">wolfSSL_CertManagerSetOCSPOverrideURL</a> (WOLFSSL_CERT_MANAGER *cm, const char *url)</td></tr>
<tr class="memdesc:gaae16a6566a0a4ac899ca94e8b9869158"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function copies the url to the ocspOverrideURL member of the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:ga40598eacaa03af2e003e95f57ddd30a9" id="r_ga40598eacaa03af2e003e95f57ddd30a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#ga40598eacaa03af2e003e95f57ddd30a9">wolfSSL_CertManagerSetOCSP_Cb</a> (WOLFSSL_CERT_MANAGER *cm, CbOCSPIO ioCb, CbOCSPRespFree respFreeCb, void *ioCbCtx)</td></tr>
<tr class="memdesc:ga40598eacaa03af2e003e95f57ddd30a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the OCSP callback in the WOLFSSL_CERT_MANAGER.  <br /></td></tr>
<tr class="memitem:gac17294be4393a23f98c7004217376dae" id="r_gac17294be4393a23f98c7004217376dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertManager.html#gac17294be4393a23f98c7004217376dae">wolfSSL_CertManagerEnableOCSPStapling</a> (WOLFSSL_CERT_MANAGER *cm)</td></tr>
<tr class="memdesc:gac17294be4393a23f98c7004217376dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns on OCSP stapling if it is not turned on as well as set the options.  <br /></td></tr>
<tr class="memitem:ae20963c699c42a41fa799262bdd55579" id="r_ae20963c699c42a41fa799262bdd55579"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae20963c699c42a41fa799262bdd55579">wolfSSL_EnableCRL</a> (WOLFSSL *ssl, int options)</td></tr>
<tr class="memdesc:ae20963c699c42a41fa799262bdd55579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables CRL certificate revocation.  <br /></td></tr>
<tr class="memitem:ac61342d421acd184492aa8a674270805" id="r_ac61342d421acd184492aa8a674270805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61342d421acd184492aa8a674270805">wolfSSL_DisableCRL</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ac61342d421acd184492aa8a674270805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables CRL certificate revocation.  <br /></td></tr>
<tr class="memitem:ae7e4756ce11b1803379dc9a121b2b954" id="r_ae7e4756ce11b1803379dc9a121b2b954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e4756ce11b1803379dc9a121b2b954">wolfSSL_LoadCRL</a> (WOLFSSL *ssl, const char *path, int type, int monitor)</td></tr>
<tr class="memdesc:ae7e4756ce11b1803379dc9a121b2b954"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function that ends up calling LoadCRL to load the certificate for revocation checking.  <br /></td></tr>
<tr class="memitem:a761a40b527f38ba2df833fe8b51a8408" id="r_a761a40b527f38ba2df833fe8b51a8408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a761a40b527f38ba2df833fe8b51a8408">wolfSSL_SetCRL_Cb</a> (WOLFSSL *ssl, CbMissingCRL cb)</td></tr>
<tr class="memdesc:a761a40b527f38ba2df833fe8b51a8408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CRL callback in the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:a1c18a7ff26ebcb9453dc2f6616b8950b" id="r_a1c18a7ff26ebcb9453dc2f6616b8950b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c18a7ff26ebcb9453dc2f6616b8950b">wolfSSL_EnableOCSP</a> (WOLFSSL *ssl, int options)</td></tr>
<tr class="memdesc:a1c18a7ff26ebcb9453dc2f6616b8950b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables OCSP certificate verification. The value of options if formed by or’ing one or more of the following options: WOLFSSL_OCSP_URL_OVERRIDE - use the override URL instead of the URL in certificates. The override URL is specified using the <a class="el" href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad" title="This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the i...">wolfSSL_CTX_SetOCSP_OverrideURL()</a> function. WOLFSSL_OCSP_CHECKALL - Set all OCSP checks on WOLFSSL_OCSP_NO_NONCE - Set nonce option for creating OCSP requests.  <br /></td></tr>
<tr class="memitem:abb7c9ec80311c16f4223f53e5ec8449e" id="r_abb7c9ec80311c16f4223f53e5ec8449e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb7c9ec80311c16f4223f53e5ec8449e">wolfSSL_DisableOCSP</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:abb7c9ec80311c16f4223f53e5ec8449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the OCSP certificate revocation option.  <br /></td></tr>
<tr class="memitem:adecc0f6f1d5156e7e0e2ca364fffecd4" id="r_adecc0f6f1d5156e7e0e2ca364fffecd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adecc0f6f1d5156e7e0e2ca364fffecd4">wolfSSL_SetOCSP_OverrideURL</a> (WOLFSSL *ssl, const char *url)</td></tr>
<tr class="memdesc:adecc0f6f1d5156e7e0e2ca364fffecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ocspOverrideURL member in the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:a6eb9a96acfa1bedbcdbc4e89fbb8a43a" id="r_a6eb9a96acfa1bedbcdbc4e89fbb8a43a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb9a96acfa1bedbcdbc4e89fbb8a43a">wolfSSL_SetOCSP_Cb</a> (WOLFSSL *ssl, CbOCSPIO ioCb, CbOCSPRespFree respFreeCb, void *ioCbCtx)</td></tr>
<tr class="memdesc:a6eb9a96acfa1bedbcdbc4e89fbb8a43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the OCSP callback in the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:ae3faad2d4f64d7ff6e4462e621f0ecde" id="r_ae3faad2d4f64d7ff6e4462e621f0ecde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3faad2d4f64d7ff6e4462e621f0ecde">wolfSSL_CTX_EnableCRL</a> (WOLFSSL_CTX *ctx, int options)</td></tr>
<tr class="memdesc:ae3faad2d4f64d7ff6e4462e621f0ecde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables CRL certificate verification through the CTX.  <br /></td></tr>
<tr class="memitem:a5031108243f2872aee61a6677d1f5607" id="r_a5031108243f2872aee61a6677d1f5607"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5031108243f2872aee61a6677d1f5607">wolfSSL_CTX_DisableCRL</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:a5031108243f2872aee61a6677d1f5607"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables CRL verification in the CTX structure.  <br /></td></tr>
<tr class="memitem:a6cc6cb12cc17c750139e34adc1e16698" id="r_a6cc6cb12cc17c750139e34adc1e16698"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc6cb12cc17c750139e34adc1e16698">wolfSSL_CTX_LoadCRL</a> (WOLFSSL_CTX *ctx, const char *path, int type, int monitor)</td></tr>
<tr class="memdesc:a6cc6cb12cc17c750139e34adc1e16698"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads CRL into the WOLFSSL_CTX structure through <a class="el" href="group__CertManager.html#ga407833060925d7dd8366db3ca557ce8e" title="Error checks and passes through to LoadCRL() in order to load the cert into the CRL for revocation ch...">wolfSSL_CertManagerLoadCRL()</a>.  <br /></td></tr>
<tr class="memitem:a247c19e56d7fec73c15bef2189c68804" id="r_a247c19e56d7fec73c15bef2189c68804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a247c19e56d7fec73c15bef2189c68804">wolfSSL_CTX_SetCRL_Cb</a> (WOLFSSL_CTX *ctx, CbMissingCRL cb)</td></tr>
<tr class="memdesc:a247c19e56d7fec73c15bef2189c68804"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the callback argument to the cbMissingCRL member of the WOLFSSL_CERT_MANAGER structure by calling wolfSSL_CertManagerSetCRL_Cb.  <br /></td></tr>
<tr class="memitem:a3b69fdce096db89cdab845482c90f0f1" id="r_a3b69fdce096db89cdab845482c90f0f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b69fdce096db89cdab845482c90f0f1">wolfSSL_CTX_EnableOCSP</a> (WOLFSSL_CTX *ctx, int options)</td></tr>
<tr class="memdesc:a3b69fdce096db89cdab845482c90f0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets options to configure behavior of OCSP functionality in wolfSSL. The value of options if formed by or’ing one or more of the following options: WOLFSSL_OCSP_URL_OVERRIDE - use the override URL instead of the URL in certificates. The override URL is specified using the <a class="el" href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad" title="This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the i...">wolfSSL_CTX_SetOCSP_OverrideURL()</a> function. WOLFSSL_OCSP_CHECKALL - Set all OCSP checks on WOLFSSL_OCSP_NO_NONCE - Set nonce option for creating OCSP requests.  <br /></td></tr>
<tr class="memitem:a6dd90a4253a0716bfa1fcdeff5bcb519" id="r_a6dd90a4253a0716bfa1fcdeff5bcb519"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd90a4253a0716bfa1fcdeff5bcb519">wolfSSL_CTX_DisableOCSP</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:a6dd90a4253a0716bfa1fcdeff5bcb519"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables OCSP certificate revocation checking by affecting the ocspEnabled member of the WOLFSSL_CERT_MANAGER structure.  <br /></td></tr>
<tr class="memitem:ade9a3efc38ede0e8c8f5c0caeb8e20ad" id="r_ade9a3efc38ede0e8c8f5c0caeb8e20ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad">wolfSSL_CTX_SetOCSP_OverrideURL</a> (WOLFSSL_CTX *ctx, const char *url)</td></tr>
<tr class="memdesc:ade9a3efc38ede0e8c8f5c0caeb8e20ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the individual certificate unless the WOLFSSL_OCSP_URL_OVERRIDE option is set using the wolfSSL_CTX_EnableOCSP.  <br /></td></tr>
<tr class="memitem:a083fff700d5ba1e04c0690083712640e" id="r_a083fff700d5ba1e04c0690083712640e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083fff700d5ba1e04c0690083712640e">wolfSSL_CTX_SetOCSP_Cb</a> (WOLFSSL_CTX *ctx, CbOCSPIO ioCb, CbOCSPRespFree respFreeCb, void *ioCbCtx)</td></tr>
<tr class="memdesc:a083fff700d5ba1e04c0690083712640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback for the OCSP in the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:a27c5bf3d28d3cb3e8ef25f97d0c31f7f" id="r_a27c5bf3d28d3cb3e8ef25f97d0c31f7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27c5bf3d28d3cb3e8ef25f97d0c31f7f">wolfSSL_CTX_EnableOCSPStapling</a> (WOLFSSL_CTX *)</td></tr>
<tr class="memdesc:a27c5bf3d28d3cb3e8ef25f97d0c31f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables OCSP stapling by calling <a class="el" href="group__CertManager.html#gac17294be4393a23f98c7004217376dae" title="This function turns on OCSP stapling if it is not turned on as well as set the options.">wolfSSL_CertManagerEnableOCSPStapling()</a>.  <br /></td></tr>
<tr class="memitem:gad17318a1c890b18829a9a1e204dd6f04" id="r_gad17318a1c890b18829a9a1e204dd6f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad17318a1c890b18829a9a1e204dd6f04">wolfSSL_KeepArrays</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gad17318a1c890b18829a9a1e204dd6f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. Calling this function before the handshake begins will prevent wolfSSL from freeing temporary arrays. Temporary arrays may be needed for things such as wolfSSL_get_keys() or PSK hints. When the user is done with temporary arrays, either <a class="el" href="group__CertsKeys.html#gaaa9484e1a556fe686f20de30982594b6" title="Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. If wolfSSL_KeepArrays() ha...">wolfSSL_FreeArrays()</a> may be called to free the resources immediately, or alternatively the resources will be freed when the associated SSL object is freed.  <br /></td></tr>
<tr class="memitem:gaaa9484e1a556fe686f20de30982594b6" id="r_gaaa9484e1a556fe686f20de30982594b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaaa9484e1a556fe686f20de30982594b6">wolfSSL_FreeArrays</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gaaa9484e1a556fe686f20de30982594b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. If <a class="el" href="group__CertsKeys.html#gad17318a1c890b18829a9a1e204dd6f04" title="Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. Calling this function befo...">wolfSSL_KeepArrays()</a> has been called before the handshake, wolfSSL will not free temporary arrays. This function explicitly frees temporary arrays and should be called when the user is done with temporary arrays and does not want to wait for the SSL object to be freed to free these resources.  <br /></td></tr>
<tr class="memitem:a871070b101b579dc4663217b1c3fbcd4" id="r_a871070b101b579dc4663217b1c3fbcd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a871070b101b579dc4663217b1c3fbcd4">wolfSSL_UseSNI</a> (WOLFSSL *ssl, unsigned char type, const void *data, unsigned short size)</td></tr>
<tr class="memdesc:a871070b101b579dc4663217b1c3fbcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the use of Server Name Indication in the SSL object passed in the 'ssl' parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL client and wolfSSL server will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch.  <br /></td></tr>
<tr class="memitem:a7e2d400ffb4172eb91e284951a4ae091" id="r_a7e2d400ffb4172eb91e284951a4ae091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e2d400ffb4172eb91e284951a4ae091">wolfSSL_CTX_UseSNI</a> (WOLFSSL_CTX *ctx, unsigned char type, const void *data, unsigned short size)</td></tr>
<tr class="memdesc:a7e2d400ffb4172eb91e284951a4ae091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the use of Server Name Indication for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL clients and wolfSSL servers will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch.  <br /></td></tr>
<tr class="memitem:aed8ec1ab75309570c4464449f8ce747a" id="r_aed8ec1ab75309570c4464449f8ce747a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8ec1ab75309570c4464449f8ce747a">wolfSSL_SNI_SetOptions</a> (WOLFSSL *ssl, unsigned char type, unsigned char options)</td></tr>
<tr class="memdesc:aed8ec1ab75309570c4464449f8ce747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to configure the behavior of the SSL session using Server Name Indication in the SSL object passed in the 'ssl' parameter. The options are explained below.  <br /></td></tr>
<tr class="memitem:af82999bc9cefc1b7c9b8922145348d83" id="r_af82999bc9cefc1b7c9b8922145348d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af82999bc9cefc1b7c9b8922145348d83">wolfSSL_CTX_SNI_SetOptions</a> (WOLFSSL_CTX *ctx, unsigned char type, unsigned char options)</td></tr>
<tr class="memdesc:af82999bc9cefc1b7c9b8922145348d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to configure the behavior of the SSL sessions using Server Name Indication for SSL objects created from the SSL context passed in the 'ctx' parameter. The options are explained below.  <br /></td></tr>
<tr class="memitem:a5210e395ecc885734ab8c883b62629a6" id="r_a5210e395ecc885734ab8c883b62629a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5210e395ecc885734ab8c883b62629a6">wolfSSL_SNI_GetFromBuffer</a> (const unsigned char *clientHello, unsigned int helloSz, unsigned char type, unsigned char *sni, unsigned int *inOutSz)</td></tr>
<tr class="memdesc:a5210e395ecc885734ab8c883b62629a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to retrieve the Server Name Indication provided by the client from the Client Hello message sent by the client to start a session. It does not requires context or session setup to retrieve the SNI.  <br /></td></tr>
<tr class="memitem:ga4455005c48c3bb24584984ea11dd54a0" id="r_ga4455005c48c3bb24584984ea11dd54a0"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga4455005c48c3bb24584984ea11dd54a0">wolfSSL_SNI_Status</a> (WOLFSSL *ssl, unsigned char type)</td></tr>
<tr class="memdesc:ga4455005c48c3bb24584984ea11dd54a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of an SNI object.  <br /></td></tr>
<tr class="memitem:a9c1a89c721bf16874bf84f1e77042d6c" id="r_a9c1a89c721bf16874bf84f1e77042d6c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c1a89c721bf16874bf84f1e77042d6c">wolfSSL_SNI_GetRequest</a> (WOLFSSL *ssl, unsigned char type, void **data)</td></tr>
<tr class="memdesc:a9c1a89c721bf16874bf84f1e77042d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to retrieve the Server Name Indication provided by the client in a SSL session.  <br /></td></tr>
<tr class="memitem:ga39186057ad4fc9a1fe0defcf111254b6" id="r_ga39186057ad4fc9a1fe0defcf111254b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga39186057ad4fc9a1fe0defcf111254b6">wolfSSL_UseALPN</a> (WOLFSSL *ssl, char *protocol_name_list, unsigned int protocol_name_listSz, unsigned char options)</td></tr>
<tr class="memdesc:ga39186057ad4fc9a1fe0defcf111254b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup ALPN use for a wolfSSL session.  <br /></td></tr>
<tr class="memitem:ga855e31083f892640e8a07db40c4d5be3" id="r_ga855e31083f892640e8a07db40c4d5be3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga855e31083f892640e8a07db40c4d5be3">wolfSSL_ALPN_GetProtocol</a> (WOLFSSL *ssl, char **protocol_name, unsigned short *size)</td></tr>
<tr class="memdesc:ga855e31083f892640e8a07db40c4d5be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the protocol name set by the server.  <br /></td></tr>
<tr class="memitem:ga0a63e7d191029128ea311f5a90244bd5" id="r_ga0a63e7d191029128ea311f5a90244bd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga0a63e7d191029128ea311f5a90244bd5">wolfSSL_ALPN_GetPeerProtocol</a> (WOLFSSL *ssl, char **list, unsigned short *listSz)</td></tr>
<tr class="memdesc:ga0a63e7d191029128ea311f5a90244bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the alpn_client_list data from the SSL object to the buffer.  <br /></td></tr>
<tr class="memitem:ae3a413f6cab23dd667c7cbb06ae252cb" id="r_ae3a413f6cab23dd667c7cbb06ae252cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a413f6cab23dd667c7cbb06ae252cb">wolfSSL_UseMaxFragment</a> (WOLFSSL *ssl, unsigned char mfl)</td></tr>
<tr class="memdesc:ae3a413f6cab23dd667c7cbb06ae252cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Maximum Fragment Length in the SSL object passed in the 'ssl' parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients.  <br /></td></tr>
<tr class="memitem:afcca49dd1e71d97ec4702430a682bbcb" id="r_afcca49dd1e71d97ec4702430a682bbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcca49dd1e71d97ec4702430a682bbcb">wolfSSL_CTX_UseMaxFragment</a> (WOLFSSL_CTX *ctx, unsigned char mfl)</td></tr>
<tr class="memdesc:afcca49dd1e71d97ec4702430a682bbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Maximum Fragment Length for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients.  <br /></td></tr>
<tr class="memitem:a8555f9cc188902fe3d3ca8bc9d466a4c" id="r_a8555f9cc188902fe3d3ca8bc9d466a4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8555f9cc188902fe3d3ca8bc9d466a4c">wolfSSL_UseTruncatedHMAC</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a8555f9cc188902fe3d3ca8bc9d466a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Truncated HMAC in the SSL object passed in the 'ssl' parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients.  <br /></td></tr>
<tr class="memitem:af398a71eabe6a27f783d8abbad83bd38" id="r_af398a71eabe6a27f783d8abbad83bd38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af398a71eabe6a27f783d8abbad83bd38">wolfSSL_CTX_UseTruncatedHMAC</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:af398a71eabe6a27f783d8abbad83bd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Truncated HMAC for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients.  <br /></td></tr>
<tr class="memitem:acbdb1a796d11f083f1782c001cdc6016" id="r_acbdb1a796d11f083f1782c001cdc6016"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbdb1a796d11f083f1782c001cdc6016">wolfSSL_UseOCSPStapling</a> (WOLFSSL *ssl, unsigned char status_type, unsigned char options)</td></tr>
<tr class="memdesc:acbdb1a796d11f083f1782c001cdc6016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stapling eliminates the need to contact the CA. Stapling lowers the cost of certificate revocation check presented in OCSP.  <br /></td></tr>
<tr class="memitem:a5a9469c796b581328a7de8c16d9cfcec" id="r_a5a9469c796b581328a7de8c16d9cfcec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9469c796b581328a7de8c16d9cfcec">wolfSSL_CTX_UseOCSPStapling</a> (WOLFSSL_CTX *ctx, unsigned char status_type, unsigned char options)</td></tr>
<tr class="memdesc:a5a9469c796b581328a7de8c16d9cfcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests the certificate status during the handshake.  <br /></td></tr>
<tr class="memitem:a37cbc7ec1e1fd4445c7bd59c09bae5ad" id="r_a37cbc7ec1e1fd4445c7bd59c09bae5ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37cbc7ec1e1fd4445c7bd59c09bae5ad">wolfSSL_UseOCSPStaplingV2</a> (WOLFSSL *ssl, unsigned char status_type, unsigned char options)</td></tr>
<tr class="memdesc:a37cbc7ec1e1fd4445c7bd59c09bae5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the status type and options for OCSP.  <br /></td></tr>
<tr class="memitem:a2e4f97b0d4d57dcf3a5b07166053234a" id="r_a2e4f97b0d4d57dcf3a5b07166053234a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4f97b0d4d57dcf3a5b07166053234a">wolfSSL_CTX_UseOCSPStaplingV2</a> (WOLFSSL_CTX *ctx, unsigned char status_type, unsigned char options)</td></tr>
<tr class="memdesc:a2e4f97b0d4d57dcf3a5b07166053234a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes the certificate status request for OCSP Stapling.  <br /></td></tr>
<tr class="memitem:a99a3ea2538789b78859e8ae750b802e0" id="r_a99a3ea2538789b78859e8ae750b802e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99a3ea2538789b78859e8ae750b802e0">wolfSSL_UseSupportedCurve</a> (WOLFSSL *ssl, word16 name)</td></tr>
<tr class="memdesc:a99a3ea2538789b78859e8ae750b802e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Supported Elliptic Curves Extension in the SSL object passed in the 'ssl' parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves.  <br /></td></tr>
<tr class="memitem:a49ebc57d8029df946efdf15dffaace1f" id="r_a49ebc57d8029df946efdf15dffaace1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49ebc57d8029df946efdf15dffaace1f">wolfSSL_CTX_UseSupportedCurve</a> (WOLFSSL_CTX *ctx, word16 name)</td></tr>
<tr class="memdesc:a49ebc57d8029df946efdf15dffaace1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side to enable the use of Supported Elliptic Curves Extension for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves.  <br /></td></tr>
<tr class="memitem:ga8b482a054414e3411c8d4f45f3683f3c" id="r_ga8b482a054414e3411c8d4f45f3683f3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8b482a054414e3411c8d4f45f3683f3c">wolfSSL_UseSecureRenegotiation</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga8b482a054414e3411c8d4f45f3683f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function forces secure renegotiation for the supplied WOLFSSL structure. This is not recommended.  <br /></td></tr>
<tr class="memitem:ga7ba02472014a68d0717ca9243d9dd646" id="r_ga7ba02472014a68d0717ca9243d9dd646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga7ba02472014a68d0717ca9243d9dd646">wolfSSL_Rehandshake</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga7ba02472014a68d0717ca9243d9dd646"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a secure renegotiation handshake; this is user forced as wolfSSL discourages this functionality.  <br /></td></tr>
<tr class="memitem:gae22e32f06e5b1f22116c794b3dc28577" id="r_gae22e32f06e5b1f22116c794b3dc28577"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gae22e32f06e5b1f22116c794b3dc28577">wolfSSL_UseSessionTicket</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gae22e32f06e5b1f22116c794b3dc28577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force provided WOLFSSL structure to use session ticket. The constant HAVE_SESSION_TICKET should be defined and the constant NO_WOLFSSL_CLIENT should not be defined to use this function.  <br /></td></tr>
<tr class="memitem:gad29292226decf7dbce089881ddb063cd" id="r_gad29292226decf7dbce089881ddb063cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gad29292226decf7dbce089881ddb063cd">wolfSSL_CTX_UseSessionTicket</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:gad29292226decf7dbce089881ddb063cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets wolfSSL context to use a session ticket.  <br /></td></tr>
<tr class="memitem:gab67e2593987cfe2a20c660440c087576" id="r_gab67e2593987cfe2a20c660440c087576"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gab67e2593987cfe2a20c660440c087576">wolfSSL_get_SessionTicket</a> (WOLFSSL *ssl, unsigned char *buf, word32 *bufSz)</td></tr>
<tr class="memdesc:gab67e2593987cfe2a20c660440c087576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the ticket member of the Session structure to the buffer. If buf is NULL and bufSz is non-NULL, bufSz will be set to the ticket length.  <br /></td></tr>
<tr class="memitem:ga49f87f9acd032dbbd43fa43113aa331c" id="r_ga49f87f9acd032dbbd43fa43113aa331c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga49f87f9acd032dbbd43fa43113aa331c">wolfSSL_set_SessionTicket</a> (WOLFSSL *ssl, const unsigned char *buf, word32 bufSz)</td></tr>
<tr class="memdesc:ga49f87f9acd032dbbd43fa43113aa331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ticket member of the WOLFSSL_SESSION structure within the WOLFSSL struct. The buffer passed into the function is copied to memory.  <br /></td></tr>
<tr class="memitem:a30b45a56db4091b9d9aec551ba659786" id="r_a30b45a56db4091b9d9aec551ba659786"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30b45a56db4091b9d9aec551ba659786">wolfSSL_set_SessionTicket_cb</a> (WOLFSSL *ssl, CallbackSessionTicket cb, void *ctx)</td></tr>
<tr class="memdesc:a30b45a56db4091b9d9aec551ba659786"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session ticket callback. The type CallbackSessionTicket is a function pointer with the signature of: int (<em>CallbackSessionTicket)(WOLFSSL</em>, const unsigned char*, int, void*)  <br /></td></tr>
<tr class="memitem:a1e568d0d4f32e2de793feab3204695d1" id="r_a1e568d0d4f32e2de793feab3204695d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e568d0d4f32e2de793feab3204695d1">wolfSSL_send_SessionTicket</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a1e568d0d4f32e2de793feab3204695d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a session ticket to the client after a TLS v1.3 handhsake has been established.  <br /></td></tr>
<tr class="memitem:a13c5dcdd22360eabeb70d5e7bf8e5f21" id="r_a13c5dcdd22360eabeb70d5e7bf8e5f21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c5dcdd22360eabeb70d5e7bf8e5f21">wolfSSL_CTX_set_TicketEncCb</a> (WOLFSSL_CTX *ctx, SessionTicketEncCb)</td></tr>
<tr class="memdesc:a13c5dcdd22360eabeb70d5e7bf8e5f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session ticket key encrypt callback function for a server to support session tickets as specified in RFC 5077.  <br /></td></tr>
<tr class="memitem:a22507c419dfff2da33c6a14da2d6bc62" id="r_a22507c419dfff2da33c6a14da2d6bc62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22507c419dfff2da33c6a14da2d6bc62">wolfSSL_CTX_set_TicketHint</a> (WOLFSSL_CTX *ctx, int)</td></tr>
<tr class="memdesc:a22507c419dfff2da33c6a14da2d6bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session ticket hint relayed to the client. For server side use.  <br /></td></tr>
<tr class="memitem:a123e3d57b518a8af9026f1b5efad9108" id="r_a123e3d57b518a8af9026f1b5efad9108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a123e3d57b518a8af9026f1b5efad9108">wolfSSL_CTX_set_TicketEncCtx</a> (WOLFSSL_CTX *ctx, void *)</td></tr>
<tr class="memdesc:a123e3d57b518a8af9026f1b5efad9108"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the session ticket encrypt user context for the callback. For server side use.  <br /></td></tr>
<tr class="memitem:acdb79c98dbbc1c732eeaffeb722c622c" id="r_acdb79c98dbbc1c732eeaffeb722c622c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdb79c98dbbc1c732eeaffeb722c622c">wolfSSL_CTX_get_TicketEncCtx</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:acdb79c98dbbc1c732eeaffeb722c622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the session ticket encrypt user context for the callback. For server side use.  <br /></td></tr>
<tr class="memitem:a84b8004f9fda96c4d2257b5b13372ff9" id="r_a84b8004f9fda96c4d2257b5b13372ff9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84b8004f9fda96c4d2257b5b13372ff9">wolfSSL_SetHsDoneCb</a> (WOLFSSL *ssl, HandShakeDoneCb cb, void *user_ctx)</td></tr>
<tr class="memdesc:a84b8004f9fda96c4d2257b5b13372ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handshake done callback. The hsDoneCb and hsDoneCtx members of the WOLFSSL structure are set in this function.  <br /></td></tr>
<tr class="memitem:ga0085f8baa71150d0264766e4a2b6c784" id="r_ga0085f8baa71150d0264766e4a2b6c784"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga0085f8baa71150d0264766e4a2b6c784">wolfSSL_PrintSessionStats</a> (void)</td></tr>
<tr class="memdesc:ga0085f8baa71150d0264766e4a2b6c784"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the statistics from the session.  <br /></td></tr>
<tr class="memitem:gaaaf142daad76403f27d7d5d2b6261420" id="r_gaaaf142daad76403f27d7d5d2b6261420"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaaaf142daad76403f27d7d5d2b6261420">wolfSSL_get_session_stats</a> (unsigned int *active, unsigned int *total, unsigned int *peak, unsigned int *maxSessions)</td></tr>
<tr class="memdesc:gaaaf142daad76403f27d7d5d2b6261420"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the statistics for the session.  <br /></td></tr>
<tr class="memitem:ga6666c5c5d9a81938689ab49d691b16d5" id="r_ga6666c5c5d9a81938689ab49d691b16d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga6666c5c5d9a81938689ab49d691b16d5">wolfSSL_MakeTlsMasterSecret</a> (unsigned char *ms, word32 msLen, const unsigned char *pms, word32 pmsLen, const unsigned char *cr, const unsigned char *sr, int tls1_2, int hash_type)</td></tr>
<tr class="memdesc:ga6666c5c5d9a81938689ab49d691b16d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the values of cr and sr then passes through to wc_PRF (pseudo random function) and returns that value.  <br /></td></tr>
<tr class="memitem:gacf476ce60bf62d0ac7576a21bf63bff8" id="r_gacf476ce60bf62d0ac7576a21bf63bff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gacf476ce60bf62d0ac7576a21bf63bff8">wolfSSL_DeriveTlsKeys</a> (unsigned char *key_data, word32 keyLen, const unsigned char *ms, word32 msLen, const unsigned char *sr, const unsigned char *cr, int tls1_2, int hash_type)</td></tr>
<tr class="memdesc:gacf476ce60bf62d0ac7576a21bf63bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An external facing wrapper to derive TLS Keys.  <br /></td></tr>
<tr class="memitem:a927d4a1f37cd1df66faa5d20a90482a6" id="r_a927d4a1f37cd1df66faa5d20a90482a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a927d4a1f37cd1df66faa5d20a90482a6">wolfSSL_connect_ex</a> (WOLFSSL *ssl, HandShakeCallBack hsCb, TimeoutCallBack toCb, WOLFSSL_TIMEVAL timeout)</td></tr>
<tr class="memdesc:a927d4a1f37cd1df66faa5d20a90482a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a927d4a1f37cd1df66faa5d20a90482a6" title="wolfSSL_connect_ex() is an extension that allows a HandShake Callback to be set. This can be useful i...">wolfSSL_connect_ex()</a> is an extension that allows a HandShake Callback to be set. This can be useful in embedded systems for debugging support when a debugger isn’t available and sniffing is impractical. The HandShake Callback will be called whether or not a handshake error occurred. No dynamic memory is used since the maximum number of SSL packets is known. Packet names can be accessed through packetNames[]. The connect extension also allows a Timeout Callback to be set along with a timeout value. This is useful if the user doesn’t want to wait for the TCP stack to timeout. This extension can be called with either, both, or neither callbacks.  <br /></td></tr>
<tr class="memitem:a7eb561acf87b28ecdc5e3cafbd838bcb" id="r_a7eb561acf87b28ecdc5e3cafbd838bcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb561acf87b28ecdc5e3cafbd838bcb">wolfSSL_accept_ex</a> (WOLFSSL *ssl, HandShakeCallBacki hsCb, TimeoutCallBack toCb, WOLFSSL_TIMEVAL timeout)</td></tr>
<tr class="memdesc:a7eb561acf87b28ecdc5e3cafbd838bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a7eb561acf87b28ecdc5e3cafbd838bcb" title="wolfSSL_accept_ex() is an extension that allows a HandShake Callback to be set. This can be useful in...">wolfSSL_accept_ex()</a> is an extension that allows a HandShake Callback to be set. This can be useful in embedded systems for debugging support when a debugger isn’t available and sniffing is impractical. The HandShake Callback will be called whether or not a handshake error occurred. No dynamic memory is used since the maximum number of SSL packets is known. Packet names can be accessed through packetNames[]. The connect extension also allows a Timeout Callback to be set along with a timeout value. This is useful if the user doesn’t want to wait for the TCP stack to timeout. This extension can be called with either, both, or neither callbacks.  <br /></td></tr>
<tr class="memitem:gaf05ea9cba44df853314417db7a774e99" id="r_gaf05ea9cba44df853314417db7a774e99"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gaf05ea9cba44df853314417db7a774e99">wolfSSL_BIO_set_fp</a> (WOLFSSL_BIO *bio, XFILE fp, int c)</td></tr>
<tr class="memdesc:gaf05ea9cba44df853314417db7a774e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the internal file pointer for a BIO.  <br /></td></tr>
<tr class="memitem:gac2e81c60581f1ba7b5fd3984c37ced23" id="r_gac2e81c60581f1ba7b5fd3984c37ced23"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gac2e81c60581f1ba7b5fd3984c37ced23">wolfSSL_BIO_get_fp</a> (WOLFSSL_BIO *bio, XFILE *fp)</td></tr>
<tr class="memdesc:gac2e81c60581f1ba7b5fd3984c37ced23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the internal file pointer for a BIO.  <br /></td></tr>
<tr class="memitem:gaccda5b67dbd5046f75d0d39ae46f0e37" id="r_gaccda5b67dbd5046f75d0d39ae46f0e37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaccda5b67dbd5046f75d0d39ae46f0e37">wolfSSL_check_private_key</a> (const WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaccda5b67dbd5046f75d0d39ae46f0e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks that the private key is a match with the certificate being used.  <br /></td></tr>
<tr class="memitem:gac4016413b2782a30e06bc5acfc273231" id="r_gac4016413b2782a30e06bc5acfc273231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gac4016413b2782a30e06bc5acfc273231">wolfSSL_X509_get_ext_by_NID</a> (const WOLFSSL_X509 *x509, int nid, int lastPos)</td></tr>
<tr class="memdesc:gac4016413b2782a30e06bc5acfc273231"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for and returns the extension index matching the passed in NID value.  <br /></td></tr>
<tr class="memitem:ga08f37b8d815d97581a5e64c6f8b78d6f" id="r_ga08f37b8d815d97581a5e64c6f8b78d6f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga08f37b8d815d97581a5e64c6f8b78d6f">wolfSSL_X509_get_ext_d2i</a> (const WOLFSSL_X509 *x509, int nid, int *c, int *idx)</td></tr>
<tr class="memdesc:ga08f37b8d815d97581a5e64c6f8b78d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for and returns the extension matching the passed in NID value.  <br /></td></tr>
<tr class="memitem:ga35cb1a42d29df13e4a460aa6a48a145d" id="r_ga35cb1a42d29df13e4a460aa6a48a145d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga35cb1a42d29df13e4a460aa6a48a145d">wolfSSL_X509_digest</a> (const WOLFSSL_X509 *x509, const WOLFSSL_EVP_MD *digest, unsigned char *buf, unsigned int *len)</td></tr>
<tr class="memdesc:ga35cb1a42d29df13e4a460aa6a48a145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the hash of the DER certificate.  <br /></td></tr>
<tr class="memitem:ga22f348e5fc09ca909a8b03f4235b5276" id="r_ga22f348e5fc09ca909a8b03f4235b5276"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga22f348e5fc09ca909a8b03f4235b5276">wolfSSL_use_certificate</a> (WOLFSSL *ssl, WOLFSSL_X509 *x509)</td></tr>
<tr class="memdesc:ga22f348e5fc09ca909a8b03f4235b5276"><td class="mdescLeft">&#160;</td><td class="mdescRight">his is used to set the certificate for WOLFSSL structure to use during a handshake.  <br /></td></tr>
<tr class="memitem:ga6d8dcc0a039220fa4d966745a7bac736" id="r_ga6d8dcc0a039220fa4d966745a7bac736"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga6d8dcc0a039220fa4d966745a7bac736">wolfSSL_use_certificate_ASN1</a> (WOLFSSL *ssl, unsigned char *der, int derSz)</td></tr>
<tr class="memdesc:ga6d8dcc0a039220fa4d966745a7bac736"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the certificate for WOLFSSL structure to use during a handshake. A DER formatted buffer is expected.  <br /></td></tr>
<tr class="memitem:gab1c2afbc0e774ebcd71b3e78e9742dec" id="r_gab1c2afbc0e774ebcd71b3e78e9742dec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gab1c2afbc0e774ebcd71b3e78e9742dec">wolfSSL_use_PrivateKey</a> (WOLFSSL *ssl, WOLFSSL_EVP_PKEY *pkey)</td></tr>
<tr class="memdesc:gab1c2afbc0e774ebcd71b3e78e9742dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the private key for the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga406ba9169899f71dc0675146465b3e5b" id="r_ga406ba9169899f71dc0675146465b3e5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga406ba9169899f71dc0675146465b3e5b">wolfSSL_use_PrivateKey_ASN1</a> (int pri, WOLFSSL *ssl, unsigned char *der, long derSz)</td></tr>
<tr class="memdesc:ga406ba9169899f71dc0675146465b3e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the private key for the WOLFSSL structure. A DER formatted key buffer is expected.  <br /></td></tr>
<tr class="memitem:ga21aa3ac23f36e8bbaec5403d9cbe1f01" id="r_ga21aa3ac23f36e8bbaec5403d9cbe1f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga21aa3ac23f36e8bbaec5403d9cbe1f01">wolfSSL_use_RSAPrivateKey_ASN1</a> (WOLFSSL *ssl, unsigned char *der, long derSz)</td></tr>
<tr class="memdesc:ga21aa3ac23f36e8bbaec5403d9cbe1f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the private key for the WOLFSSL structure. A DER formatted RSA key buffer is expected.  <br /></td></tr>
<tr class="memitem:ga56086906db8f24c5da25dc106bf9191c" id="r_ga56086906db8f24c5da25dc106bf9191c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_DH *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga56086906db8f24c5da25dc106bf9191c">wolfSSL_DSA_dup_DH</a> (const WOLFSSL_DSA *r)</td></tr>
<tr class="memdesc:ga56086906db8f24c5da25dc106bf9191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function duplicates the parameters in dsa to a newly created WOLFSSL_DH structure.  <br /></td></tr>
<tr class="memitem:ga9b6c637f5100e9e3f5a246c464d5b150" id="r_ga9b6c637f5100e9e3f5a246c464d5b150"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga9b6c637f5100e9e3f5a246c464d5b150">wolfSSL_SESSION_get_master_key</a> (const WOLFSSL_SESSION *ses, unsigned char *out, int outSz)</td></tr>
<tr class="memdesc:ga9b6c637f5100e9e3f5a246c464d5b150"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the master key after completing a handshake.  <br /></td></tr>
<tr class="memitem:ga8643a40cddc2c5daa6331d993e9787a7" id="r_ga8643a40cddc2c5daa6331d993e9787a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga8643a40cddc2c5daa6331d993e9787a7">wolfSSL_SESSION_get_master_key_length</a> (const WOLFSSL_SESSION *ses)</td></tr>
<tr class="memdesc:ga8643a40cddc2c5daa6331d993e9787a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the master secret key length.  <br /></td></tr>
<tr class="memitem:ga1c56772fa6d29b0a7a3bd5b68d1c6382" id="r_ga1c56772fa6d29b0a7a3bd5b68d1c6382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga1c56772fa6d29b0a7a3bd5b68d1c6382">wolfSSL_CTX_set_cert_store</a> (WOLFSSL_CTX *ctx, WOLFSSL_X509_STORE *str)</td></tr>
<tr class="memdesc:ga1c56772fa6d29b0a7a3bd5b68d1c6382"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a setter function for the WOLFSSL_X509_STORE structure in ctx.  <br /></td></tr>
<tr class="memitem:gac0637210376922623206261c99312df0" id="r_gac0637210376922623206261c99312df0"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gac0637210376922623206261c99312df0">wolfSSL_d2i_X509_bio</a> (WOLFSSL_BIO *bio, WOLFSSL_X509 **x509)</td></tr>
<tr class="memdesc:gac0637210376922623206261c99312df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the DER buffer from bio and converts it to a WOLFSSL_X509 structure.  <br /></td></tr>
<tr class="memitem:ga5a601c5fd3c0678c4d1c594a2cf63a99" id="r_ga5a601c5fd3c0678c4d1c594a2cf63a99"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_STORE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga5a601c5fd3c0678c4d1c594a2cf63a99">wolfSSL_CTX_get_cert_store</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga5a601c5fd3c0678c4d1c594a2cf63a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a getter function for the WOLFSSL_X509_STORE structure in ctx.  <br /></td></tr>
<tr class="memitem:ga344b890cf2459ab7860924ac059ac927" id="r_ga344b890cf2459ab7860924ac059ac927"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga344b890cf2459ab7860924ac059ac927">wolfSSL_BIO_ctrl_pending</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>)</td></tr>
<tr class="memdesc:ga344b890cf2459ab7860924ac059ac927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pending bytes to read. If BIO type is BIO_BIO then is the number to read from pair. If BIO contains an SSL object then is pending data from SSL object (wolfSSL_pending(ssl)). If is BIO_MEMORY type then returns the size of memory buffer.  <br /></td></tr>
<tr class="memitem:ga498689187c3d598de429e03eb30c77c9" id="r_ga498689187c3d598de429e03eb30c77c9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga498689187c3d598de429e03eb30c77c9">wolfSSL_get_server_random</a> (const WOLFSSL *ssl, unsigned char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga498689187c3d598de429e03eb30c77c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the random data sent by the server during the handshake.  <br /></td></tr>
<tr class="memitem:ga896c420c9008f43603847a0035e6c3fb" id="r_ga896c420c9008f43603847a0035e6c3fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga896c420c9008f43603847a0035e6c3fb">wolfSSL_get_client_random</a> (const WOLFSSL *ssl, unsigned char *out, size_t outSz)</td></tr>
<tr class="memdesc:ga896c420c9008f43603847a0035e6c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the random data sent by the client during the handshake.  <br /></td></tr>
<tr class="memitem:ga1e7c20bb385c3cd74fcdc27eef66ad88" id="r_ga1e7c20bb385c3cd74fcdc27eef66ad88"><td class="memItemLeft" align="right" valign="top">wc_pem_password_cb *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga1e7c20bb385c3cd74fcdc27eef66ad88">wolfSSL_CTX_get_default_passwd_cb</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga1e7c20bb385c3cd74fcdc27eef66ad88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a getter function for the password callback set in ctx.  <br /></td></tr>
<tr class="memitem:ga9706ef3b8e7271e9549085f1c1d6ccd5" id="r_ga9706ef3b8e7271e9549085f1c1d6ccd5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga9706ef3b8e7271e9549085f1c1d6ccd5">wolfSSL_CTX_get_default_passwd_cb_userdata</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga9706ef3b8e7271e9549085f1c1d6ccd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a getter function for the password callback user data set in ctx.  <br /></td></tr>
<tr class="memitem:ga87c1045d2e6e1fc397f83f0b6444a6bd" id="r_ga87c1045d2e6e1fc397f83f0b6444a6bd"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga87c1045d2e6e1fc397f83f0b6444a6bd">wolfSSL_PEM_read_bio_X509_AUX</a> (WOLFSSL_BIO *bp, WOLFSSL_X509 **x, wc_pem_password_cb *cb, void *u)</td></tr>
<tr class="memdesc:ga87c1045d2e6e1fc397f83f0b6444a6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function behaves the same as wolfSSL_PEM_read_bio_X509. AUX signifies containing extra information such as trusted/rejected use cases and friendly name for human readability.  <br /></td></tr>
<tr class="memitem:gaf84e1321d1d9a75aa8b7883a665b5591" id="r_gaf84e1321d1d9a75aa8b7883a665b5591"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gaf84e1321d1d9a75aa8b7883a665b5591">wolfSSL_CTX_set_tmp_dh</a> (WOLFSSL_CTX *ctx, WOLFSSL_DH *dh)</td></tr>
<tr class="memdesc:gaf84e1321d1d9a75aa8b7883a665b5591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the WOLFSSL_CTX structure’s dh member with the Diffie-Hellman parameters.  <br /></td></tr>
<tr class="memitem:ga165cb42ef98c4db177139576a6998ad7" id="r_ga165cb42ef98c4db177139576a6998ad7"><td class="memItemLeft" align="right" valign="top">WOLFSSL_DSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga165cb42ef98c4db177139576a6998ad7">wolfSSL_PEM_read_bio_DSAparams</a> (WOLFSSL_BIO *bp, WOLFSSL_DSA **x, wc_pem_password_cb *cb, void *u)</td></tr>
<tr class="memdesc:ga165cb42ef98c4db177139576a6998ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the DSA parameters from a PEM buffer in bio.  <br /></td></tr>
<tr class="memitem:ga672812a5459d1172e9cf2e1bcc48570e" id="r_ga672812a5459d1172e9cf2e1bcc48570e"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Debug.html#ga672812a5459d1172e9cf2e1bcc48570e">wolfSSL_ERR_peek_last_error</a> (void)</td></tr>
<tr class="memdesc:ga672812a5459d1172e9cf2e1bcc48570e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the absolute value of the last error from WOLFSSL_ERROR encountered.  <br /></td></tr>
<tr class="memitem:ga9aa6e326195805ad0782cc7d70d49691" id="r_ga9aa6e326195805ad0782cc7d70d49691"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga9aa6e326195805ad0782cc7d70d49691">WOLF_STACK_OF</a> (WOLFSSL_X509) *wolfSSL_get_peer_cert_chain(const WOLFSSL *)</td></tr>
<tr class="memdesc:ga9aa6e326195805ad0782cc7d70d49691"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the peer’s certificate chain.  <br /></td></tr>
<tr class="memitem:gaa59ca968865328e51b664ddf1e8743d0" id="r_gaa59ca968865328e51b664ddf1e8743d0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa59ca968865328e51b664ddf1e8743d0">wolfSSL_CTX_clear_options</a> (WOLFSSL_CTX *ctx, long opt)</td></tr>
<tr class="memdesc:gaa59ca968865328e51b664ddf1e8743d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets option bits of WOLFSSL_CTX object.  <br /></td></tr>
<tr class="memitem:gadea64abddfb32623d439ced576afb498" id="r_gadea64abddfb32623d439ced576afb498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gadea64abddfb32623d439ced576afb498">wolfSSL_set_jobject</a> (WOLFSSL *ssl, void *objPtr)</td></tr>
<tr class="memdesc:gadea64abddfb32623d439ced576afb498"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the jObjectRef member of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga89aed85f25618a8a012ae855d07e2023" id="r_ga89aed85f25618a8a012ae855d07e2023"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga89aed85f25618a8a012ae855d07e2023">wolfSSL_get_jobject</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga89aed85f25618a8a012ae855d07e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the jObjectRef member of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga5393e16941d9b53ee9b33104951ba5df" id="r_ga5393e16941d9b53ee9b33104951ba5df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga5393e16941d9b53ee9b33104951ba5df">wolfSSL_set_msg_callback</a> (WOLFSSL *ssl, SSL_Msg_Cb cb)</td></tr>
<tr class="memdesc:ga5393e16941d9b53ee9b33104951ba5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a callback in the ssl. The callback is to observe handshake messages. NULL value of cb resets the callback.  <br /></td></tr>
<tr class="memitem:gaa945449401773c20d8821b57701d6941" id="r_gaa945449401773c20d8821b57701d6941"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaa945449401773c20d8821b57701d6941">wolfSSL_set_msg_callback_arg</a> (WOLFSSL *ssl, void *arg)</td></tr>
<tr class="memdesc:gaa945449401773c20d8821b57701d6941"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets associated callback context value in the ssl. The value is handed over to the callback argument.  <br /></td></tr>
<tr class="memitem:ga5ae819fe6c9d141fd635796318c5ae6a" id="r_ga5ae819fe6c9d141fd635796318c5ae6a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#ga5ae819fe6c9d141fd635796318c5ae6a">wolfSSL_X509_get_next_altname</a> (WOLFSSL_X509 *)</td></tr>
<tr class="memdesc:ga5ae819fe6c9d141fd635796318c5ae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the next, if any, altname from the peer certificate.  <br /></td></tr>
<tr class="memitem:gad832c5c58312721e756391124d161cf5" id="r_gad832c5c58312721e756391124d161cf5"><td class="memItemLeft" align="right" valign="top">WOLFSSL_ASN1_TIME *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CertsKeys.html#gad832c5c58312721e756391124d161cf5">wolfSSL_X509_get_notBefore</a> (WOLFSSL_X509 *)</td></tr>
<tr class="memdesc:gad832c5c58312721e756391124d161cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function checks to see if x509 is NULL and if it’s not, it returns the notBefore member of the x509 struct.  <br /></td></tr>
<tr class="memitem:ga5b8f41cca120758d1860c7bc959755dd" id="r_ga5b8f41cca120758d1860c7bc959755dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd">wolfSSL_connect</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5b8f41cca120758d1860c7bc959755dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates an SSL/TLS handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended.  <br /></td></tr>
<tr class="memitem:ga794717a9379491eac23dd1ea02e34bdb" id="r_ga794717a9379491eac23dd1ea02e34bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga794717a9379491eac23dd1ea02e34bdb">wolfSSL_send_hrr_cookie</a> (WOLFSSL *ssl, const unsigned char *secret, unsigned int secretSz)</td></tr>
<tr class="memdesc:ga794717a9379491eac23dd1ea02e34bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to indicate that a HelloRetryRequest message must contain a Cookie and, in case of using protocol DTLS v1.3, that the handshake will always include a cookie exchange. Please note that when using protocol DTLS v1.3, the cookie exchange is enabled by default. The Cookie holds a hash of the current transcript so that another server process can handle the ClientHello in reply. The secret is used when generating the integrity check on the Cookie data.  <br /></td></tr>
<tr class="memitem:ga80b44ec4e7d064c4e7b7587259df14fa" id="r_ga80b44ec4e7d064c4e7b7587259df14fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga80b44ec4e7d064c4e7b7587259df14fa">wolfSSL_disable_hrr_cookie</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga80b44ec4e7d064c4e7b7587259df14fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side to indicate that a HelloRetryRequest message must NOT contain a Cookie and that, if using protocol DTLS v1.3, a cookie exchange will not be included in the handshake. Please note that not doing a cookie exchange when using protocol DTLS v1.3 can make the server susceptible to DoS/Amplification attacks.  <br /></td></tr>
<tr class="memitem:ga21b775f1fde3845814d8673de5397c68" id="r_ga21b775f1fde3845814d8673de5397c68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga21b775f1fde3845814d8673de5397c68">wolfSSL_CTX_no_ticket_TLSv13</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga21b775f1fde3845814d8673de5397c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server to stop it from sending a resumption session ticket once the handshake is complete.  <br /></td></tr>
<tr class="memitem:ga929fd758faf432077ba23510cd408192" id="r_ga929fd758faf432077ba23510cd408192"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga929fd758faf432077ba23510cd408192">wolfSSL_no_ticket_TLSv13</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga929fd758faf432077ba23510cd408192"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server to stop it from sending a resumption session ticket once the handshake is complete.  <br /></td></tr>
<tr class="memitem:ga58150407cb2e1527ebaf6699657d80d5" id="r_ga58150407cb2e1527ebaf6699657d80d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga58150407cb2e1527ebaf6699657d80d5">wolfSSL_CTX_no_dhe_psk</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga58150407cb2e1527ebaf6699657d80d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 wolfSSL context to disallow Diffie-Hellman (DH) style key exchanges when handshakes are using pre-shared keys for authentication.  <br /></td></tr>
<tr class="memitem:ga7dfc5ce4f88fb311c4f87c188b2b309f" id="r_ga7dfc5ce4f88fb311c4f87c188b2b309f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7dfc5ce4f88fb311c4f87c188b2b309f">wolfSSL_no_dhe_psk</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga7dfc5ce4f88fb311c4f87c188b2b309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client or server wolfSSL to disallow Diffie-Hellman (DH) style key exchanges when handshakes are using pre-shared keys for authentication.  <br /></td></tr>
<tr class="memitem:ga38ef7eb0a15b65f3b68d2490dd0535a0" id="r_ga38ef7eb0a15b65f3b68d2490dd0535a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga38ef7eb0a15b65f3b68d2490dd0535a0">wolfSSL_update_keys</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga38ef7eb0a15b65f3b68d2490dd0535a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys. A KeyUpdate message is sent to the peer and new keys are calculated for encryption. The peer will send back a KeyUpdate message and the new decryption keys will then be calculated. This function can only be called after a handshake has been completed.  <br /></td></tr>
<tr class="memitem:ga2f38357d4d7fba294745516caa8f4180" id="r_ga2f38357d4d7fba294745516caa8f4180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2f38357d4d7fba294745516caa8f4180">wolfSSL_key_update_response</a> (WOLFSSL *ssl, int *required)</td></tr>
<tr class="memdesc:ga2f38357d4d7fba294745516caa8f4180"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client or server wolfSSL to determine whether a rollover of keys is in progress. When <a class="el" href="group__IO.html#ga38ef7eb0a15b65f3b68d2490dd0535a0" title="This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys....">wolfSSL_update_keys()</a> is called, a KeyUpdate message is sent and the encryption key is updated. The decryption key is updated when the response is received.  <br /></td></tr>
<tr class="memitem:ga4c80a396f6b7b53c9b0d204120e52e6a" id="r_ga4c80a396f6b7b53c9b0d204120e52e6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga4c80a396f6b7b53c9b0d204120e52e6a">wolfSSL_CTX_allow_post_handshake_auth</a> (WOLFSSL_CTX *ctx)</td></tr>
<tr class="memdesc:ga4c80a396f6b7b53c9b0d204120e52e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client wolfSSL context to allow a client certificate to be sent post handshake upon request from server. This is useful when connecting to a web server that has some pages that require client authentication and others that don't.  <br /></td></tr>
<tr class="memitem:ga84f52f3a3dc072414e05d725cc4e0654" id="r_ga84f52f3a3dc072414e05d725cc4e0654"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga84f52f3a3dc072414e05d725cc4e0654">wolfSSL_allow_post_handshake_auth</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga84f52f3a3dc072414e05d725cc4e0654"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client wolfSSL to allow a client certificate to be sent post handshake upon request from server. A Post-Handshake Client Authentication extension is sent in the ClientHello. This is useful when connecting to a web server that has some pages that require client authentication and others that don't.  <br /></td></tr>
<tr class="memitem:ga5bdfe1a09ee4d55d3e73f0bfec790d13" id="r_ga5bdfe1a09ee4d55d3e73f0bfec790d13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga5bdfe1a09ee4d55d3e73f0bfec790d13">wolfSSL_request_certificate</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5bdfe1a09ee4d55d3e73f0bfec790d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests a client certificate from the TLS v1.3 client. This is useful when a web server is serving some pages that require client authentication and others that don't. A maximum of 256 requests can be sent on a connection.  <br /></td></tr>
<tr class="memitem:ga7d8482831c10c4628a51f34f8bcb4d96" id="r_ga7d8482831c10c4628a51f34f8bcb4d96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7d8482831c10c4628a51f34f8bcb4d96">wolfSSL_CTX_set1_groups_list</a> (WOLFSSL_CTX *ctx, char *list)</td></tr>
<tr class="memdesc:ga7d8482831c10c4628a51f34f8bcb4d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the list of elliptic curve groups to allow on a wolfSSL context in order of preference. The list is a null-terminated text string, and a colon-delimited list. Call this function to set the key exchange elliptic curve parameters to use with the TLS v1.3 connections.  <br /></td></tr>
<tr class="memitem:ga789a0a18aa33f7cd9b64e4f2590335ec" id="r_ga789a0a18aa33f7cd9b64e4f2590335ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga789a0a18aa33f7cd9b64e4f2590335ec">wolfSSL_set1_groups_list</a> (WOLFSSL *ssl, char *list)</td></tr>
<tr class="memdesc:ga789a0a18aa33f7cd9b64e4f2590335ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the list of elliptic curve groups to allow on a wolfSSL in order of preference. The list is a null-terminated text string, and a colon-delimited list. Call this function to set the key exchange elliptic curve parameters to use with the TLS v1.3 connections.  <br /></td></tr>
<tr class="memitem:gae50a6326d822bfce8172ff435b0ebff3" id="r_gae50a6326d822bfce8172ff435b0ebff3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#gae50a6326d822bfce8172ff435b0ebff3">wolfSSL_preferred_group</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gae50a6326d822bfce8172ff435b0ebff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the key exchange group the client prefers to use in the TLS v1.3 handshake. Call this function to after a handshake is complete to determine which group the server prefers so that this information can be used in future connections to pre-generate a key pair for key exchange.  <br /></td></tr>
<tr class="memitem:ga5bab039f79486d3ac31be72bc5f4e1e8" id="r_ga5bab039f79486d3ac31be72bc5f4e1e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga5bab039f79486d3ac31be72bc5f4e1e8">wolfSSL_CTX_set_groups</a> (WOLFSSL_CTX *ctx, int *groups, int count)</td></tr>
<tr class="memdesc:ga5bab039f79486d3ac31be72bc5f4e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the list of elliptic curve groups to allow on a wolfSSL context in order of preference. The list is an array of group identifiers with the number of identifiers specified in count. Call this function to set the key exchange elliptic curve parameters to use with the TLS v1.3 connections.  <br /></td></tr>
<tr class="memitem:ga4364fed6282be996cd4b2503ae81a79b" id="r_ga4364fed6282be996cd4b2503ae81a79b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga4364fed6282be996cd4b2503ae81a79b">wolfSSL_set_groups</a> (WOLFSSL *ssl, int *groups, int count)</td></tr>
<tr class="memdesc:ga4364fed6282be996cd4b2503ae81a79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the list of elliptic curve groups to allow on a wolfSSL. The list is an array of group identifiers with the number of identifiers specified in count. Call this function to set the key exchange elliptic curve parameters to use with the TLS v1.3 connections.  <br /></td></tr>
<tr class="memitem:ga2c85ff2299e5cb41d809dfdce9115d38" id="r_ga2c85ff2299e5cb41d809dfdce9115d38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga2c85ff2299e5cb41d809dfdce9115d38">wolfSSL_connect_TLSv13</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga2c85ff2299e5cb41d809dfdce9115d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates a TLS v1.3 handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended.  <br /></td></tr>
<tr class="memitem:ga8344dc66a938e474d2f79bc4947d92cc" id="r_ga8344dc66a938e474d2f79bc4947d92cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga8344dc66a938e474d2f79bc4947d92cc">wolfSSL_accept_TLSv13</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga8344dc66a938e474d2f79bc4947d92cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred. Call this function when expecting a TLS v1.3 connection though older version ClientHello messages are supported.  <br /></td></tr>
<tr class="memitem:ga9da5e361b0a7062f8395a82d8a5cb02f" id="r_ga9da5e361b0a7062f8395a82d8a5cb02f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga9da5e361b0a7062f8395a82d8a5cb02f">wolfSSL_CTX_set_max_early_data</a> (WOLFSSL_CTX *ctx, unsigned int sz)</td></tr>
<tr class="memdesc:ga9da5e361b0a7062f8395a82d8a5cb02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the maximum amount of early data that a TLS v1.3 client or server is willing to exchange using the wolfSSL context. Call this function to limit the amount of early data to process to mitigate replay attacks. Early data is protected by keys derived from those of the connection that the session ticket was sent and therefore will be the same every time a session ticket is used in resumption. The value is included in the session ticket for resumption. A server value of zero indicates no early data is to be sent by client using session tickets. A client value of zero indicates that the client will not send any early data. It is recommended that the number of early data bytes be kept as low as practically possible in the application.  <br /></td></tr>
<tr class="memitem:ga8f2489e4651943fcc2dd45196377a2b1" id="r_ga8f2489e4651943fcc2dd45196377a2b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga8f2489e4651943fcc2dd45196377a2b1">wolfSSL_set_max_early_data</a> (WOLFSSL *ssl, unsigned int sz)</td></tr>
<tr class="memdesc:ga8f2489e4651943fcc2dd45196377a2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the maximum amount of early data that a TLS v1.3 client or server is willing to exchange. Call this function to limit the amount of early data to process to mitigate replay attacks. Early data is protected by keys derived from those of the connection that the session ticket was sent and therefore will be the same every time a session ticket is used in resumption. The value is included in the session ticket for resumption. A server value of zero indicates no early data is to be sent by client using session tickets. A client value of zero indicates that the client will not send any early data. It is recommended that the number of early data bytes be kept as low as practically possible in the application.  <br /></td></tr>
<tr class="memitem:gade058c507ad769c52e508e5ddf7c2a94" id="r_gade058c507ad769c52e508e5ddf7c2a94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gade058c507ad769c52e508e5ddf7c2a94">wolfSSL_write_early_data</a> (WOLFSSL *ssl, const void *data, int sz, int *outSz)</td></tr>
<tr class="memdesc:gade058c507ad769c52e508e5ddf7c2a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes early data to the server on resumption. Call this function instead of <a class="el" href="group__IO.html#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="group__IO.html#ga2c85ff2299e5cb41d809dfdce9115d38" title="This function is called on the client side and initiates a TLS v1.3 handshake with a server....">wolfSSL_connect_TLSv13()</a> to connect to the server and send the data in the handshake. This function is only used with clients.  <br /></td></tr>
<tr class="memitem:ga218900890eae44f86614e3c54f0f02ab" id="r_ga218900890eae44f86614e3c54f0f02ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#ga218900890eae44f86614e3c54f0f02ab">wolfSSL_read_early_data</a> (WOLFSSL *ssl, void *data, int sz, int *outSz)</td></tr>
<tr class="memdesc:ga218900890eae44f86614e3c54f0f02ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads any early data from a client on resumption. Call this function instead of <a class="el" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> or <a class="el" href="group__IO.html#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13()</a> to accept a client and read any early data in the handshake. The function should be invoked until <a class="el" href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b" title="This function checks to see if the connection is established.">wolfSSL_is_init_finished()</a> returns true. Early data may be sent by the client in multiple messages. If there is no early data then the handshake will be processed as normal. This function is only used with servers.  <br /></td></tr>
<tr class="memitem:gac0ad4fa3f78e9c8438d656392afbd46b" id="r_gac0ad4fa3f78e9c8438d656392afbd46b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IO.html#gac0ad4fa3f78e9c8438d656392afbd46b">wolfSSL_inject</a> (WOLFSSL *ssl, const void *data, int sz)</td></tr>
<tr class="memdesc:gac0ad4fa3f78e9c8438d656392afbd46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to inject data into the WOLFSSL object. This is useful when data needs to be read from a single place and demultiplexed into multiple connections. The caller should then call <a class="el" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> to extract the plaintext data from the WOLFSSL object.  <br /></td></tr>
<tr class="memitem:ga97cc71353b919a3bc2ba0b85763dba9c" id="r_ga97cc71353b919a3bc2ba0b85763dba9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga97cc71353b919a3bc2ba0b85763dba9c">wolfSSL_CTX_set_psk_client_tls13_callback</a> (WOLFSSL_CTX *ctx, wc_psk_client_tls13_callback cb)</td></tr>
<tr class="memdesc:ga97cc71353b919a3bc2ba0b85763dba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Pre-Shared Key (PSK) client side callback for TLS v1.3 connections. The callback is used to find a PSK identity and return its key and the name of the cipher to use for the handshake. The function sets the client_psk_tls13_cb member of the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:ga034712e056a74800f70138877a1027cb" id="r_ga034712e056a74800f70138877a1027cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga034712e056a74800f70138877a1027cb">wolfSSL_set_psk_client_tls13_callback</a> (WOLFSSL *ssl, wc_psk_client_tls13_callback cb)</td></tr>
<tr class="memdesc:ga034712e056a74800f70138877a1027cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Pre-Shared Key (PSK) client side callback for TLS v1.3 connections. The callback is used to find a PSK identity and return its key and the name of the cipher to use for the handshake. The function sets the client_psk_tls13_cb member of the options field in WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga7a8987c1610fff02c0a7d7c326e60720" id="r_ga7a8987c1610fff02c0a7d7c326e60720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7a8987c1610fff02c0a7d7c326e60720">wolfSSL_CTX_set_psk_server_tls13_callback</a> (WOLFSSL_CTX *ctx, wc_psk_server_tls13_callback cb)</td></tr>
<tr class="memdesc:ga7a8987c1610fff02c0a7d7c326e60720"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Pre-Shared Key (PSK) server side callback for TLS v1.3 connections. The callback is used to find a PSK identity and return its key and the name of the cipher to use for the handshake. The function sets the server_psk_tls13_cb member of the WOLFSSL_CTX structure.  <br /></td></tr>
<tr class="memitem:gac2077bbbc470b1956b2efcea5ea80d48" id="r_gac2077bbbc470b1956b2efcea5ea80d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gac2077bbbc470b1956b2efcea5ea80d48">wolfSSL_set_psk_server_tls13_callback</a> (WOLFSSL *ssl, wc_psk_server_tls13_callback cb)</td></tr>
<tr class="memdesc:gac2077bbbc470b1956b2efcea5ea80d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Pre-Shared Key (PSK) server side callback for TLS v1.3 connections. The callback is used to find a PSK identity and return its key and the name of the cipher to use for the handshake. The function sets the server_psk_tls13_cb member of the options field in WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gac2d00ac65513f10e0ccd1b67d9a99e3d" id="r_gac2d00ac65513f10e0ccd1b67d9a99e3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gac2d00ac65513f10e0ccd1b67d9a99e3d">wolfSSL_UseKeyShare</a> (WOLFSSL *ssl, word16 group)</td></tr>
<tr class="memdesc:gac2d00ac65513f10e0ccd1b67d9a99e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a key share entry from the group including generating a key pair. The KeyShare extension contains all the generated public keys for key exchange. If this function is called, then only the groups specified will be included. Call this function when a preferred group has been previously established for the server.  <br /></td></tr>
<tr class="memitem:gacceeea00b1692593e95af822f03b779b" id="r_gacceeea00b1692593e95af822f03b779b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gacceeea00b1692593e95af822f03b779b">wolfSSL_NoKeyShares</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gacceeea00b1692593e95af822f03b779b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to ensure no key shares are sent in the ClientHello. This will force the server to respond with a HelloRetryRequest if a key exchange is required in the handshake. Call this function when the expected key exchange group is not known and to avoid the generation of keys unnecessarily. Note that an extra round-trip will be required to complete the handshake when a key exchange is required.  <br /></td></tr>
<tr class="memitem:gab393cb59fc2fcccf4e12f6aa503bafd4" id="r_gab393cb59fc2fcccf4e12f6aa503bafd4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab393cb59fc2fcccf4e12f6aa503bafd4">wolfTLSv1_3_server_method_ex</a> (void *heap)</td></tr>
<tr class="memdesc:gab393cb59fc2fcccf4e12f6aa503bafd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to indicate that the application is a server and will only support the TLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:gab94cfeeb62557b65111c42fc335b2244" id="r_gab94cfeeb62557b65111c42fc335b2244"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gab94cfeeb62557b65111c42fc335b2244">wolfTLSv1_3_client_method_ex</a> (void *heap)</td></tr>
<tr class="memdesc:gab94cfeeb62557b65111c42fc335b2244"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to indicate that the application is a client and will only support the TLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga99ec4e5171b75c904bd388f9ffe062c4" id="r_ga99ec4e5171b75c904bd388f9ffe062c4"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga99ec4e5171b75c904bd388f9ffe062c4">wolfTLSv1_3_server_method</a> (void)</td></tr>
<tr class="memdesc:ga99ec4e5171b75c904bd388f9ffe062c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to indicate that the application is a server and will only support the TLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga7a3cea32f71942007b25c54dc65892d5" id="r_ga7a3cea32f71942007b25c54dc65892d5"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7a3cea32f71942007b25c54dc65892d5">wolfTLSv1_3_client_method</a> (void)</td></tr>
<tr class="memdesc:ga7a3cea32f71942007b25c54dc65892d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to indicate that the application is a client and will only support the TLS 1.3 protocol. This function allocates memory for and initializes a new wolfSSL_METHOD structure to be used when creating the SSL/TLS context with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.  <br /></td></tr>
<tr class="memitem:ga384a5f26dd88b47466d63e6104d3937c" id="r_ga384a5f26dd88b47466d63e6104d3937c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga384a5f26dd88b47466d63e6104d3937c">wolfTLSv1_3_method_ex</a> (void *heap)</td></tr>
<tr class="memdesc:ga384a5f26dd88b47466d63e6104d3937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a WOLFSSL_METHOD similar to wolfTLSv1_3_client_method except that it is not determined which side yet (server/client).  <br /></td></tr>
<tr class="memitem:ga7930745c6e58ba642f33de11e7675a59" id="r_ga7930745c6e58ba642f33de11e7675a59"><td class="memItemLeft" align="right" valign="top">WOLFSSL_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga7930745c6e58ba642f33de11e7675a59">wolfTLSv1_3_method</a> (void)</td></tr>
<tr class="memdesc:ga7930745c6e58ba642f33de11e7675a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a WOLFSSL_METHOD similar to wolfTLSv1_3_client_method except that it is not determined which side yet (server/client).  <br /></td></tr>
<tr class="memitem:ae33ad1ed1a09d60531882711396a754c" id="r_ae33ad1ed1a09d60531882711396a754c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33ad1ed1a09d60531882711396a754c">wolfSSL_CTX_set_ephemeral_key</a> (WOLFSSL_CTX *ctx, int keyAlgo, const char *key, unsigned int keySz, int format)</td></tr>
<tr class="memdesc:ae33ad1ed1a09d60531882711396a754c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a fixed / static ephemeral key for testing only.  <br /></td></tr>
<tr class="memitem:ad3b2ce849382c9f86275de47af4c38c5" id="r_ad3b2ce849382c9f86275de47af4c38c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b2ce849382c9f86275de47af4c38c5">wolfSSL_set_ephemeral_key</a> (WOLFSSL *ssl, int keyAlgo, const char *key, unsigned int keySz, int format)</td></tr>
<tr class="memdesc:ad3b2ce849382c9f86275de47af4c38c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a fixed / static ephemeral key for testing only.  <br /></td></tr>
<tr class="memitem:a944cf1dededa231ff8883f70804c4f89" id="r_a944cf1dededa231ff8883f70804c4f89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a944cf1dededa231ff8883f70804c4f89">wolfSSL_CTX_get_ephemeral_key</a> (WOLFSSL_CTX *ctx, int keyAlgo, const unsigned char **key, unsigned int *keySz)</td></tr>
<tr class="memdesc:a944cf1dededa231ff8883f70804c4f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns pointer to loaded key as ASN.1/DER.  <br /></td></tr>
<tr class="memitem:a48e4dcab8f599fec761f55a3c91a0e7b" id="r_a48e4dcab8f599fec761f55a3c91a0e7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48e4dcab8f599fec761f55a3c91a0e7b">wolfSSL_get_ephemeral_key</a> (WOLFSSL *ssl, int keyAlgo, const unsigned char **key, unsigned int *keySz)</td></tr>
<tr class="memdesc:a48e4dcab8f599fec761f55a3c91a0e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns pointer to loaded key as ASN.1/DER.  <br /></td></tr>
<tr class="memitem:a61e37b570331e89d27ef01988c57d5aa" id="r_a61e37b570331e89d27ef01988c57d5aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e37b570331e89d27ef01988c57d5aa">wolfSSL_RSA_sign_generic_padding</a> (int type, const unsigned char *m, unsigned int mLen, unsigned char *sigRet, unsigned int *sigLen, WOLFSSL_RSA *rsa, int flag, int padding)</td></tr>
<tr class="memdesc:a61e37b570331e89d27ef01988c57d5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a message with the chosen message digest, padding, and RSA key.  <br /></td></tr>
<tr class="memitem:a5a5938dd9d0e7dc3deb364a1b017e573" id="r_a5a5938dd9d0e7dc3deb364a1b017e573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a5938dd9d0e7dc3deb364a1b017e573">wolfSSL_dtls13_has_pending_msg</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a5a5938dd9d0e7dc3deb364a1b017e573"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if DTLSv1.3 stack has some messages sent but not yet acknowledged by the other peer  <br /></td></tr>
<tr class="memitem:a00368a4d60ecb4f606103ec94c353e3f" id="r_a00368a4d60ecb4f606103ec94c353e3f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00368a4d60ecb4f606103ec94c353e3f">wolfSSL_SESSION_get_max_early_data</a> (const WOLFSSL_SESSION *s)</td></tr>
<tr class="memdesc:a00368a4d60ecb4f606103ec94c353e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum size of Early Data from a session.  <br /></td></tr>
<tr class="memitem:a45bddab50ffcf8b3fba0be19fb9b4f1d" id="r_a45bddab50ffcf8b3fba0be19fb9b4f1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45bddab50ffcf8b3fba0be19fb9b4f1d">wolfSSL_CRYPTO_get_ex_new_index</a> (int, void *, void *, void *, void *)</td></tr>
<tr class="memdesc:a45bddab50ffcf8b3fba0be19fb9b4f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new index for external data. This entry applies also for the following API:  <br /></td></tr>
<tr class="memitem:ga4e0b234edb4864ccc33928fae38eef78" id="r_ga4e0b234edb4864ccc33928fae38eef78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga4e0b234edb4864ccc33928fae38eef78">wolfSSL_CTX_set_client_cert_type</a> (WOLFSSL_CTX *ctx, const char *buf, int len)</td></tr>
<tr class="memdesc:ga4e0b234edb4864ccc33928fae38eef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case this function is called in a client side, set certificate types that can be sent to its peer. In case called in a server side, set certificate types that can be acceptable from its peer. Put cert types in the buffer with prioritised order. To reset the settings to default, pass NULL for the buffer or pass zero for len. By default, certificate type is only X509. In case both side intend to send or accept "Raw public key" cert, WOLFSSL_CERT_TYPE_RPK should be included in the buffer to set.  <br /></td></tr>
<tr class="memitem:gaceca8dcac1454ec6cf310597bd8b6895" id="r_gaceca8dcac1454ec6cf310597bd8b6895"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#gaceca8dcac1454ec6cf310597bd8b6895">wolfSSL_CTX_set_server_cert_type</a> (WOLFSSL_CTX *ctx, const char *buf, int len)</td></tr>
<tr class="memdesc:gaceca8dcac1454ec6cf310597bd8b6895"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case this function is called in a server side, set certificate types that can be sent to its peer. In case called in a client side, set certificate types that can be acceptable from its peer. Put cert types in the buffer with prioritised order. To reset the settings to default, pass NULL for the buffer or pass zero for len. By default, certificate type is only X509. In case both side intend to send or accept "Raw public key" cert, WOLFSSL_CERT_TYPE_RPK should be included in the buffer to set.  <br /></td></tr>
<tr class="memitem:ga40c884153d93bc6aa261c6b96915a236" id="r_ga40c884153d93bc6aa261c6b96915a236"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga40c884153d93bc6aa261c6b96915a236">wolfSSL_set_client_cert_type</a> (WOLFSSL *ssl, const char *buf, int len)</td></tr>
<tr class="memdesc:ga40c884153d93bc6aa261c6b96915a236"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case this function is called in a client side, set certificate types that can be sent to its peer. In case called in a server side, set certificate types that can be acceptable from its peer. Put cert types in the buffer with prioritised order. To reset the settings to default, pass NULL for the buffer or pass zero for len. By default, certificate type is only X509. In case both side intend to send or accept "Raw public key" cert, WOLFSSL_CERT_TYPE_RPK should be included in the buffer to set.  <br /></td></tr>
<tr class="memitem:ga134f244a4a790fde86e244b7e3df6723" id="r_ga134f244a4a790fde86e244b7e3df6723"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Setup.html#ga134f244a4a790fde86e244b7e3df6723">wolfSSL_set_server_cert_type</a> (WOLFSSL *ssl, const char *buf, int len)</td></tr>
<tr class="memdesc:ga134f244a4a790fde86e244b7e3df6723"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case this function is called in a server side, set certificate types that can be sent to its peer. In case called in a client side, set certificate types that can be acceptable from its peer. Put cert types in the buffer with prioritised order. To reset the settings to default, pass NULL for the buffer or pass zero for len. By default, certificate type is only X509. In case both side intend to send or accept "Raw public key" cert, WOLFSSL_CERT_TYPE_RPK should be included in the buffer to set.  <br /></td></tr>
<tr class="memitem:a9370b0972916f388d2eab0342521ded3" id="r_a9370b0972916f388d2eab0342521ded3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9370b0972916f388d2eab0342521ded3">wolfSSL_get_negotiated_client_cert_type</a> (WOLFSSL *ssl, int *tp)</td></tr>
<tr class="memdesc:a9370b0972916f388d2eab0342521ded3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the result of the client certificate type negotiation done in ClientHello and ServerHello. WOLFSSL_SUCCESS is returned as a return value if no negotiation occurs and WOLFSSL_CERT_TYPE_UNKNOWN is returned as the certificate type.  <br /></td></tr>
<tr class="memitem:a2a965b3cc8d874fff75fcdef43961220" id="r_a2a965b3cc8d874fff75fcdef43961220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a965b3cc8d874fff75fcdef43961220">wolfSSL_get_negotiated_server_cert_type</a> (WOLFSSL *ssl, int *tp)</td></tr>
<tr class="memdesc:a2a965b3cc8d874fff75fcdef43961220"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the result of the server certificate type negotiation done in ClientHello and ServerHello. WOLFSSL_SUCCESS is returned as a return value if no negotiation occurs and WOLFSSL_CERT_TYPE_UNKNOWN is returned as the certificate type.  <br /></td></tr>
<tr class="memitem:a2a23caed3a0c38d1ebe1366dc844b34c" id="r_a2a23caed3a0c38d1ebe1366dc844b34c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c">wolfSSL_dtls_cid_use</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a2a23caed3a0c38d1ebe1366dc844b34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.  <br /></td></tr>
<tr class="memitem:a7e7f6700dd9eef47d6f83ae507dc6e0b" id="r_a7e7f6700dd9eef47d6f83ae507dc6e0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b">wolfSSL_dtls_cid_is_enabled</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:a7e7f6700dd9eef47d6f83ae507dc6e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for the SSL object. See RFC 9146 and RFC 9147.  <br /></td></tr>
<tr class="memitem:a4c3f01c34e2386f57b791f2b4746da67" id="r_a4c3f01c34e2386f57b791f2b4746da67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67">wolfSSL_dtls_cid_set</a> (WOLFSSL *ssl, unsigned char *cid, unsigned int size)</td></tr>
<tr class="memdesc:a4c3f01c34e2386f57b791f2b4746da67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC 9147. The ConnectionID must be at maximum DTLS_CID_MAX_SIZE, that is an tunable compile time define, and it can't never be bigger than 255 bytes.  <br /></td></tr>
<tr class="memitem:a98e346811ddfa58b342642f886c0d09e" id="r_a98e346811ddfa58b342642f886c0d09e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e346811ddfa58b342642f886c0d09e">wolfSSL_dtls_cid_get_rx_size</a> (WOLFSSL *ssl, unsigned int *size)</td></tr>
<tr class="memdesc:a98e346811ddfa58b342642f886c0d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC 9147. The size is stored in the parameter size.  <br /></td></tr>
<tr class="memitem:a9c7c6e4efea4ecf0bb9b9a1fb1365408" id="r_a9c7c6e4efea4ecf0bb9b9a1fb1365408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408">wolfSSL_dtls_cid_get_rx</a> (WOLFSSL *ssl, unsigned char *buffer, unsigned int bufferSz)</td></tr>
<tr class="memdesc:a9c7c6e4efea4ecf0bb9b9a1fb1365408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the ConnectionID used by the other peer to send records in this connection into the buffer pointed by the parameter buffer. See RFC 9146 and RFC.  <br /></td></tr>
<tr class="memitem:acb4dcd90229f9f5e44b0b80340bb5e65" id="r_acb4dcd90229f9f5e44b0b80340bb5e65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4dcd90229f9f5e44b0b80340bb5e65">wolfSSL_dtls_cid_get0_rx</a> (WOLFSSL *ssl, unsigned char **cid)</td></tr>
<tr class="memdesc:acb4dcd90229f9f5e44b0b80340bb5e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ConnectionID used by the other peer. See RFC 9146 and RFC 9147.  <br /></td></tr>
<tr class="memitem:aee6e35bce04662d8021c29de41febabd" id="r_aee6e35bce04662d8021c29de41febabd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6e35bce04662d8021c29de41febabd">wolfSSL_dtls_cid_get_tx_size</a> (WOLFSSL *ssl, unsigned int *size)</td></tr>
<tr class="memdesc:aee6e35bce04662d8021c29de41febabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147. The size is stored in the parameter size.  <br /></td></tr>
<tr class="memitem:a719db6450251717616cb6a9f92463273" id="r_a719db6450251717616cb6a9f92463273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a719db6450251717616cb6a9f92463273">wolfSSL_dtls_cid_get_tx</a> (WOLFSSL *ssl, unsigned char *buffer, unsigned int bufferSz)</td></tr>
<tr class="memdesc:a719db6450251717616cb6a9f92463273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the ConnectionID used when sending records in this connection into the buffer pointer by the parameter buffer. See RFC 9146 and RFC 9147. The available size need to be provided in bufferSz.  <br /></td></tr>
<tr class="memitem:a40f8d108b7490ffeccdfc0dac952b9b0" id="r_a40f8d108b7490ffeccdfc0dac952b9b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40f8d108b7490ffeccdfc0dac952b9b0">wolfSSL_dtls_cid_get0_tx</a> (WOLFSSL *ssl, unsigned char **cid)</td></tr>
<tr class="memdesc:a40f8d108b7490ffeccdfc0dac952b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ConnectionID used when sending records in this connection. See RFC 9146 and RFC 9147.  <br /></td></tr>
<tr class="memitem:aa2288103683ccb84fe48bfc56f0bd147" id="r_aa2288103683ccb84fe48bfc56f0bd147"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2288103683ccb84fe48bfc56f0bd147">wolfSSL_dtls_cid_parse</a> (const unsigned char *msg, unsigned int msgSz, unsigned int cidSz)</td></tr>
<tr class="memdesc:aa2288103683ccb84fe48bfc56f0bd147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the ConnectionID from a record datagram/message. See RFC 9146 and RFC 9147.  <br /></td></tr>
<tr class="memitem:ga1c10281cbcf225219c64f7d09a5af6c4" id="r_ga1c10281cbcf225219c64f7d09a5af6c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga1c10281cbcf225219c64f7d09a5af6c4">wolfSSL_get_client_suites_sigalgs</a> (const WOLFSSL *ssl, const byte **suites, word16 *suiteSz, const byte **hashSigAlgo, word16 *hashSigAlgoSz)</td></tr>
<tr class="memdesc:ga1c10281cbcf225219c64f7d09a5af6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raw list of ciphersuites and signature algorithms offered by the client. The lists are only stored and returned inside a callback setup with wolfSSL_CTX_set_cert_cb(). This is useful to be able to dynamically load certificates and keys based on the available ciphersuites and signature algorithms.  <br /></td></tr>
<tr class="memitem:ga89c7dae4a60043bc4463a61f5fc85005" id="r_ga89c7dae4a60043bc4463a61f5fc85005"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CIPHERSUITE_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga89c7dae4a60043bc4463a61f5fc85005">wolfSSL_get_ciphersuite_info</a> (byte first, byte second)</td></tr>
<tr class="memdesc:ga89c7dae4a60043bc4463a61f5fc85005"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns information about the ciphersuite directly from the raw ciphersuite bytes.  <br /></td></tr>
<tr class="memitem:ga8401712b6d6705a712c6c67c4cb114ad" id="r_ga8401712b6d6705a712c6c67c4cb114ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TLS.html#ga8401712b6d6705a712c6c67c4cb114ad">wolfSSL_get_sigalg_info</a> (byte first, byte second, int *hashAlgo, int *sigAlgo)</td></tr>
<tr class="memdesc:ga8401712b6d6705a712c6c67c4cb114ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns information about the hash and signature algorithm directly from the raw ciphersuite bytes.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a1736540e27446e5c29b3845a0d76bebb" name="a1736540e27446e5c29b3845a0d76bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1736540e27446e5c29b3845a0d76bebb">&#9670;&#160;</a></span>wolfDTLSv1_2_client_method_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_METHOD * wolfDTLSv1_2_client_method_ex </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the DTLS v1.2 client method. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer This function returns a pointer to a new WOLFSSL_METHOD structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a>();</div>
<div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(wolfDTLSv1_2_client_method());</div>
<div class="line">…</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="ttc" id="agroup__Setup_html_ga2bcaa81e9fd11074c6e504891370dd45"><div class="ttname"><a href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a></div><div class="ttdeci">WOLFSSL_CTX * wolfSSL_CTX_new(WOLFSSL_METHOD *)</div><div class="ttdoc">This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.</div></div>
<div class="ttc" id="agroup__Setup_html_gab6d54b7485d74962e57bc636008aa9a0"><div class="ttname"><a href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a></div><div class="ttdeci">WOLFSSL * wolfSSL_new(WOLFSSL_CTX *)</div><div class="ttdoc">This function creates a new SSL session, taking an already created SSL context as input.</div></div>
<div class="ttc" id="agroup__TLS_html_ga789ef74e34df659a62f06da2ea709737"><div class="ttname"><a href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a></div><div class="ttdeci">int wolfSSL_Init(void)</div><div class="ttdoc">Initializes the wolfSSL library for use. Must be called once per application and before any other cal...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737" title="Initializes the wolfSSL library for use. Must be called once per application and before any other cal...">wolfSSL_Init</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd></dl>

</div>
</div>
<a id="a22fbd4add0987197fb393df285be7a30" name="a22fbd4add0987197fb393df285be7a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fbd4add0987197fb393df285be7a30">&#9670;&#160;</a></span>wolfDTLSv1_2_server_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_METHOD * wolfDTLSv1_2_server_method </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates and initializes a WOLFSSL_METHOD for the server side. </p>
<dl class="section return"><dt>Returns</dt><dd>This function returns a WOLFSSL_METHOD pointer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(<a class="code hl_function" href="#a22fbd4add0987197fb393df285be7a30">wolfDTLSv1_2_server_method</a>());</div>
<div class="line">WOLFSSL* ssl = WOLFSSL_new(ctx);</div>
<div class="line">…</div>
<div class="ttc" id="assl_8h_html_a22fbd4add0987197fb393df285be7a30"><div class="ttname"><a href="#a22fbd4add0987197fb393df285be7a30">wolfDTLSv1_2_server_method</a></div><div class="ttdeci">WOLFSSL_METHOD * wolfDTLSv1_2_server_method(void)</div><div class="ttdoc">This function creates and initializes a WOLFSSL_METHOD for the server side.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd></dl>

</div>
</div>
<a id="a7eb561acf87b28ecdc5e3cafbd838bcb" name="a7eb561acf87b28ecdc5e3cafbd838bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb561acf87b28ecdc5e3cafbd838bcb">&#9670;&#160;</a></span>wolfSSL_accept_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_accept_ex </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandShakeCallBacki</td>          <td class="paramname"><span class="paramname"><em>hsCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeoutCallBack</td>          <td class="paramname"><span class="paramname"><em>toCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_TIMEVAL</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a7eb561acf87b28ecdc5e3cafbd838bcb" title="wolfSSL_accept_ex() is an extension that allows a HandShake Callback to be set. This can be useful in...">wolfSSL_accept_ex()</a> is an extension that allows a HandShake Callback to be set. This can be useful in embedded systems for debugging support when a debugger isn’t available and sniffing is impractical. The HandShake Callback will be called whether or not a handshake error occurred. No dynamic memory is used since the maximum number of SSL packets is known. Packet names can be accessed through packetNames[]. The connect extension also allows a Timeout Callback to be set along with a timeout value. This is useful if the user doesn’t want to wait for the TCP stack to timeout. This extension can be called with either, both, or neither callbacks. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
GETTIME_ERROR will be returned if gettimeofday() encountered an error. </dd>
<dd>
SETITIMER_ERROR will be returned if setitimer() encountered an error. </dd>
<dd>
SIGACT_ERROR will be returned if sigaction() encountered an error. </dd>
<dd>
SSL_FATAL_ERROR will be returned if the underlying SSL_accept() call encountered an error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a927d4a1f37cd1df66faa5d20a90482a6" title="wolfSSL_connect_ex() is an extension that allows a HandShake Callback to be set. This can be useful i...">wolfSSL_connect_ex</a> </dd></dl>

</div>
</div>
<a id="aa28e1637d83269c0f9f37912b3c06a46" name="aa28e1637d83269c0f9f37912b3c06a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28e1637d83269c0f9f37912b3c06a46">&#9670;&#160;</a></span>wolfSSL_CertManagerCheckCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CertManagerCheckCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CERT_MANAGER *</td>          <td class="paramname"><span class="paramname"><em>cm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check CRL if the option is enabled and compares the cert to the CRL list. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returns if the function returned as expected. If the crlEnabled member of the WOLFSSL_CERT_MANAGER struct is turned on. </dd>
<dd>
MEMORY_E returns if the allocated memory failed. </dd>
<dd>
BAD_FUNC_ARG if the WOLFSSL_CERT_MANAGER is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cm</td><td>a pointer to a WOLFSSL_CERT_MANAGER struct. </td></tr>
    <tr><td class="paramname">der</td><td>pointer to a DER formatted certificate. </td></tr>
    <tr><td class="paramname">sz</td><td>size of the certificate.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CERT_MANAGER* cm;</div>
<div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line"><span class="keywordtype">int</span> sz; <span class="comment">// size of der</span></div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#aa28e1637d83269c0f9f37912b3c06a46">wolfSSL_CertManagerCheckCRL</a>(cm, der, sz) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Error returned. Deal with failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_aa28e1637d83269c0f9f37912b3c06a46"><div class="ttname"><a href="#aa28e1637d83269c0f9f37912b3c06a46">wolfSSL_CertManagerCheckCRL</a></div><div class="ttdeci">int wolfSSL_CertManagerCheckCRL(WOLFSSL_CERT_MANAGER *cm, unsigned char *der, int sz)</div><div class="ttdoc">Check CRL if the option is enabled and compares the cert to the CRL list.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>CheckCertCRL </dd>
<dd>
ParseCertRelative </dd>
<dd>
wolfSSL_CertManagerSetCRL_CB </dd>
<dd>
InitDecodedCert </dd></dl>

</div>
</div>
<a id="a927d4a1f37cd1df66faa5d20a90482a6" name="a927d4a1f37cd1df66faa5d20a90482a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927d4a1f37cd1df66faa5d20a90482a6">&#9670;&#160;</a></span>wolfSSL_connect_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_connect_ex </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandShakeCallBack</td>          <td class="paramname"><span class="paramname"><em>hsCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeoutCallBack</td>          <td class="paramname"><span class="paramname"><em>toCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_TIMEVAL</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a927d4a1f37cd1df66faa5d20a90482a6" title="wolfSSL_connect_ex() is an extension that allows a HandShake Callback to be set. This can be useful i...">wolfSSL_connect_ex()</a> is an extension that allows a HandShake Callback to be set. This can be useful in embedded systems for debugging support when a debugger isn’t available and sniffing is impractical. The HandShake Callback will be called whether or not a handshake error occurred. No dynamic memory is used since the maximum number of SSL packets is known. Packet names can be accessed through packetNames[]. The connect extension also allows a Timeout Callback to be set along with a timeout value. This is useful if the user doesn’t want to wait for the TCP stack to timeout. This extension can be called with either, both, or neither callbacks. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
GETTIME_ERROR will be returned if gettimeofday() encountered an error. </dd>
<dd>
SETITIMER_ERROR will be returned if setitimer() encountered an error. </dd>
<dd>
SIGACT_ERROR will be returned if sigaction() encountered an error. </dd>
<dd>
SSL_FATAL_ERROR will be returned if the underlying SSL_connect() call encountered an error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7eb561acf87b28ecdc5e3cafbd838bcb" title="wolfSSL_accept_ex() is an extension that allows a HandShake Callback to be set. This can be useful in...">wolfSSL_accept_ex</a> </dd></dl>

</div>
</div>
<a id="a45bddab50ffcf8b3fba0be19fb9b4f1d" name="a45bddab50ffcf8b3fba0be19fb9b4f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bddab50ffcf8b3fba0be19fb9b4f1d">&#9670;&#160;</a></span>wolfSSL_CRYPTO_get_ex_new_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CRYPTO_get_ex_new_index </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a new index for external data. This entry applies also for the following API: </p>
<ul>
<li>wolfSSL_CTX_get_ex_new_index</li>
<li>wolfSSL_get_ex_new_index</li>
<li>wolfSSL_SESSION_get_ex_new_index</li>
<li>wolfSSL_X509_get_ex_new_index</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">All</td><td>input parameters are ignored. The callback functions are not supported with wolfSSL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new index value to be used with the external data API for this object class. </dd></dl>

</div>
</div>
<a id="a5031108243f2872aee61a6677d1f5607" name="a5031108243f2872aee61a6677d1f5607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5031108243f2872aee61a6677d1f5607">&#9670;&#160;</a></span>wolfSSL_CTX_DisableCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_DisableCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables CRL verification in the CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executes without error. The crlEnabled member of the WOLFSSL_CERT_MANAGER struct is set to 0. </dd>
<dd>
BAD_FUNC_ARG returned if either the CTX struct or the CM struct has a NULL value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#a5031108243f2872aee61a6677d1f5607">wolfSSL_CTX_DisableCRL</a>(ssl-&gt;ctx) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a5031108243f2872aee61a6677d1f5607"><div class="ttname"><a href="#a5031108243f2872aee61a6677d1f5607">wolfSSL_CTX_DisableCRL</a></div><div class="ttdeci">int wolfSSL_CTX_DisableCRL(WOLFSSL_CTX *ctx)</div><div class="ttdoc">This function disables CRL verification in the CTX structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga9e8cc5c00936adde105e64dbf1e8d403" title="Turns off Certificate Revocation List checking when verifying certificates with the Certificate Manag...">wolfSSL_CertManagerDisableCRL</a> </dd></dl>

</div>
</div>
<a id="a6dd90a4253a0716bfa1fcdeff5bcb519" name="a6dd90a4253a0716bfa1fcdeff5bcb519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd90a4253a0716bfa1fcdeff5bcb519">&#9670;&#160;</a></span>wolfSSL_CTX_DisableOCSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_DisableOCSP </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables OCSP certificate revocation checking by affecting the ocspEnabled member of the WOLFSSL_CERT_MANAGER structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executes without error. The ocspEnabled member of the CM has been disabled. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL_CTX structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if(!<a class="code hl_function" href="#a6dd90a4253a0716bfa1fcdeff5bcb519">wolfSSL_CTX_DisableOCSP</a>(ssl-&gt;ctx)){</div>
<div class="line">    <span class="comment">// OCSP is not disabled</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a6dd90a4253a0716bfa1fcdeff5bcb519"><div class="ttname"><a href="#a6dd90a4253a0716bfa1fcdeff5bcb519">wolfSSL_CTX_DisableOCSP</a></div><div class="ttdeci">int wolfSSL_CTX_DisableOCSP(WOLFSSL_CTX *)</div><div class="ttdoc">This function disables OCSP certificate revocation checking by affecting the ocspEnabled member of th...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb7c9ec80311c16f4223f53e5ec8449e" title="Disables the OCSP certificate revocation option.">wolfSSL_DisableOCSP</a> </dd>
<dd>
<a class="el" href="group__CertManager.html#ga31367a0d315f0342113ce827128727f9" title="Disables OCSP certificate revocation.">wolfSSL_CertManagerDisableOCSP</a> </dd></dl>

</div>
</div>
<a id="a65e317e419b97b46fd287f6ddd2d8b04" name="a65e317e419b97b46fd287f6ddd2d8b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e317e419b97b46fd287f6ddd2d8b04">&#9670;&#160;</a></span>wolfSSL_CTX_dtls_set_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_dtls_set_export </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_dtls_export</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04" title="The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...">wolfSSL_CTX_dtls_set_export()</a> function is used to set the callback function for exporting a session. It is allowed to pass in NULL as the parameter func to clear the export function previously stored. Used on the server side and is called immediately after handshake is completed. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG If null or not expected arguments are passed in</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">func</td><td>wc_dtls_export function to use when exporting a session.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> send_session(WOLFSSL* ssl, <span class="keywordtype">byte</span>* buf, word32 sz, <span class="keywordtype">void</span>* userCtx);</div>
<div class="line"><span class="comment">// body of send session (wc_dtls_export) that passes</span></div>
<div class="line"><span class="comment">// buf (serialized session) to destination</span></div>
<div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a65e317e419b97b46fd287f6ddd2d8b04">wolfSSL_CTX_dtls_set_export</a>(ctx, send_session);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a>(ssl);</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_gaf0cfc676947d7eabd67ec1a4661ed625"><div class="ttname"><a href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a></div><div class="ttdeci">int wolfSSL_accept(WOLFSSL *)</div><div class="ttdoc">This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...</div></div>
<div class="ttc" id="assl_8h_html_a65e317e419b97b46fd287f6ddd2d8b04"><div class="ttname"><a href="#a65e317e419b97b46fd287f6ddd2d8b04">wolfSSL_CTX_dtls_set_export</a></div><div class="ttdeci">int wolfSSL_CTX_dtls_set_export(WOLFSSL_CTX *ctx, wc_dtls_export func)</div><div class="ttdoc">The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a515a17c2d7dd1b2f79d9849fcec38c4e" title="The wolfSSL_dtls_set_export() function is used to set the callback function for exporting a session....">wolfSSL_dtls_set_export</a> </dd>
<dd>
Static buffer use </dd></dl>

</div>
</div>
<a id="ae3faad2d4f64d7ff6e4462e621f0ecde" name="ae3faad2d4f64d7ff6e4462e621f0ecde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3faad2d4f64d7ff6e4462e621f0ecde">&#9670;&#160;</a></span>wolfSSL_CTX_EnableCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_EnableCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables CRL certificate verification through the CTX. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if this function and it’s subroutines execute without errors. </dd>
<dd>
BAD_FUNC_ARG returned if the CTX struct is NULL or there was otherwise an invalid argument passed in a subroutine. </dd>
<dd>
MEMORY_E returned if there was an error allocating memory during execution of the function. </dd>
<dd>
SSL_FAILURE returned if the crl member of the WOLFSSL_CERT_MANAGER fails to initialize correctly. </dd>
<dd>
NOT_COMPILED_IN wolfSSL was not compiled with the HAVE_CRL option.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ae3faad2d4f64d7ff6e4462e621f0ecde">wolfSSL_CTX_EnableCRL</a>(ssl-&gt;ctx, options) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// The function failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ae3faad2d4f64d7ff6e4462e621f0ecde"><div class="ttname"><a href="#ae3faad2d4f64d7ff6e4462e621f0ecde">wolfSSL_CTX_EnableCRL</a></div><div class="ttdeci">int wolfSSL_CTX_EnableCRL(WOLFSSL_CTX *ctx, int options)</div><div class="ttdoc">Enables CRL certificate verification through the CTX.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#gaa0caa567b553f8417bca591cd18c9a25" title="Turns on Certificate Revocation List checking when verifying certificates with the Certificate Manage...">wolfSSL_CertManagerEnableCRL</a> </dd>
<dd>
InitCRL </dd>
<dd>
<a class="el" href="#a5031108243f2872aee61a6677d1f5607" title="This function disables CRL verification in the CTX structure.">wolfSSL_CTX_DisableCRL</a> </dd></dl>

</div>
</div>
<a id="a3b69fdce096db89cdab845482c90f0f1" name="a3b69fdce096db89cdab845482c90f0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b69fdce096db89cdab845482c90f0f1">&#9670;&#160;</a></span>wolfSSL_CTX_EnableOCSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_EnableOCSP </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets options to configure behavior of OCSP functionality in wolfSSL. The value of options if formed by or’ing one or more of the following options: WOLFSSL_OCSP_URL_OVERRIDE - use the override URL instead of the URL in certificates. The override URL is specified using the <a class="el" href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad" title="This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the i...">wolfSSL_CTX_SetOCSP_OverrideURL()</a> function. WOLFSSL_OCSP_CHECKALL - Set all OCSP checks on WOLFSSL_OCSP_NO_NONCE - Set nonce option for creating OCSP requests. </p>
<p>This function only sets the OCSP options when wolfSSL has been compiled with OCSP support (&ndash;enable-ocsp, #define HAVE_OCSP).</p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS is returned upon success. </dd>
<dd>
SSL_FAILURE is returned upon failure. </dd>
<dd>
NOT_COMPILED_IN is returned when this function has been called, but OCSP support was not enabled when wolfSSL was compiled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">options</td><td>value used to set the OCSP options.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line"><span class="keywordtype">int</span> options; <span class="comment">// initialize to option constant</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> ret = <a class="code hl_function" href="#a3b69fdce096db89cdab845482c90f0f1">wolfSSL_CTX_EnableOCSP</a>(ctx, options);</div>
<div class="line"><span class="keywordflow">if</span>(ret != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// OCSP is not enabled</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a3b69fdce096db89cdab845482c90f0f1"><div class="ttname"><a href="#a3b69fdce096db89cdab845482c90f0f1">wolfSSL_CTX_EnableOCSP</a></div><div class="ttdeci">int wolfSSL_CTX_EnableOCSP(WOLFSSL_CTX *ctx, int options)</div><div class="ttdoc">This function sets options to configure behavior of OCSP functionality in wolfSSL....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga05b1f36d81c5cf5316336a2f54d53e68" title="Turns on OCSP if it’s turned off and if compiled with the set option available.">wolfSSL_CertManagerEnableOCSP</a> </dd>
<dd>
<a class="el" href="#a1c18a7ff26ebcb9453dc2f6616b8950b" title="This function enables OCSP certificate verification. The value of options if formed by or’ing one or ...">wolfSSL_EnableOCSP</a> </dd></dl>

</div>
</div>
<a id="a27c5bf3d28d3cb3e8ef25f97d0c31f7f" name="a27c5bf3d28d3cb3e8ef25f97d0c31f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c5bf3d28d3cb3e8ef25f97d0c31f7f">&#9670;&#160;</a></span>wolfSSL_CTX_EnableOCSPStapling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_EnableOCSPStapling </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables OCSP stapling by calling <a class="el" href="group__CertManager.html#gac17294be4393a23f98c7004217376dae" title="This function turns on OCSP stapling if it is not turned on as well as set the options.">wolfSSL_CertManagerEnableOCSPStapling()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if there were no errors and the function executed successfully. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL_CTX structure is NULL or otherwise if there was a unpermitted argument value passed to a subroutine. </dd>
<dd>
MEMORY_E returned if there was an issue allocating memory. </dd>
<dd>
SSL_FAILURE returned if the initialization of the OCSP structure failed. </dd>
<dd>
NOT_COMPILED_IN returned if wolfSSL was not compiled with HAVE_CERTIFICATE_STATUS_REQUEST option.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = WOLFSSL_new();</div>
<div class="line">ssl-&gt;method.version; <span class="comment">// set to desired protocol</span></div>
<div class="line">...</div>
<div class="line">if(!<a class="code hl_function" href="#a27c5bf3d28d3cb3e8ef25f97d0c31f7f">wolfSSL_CTX_EnableOCSPStapling</a>(ssl-&gt;ctx)){</div>
<div class="line">    <span class="comment">// OCSP stapling is not enabled</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a27c5bf3d28d3cb3e8ef25f97d0c31f7f"><div class="ttname"><a href="#a27c5bf3d28d3cb3e8ef25f97d0c31f7f">wolfSSL_CTX_EnableOCSPStapling</a></div><div class="ttdeci">int wolfSSL_CTX_EnableOCSPStapling(WOLFSSL_CTX *)</div><div class="ttdoc">This function enables OCSP stapling by calling wolfSSL_CertManagerEnableOCSPStapling().</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#gac17294be4393a23f98c7004217376dae" title="This function turns on OCSP stapling if it is not turned on as well as set the options.">wolfSSL_CertManagerEnableOCSPStapling</a> </dd>
<dd>
InitOCSP </dd></dl>

</div>
</div>
<a id="a944cf1dededa231ff8883f70804c4f89" name="a944cf1dededa231ff8883f70804c4f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944cf1dededa231ff8883f70804c4f89">&#9670;&#160;</a></span>wolfSSL_CTX_get_ephemeral_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_get_ephemeral_key </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keyAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns pointer to loaded key as ASN.1/DER. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Key returned successfully </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A WOLFSSL_CTX context pointer </td></tr>
    <tr><td class="paramname">keyAlgo</td><td>enum wc_PkType like WC_PK_TYPE_DH and WC_PK_TYPE_ECDH </td></tr>
    <tr><td class="paramname">key</td><td>key buffer pointer </td></tr>
    <tr><td class="paramname">keySz</td><td>key size pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae33ad1ed1a09d60531882711396a754c" title="This function sets a fixed / static ephemeral key for testing only.">wolfSSL_CTX_set_ephemeral_key</a> </dd></dl>

</div>
</div>
<a id="a579ed69665d9aa441c281b5716198ca4" name="a579ed69665d9aa441c281b5716198ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579ed69665d9aa441c281b5716198ca4">&#9670;&#160;</a></span>wolfSSL_CTX_get_psk_callback_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_CTX_get_psk_callback_ctx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a PSK user context in the WOLFSSL_CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>void pointer to user PSK context</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac8862b6583b25e63d7279929f9f96ffc" title="Sets a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a25324f17616aca4bf3b70fd872a83031" title="Sets a PSK user context in the WOLFSSL structure options member.">wolfSSL_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a22d011e8be92a7e5c025fd0da355c12e" title="Get a PSK user context in the WOLFSSL structure options member.">wolfSSL_get_psk_callback_ctx</a> </dd></dl>

</div>
</div>
<a id="acdb79c98dbbc1c732eeaffeb722c622c" name="acdb79c98dbbc1c732eeaffeb722c622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb79c98dbbc1c732eeaffeb722c622c">&#9670;&#160;</a></span>wolfSSL_CTX_get_TicketEncCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_CTX_get_TicketEncCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the session ticket encrypt user context for the callback. For server side use. </p>
<dl class="section return"><dt>Returns</dt><dd>userCtx will be returned upon successfully getting the session. </dd>
<dd>
NULL will be returned on failure. This is caused by passing invalid arguments to the function, or when the user context has not been set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the WOLFSSL_CTX object, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a123e3d57b518a8af9026f1b5efad9108" title="This function sets the session ticket encrypt user context for the callback. For server side use.">wolfSSL_CTX_set_TicketEncCtx</a> </dd></dl>

</div>
</div>
<a id="a0950b92f3358093047d4e2a7bd744b9e" name="a0950b92f3358093047d4e2a7bd744b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950b92f3358093047d4e2a7bd744b9e">&#9670;&#160;</a></span>wolfSSL_CTX_GetDevId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_GetDevId </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the Device Id. </p>
<dl class="section return"><dt>Returns</dt><dd>devId upon success. </dd>
<dd>
INVALID_DEVID if both ssl and ctx are NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a0950b92f3358093047d4e2a7bd744b9e">wolfSSL_CTX_GetDevId</a>(ctx, ssl);</div>
<div class="ttc" id="assl_8h_html_a0950b92f3358093047d4e2a7bd744b9e"><div class="ttname"><a href="#a0950b92f3358093047d4e2a7bd744b9e">wolfSSL_CTX_GetDevId</a></div><div class="ttdeci">int wolfSSL_CTX_GetDevId(WOLFSSL_CTX *ctx, WOLFSSL *ssl)</div><div class="ttdoc">This function retrieves the Device Id.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a706356ae2ac664740d36b2a53abe5c36" title="This function sets the Device Id at the WOLFSSL session level.">wolfSSL_SetDevId</a> </dd>
<dd>
<a class="el" href="#a4eb1f02e6f8e0d20e7739c81478f0930" title="This function sets the Device Id at the WOLFSSL_CTX context level.">wolfSSL_CTX_SetDevId</a> </dd></dl>

</div>
</div>
<a id="ad478677f213dad5e6c6e60cc636705e1" name="ad478677f213dad5e6c6e60cc636705e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad478677f213dad5e6c6e60cc636705e1">&#9670;&#160;</a></span>wolfSSL_CTX_GetEccSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_CTX_GetEccSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with <a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb" title="Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetEccSignCb</a> </dd>
<dd>
<a class="el" href="#a930c2e720e3ca1f998cf61c4b537ffe1" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_CTX_SetEccSignCtx</a> </dd></dl>

</div>
</div>
<a id="abfbe388005d1f6474e4a21131127369a" name="abfbe388005d1f6474e4a21131127369a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbe388005d1f6474e4a21131127369a">&#9670;&#160;</a></span>wolfSSL_CTX_is_static_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_is_static_memory </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_MEM_STATS *</td>          <td class="paramname"><span class="paramname"><em>mem_stats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does not change any of the connections behavior and is used only for gathering information about the static memory usage. </p>
<dl class="section return"><dt>Returns</dt><dd>1 is returned if using static memory for the CTX is true. </dd>
<dd>
0 is returned if not using static memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">mem_stats</td><td>structure to hold information about static memory usage.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL_MEM_STATS mem_stats;</div>
<div class="line">...</div>
<div class="line"><span class="comment">//get information about static memory with CTX</span></div>
<div class="line">ret = <a class="code hl_function" href="group__Memory.html#gabfbe388005d1f6474e4a21131127369a">wolfSSL_CTX_is_static_memory</a>(ctx, &amp;mem_stats);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 1) {</div>
<div class="line">    <span class="comment">// handle case of is using static memory</span></div>
<div class="line">    <span class="comment">// print out or inspect elements of mem_stats</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    <span class="comment">//handle case of ctx not using static memory</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="ttc" id="agroup__Memory_html_gabfbe388005d1f6474e4a21131127369a"><div class="ttname"><a href="group__Memory.html#gabfbe388005d1f6474e4a21131127369a">wolfSSL_CTX_is_static_memory</a></div><div class="ttdeci">int wolfSSL_CTX_is_static_memory(WOLFSSL_CTX *ctx, WOLFSSL_MEM_STATS *mem_stats)</div><div class="ttdoc">This function does not change any of the connections behavior and is used only for gathering informat...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a75be1b403d25b61275655315f5f2abad" title="This function is used to set aside static memory for a CTX. Memory set aside is then used for the CTX...">wolfSSL_CTX_load_static_memory</a> </dd>
<dd>
<a class="el" href="#a82d11d0414fbd4b8e06f7ecbd2ac0295" title="wolfSSL_is_static_memory is used to gather information about a SSL’s static memory usage....">wolfSSL_is_static_memory</a> </dd></dl>

</div>
</div>
<a id="a75be1b403d25b61275655315f5f2abad" name="a75be1b403d25b61275655315f5f2abad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75be1b403d25b61275655315f5f2abad">&#9670;&#160;</a></span>wolfSSL_CTX_load_static_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_load_static_memory </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX **</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wolfSSL_method_func</td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set aside static memory for a CTX. Memory set aside is then used for the CTX’s lifetime and for any SSL objects created from the CTX. By passing in a NULL ctx pointer and a wolfSSL_method_func function the creation of the CTX itself will also use static memory. wolfSSL_method_func has the function signature of WOLFSSL_METHOD* (<em>wolfSSL_method_func)(void</em> heap);. Passing in 0 for max makes it behave as if not set and no max concurrent use restrictions is in place. The flag value passed in determines how the memory is used and behavior while operating. Available flags are the following: 0 - default general memory, WOLFMEM_IO_POOL - used for input/output buffer when sending receiving messages and overrides general memory, so all memory in buffer passed in is used for IO, WOLFMEM_IO_FIXED - same as WOLFMEM_IO_POOL but each SSL now keeps two buffers to themselves for their lifetime, WOLFMEM_TRACK_STATS - each SSL keeps track of memory stats while running. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
SSL_FAILURE upon failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>address of pointer to a WOLFSSL_CTX structure. </td></tr>
    <tr><td class="paramname">method</td><td>function to create protocol. (should be NULL if ctx is not also NULL) </td></tr>
    <tr><td class="paramname">buf</td><td>memory to use for all operations. </td></tr>
    <tr><td class="paramname">sz</td><td>size of memory buffer being passed in. </td></tr>
    <tr><td class="paramname">flag</td><td>type of memory. </td></tr>
    <tr><td class="paramname">max</td><td>max concurrent operations.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> memory[MAX];</div>
<div class="line"><span class="keywordtype">int</span> memorySz = MAX;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> IO[MAX];</div>
<div class="line"><span class="keywordtype">int</span> IOSz = MAX;</div>
<div class="line"><span class="keywordtype">int</span> flag = WOLFMEM_IO_FIXED | WOLFMEM_TRACK_STATS;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// create ctx also using static memory, start with general memory to use</span></div>
<div class="line">ctx = NULL:</div>
<div class="line">ret = <a class="code hl_function" href="group__Memory.html#ga75be1b403d25b61275655315f5f2abad">wolfSSL_CTX_load_static_memory</a>(&amp;ctx, wolfSSLv23_server_method_ex,</div>
<div class="line">memory, memorySz, 0,    MAX_CONCURRENT_HANDSHAKES);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line"><span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// load in memory for use with IO</span></div>
<div class="line">ret = <a class="code hl_function" href="group__Memory.html#ga75be1b403d25b61275655315f5f2abad">wolfSSL_CTX_load_static_memory</a>(&amp;ctx, NULL, IO, IOSz, flag,</div>
<div class="line">MAX_CONCURRENT_IO);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line"><span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="agroup__Memory_html_ga75be1b403d25b61275655315f5f2abad"><div class="ttname"><a href="group__Memory.html#ga75be1b403d25b61275655315f5f2abad">wolfSSL_CTX_load_static_memory</a></div><div class="ttdeci">int wolfSSL_CTX_load_static_memory(WOLFSSL_CTX **ctx, wolfSSL_method_func method, unsigned char *buf, unsigned int sz, int flag, int max)</div><div class="ttdoc">This function is used to set aside static memory for a CTX. Memory set aside is then used for the CTX...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#abfbe388005d1f6474e4a21131127369a" title="This function does not change any of the connections behavior and is used only for gathering informat...">wolfSSL_CTX_is_static_memory</a> </dd>
<dd>
<a class="el" href="#a82d11d0414fbd4b8e06f7ecbd2ac0295" title="wolfSSL_is_static_memory is used to gather information about a SSL’s static memory usage....">wolfSSL_is_static_memory</a> </dd></dl>

</div>
</div>
<a id="a6cc6cb12cc17c750139e34adc1e16698" name="a6cc6cb12cc17c750139e34adc1e16698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6cb12cc17c750139e34adc1e16698">&#9670;&#160;</a></span>wolfSSL_CTX_LoadCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_LoadCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>monitor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads CRL into the WOLFSSL_CTX structure through <a class="el" href="group__CertManager.html#ga407833060925d7dd8366db3ca557ce8e" title="Error checks and passes through to LoadCRL() in order to load the cert into the CRL for revocation ch...">wolfSSL_CertManagerLoadCRL()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS - returned if the function and its subroutines execute without error. </dd>
<dd>
BAD_FUNC_ARG - returned if this function or any subroutines are passed NULL structures. </dd>
<dd>
BAD_PATH_ERROR - returned if the path variable opens as NULL. </dd>
<dd>
MEMORY_E - returned if an allocation of memory failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">path</td><td>the path to the certificate. </td></tr>
    <tr><td class="paramname">type</td><td>an integer variable holding the type of certificate. </td></tr>
    <tr><td class="paramname">monitor</td><td>an integer variable used to determine if the monitor path is requested.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* path;</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="#a6cc6cb12cc17c750139e34adc1e16698">wolfSSL_CTX_LoadCRL</a>(ctx, path, SSL_FILETYPE_PEM, 0);</div>
<div class="ttc" id="assl_8h_html_a6cc6cb12cc17c750139e34adc1e16698"><div class="ttname"><a href="#a6cc6cb12cc17c750139e34adc1e16698">wolfSSL_CTX_LoadCRL</a></div><div class="ttdeci">int wolfSSL_CTX_LoadCRL(WOLFSSL_CTX *ctx, const char *path, int type, int monitor)</div><div class="ttdoc">This function loads CRL into the WOLFSSL_CTX structure through wolfSSL_CertManagerLoadCRL().</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga407833060925d7dd8366db3ca557ce8e" title="Error checks and passes through to LoadCRL() in order to load the cert into the CRL for revocation ch...">wolfSSL_CertManagerLoadCRL</a> </dd>
<dd>
LoadCRL </dd></dl>

</div>
</div>
<a id="ae33ad1ed1a09d60531882711396a754c" name="ae33ad1ed1a09d60531882711396a754c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33ad1ed1a09d60531882711396a754c">&#9670;&#160;</a></span>wolfSSL_CTX_set_ephemeral_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_set_ephemeral_key </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keyAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a fixed / static ephemeral key for testing only. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Key loaded successfully </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A WOLFSSL_CTX context pointer </td></tr>
    <tr><td class="paramname">keyAlgo</td><td>enum wc_PkType like WC_PK_TYPE_DH and WC_PK_TYPE_ECDH </td></tr>
    <tr><td class="paramname">key</td><td>key file path (if keySz == 0) or actual key buffer (PEM or ASN.1) </td></tr>
    <tr><td class="paramname">keySz</td><td>key size (should be 0 for "key" arg is file path) </td></tr>
    <tr><td class="paramname">format</td><td>WOLFSSL_FILETYPE_ASN1 or WOLFSSL_FILETYPE_PEM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a944cf1dededa231ff8883f70804c4f89" title="This function returns pointer to loaded key as ASN.1/DER.">wolfSSL_CTX_get_ephemeral_key</a> </dd></dl>

</div>
</div>
<a id="ac8862b6583b25e63d7279929f9f96ffc" name="ac8862b6583b25e63d7279929f9f96ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8862b6583b25e63d7279929f9f96ffc">&#9670;&#160;</a></span>wolfSSL_CTX_set_psk_callback_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_set_psk_callback_ctx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>psk_ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a PSK user context in the WOLFSSL_CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS or WOLFSSL_FAILURE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">psk_ctx</td><td>void pointer to user PSK context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a25324f17616aca4bf3b70fd872a83031" title="Sets a PSK user context in the WOLFSSL structure options member.">wolfSSL_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a22d011e8be92a7e5c025fd0da355c12e" title="Get a PSK user context in the WOLFSSL structure options member.">wolfSSL_get_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a579ed69665d9aa441c281b5716198ca4" title="Get a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_get_psk_callback_ctx</a> </dd></dl>

</div>
</div>
<a id="afb48159280dafa4a58a0f9f7da96cb65" name="afb48159280dafa4a58a0f9f7da96cb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb48159280dafa4a58a0f9f7da96cb65">&#9670;&#160;</a></span>wolfSSL_CTX_set_psk_client_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_set_psk_client_callback </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_psk_client_callback</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the client_psk_cb member of the WOLFSSL_CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>wc_psk_client_callback is a function pointer that will be stored in the WOLFSSL_CTX structure. Return value is the key length on success or zero on error. unsigned int (<em>wc_psk_client_callback) PSK client callback parameters: WOLFSSL</em> ssl - Pointer to the wolfSSL structure const char* hint - A stored string that could be displayed to provide a hint to the user. char* identity - The ID will be stored here. unsigned int id_max_len - Size of the ID buffer. unsigned char* key - The key will be stored here. unsigned int key_max_len - The max size of the key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = WOLFSSL_CTX_new( protocol def );</div>
<div class="line">…</div>
<div class="line"><span class="keyword">static</span> WC_INLINE <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_psk_client_cb(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">char</span>* hint,</div>
<div class="line"><span class="keywordtype">char</span>* identity, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_max_len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* key,</div>
<div class="line">Unsigned <span class="keywordtype">int</span> key_max_len){</div>
<div class="line">…</div>
<div class="line"><a class="code hl_function" href="#afb48159280dafa4a58a0f9f7da96cb65">wolfSSL_CTX_set_psk_client_callback</a>(ctx, my_psk_client_cb);</div>
<div class="ttc" id="assl_8h_html_afb48159280dafa4a58a0f9f7da96cb65"><div class="ttname"><a href="#afb48159280dafa4a58a0f9f7da96cb65">wolfSSL_CTX_set_psk_client_callback</a></div><div class="ttdeci">void wolfSSL_CTX_set_psk_client_callback(WOLFSSL_CTX *ctx, wc_psk_client_callback cb)</div><div class="ttdoc">The function sets the client_psk_cb member of the WOLFSSL_CTX structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7eccdf80887061a222c904e0531bf516" title="Sets the PSK client side callback.">wolfSSL_set_psk_client_callback</a> </dd>
<dd>
<a class="el" href="#a2fb471b8b706f1c85fa53c46220c9d5d" title="Sets the psk callback for the server side by setting the WOLFSSL structure options members.">wolfSSL_set_psk_server_callback</a> </dd>
<dd>
<a class="el" href="#aa22b4232a9bc1e4f2d4ea10c71af8521" title="This function sets the psk callback for the server side in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_server_callback</a> </dd>
<dd>
<a class="el" href="#afb48159280dafa4a58a0f9f7da96cb65" title="The function sets the client_psk_cb member of the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_client_callback</a> </dd></dl>

</div>
</div>
<a id="aa22b4232a9bc1e4f2d4ea10c71af8521" name="aa22b4232a9bc1e4f2d4ea10c71af8521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22b4232a9bc1e4f2d4ea10c71af8521">&#9670;&#160;</a></span>wolfSSL_CTX_set_psk_server_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_set_psk_server_callback </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_psk_server_callback</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the psk callback for the server side in the WOLFSSL_CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer for the callback and will be stored in the WOLFSSL_CTX structure. Return value is the key length on success or zero on error. unsigned int (<em>wc_psk_server_callback) PSK server callback parameters WOLFSSL</em> ssl - Pointer to the wolfSSL structure char* identity - The ID will be stored here. unsigned char* key - The key will be stored here. unsigned int key_max_len - The max size of the key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_psk_server_cb(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">char</span>* identity,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_max_len)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Function body.</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(ctx != NULL){</div>
<div class="line">    <a class="code hl_function" href="#aa22b4232a9bc1e4f2d4ea10c71af8521">wolfSSL_CTX_set_psk_server_callback</a>(ctx, my_psk_server_cb);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The CTX object was not properly initialized.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_aa22b4232a9bc1e4f2d4ea10c71af8521"><div class="ttname"><a href="#aa22b4232a9bc1e4f2d4ea10c71af8521">wolfSSL_CTX_set_psk_server_callback</a></div><div class="ttdeci">void wolfSSL_CTX_set_psk_server_callback(WOLFSSL_CTX *ctx, wc_psk_server_callback cb)</div><div class="ttdoc">This function sets the psk callback for the server side in the WOLFSSL_CTX structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_psk_server_callback </dd>
<dd>
<a class="el" href="#a7eccdf80887061a222c904e0531bf516" title="Sets the PSK client side callback.">wolfSSL_set_psk_client_callback</a> </dd>
<dd>
<a class="el" href="#a2fb471b8b706f1c85fa53c46220c9d5d" title="Sets the psk callback for the server side by setting the WOLFSSL structure options members.">wolfSSL_set_psk_server_callback</a> </dd>
<dd>
<a class="el" href="#afb48159280dafa4a58a0f9f7da96cb65" title="The function sets the client_psk_cb member of the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_client_callback</a> </dd></dl>

</div>
</div>
<a id="a13c5dcdd22360eabeb70d5e7bf8e5f21" name="a13c5dcdd22360eabeb70d5e7bf8e5f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5dcdd22360eabeb70d5e7bf8e5f21">&#9670;&#160;</a></span>wolfSSL_CTX_set_TicketEncCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_set_TicketEncCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SessionTicketEncCb</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the session ticket key encrypt callback function for a server to support session tickets as specified in RFC 5077. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon successfully setting the session. </dd>
<dd>
BAD_FUNC_ARG will be returned on failure. This is caused by passing invalid arguments to the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the WOLFSSL_CTX object, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>user callback function to encrypt/decrypt session tickets </td></tr>
    <tr><td class="paramname">ssl(Callback)</td><td>pointer to the WOLFSSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a> </td></tr>
    <tr><td class="paramname">key_name(Callback)</td><td>unique key name for this ticket context, should be randomly generated </td></tr>
    <tr><td class="paramname">iv(Callback)</td><td>unique IV for this ticket, up to 128 bits, should be randomly generated </td></tr>
    <tr><td class="paramname">mac(Callback)</td><td>up to 256 bit mac for this ticket </td></tr>
    <tr><td class="paramname">enc(Callback)</td><td>if this encrypt parameter is true the user should fill in key_name, iv, mac, and encrypt the ticket in-place of length inLen and set the resulting output length in *outLen. Returning WOLFSSL_TICKET_RET_OK tells wolfSSL that the encryption was successful. If this encrypt parameter is false, the user should perform a decrypt of the ticket in-place of length inLen using key_name, iv, and mac. The resulting decrypt length should be set in *outLen. Returning WOLFSSL_TICKET_RET_OK tells wolfSSL to proceed using the decrypted ticket. Returning WOLFSSL_TICKET_RET_CREATE tells wolfSSL to use the decrypted ticket but also to generate a new one to send to the client, helpful if recently rolled keys and don’t want to force a full handshake. Returning WOLFSSL_TICKET_RET_REJECT tells wolfSSL to reject this ticket, perform a full handshake, and create a new standard session ID for normal session resumption. Returning WOLFSSL_TICKET_RET_FATAL tells wolfSSL to end the connection attempt with a fatal error. </td></tr>
    <tr><td class="paramname">ticket(Callback)</td><td>the input/output buffer for the encrypted ticket. See the enc parameter </td></tr>
    <tr><td class="paramname">inLen(Callback)</td><td>the input length of the ticket parameter </td></tr>
    <tr><td class="paramname">outLen(Callback)</td><td>the resulting output length of the ticket parameter. When entering the callback outLen will indicate the maximum size available in the ticket buffer. </td></tr>
    <tr><td class="paramname">userCtx(Callback)</td><td>the user context set with <a class="el" href="#a123e3d57b518a8af9026f1b5efad9108" title="This function sets the session ticket encrypt user context for the callback. For server side use.">wolfSSL_CTX_set_TicketEncCtx()</a></td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">See wolfssl/test.h myTicketEncCb() used by the example</div>
<div class="line">server and example echoserver.</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22507c419dfff2da33c6a14da2d6bc62" title="This function sets the session ticket hint relayed to the client. For server side use.">wolfSSL_CTX_set_TicketHint</a> </dd>
<dd>
<a class="el" href="#a123e3d57b518a8af9026f1b5efad9108" title="This function sets the session ticket encrypt user context for the callback. For server side use.">wolfSSL_CTX_set_TicketEncCtx</a> </dd></dl>

</div>
</div>
<a id="a123e3d57b518a8af9026f1b5efad9108" name="a123e3d57b518a8af9026f1b5efad9108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e3d57b518a8af9026f1b5efad9108">&#9670;&#160;</a></span>wolfSSL_CTX_set_TicketEncCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_set_TicketEncCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the session ticket encrypt user context for the callback. For server side use. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon successfully setting the session. </dd>
<dd>
BAD_FUNC_ARG will be returned on failure. This is caused by passing invalid arguments to the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the WOLFSSL_CTX object, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">userCtx</td><td>the user context for the callback</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a13c5dcdd22360eabeb70d5e7bf8e5f21" title="This function sets the session ticket key encrypt callback function for a server to support session t...">wolfSSL_CTX_set_TicketEncCb</a> </dd></dl>

</div>
</div>
<a id="a22507c419dfff2da33c6a14da2d6bc62" name="a22507c419dfff2da33c6a14da2d6bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22507c419dfff2da33c6a14da2d6bc62">&#9670;&#160;</a></span>wolfSSL_CTX_set_TicketHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_set_TicketHint </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the session ticket hint relayed to the client. For server side use. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon successfully setting the session. </dd>
<dd>
BAD_FUNC_ARG will be returned on failure. This is caused by passing invalid arguments to the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the WOLFSSL_CTX object, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">hint</td><td>number of seconds the ticket might be valid for. Hint to client.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a13c5dcdd22360eabeb70d5e7bf8e5f21" title="This function sets the session ticket key encrypt callback function for a server to support session t...">wolfSSL_CTX_set_TicketEncCb</a> </dd></dl>

</div>
</div>
<a id="ab926a750284cd59ed7cd71b708852404" name="ab926a750284cd59ed7cd71b708852404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab926a750284cd59ed7cd71b708852404">&#9670;&#160;</a></span>wolfSSL_CTX_SetCACb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetCACb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackCACache</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a callback with the SSL context (WOLFSSL_CTX) to be called when a new CA certificate is loaded into wolfSSL. The callback is given a buffer with the DER-encoded certificate. </p>
<dl class="section return"><dt>Returns</dt><dd>none No return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">callback</td><td>function to be registered as the CA callback for the wolfSSL context, ctx. The signature of this function must follow that as shown above in the Synopsis section.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CA callback prototype</span></div>
<div class="line"><span class="keywordtype">int</span> MyCACallback(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *der, <span class="keywordtype">int</span> sz, <span class="keywordtype">int</span> type);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the custom CA callback with the SSL context</span></div>
<div class="line"><a class="code hl_function" href="#ab926a750284cd59ed7cd71b708852404">wolfSSL_CTX_SetCACb</a>(ctx, MyCACallback);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> MyCACallback(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* der, <span class="keywordtype">int</span> sz, <span class="keywordtype">int</span> type)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// custom CA callback function, DER-encoded cert</span></div>
<div class="line">    <span class="comment">// located in “der” of size “sz” with type “type”</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ab926a750284cd59ed7cd71b708852404"><div class="ttname"><a href="#ab926a750284cd59ed7cd71b708852404">wolfSSL_CTX_SetCACb</a></div><div class="ttdeci">void wolfSSL_CTX_SetCACb(WOLFSSL_CTX *ctx, CallbackCACache cb)</div><div class="ttdoc">This function registers a callback with the SSL context (WOLFSSL_CTX) to be called when a new CA cert...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertsKeys.html#gaf592c652b5d7a599ee511a394dfc488e" title="This function loads PEM-formatted CA certificate files into the SSL context (WOLFSSL_CTX)....">wolfSSL_CTX_load_verify_locations</a> </dd></dl>

</div>
</div>
<a id="a247c19e56d7fec73c15bef2189c68804" name="a247c19e56d7fec73c15bef2189c68804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247c19e56d7fec73c15bef2189c68804">&#9670;&#160;</a></span>wolfSSL_CTX_SetCRL_Cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_SetCRL_Cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbMissingCRL</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the callback argument to the cbMissingCRL member of the WOLFSSL_CERT_MANAGER structure by calling wolfSSL_CertManagerSetCRL_Cb. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned for a successful execution. The WOLFSSL_CERT_MANAGER structure’s member cbMssingCRL was successfully set to cb. </dd>
<dd>
BAD_FUNC_ARG returned if WOLFSSL_CTX or WOLFSSL_CERT_MANAGER are NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a pointer to a callback function of type CbMissingCRL. Signature requirement: void (<em>CbMissingCRL)(const char</em> url);</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">void</span> cb(<span class="keyword">const</span> <span class="keywordtype">char</span>* url) <span class="comment">// Required signature</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Function body</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#a247c19e56d7fec73c15bef2189c68804">wolfSSL_CTX_SetCRL_Cb</a>(ctx, cb) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case, cb was not set correctly.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a247c19e56d7fec73c15bef2189c68804"><div class="ttname"><a href="#a247c19e56d7fec73c15bef2189c68804">wolfSSL_CTX_SetCRL_Cb</a></div><div class="ttdeci">int wolfSSL_CTX_SetCRL_Cb(WOLFSSL_CTX *ctx, CbMissingCRL cb)</div><div class="ttdoc">This function will set the callback argument to the cbMissingCRL member of the WOLFSSL_CERT_MANAGER s...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga4929fe270fdc7cf0bdfca82d2c8a88ef" title="This function sets the CRL Certificate Manager callback. If HAVE_CRL is defined and a matching CRL re...">wolfSSL_CertManagerSetCRL_Cb</a> </dd>
<dd>
CbMissingCRL </dd></dl>

</div>
</div>
<a id="a5f636c2e3517c2bb054d5bb50924b352" name="a5f636c2e3517c2bb054d5bb50924b352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f636c2e3517c2bb054d5bb50924b352">&#9670;&#160;</a></span>wolfSSL_CTX_SetDecryptVerifyCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetDecryptVerifyCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackDecryptVerify</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. decOut is the output buffer where the result of the decryption should be stored. decIn is the encrypted input buffer and decInSz notes the size of the buffer. content and verify are needed for <a class="el" href="#acdba6b6ac9c948dd82c3d3a8ed256595" title="Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to in...">wolfSSL_SetTlsHmacInner()</a> and be passed along as is. padSz is an output variable that should be set with the total value of the padding. That is, the mac size plus any padding and pad bytes. An example callback can be found wolfssl/test.h myDecryptVerifyCb(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.">wolfSSL_SetMacEncryptCtx</a> </dd>
<dd>
<a class="el" href="#a84e59d1c4a3f24ff5ece668e922d7548" title="Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously s...">wolfSSL_GetMacEncryptCtx</a> </dd></dl>

</div>
</div>
<a id="a4eb1f02e6f8e0d20e7739c81478f0930" name="a4eb1f02e6f8e0d20e7739c81478f0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb1f02e6f8e0d20e7739c81478f0930">&#9670;&#160;</a></span>wolfSSL_CTX_SetDevId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_SetDevId </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>devId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Device Id at the WOLFSSL_CTX context level. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG if ssl is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">devId</td><td>ID to use with crypto callbacks or async hardware. Set to INVALID_DEVID (-2) if not used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line"><span class="keywordtype">int</span> DevId = -2;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a4eb1f02e6f8e0d20e7739c81478f0930">wolfSSL_CTX_SetDevId</a>(ctx, devId);</div>
<div class="ttc" id="assl_8h_html_a4eb1f02e6f8e0d20e7739c81478f0930"><div class="ttname"><a href="#a4eb1f02e6f8e0d20e7739c81478f0930">wolfSSL_CTX_SetDevId</a></div><div class="ttdeci">int wolfSSL_CTX_SetDevId(WOLFSSL_CTX *ctx, int devId)</div><div class="ttdoc">This function sets the Device Id at the WOLFSSL_CTX context level.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a706356ae2ac664740d36b2a53abe5c36" title="This function sets the Device Id at the WOLFSSL session level.">wolfSSL_SetDevId</a> </dd>
<dd>
<a class="el" href="#a0950b92f3358093047d4e2a7bd744b9e" title="This function retrieves the Device Id.">wolfSSL_CTX_GetDevId</a> </dd></dl>

</div>
</div>
<a id="aee3ccfce4e8b5aa1a2ccfbb447365dfb" name="aee3ccfce4e8b5aa1a2ccfbb447365dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb">&#9670;&#160;</a></span>wolfSSL_CTX_SetEccSignCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetEccSignCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackEccSign</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to sign while inSz denotes the length of the input. out is the output buffer where the result of the signature should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. keyDer is the ECC Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myEccSign(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx</a> </dd>
<dd>
<a class="el" href="#ac731df86e30f87e7823a7da59b461adb" title="Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with wolfSSL_...">wolfSSL_GetEccSignCtx</a> </dd></dl>

</div>
</div>
<a id="a930c2e720e3ca1f998cf61c4b537ffe1" name="a930c2e720e3ca1f998cf61c4b537ffe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930c2e720e3ca1f998cf61c4b537ffe1">&#9670;&#160;</a></span>wolfSSL_CTX_SetEccSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetEccSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>userCtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Ecc Signing Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">ctx</td><td>a pointer to the user context to be stored</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb" title="Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetEccSignCb</a> </dd>
<dd>
<a class="el" href="#ad478677f213dad5e6c6e60cc636705e1" title="Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with wolfSSL_...">wolfSSL_CTX_GetEccSignCtx</a> </dd></dl>

</div>
</div>
<a id="ab58ec34fc70378f3be1a8035637091eb" name="ab58ec34fc70378f3be1a8035637091eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58ec34fc70378f3be1a8035637091eb">&#9670;&#160;</a></span>wolfSSL_CTX_SetEccVerifyCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetEccVerifyCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackEccVerify</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for ECC Verification. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. sig is the signature to verify and sigSz denotes the length of the signature. hash is an input buffer containing the digest of the message and hashSz denotes the length in bytes of the hash. result is an output variable where the result of the verification should be stored, 1 for success and 0 for failure. keyDer is the ECC Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myEccVerify(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c89bf6fc378bfbf8c0559b4e6c820e1" title="Allows caller to set the Public Key Ecc Verification Callback Context to ctx.">wolfSSL_SetEccVerifyCtx</a> </dd>
<dd>
<a class="el" href="#ace78694804dc9bc862904b78ef73d40d" title="Allows caller to retrieve the Public Key Ecc Verification Callback Context previously stored with wol...">wolfSSL_GetEccVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="ac48d6f657d683557e23f9ce388488039" name="ac48d6f657d683557e23f9ce388488039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48d6f657d683557e23f9ce388488039">&#9670;&#160;</a></span>wolfSSL_CTX_SetMacEncryptCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetMacEncryptCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackMacEncrypti</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. macOut is the output buffer where the result of the mac should be stored. macIn is the mac input buffer and macInSz notes the size of the buffer. macContent and macVerify are needed for <a class="el" href="#acdba6b6ac9c948dd82c3d3a8ed256595" title="Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to in...">wolfSSL_SetTlsHmacInner()</a> and be passed along as is. encOut is the output buffer where the result on the encryption should be stored. encIn is the input buffer to encrypt while encSz is the size of the input. An example callback can be found wolfssl/test.h myMacEncryptCb(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">No</td><td>parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.">wolfSSL_SetMacEncryptCtx</a> </dd>
<dd>
<a class="el" href="#a84e59d1c4a3f24ff5ece668e922d7548" title="Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously s...">wolfSSL_GetMacEncryptCtx</a> </dd></dl>

</div>
</div>
<a id="a083fff700d5ba1e04c0690083712640e" name="a083fff700d5ba1e04c0690083712640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083fff700d5ba1e04c0690083712640e">&#9670;&#160;</a></span>wolfSSL_CTX_SetOCSP_Cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_SetOCSP_Cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbOCSPIO</td>          <td class="paramname"><span class="paramname"><em>ioCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbOCSPRespFree</td>          <td class="paramname"><span class="paramname"><em>respFreeCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ioCbCtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the callback for the OCSP in the WOLFSSL_CTX structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed successfully. The ocspIOCb, ocspRespFreeCb, and ocspIOCtx members in the CM were successfully set. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL_CTX or WOLFSSL_CERT_MANAGER structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">ioCb</td><td>a CbOCSPIO type that is a function pointer. </td></tr>
    <tr><td class="paramname">respFreeCb</td><td>a CbOCSPRespFree type that is a function pointer. </td></tr>
    <tr><td class="paramname">ioCbCtx</td><td>a void pointer that will be held in the WOLFSSL_CERT_MANAGER.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">…</div>
<div class="line">CbOCSPIO ocspIOCb;</div>
<div class="line">CbOCSPRespFree ocspRespFreeCb;</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">void</span>* ioCbCtx;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> isSetOCSP = <a class="code hl_function" href="#a083fff700d5ba1e04c0690083712640e">wolfSSL_CTX_SetOCSP_Cb</a>(ctx, ocspIOCb,</div>
<div class="line">ocspRespFreeCb, ioCbCtx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(isSetOCSP != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// The function did not return successfully.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a083fff700d5ba1e04c0690083712640e"><div class="ttname"><a href="#a083fff700d5ba1e04c0690083712640e">wolfSSL_CTX_SetOCSP_Cb</a></div><div class="ttdeci">int wolfSSL_CTX_SetOCSP_Cb(WOLFSSL_CTX *ctx, CbOCSPIO ioCb, CbOCSPRespFree respFreeCb, void *ioCbCtx)</div><div class="ttdoc">Sets the callback for the OCSP in the WOLFSSL_CTX structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga40598eacaa03af2e003e95f57ddd30a9" title="The function sets the OCSP callback in the WOLFSSL_CERT_MANAGER.">wolfSSL_CertManagerSetOCSP_Cb</a> </dd>
<dd>
CbOCSPIO </dd>
<dd>
CbOCSPRespFree </dd></dl>

</div>
</div>
<a id="ade9a3efc38ede0e8c8f5c0caeb8e20ad" name="ade9a3efc38ede0e8c8f5c0caeb8e20ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad">&#9670;&#160;</a></span>wolfSSL_CTX_SetOCSP_OverrideURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_SetOCSP_OverrideURL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>url</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the individual certificate unless the WOLFSSL_OCSP_URL_OVERRIDE option is set using the wolfSSL_CTX_EnableOCSP. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS is returned upon success. </dd>
<dd>
SSL_FAILURE is returned upon failure. </dd>
<dd>
NOT_COMPILED_IN is returned when this function has been called, but OCSP support was not enabled when wolfSSL was compiled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">url</td><td>pointer to the OCSP URL for wolfSSL to use.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">...</div>
<div class="line">wolfSSL_CTX_OCSP_set_override_url(ctx, “custom-url-here”);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_CTX_OCSP_set_options </dd></dl>

</div>
</div>
<a id="af2d8a09019d57278c2f2079df3a9112d" name="af2d8a09019d57278c2f2079df3a9112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d8a09019d57278c2f2079df3a9112d">&#9670;&#160;</a></span>wolfSSL_CTX_SetRsaDecCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetRsaDecCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackRsaDec</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for RSA Private Decrypt. The callback should return the number of plaintext bytes for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to decrypt and inSz denotes the length of the input. out should be set to the beginning of the decryption buffer after the decryption process and any padding. keyDer is the RSA Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaDec(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5e7d5db6deee59da336e3d399a62fb8f" title="Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx.">wolfSSL_SetRsaDecCtx</a> </dd>
<dd>
<a class="el" href="#a6610b35607255d7cdaf911e681f8559a" title="Allows caller to retrieve the Public Key RSA Private Decrypt Callback Context previously stored with ...">wolfSSL_GetRsaDecCtx</a> </dd></dl>

</div>
</div>
<a id="a8669fb775ff5541e6e4713ebb5e56f42" name="a8669fb775ff5541e6e4713ebb5e56f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8669fb775ff5541e6e4713ebb5e56f42">&#9670;&#160;</a></span>wolfSSL_CTX_SetRsaEncCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetRsaEncCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackRsaEnc</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for RSA Public Encrypt. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to encrypt while inSz denotes the length of the input. out is the output buffer where the result of the encryption should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the encryption should be stored there before returning. keyDer is the RSA Public key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaEnc(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Examples</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1ffa93301f06d864f5e41f99104a4a2e" title="Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx.">wolfSSL_SetRsaEncCtx</a> </dd>
<dd>
<a class="el" href="#abce00333fd98f987d37b2ea6bc391c33" title="Allows caller to retrieve the Public Key RSA Public Encrypt Callback Context previously stored with w...">wolfSSL_GetRsaEncCtx</a> </dd></dl>

</div>
</div>
<a id="a456c256848365be4a742b99b5a5cb84b" name="a456c256848365be4a742b99b5a5cb84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456c256848365be4a742b99b5a5cb84b">&#9670;&#160;</a></span>wolfSSL_CTX_SetRsaSignCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetRsaSignCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackRsaSign</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for RSA Signing. The callback should return 0 for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. in is the input buffer to sign while inSz denotes the length of the input. out is the output buffer where the result of the signature should be stored. outSz is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. keyDer is the RSA Private key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaSign(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aff1829c6e4c7ed720774ed3a92881f1c" title="Allows caller to set the Public Key RSA Signing Callback Context to ctx.">wolfSSL_SetRsaSignCtx</a> </dd>
<dd>
<a class="el" href="#a02c1b4c6be145f901e7abb2c3910b93c" title="Allows caller to retrieve the Public Key RSA Signing Callback Context previously stored with wolfSSL_...">wolfSSL_GetRsaSignCtx</a> </dd></dl>

</div>
</div>
<a id="a50a079dcac754ad333f983b943a9f587" name="a50a079dcac754ad333f983b943a9f587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a079dcac754ad333f983b943a9f587">&#9670;&#160;</a></span>wolfSSL_CTX_SetRsaVerifyCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SetRsaVerifyCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackRsaVerify</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Callback for RSA Verification. The callback should return the number of plaintext bytes for success or &lt; 0 for an error. The ssl and ctx pointers are available for the user’s convenience. sig is the signature to verify and sigSz denotes the length of the signature. out should be set to the beginning of the verification buffer after the decryption process and any padding. keyDer is the RSA Public key in ASN1 format and keySz is the length of the key in bytes. An example callback can be found wolfssl/test.h myRsaVerify(). </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae85c95865fb414c3f38d76cd2ac23606" title="Allows caller to set the Public Key RSA Verification Callback Context to ctx.">wolfSSL_SetRsaVerifyCtx</a> </dd>
<dd>
<a class="el" href="#a0b3febe7a64aeb29f35674bcb32a3e8d" title="Allows caller to retrieve the Public Key RSA Verification Callback Context previously stored with wol...">wolfSSL_GetRsaVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="af82999bc9cefc1b7c9b8922145348d83" name="af82999bc9cefc1b7c9b8922145348d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82999bc9cefc1b7c9b8922145348d83">&#9670;&#160;</a></span>wolfSSL_CTX_SNI_SetOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_CTX_SNI_SetOptions </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side to configure the behavior of the SSL sessions using Server Name Indication for SSL objects created from the SSL context passed in the 'ctx' parameter. The options are explained below. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to a SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been passed in data. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">options</td><td>a bitwise semaphore with the chosen options. The available options are: enum { WOLFSSL_SNI_CONTINUE_ON_MISMATCH = 0x01, WOLFSSL_SNI_ANSWER_ON_MISMATCH = 0x02 }; Normally the server will abort the handshake by sending a fatal-level unrecognized_name(112) alert if the hostname provided by the client mismatch with the servers. </td></tr>
    <tr><td class="paramname">WOLFSSL_SNI_CONTINUE_ON_MISMATCH</td><td>With this option set, the server will not send a SNI response instead of aborting the session. </td></tr>
    <tr><td class="paramname">WOLFSSL_SNI_ANSWER_ON_MISMATCH</td><td>With this option set, the server will send a SNI response as if the host names match instead of aborting the session.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">   <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a7e2d400ffb4172eb91e284951a4ae091">wolfSSL_CTX_UseSNI</a>(ctx, 0, <span class="stringliteral">&quot;www.yassl.com&quot;</span>, strlen(<span class="stringliteral">&quot;www.yassl.com&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni usage failed</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="#af82999bc9cefc1b7c9b8922145348d83">wolfSSL_CTX_SNI_SetOptions</a>(ctx, WOLFSSL_SNI_HOST_NAME,</div>
<div class="line">WOLFSSL_SNI_CONTINUE_ON_MISMATCH);</div>
<div class="ttc" id="assl_8h_html_a7e2d400ffb4172eb91e284951a4ae091"><div class="ttname"><a href="#a7e2d400ffb4172eb91e284951a4ae091">wolfSSL_CTX_UseSNI</a></div><div class="ttdeci">int wolfSSL_CTX_UseSNI(WOLFSSL_CTX *ctx, unsigned char type, const void *data, unsigned short size)</div><div class="ttdoc">This function enables the use of Server Name Indication for SSL objects created from the SSL context ...</div></div>
<div class="ttc" id="assl_8h_html_af82999bc9cefc1b7c9b8922145348d83"><div class="ttname"><a href="#af82999bc9cefc1b7c9b8922145348d83">wolfSSL_CTX_SNI_SetOptions</a></div><div class="ttdeci">void wolfSSL_CTX_SNI_SetOptions(WOLFSSL_CTX *ctx, unsigned char type, unsigned char options)</div><div class="ttdoc">This function is called on the server side to configure the behavior of the SSL sessions using Server...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a7e2d400ffb4172eb91e284951a4ae091" title="This function enables the use of Server Name Indication for SSL objects created from the SSL context ...">wolfSSL_CTX_UseSNI</a> </dd>
<dd>
<a class="el" href="#aed8ec1ab75309570c4464449f8ce747a" title="This function is called on the server side to configure the behavior of the SSL session using Server ...">wolfSSL_SNI_SetOptions</a> </dd></dl>

</div>
</div>
<a id="afcca49dd1e71d97ec4702430a682bbcb" name="afcca49dd1e71d97ec4702430a682bbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcca49dd1e71d97ec4702430a682bbcb">&#9670;&#160;</a></span>wolfSSL_CTX_UseMaxFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseMaxFragment </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>mfl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Maximum Fragment Length for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ctx is NULL, mfl is out of range. </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to a SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">mfl</td><td>indicates which is the Maximum Fragment Length requested for the session. The available options are: enum { WOLFSSL_MFL_2_9 = 1 512 bytes, WOLFSSL_MFL_2_10 = 2 1024 bytes, WOLFSSL_MFL_2_11 = 3 2048 bytes WOLFSSL_MFL_2_12 = 4 4096 bytes, WOLFSSL_MFL_2_13 = 5 8192 bytes wolfSSL ONLY!!!, WOLFSSL_MFL_2_13 = 6 256 bytes wolfSSL ONLY!!! };</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#afcca49dd1e71d97ec4702430a682bbcb">wolfSSL_CTX_UseMaxFragment</a>(ctx, WOLFSSL_MFL_2_11);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// max fragment usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_afcca49dd1e71d97ec4702430a682bbcb"><div class="ttname"><a href="#afcca49dd1e71d97ec4702430a682bbcb">wolfSSL_CTX_UseMaxFragment</a></div><div class="ttdeci">int wolfSSL_CTX_UseMaxFragment(WOLFSSL_CTX *ctx, unsigned char mfl)</div><div class="ttdoc">This function is called on the client side to enable the use of Maximum Fragment Length for SSL objec...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#ae3a413f6cab23dd667c7cbb06ae252cb" title="This function is called on the client side to enable the use of Maximum Fragment Length in the SSL ob...">wolfSSL_UseMaxFragment</a> </dd></dl>

</div>
</div>
<a id="a5a9469c796b581328a7de8c16d9cfcec" name="a5a9469c796b581328a7de8c16d9cfcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9469c796b581328a7de8c16d9cfcec">&#9670;&#160;</a></span>wolfSSL_CTX_UseOCSPStapling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseOCSPStapling </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>status_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requests the certificate status during the handshake. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function and subroutines execute without error. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL_CTX structure is NULL or otherwise if a unpermitted value is passed to a subroutine. </dd>
<dd>
MEMORY_E returned if the function or subroutine failed to properly allocate memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">status_type</td><td>a byte type that is passed through to TLSX_UseCertificateStatusRequest() and stored in the CertificateStatusRequest structure. </td></tr>
    <tr><td class="paramname">options</td><td>a byte type that is passed through to TLSX_UseCertificateStatusRequest() and stored in the CertificateStatusRequest structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">byte</span> statusRequest = 0; <span class="comment">// Initialize status request</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">switch</span>(statusRequest){</div>
<div class="line">    <span class="keywordflow">case</span> WOLFSSL_CSR_OCSP:</div>
<div class="line">        <span class="keywordflow">if</span>(<a class="code hl_function" href="#a5a9469c796b581328a7de8c16d9cfcec">wolfSSL_CTX_UseOCSPStapling</a>(ssl-&gt;ctx, WOLFSSL_CSR_OCSP,</div>
<div class="line">WOLF_CSR_OCSP_USE_NONCE) != SSL_SUCCESS){</div>
<div class="line"><span class="comment">// UseCertificateStatusRequest failed</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Continue switch cases</span></div>
<div class="ttc" id="assl_8h_html_a5a9469c796b581328a7de8c16d9cfcec"><div class="ttname"><a href="#a5a9469c796b581328a7de8c16d9cfcec">wolfSSL_CTX_UseOCSPStapling</a></div><div class="ttdeci">int wolfSSL_CTX_UseOCSPStapling(WOLFSSL_CTX *ctx, unsigned char status_type, unsigned char options)</div><div class="ttdoc">This function requests the certificate status during the handshake.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a37cbc7ec1e1fd4445c7bd59c09bae5ad" title="The function sets the status type and options for OCSP.">wolfSSL_UseOCSPStaplingV2</a> </dd>
<dd>
<a class="el" href="#acbdb1a796d11f083f1782c001cdc6016" title="Stapling eliminates the need to contact the CA. Stapling lowers the cost of certificate revocation ch...">wolfSSL_UseOCSPStapling</a> </dd>
<dd>
TLSX_UseCertificateStatusRequest </dd></dl>

</div>
</div>
<a id="a2e4f97b0d4d57dcf3a5b07166053234a" name="a2e4f97b0d4d57dcf3a5b07166053234a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4f97b0d4d57dcf3a5b07166053234a">&#9670;&#160;</a></span>wolfSSL_CTX_UseOCSPStaplingV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseOCSPStaplingV2 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>status_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes the certificate status request for OCSP Stapling. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS if the function and subroutines executed without error. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL_CTX structure is NULL or if the side variable is not client side. </dd>
<dd>
MEMORY_E returned if the allocation of memory failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">status_type</td><td>a byte type that is located in the CertificatStatusRequest structure and must be either WOLFSSL_CSR2_OCSP or WOLFSSL_CSR2_OCSP_MULTI. </td></tr>
    <tr><td class="paramname">options</td><td>a byte type that will be held in CertificateStatusRequestItemV2 struct.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx  = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line"><span class="keywordtype">byte</span> status_type;</div>
<div class="line"><span class="keywordtype">byte</span> options;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#a2e4f97b0d4d57dcf3a5b07166053234a">wolfSSL_CTX_UseOCSPStaplingV2</a>(ctx, status_type, options); != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a2e4f97b0d4d57dcf3a5b07166053234a"><div class="ttname"><a href="#a2e4f97b0d4d57dcf3a5b07166053234a">wolfSSL_CTX_UseOCSPStaplingV2</a></div><div class="ttdeci">int wolfSSL_CTX_UseOCSPStaplingV2(WOLFSSL_CTX *ctx, unsigned char status_type, unsigned char options)</div><div class="ttdoc">Creates and initializes the certificate status request for OCSP Stapling.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_UseCertificateStatusRequestV2 </dd>
<dd>
<a class="el" href="group__Random.html#ga9a289fb3f58f4a5f7e15c2b5a1b0d7c6" title="Copies a sz bytes of pseudorandom data to output. Will reseed rng if needed (blocking).">wc_RNG_GenerateBlock</a> </dd>
<dd>
TLSX_Push </dd></dl>

</div>
</div>
<a id="a7e2d400ffb4172eb91e284951a4ae091" name="a7e2d400ffb4172eb91e284951a4ae091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2d400ffb4172eb91e284951a4ae091">&#9670;&#160;</a></span>wolfSSL_CTX_UseSNI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseSNI </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the use of Server Name Indication for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL clients and wolfSSL servers will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ctx is NULL, data is NULL, type is a unknown value. (see below) </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to a SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been passed in data. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the server name data. </td></tr>
    <tr><td class="paramname">size</td><td>size of the server name data.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a7e2d400ffb4172eb91e284951a4ae091">wolfSSL_CTX_UseSNI</a>(ctx, WOLFSSL_SNI_HOST_NAME, <span class="stringliteral">&quot;www.yassl.com&quot;</span>,</div>
<div class="line">    strlen(<span class="stringliteral">&quot;www.yassl.com&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni usage failed</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a871070b101b579dc4663217b1c3fbcd4" title="This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; paramet...">wolfSSL_UseSNI</a> </dd></dl>

</div>
</div>
<a id="a49ebc57d8029df946efdf15dffaace1f" name="a49ebc57d8029df946efdf15dffaace1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ebc57d8029df946efdf15dffaace1f">&#9670;&#160;</a></span>wolfSSL_CTX_UseSupportedCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseSupportedCurve </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Supported Elliptic Curves Extension for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ctx is NULL, name is a unknown value. (see below) </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to a SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>indicates which curve will be supported for the session. The available options are: enum { WOLFSSL_ECC_SECP160R1 = 0x10, WOLFSSL_ECC_SECP192R1 = 0x13, WOLFSSL_ECC_SECP224R1 = 0x15, WOLFSSL_ECC_SECP256R1 = 0x17, WOLFSSL_ECC_SECP384R1 = 0x18, WOLFSSL_ECC_SECP521R1 = 0x19 };</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a49ebc57d8029df946efdf15dffaace1f">wolfSSL_CTX_UseSupportedCurve</a>(ctx, WOLFSSL_ECC_SECP256R1);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// Elliptic Curve Extension usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a49ebc57d8029df946efdf15dffaace1f"><div class="ttname"><a href="#a49ebc57d8029df946efdf15dffaace1f">wolfSSL_CTX_UseSupportedCurve</a></div><div class="ttdeci">int wolfSSL_CTX_UseSupportedCurve(WOLFSSL_CTX *ctx, word16 name)</div><div class="ttdoc">This function is called on the client side to enable the use of Supported Elliptic Curves Extension f...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a99a3ea2538789b78859e8ae750b802e0" title="This function is called on the client side to enable the use of Supported Elliptic Curves Extension i...">wolfSSL_UseSupportedCurve</a> </dd></dl>

</div>
</div>
<a id="af398a71eabe6a27f783d8abbad83bd38" name="af398a71eabe6a27f783d8abbad83bd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af398a71eabe6a27f783d8abbad83bd38">&#9670;&#160;</a></span>wolfSSL_CTX_UseTruncatedHMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_CTX_UseTruncatedHMAC </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Truncated HMAC for SSL objects created from the SSL context passed in the 'ctx' parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ctx is NULL </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to a SSL context, created with <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#af398a71eabe6a27f783d8abbad83bd38">wolfSSL_CTX_UseTruncatedHMAC</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// truncated HMAC usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_af398a71eabe6a27f783d8abbad83bd38"><div class="ttname"><a href="#af398a71eabe6a27f783d8abbad83bd38">wolfSSL_CTX_UseTruncatedHMAC</a></div><div class="ttdeci">int wolfSSL_CTX_UseTruncatedHMAC(WOLFSSL_CTX *ctx)</div><div class="ttdoc">This function is called on the client side to enable the use of Truncated HMAC for SSL objects create...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#ae3a413f6cab23dd667c7cbb06ae252cb" title="This function is called on the client side to enable the use of Maximum Fragment Length in the SSL ob...">wolfSSL_UseMaxFragment</a> </dd></dl>

</div>
</div>
<a id="ac61342d421acd184492aa8a674270805" name="ac61342d421acd184492aa8a674270805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61342d421acd184492aa8a674270805">&#9670;&#160;</a></span>wolfSSL_DisableCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_DisableCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables CRL certificate revocation. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS wolfSSL_CertMangerDisableCRL successfully disabled the crlEnabled member of the WOLFSSL_CERT_MANAGER structure. </dd>
<dd>
BAD_FUNC_ARG the WOLFSSL structure was NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ac61342d421acd184492aa8a674270805">wolfSSL_DisableCRL</a>(ssl) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ac61342d421acd184492aa8a674270805"><div class="ttname"><a href="#ac61342d421acd184492aa8a674270805">wolfSSL_DisableCRL</a></div><div class="ttdeci">int wolfSSL_DisableCRL(WOLFSSL *ssl)</div><div class="ttdoc">Disables CRL certificate revocation.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga9e8cc5c00936adde105e64dbf1e8d403" title="Turns off Certificate Revocation List checking when verifying certificates with the Certificate Manag...">wolfSSL_CertManagerDisableCRL</a> </dd>
<dd>
<a class="el" href="group__CertManager.html#ga31367a0d315f0342113ce827128727f9" title="Disables OCSP certificate revocation.">wolfSSL_CertManagerDisableOCSP</a> </dd></dl>

</div>
</div>
<a id="abb7c9ec80311c16f4223f53e5ec8449e" name="abb7c9ec80311c16f4223f53e5ec8449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7c9ec80311c16f4223f53e5ec8449e">&#9670;&#160;</a></span>wolfSSL_DisableOCSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_DisableOCSP </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the OCSP certificate revocation option. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function and its subroutine return with no errors. The ocspEnabled member of the WOLFSSL_CERT_MANAGER structure was successfully set. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#abb7c9ec80311c16f4223f53e5ec8449e">wolfSSL_DisableOCSP</a>(ssl) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Returned with an error. Failure case in this block.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_abb7c9ec80311c16f4223f53e5ec8449e"><div class="ttname"><a href="#abb7c9ec80311c16f4223f53e5ec8449e">wolfSSL_DisableOCSP</a></div><div class="ttdeci">int wolfSSL_DisableOCSP(WOLFSSL *)</div><div class="ttdoc">Disables the OCSP certificate revocation option.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga31367a0d315f0342113ce827128727f9" title="Disables OCSP certificate revocation.">wolfSSL_CertManagerDisableOCSP</a> </dd></dl>

</div>
</div>
<a id="a298a34e67ad57069d88f6e626df139a1" name="a298a34e67ad57069d88f6e626df139a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298a34e67ad57069d88f6e626df139a1">&#9670;&#160;</a></span>wolfSSL_dtls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to determine if the SSL session has been configured to use DTLS. </p>
<dl class="section return"><dt>Returns</dt><dd>1 If the SSL session (ssl) has been configured to use DTLS, this function will return 1. </dd>
<dd>
0 otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a298a34e67ad57069d88f6e626df139a1">wolfSSL_dtls</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret) {</div>
<div class="line">    <span class="comment">// SSL session has been configured to use DTLS</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a298a34e67ad57069d88f6e626df139a1"><div class="ttname"><a href="#a298a34e67ad57069d88f6e626df139a1">wolfSSL_dtls</a></div><div class="ttdeci">int wolfSSL_dtls(WOLFSSL *ssl)</div><div class="ttdoc">This function is used to determine if the SSL session has been configured to use DTLS.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd></dl>

</div>
</div>
<a id="a5a5938dd9d0e7dc3deb364a1b017e573" name="a5a5938dd9d0e7dc3deb364a1b017e573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5938dd9d0e7dc3deb364a1b017e573">&#9670;&#160;</a></span>wolfSSL_dtls13_has_pending_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls13_has_pending_msg </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if DTLSv1.3 stack has some messages sent but not yet acknowledged by the other peer </p>
<dl class="section return"><dt>Returns</dt><dd>1 if there are pending messages, 0 otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61f3b53cb0397dd1debc8b8daaa490c2" name="a61f3b53cb0397dd1debc8b8daaa490c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f3b53cb0397dd1debc8b8daaa490c2">&#9670;&#160;</a></span>wolfSSL_dtls13_use_quick_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls13_use_quick_timeout </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns true if the application should setup a quicker timeout. When using non-blocking sockets, something in the user code needs to decide when to check for available data and how long it needs to wait. If this function returns true, it means that the library already detected some disruption in the communication, but it wants to wait for a little longer in case some messages from the other peers are still in flight. Is up to the application to fine tune the value of this timer, a good one may be dtls_get_current_timeout() / 4. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the application code should setup a quicker timeout</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd>
<dd>
<a class="el" href="group__Setup.html#gab631873fe556faaa4aa7cddda1534391" title="This function sets whether the library should send ACKs to the other peer immediately when detecting ...">wolfSSL_dtls13_set_send_more_acks</a> </dd></dl>

</div>
</div>
<a id="acb4dcd90229f9f5e44b0b80340bb5e65" name="acb4dcd90229f9f5e44b0b80340bb5e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4dcd90229f9f5e44b0b80340bb5e65">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get0_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get0_rx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **</td>          <td class="paramname"><span class="paramname"><em>cid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ConnectionID used by the other peer. See RFC 9146 and RFC 9147. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly set in cid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">cid</td><td>Pointer that will be set to the internal memory that holds the CID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="a40f8d108b7490ffeccdfc0dac952b9b0" name="a40f8d108b7490ffeccdfc0dac952b9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f8d108b7490ffeccdfc0dac952b9b0">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get0_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get0_tx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **</td>          <td class="paramname"><span class="paramname"><em>cid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ConnectionID used when sending records in this connection. See RFC 9146 and RFC 9147. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly retrieved, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">cid</td><td>Pointer that will be set to the internal memory that holds the CID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd>
<dd>
<a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd></dl>

</div>
</div>
<a id="a9c7c6e4efea4ecf0bb9b9a1fb1365408" name="a9c7c6e4efea4ecf0bb9b9a1fb1365408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get_rx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>bufferSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the ConnectionID used by the other peer to send records in this connection into the buffer pointed by the parameter buffer. See RFC 9146 and RFC. </p>
<ol type="1">
<li><p class="startli">The available space in the buffer need to be provided in bufferSz.</p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly copied, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer where the ConnectionID will be copied </td></tr>
    <tr><td class="paramname">bufferSz</td><td>available space in buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acb4dcd90229f9f5e44b0b80340bb5e65" title="Get the ConnectionID used by the other peer. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_get0_rx</a> </dd>
<dd>
<a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a98e346811ddfa58b342642f886c0d09e" name="a98e346811ddfa58b342642f886c0d09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e346811ddfa58b342642f886c0d09e">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get_rx_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get_rx_size </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC 9147. The size is stored in the parameter size. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly negotiated, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">size</td><td>a pointer to an unsigned int where the size will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="a719db6450251717616cb6a9f92463273" name="a719db6450251717616cb6a9f92463273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719db6450251717616cb6a9f92463273">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get_tx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>bufferSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the ConnectionID used when sending records in this connection into the buffer pointer by the parameter buffer. See RFC 9146 and RFC 9147. The available size need to be provided in bufferSz. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly copied, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer where the ConnectionID will be copied </td></tr>
    <tr><td class="paramname">bufferSz</td><td>available space in buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a40f8d108b7490ffeccdfc0dac952b9b0" title="Get the ConnectionID used when sending records in this connection. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_get0_tx</a> </dd>
<dd>
<a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd></dl>

</div>
</div>
<a id="aee6e35bce04662d8021c29de41febabd" name="aee6e35bce04662d8021c29de41febabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6e35bce04662d8021c29de41febabd">&#9670;&#160;</a></span>wolfSSL_dtls_cid_get_tx_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_get_tx_size </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147. The size is stored in the parameter size. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID size was correctly stored, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">size</td><td>a pointer to an unsigned int where the size will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="a7e7f6700dd9eef47d6f83ae507dc6e0b" name="a7e7f6700dd9eef47d6f83ae507dc6e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7f6700dd9eef47d6f83ae507dc6e0b">&#9670;&#160;</a></span>wolfSSL_dtls_cid_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_is_enabled </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for the SSL object. See RFC 9146 and RFC 9147. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if ConnectionID was correctly negotiated, 0 otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="aa2288103683ccb84fe48bfc56f0bd147" name="aa2288103683ccb84fe48bfc56f0bd147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2288103683ccb84fe48bfc56f0bd147">&#9670;&#160;</a></span>wolfSSL_dtls_cid_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_dtls_cid_parse </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>msgSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>cidSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the ConnectionID from a record datagram/message. See RFC 9146 and RFC 9147. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>buffer holding the datagram read from the network </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of msg in bytes </td></tr>
    <tr><td class="paramname">cid</td><td>pointer to the start of the CID inside the msg buffer </td></tr>
    <tr><td class="paramname">cidSz</td><td>the expected size of the CID. The record layer does not have a CID size field so we have to know beforehand the size of the CID. It is recommended to use a constant CID for all connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd>
<dd>
<a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd></dl>

</div>
</div>
<a id="a4c3f01c34e2386f57b791f2b4746da67" name="a4c3f01c34e2386f57b791f2b4746da67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f01c34e2386f57b791f2b4746da67">&#9670;&#160;</a></span>wolfSSL_dtls_cid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_set </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>cid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC 9147. The ConnectionID must be at maximum DTLS_CID_MAX_SIZE, that is an tunable compile time define, and it can't never be bigger than 255 bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if ConnectionID was correctly set, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointern </td></tr>
    <tr><td class="paramname">cid</td><td>the ConnectionID to be used </td></tr>
    <tr><td class="paramname">size</td><td>of the ConnectionID provided</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2a23caed3a0c38d1ebe1366dc844b34c" title="Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147.">wolfSSL_dtls_cid_use</a> </dd>
<dd>
<a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="a2a23caed3a0c38d1ebe1366dc844b34c" name="a2a23caed3a0c38d1ebe1366dc844b34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a23caed3a0c38d1ebe1366dc844b34c">&#9670;&#160;</a></span>wolfSSL_dtls_cid_use()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_cid_use </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable use of ConnectionID extensions for the SSL object. See RFC 9146 and RFC 9147. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS on success, error code otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7e7f6700dd9eef47d6f83ae507dc6e0b" title="If invoked after the handshake is complete it checks if ConnectionID was successfully negotiated for ...">wolfSSL_dtls_cid_is_enabled</a> </dd>
<dd>
<a class="el" href="#a4c3f01c34e2386f57b791f2b4746da67" title="Set the ConnectionID used by the other peer to send records in this connection. See RFC 9146 and RFC ...">wolfSSL_dtls_cid_set</a> </dd>
<dd>
<a class="el" href="#a98e346811ddfa58b342642f886c0d09e" title="Get the size of the ConnectionID used by the other peer to send records in this connection....">wolfSSL_dtls_cid_get_rx_size</a> </dd>
<dd>
<a class="el" href="#a9c7c6e4efea4ecf0bb9b9a1fb1365408" title="Copy the ConnectionID used by the other peer to send records in this connection into the buffer point...">wolfSSL_dtls_cid_get_rx</a> </dd>
<dd>
<a class="el" href="#aee6e35bce04662d8021c29de41febabd" title="Get the size of the ConnectionID used to send records in this connection. See RFC 9146 and RFC 9147....">wolfSSL_dtls_cid_get_tx_size</a> </dd>
<dd>
<a class="el" href="#a719db6450251717616cb6a9f92463273" title="Copy the ConnectionID used when sending records in this connection into the buffer pointer by the par...">wolfSSL_dtls_cid_get_tx</a> </dd></dl>

</div>
</div>
<a id="af072e84c62c596bacd4026b4b0078aeb" name="af072e84c62c596bacd4026b4b0078aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af072e84c62c596bacd4026b4b0078aeb">&#9670;&#160;</a></span>wolfSSL_dtls_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_export </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="#af072e84c62c596bacd4026b4b0078aeb" title="The wolfSSL_dtls_export() function is used to serialize a WOLFSSL session into the provided buffer....">wolfSSL_dtls_export()</a> function is used to serialize a WOLFSSL session into the provided buffer. Allows for less memory overhead than using a function callback for sending a session and choice over when the session is serialized. If buffer is NULL when passed to function then sz will be set to the size of buffer needed for serializing the WOLFSSL session. </p>
<dl class="section return"><dt>Returns</dt><dd>Success If successful, the amount of the buffer used will be returned. </dd>
<dd>
Failure All unsuccessful return values will be less than 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to hold serialized session. </td></tr>
    <tr><td class="paramname">sz</td><td>size of buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[MAX];</div>
<div class="line">bufSz = MAX;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#af072e84c62c596bacd4026b4b0078aeb">wolfSSL_dtls_export</a>(ssl, buf, bufSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="assl_8h_html_af072e84c62c596bacd4026b4b0078aeb"><div class="ttname"><a href="#af072e84c62c596bacd4026b4b0078aeb">wolfSSL_dtls_export</a></div><div class="ttdeci">int wolfSSL_dtls_export(WOLFSSL *ssl, unsigned char *buf, unsigned int *sz)</div><div class="ttdoc">The wolfSSL_dtls_export() function is used to serialize a WOLFSSL session into the provided buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04" title="The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...">wolfSSL_CTX_dtls_set_export</a> </dd>
<dd>
<a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8" title="The wolfSSL_dtls_import() function is used to parse in a serialized session state....">wolfSSL_dtls_import</a> </dd></dl>

</div>
</div>
<a id="affc102e6ba1e2eee0ab8ab24ddc7d34d" name="affc102e6ba1e2eee0ab8ab24ddc7d34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc102e6ba1e2eee0ab8ab24ddc7d34d">&#9670;&#160;</a></span>wolfSSL_dtls_get0_peer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_get0_peer </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **</td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>peerSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. This is a zero-copy alternative to <a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success. </dd>
<dd>
SSL_FAILURE will be returned upon failure. </dd>
<dd>
SSL_NOT_IMPLEMENTED will be returned if wolfSSL was not compiled with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">peer</td><td>pointer to return the internal buffer holding the peer address </td></tr>
    <tr><td class="paramname">peerSz</td><td>output the size of the actual sockaddr_in structure pointed to by peer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">sockaddr_in* addr;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addrSz;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a98b070301e0424c878c8177789700830">wolfSSL_dtls_get_peer</a>(ssl, &amp;addr, &amp;addrSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to get DTLS peer</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a98b070301e0424c878c8177789700830"><div class="ttname"><a href="#a98b070301e0424c878c8177789700830">wolfSSL_dtls_get_peer</a></div><div class="ttdeci">int wolfSSL_dtls_get_peer(WOLFSSL *ssl, void *peer, unsigned int *peerSz)</div><div class="ttdoc">This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="a07da5ada53a2a68ee8e7a6dab9b5f429" name="a07da5ada53a2a68ee8e7a6dab9b5f429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07da5ada53a2a68ee8e7a6dab9b5f429">&#9670;&#160;</a></span>wolfSSL_dtls_get_current_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_get_current_timeout </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current timeout value in seconds for the WOLFSSL object. When using non-blocking sockets, something in the user code needs to decide when to check for available recv data and how long it has been waiting. The value returned by this function indicates how long the application should wait. </p>
<dl class="section return"><dt>Returns</dt><dd>seconds The current DTLS timeout value in seconds </dd>
<dd>
NOT_COMPILED_IN if wolfSSL was not built with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> timeout = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">timeout = wolfSSL_get_dtls_current_timeout(ssl);</div>
<div class="line">printf(“DTLS timeout (sec) = %d\n”, timeout);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd></dl>

</div>
</div>
<a id="a98b070301e0424c878c8177789700830" name="a98b070301e0424c878c8177789700830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b070301e0424c878c8177789700830">&#9670;&#160;</a></span>wolfSSL_dtls_get_peer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_get_peer </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>peerSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compare peerSz to the actual DTLS peer size stored in the SSL session. If the peer will fit into peer, the peer’s sockaddr_in will be copied into peer, with peerSz set to the size of peer. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success. </dd>
<dd>
SSL_FAILURE will be returned upon failure. </dd>
<dd>
SSL_NOT_IMPLEMENTED will be returned if wolfSSL was not compiled with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">peer</td><td>pointer to memory location to store peer’s sockaddr_in structure. </td></tr>
    <tr><td class="paramname">peerSz</td><td>input/output size. As input, the size of the allocated memory pointed to by peer. As output, the size of the actual sockaddr_in structure pointed to by peer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">sockaddr_in addr;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a98b070301e0424c878c8177789700830">wolfSSL_dtls_get_peer</a>(ssl, &amp;addr, <span class="keyword">sizeof</span>(addr));</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to get DTLS peer</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="a31d2641262d1f25e110033fb0c40cc59" name="a31d2641262d1f25e110033fb0c40cc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d2641262d1f25e110033fb0c40cc59">&#9670;&#160;</a></span>wolfSSL_dtls_get_using_nonblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_get_using_nonblock </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the application to determine if wolfSSL is using non-blocking I/O with UDP. If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0. After an application creates a WOLFSSL object, if it will be used with a non-blocking UDP socket, call <a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out. This function is only meaningful to DTLS sessions. </p>
<dl class="section return"><dt>Returns</dt><dd>0 underlying I/O is blocking. </dd>
<dd>
1 underlying I/O is non-blocking.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the DTLS session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a31d2641262d1f25e110033fb0c40cc59">wolfSSL_dtls_get_using_nonblock</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 1) {</div>
<div class="line">    <span class="comment">// underlying I/O is non-blocking</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="assl_8h_html_a31d2641262d1f25e110033fb0c40cc59"><div class="ttname"><a href="#a31d2641262d1f25e110033fb0c40cc59">wolfSSL_dtls_get_using_nonblock</a></div><div class="ttdeci">int wolfSSL_dtls_get_using_nonblock(WOLFSSL *ssl)</div><div class="ttdoc">This function allows the application to determine if wolfSSL is using non-blocking I/O with UDP....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock</a> </dd></dl>

</div>
</div>
<a id="a86c630a78e966b768332c5b19e485a51" name="a86c630a78e966b768332c5b19e485a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c630a78e966b768332c5b19e485a51">&#9670;&#160;</a></span>wolfSSL_dtls_got_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_got_timeout </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when the controlling code thinks the transmission has timed out. It performs the actions needed to retry the last transmit, including adjusting the timeout value. If it has been too long, this will return a failure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success </dd>
<dd>
SSL_FATAL_ERROR will be returned if there have been too many retransmissions/timeouts without getting a response from the peer. </dd>
<dd>
NOT_COMPILED_IN will be returned if wolfSSL was not compiled with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">See the following files <span class="keywordflow">for</span> usage examples:</div>
<div class="line">&lt;wolfssl_root&gt;/examples/client/client.c</div>
<div class="line">&lt;wolfssl_root&gt;/examples/server/server.c</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="a42edf8e49a9aee400c06cf6a2a2f04d8" name="a42edf8e49a9aee400c06cf6a2a2f04d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42edf8e49a9aee400c06cf6a2a2f04d8">&#9670;&#160;</a></span>wolfSSL_dtls_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_import </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8" title="The wolfSSL_dtls_import() function is used to parse in a serialized session state....">wolfSSL_dtls_import()</a> function is used to parse in a serialized session state. This allows for picking up the connection after the handshake has been completed. </p>
<dl class="section return"><dt>Returns</dt><dd>Success If successful, the amount of the buffer read will be returned. </dd>
<dd>
Failure All unsuccessful return values will be less than 0. </dd>
<dd>
VERSION_ERROR If a version mismatch is found ie DTLS v1 and ctx was set up for DTLS v1.2 then VERSION_ERROR is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>serialized session to import. </td></tr>
    <tr><td class="paramname">sz</td><td>size of serialized session buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[MAX];</div>
<div class="line">bufSz = MAX;</div>
<div class="line">...</div>
<div class="line"><span class="comment">//get information sent from wc_dtls_export function and place it in buf</span></div>
<div class="line">fread(buf, 1, bufSz, input);</div>
<div class="line">ret = <a class="code hl_function" href="#a42edf8e49a9aee400c06cf6a2a2f04d8">wolfSSL_dtls_import</a>(ssl, buf, bufSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line"><span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// no wolfSSL_accept needed since handshake was already done</span></div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a>(ssl) and <a class="code hl_function" href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a>(ssl);</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_ga80c3ccd3c0441c77307df3afe88a5c35"><div class="ttname"><a href="group__IO.html#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a></div><div class="ttdeci">int wolfSSL_read(WOLFSSL *ssl, void *data, int sz)</div><div class="ttdoc">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....</div></div>
<div class="ttc" id="agroup__IO_html_gad6cbb3cb90e4d606e9507e4ec06197df"><div class="ttname"><a href="group__IO.html#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a></div><div class="ttdeci">int wolfSSL_write(WOLFSSL *ssl, const void *data, int sz)</div><div class="ttdoc">This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...</div></div>
<div class="ttc" id="assl_8h_html_a42edf8e49a9aee400c06cf6a2a2f04d8"><div class="ttname"><a href="#a42edf8e49a9aee400c06cf6a2a2f04d8">wolfSSL_dtls_import</a></div><div class="ttdeci">int wolfSSL_dtls_import(WOLFSSL *ssl, unsigned char *buf, unsigned int sz)</div><div class="ttdoc">The wolfSSL_dtls_import() function is used to parse in a serialized session state....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04" title="The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...">wolfSSL_CTX_dtls_set_export</a> </dd></dl>

</div>
</div>
<a id="a4646c73f068c7949cc61a7d16e48843b" name="a4646c73f068c7949cc61a7d16e48843b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4646c73f068c7949cc61a7d16e48843b">&#9670;&#160;</a></span>wolfSSL_dtls_retransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_retransmit </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using non-blocking sockets with DTLS, this function retransmits the last handshake flight ignoring the expected timeout value and retransmit count. It is useful for applications that are using DTLS and need to manage even the timeout and retry count. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success </dd>
<dd>
SSL_FATAL_ERROR will be returned if there have been too many retransmissions/timeouts without getting a response from the peer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a4646c73f068c7949cc61a7d16e48843b">wolfSSL_dtls_retransmit</a>(ssl);</div>
<div class="ttc" id="assl_8h_html_a4646c73f068c7949cc61a7d16e48843b"><div class="ttname"><a href="#a4646c73f068c7949cc61a7d16e48843b">wolfSSL_dtls_retransmit</a></div><div class="ttdeci">int wolfSSL_dtls_retransmit(WOLFSSL *ssl)</div><div class="ttdoc">When using non-blocking sockets with DTLS, this function retransmits the last handshake flight ignori...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="a515a17c2d7dd1b2f79d9849fcec38c4e" name="a515a17c2d7dd1b2f79d9849fcec38c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515a17c2d7dd1b2f79d9849fcec38c4e">&#9670;&#160;</a></span>wolfSSL_dtls_set_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_set_export </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_dtls_export</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="#a515a17c2d7dd1b2f79d9849fcec38c4e" title="The wolfSSL_dtls_set_export() function is used to set the callback function for exporting a session....">wolfSSL_dtls_set_export()</a> function is used to set the callback function for exporting a session. It is allowed to pass in NULL as the parameter func to clear the export function previously stored. Used on the server side and is called immediately after handshake is completed. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG If null or not expected arguments are passed in</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">func</td><td>wc_dtls_export function to use when exporting a session.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> send_session(WOLFSSL* ssl, <span class="keywordtype">byte</span>* buf, word32 sz, <span class="keywordtype">void</span>* userCtx);</div>
<div class="line"><span class="comment">// body of send session (wc_dtls_export) that passes</span></div>
<div class="line"><span class="comment">// buf (serialized session) to destination</span></div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a515a17c2d7dd1b2f79d9849fcec38c4e">wolfSSL_dtls_set_export</a>(ssl, send_session);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// handle error case</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a>(ssl);</div>
<div class="line">...</div>
<div class="ttc" id="assl_8h_html_a515a17c2d7dd1b2f79d9849fcec38c4e"><div class="ttname"><a href="#a515a17c2d7dd1b2f79d9849fcec38c4e">wolfSSL_dtls_set_export</a></div><div class="ttdeci">int wolfSSL_dtls_set_export(WOLFSSL *ssl, wc_dtls_export func)</div><div class="ttdoc">The wolfSSL_dtls_set_export() function is used to set the callback function for exporting a session....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a65e317e419b97b46fd287f6ddd2d8b04" title="The wolfSSL_CTX_dtls_set_export() function is used to set the callback function for exporting a sessi...">wolfSSL_CTX_dtls_set_export</a> </dd></dl>

</div>
</div>
<a id="a7d0dd41cc5166c33b952e0091f38d088" name="a7d0dd41cc5166c33b952e0091f38d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0dd41cc5166c33b952e0091f38d088">&#9670;&#160;</a></span>wolfSSL_dtls_set_peer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_set_peer </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>peerSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success. </dd>
<dd>
SSL_FAILURE will be returned upon failure. </dd>
<dd>
SSL_NOT_IMPLEMENTED will be returned if wolfSSL was not compiled with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">peer</td><td>pointer to peer’s sockaddr_in structure. If NULL then the peer information in ssl is cleared. </td></tr>
    <tr><td class="paramname">peerSz</td><td>size of the sockaddr_in structure pointed to by peer. If 0 then the peer information in ssl is cleared.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">sockaddr_in addr;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#a7d0dd41cc5166c33b952e0091f38d088">wolfSSL_dtls_set_peer</a>(ssl, &amp;addr, <span class="keyword">sizeof</span>(addr));</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to set DTLS peer</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a7d0dd41cc5166c33b952e0091f38d088"><div class="ttname"><a href="#a7d0dd41cc5166c33b952e0091f38d088">wolfSSL_dtls_set_peer</a></div><div class="ttdeci">int wolfSSL_dtls_set_peer(WOLFSSL *ssl, void *peer, unsigned int peerSz)</div><div class="ttdoc">This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#af4b8699cfb0d882047a38441380ad92d" title="This function sets the pending DTLS peer, peer (sockaddr_in) with size of peerSz. This sets the pendi...">wolfSSL_dtls_set_pending_peer</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="af4b8699cfb0d882047a38441380ad92d" name="af4b8699cfb0d882047a38441380ad92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b8699cfb0d882047a38441380ad92d">&#9670;&#160;</a></span>wolfSSL_dtls_set_pending_peer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_set_pending_peer </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>peerSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the pending DTLS peer, peer (sockaddr_in) with size of peerSz. This sets the pending peer that will be upgraded to a regular peer when we successfully de-protect the next record. This is useful in scenarios where the peer's address can change to avoid off-path attackers from changing the peer address. This should be used with Connection ID's to allow seamless and safe transition to a new peer address. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned upon success. </dd>
<dd>
SSL_FAILURE will be returned upon failure. </dd>
<dd>
SSL_NOT_IMPLEMENTED will be returned if wolfSSL was not compiled with DTLS support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">peer</td><td>pointer to peer’s sockaddr_in structure. If NULL then the peer information in ssl is cleared. </td></tr>
    <tr><td class="paramname">peerSz</td><td>size of the sockaddr_in structure pointed to by peer. If 0 then the peer information in ssl is cleared.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">sockaddr_in addr;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#af4b8699cfb0d882047a38441380ad92d">wolfSSL_dtls_set_pending_peer</a>(ssl, &amp;addr, <span class="keyword">sizeof</span>(addr));</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to set DTLS peer</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_af4b8699cfb0d882047a38441380ad92d"><div class="ttname"><a href="#af4b8699cfb0d882047a38441380ad92d">wolfSSL_dtls_set_pending_peer</a></div><div class="ttdeci">int wolfSSL_dtls_set_pending_peer(WOLFSSL *ssl, void *peer, unsigned int peerSz)</div><div class="ttdoc">This function sets the pending DTLS peer, peer (sockaddr_in) with size of peerSz. This sets the pendi...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd>
<dd>
<a class="el" href="#a7d0dd41cc5166c33b952e0091f38d088" title="This function sets the DTLS peer, peer (sockaddr_in) with size of peerSz.">wolfSSL_dtls_set_peer</a> </dd>
<dd>
<a class="el" href="#a98b070301e0424c878c8177789700830" title="This function gets the sockaddr_in (of size peerSz) of the current DTLS peer. The function will compa...">wolfSSL_dtls_get_peer</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a298a34e67ad57069d88f6e626df139a1" title="This function is used to determine if the SSL session has been configured to use DTLS.">wolfSSL_dtls</a> </dd></dl>

</div>
</div>
<a id="a10d57d8c34afabdf6242b9cb164485be" name="a10d57d8c34afabdf6242b9cb164485be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d57d8c34afabdf6242b9cb164485be">&#9670;&#160;</a></span>wolfSSL_dtls_set_timeout_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_dtls_set_timeout_max </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the maximum dtls timeout. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without an error. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL struct is NULL or if the timeout argument is not greater than zero or is less than the dtls_timeout_init member of the WOLFSSL structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">timeout</td><td>an int type representing the dtls maximum timeout.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">int</span> timeout = TIMEOUTVAL;</div>
<div class="line">...</div>
<div class="line">int ret = <a class="code hl_function" href="#a10d57d8c34afabdf6242b9cb164485be">wolfSSL_dtls_set_timeout_max</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span>(!ret){</div>
<div class="line">    <span class="comment">// Failed to set the max timeout</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a10d57d8c34afabdf6242b9cb164485be"><div class="ttname"><a href="#a10d57d8c34afabdf6242b9cb164485be">wolfSSL_dtls_set_timeout_max</a></div><div class="ttdeci">int wolfSSL_dtls_set_timeout_max(WOLFSSL *ssl, int)</div><div class="ttdoc">This function sets the maximum dtls timeout.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga1dd3c408c996a80b9abfae8f74645d21" title="This function sets the dtls timeout.">wolfSSL_dtls_set_timeout_init</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd></dl>

</div>
</div>
<a id="a585412eb9473686f4d65b971c8afc223" name="a585412eb9473686f4d65b971c8afc223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585412eb9473686f4d65b971c8afc223">&#9670;&#160;</a></span>wolfSSL_dtls_set_using_nonblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_dtls_set_using_nonblock </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nonblock</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking. After an application creates a WOLFSSL object, if it will be used with a non-blocking UDP socket, call <a class="el" href="#a585412eb9473686f4d65b971c8afc223" title="This function informs the WOLFSSL DTLS object that the underlying UDP I/O is non-blocking....">wolfSSL_dtls_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out. </p>
<dl class="section return"><dt>Returns</dt><dd>none No return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the DTLS session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">nonblock</td><td>value used to set non-blocking flag on WOLFSSL object. Use 1 to specify non-blocking, otherwise 0.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">wolfSSL_dtls_set_using_nonblock(ssl, 1);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a31d2641262d1f25e110033fb0c40cc59" title="This function allows the application to determine if wolfSSL is using non-blocking I/O with UDP....">wolfSSL_dtls_get_using_nonblock</a> </dd>
<dd>
<a class="el" href="#a86c630a78e966b768332c5b19e485a51" title="When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when ...">wolfSSL_dtls_got_timeout</a> </dd>
<dd>
<a class="el" href="#a07da5ada53a2a68ee8e7a6dab9b5f429" title="This function returns the current timeout value in seconds for the WOLFSSL object....">wolfSSL_dtls_get_current_timeout</a> </dd></dl>

</div>
</div>
<a id="a5b8b3f5e2ece0d4dfb06480a67ebb4e1" name="a5b8b3f5e2ece0d4dfb06480a67ebb4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8b3f5e2ece0d4dfb06480a67ebb4e1">&#9670;&#160;</a></span>wolfSSL_DTLS_SetCookieSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_DTLS_SetCookieSecret </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>secret</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>secretSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a new dtls cookie secret. </p>
<dl class="section return"><dt>Returns</dt><dd>0 returned if the function executed without an error. </dd>
<dd>
BAD_FUNC_ARG returned if there was an argument passed to the function with an unacceptable value. </dd>
<dd>
COOKIE_SECRET_SZ returned if the secret size is 0. </dd>
<dd>
MEMORY_ERROR returned if there was a problem allocating memory for a new cookie secret.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">secret</td><td>a constant byte pointer representing the secret buffer. </td></tr>
    <tr><td class="paramname">secretSz</td><td>the size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keyword">const</span>* <span class="keywordtype">byte</span> secret;</div>
<div class="line">word32 secretSz; <span class="comment">// size of secret</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(!<a class="code hl_function" href="#a5b8b3f5e2ece0d4dfb06480a67ebb4e1">wolfSSL_DTLS_SetCookieSecret</a>(ssl, secret, secretSz)){</div>
<div class="line">    <span class="comment">// Code block for failure to set DTLS cookie secret</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Success! Cookie secret is set.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a5b8b3f5e2ece0d4dfb06480a67ebb4e1"><div class="ttname"><a href="#a5b8b3f5e2ece0d4dfb06480a67ebb4e1">wolfSSL_DTLS_SetCookieSecret</a></div><div class="ttdeci">int wolfSSL_DTLS_SetCookieSecret(WOLFSSL *ssl, const unsigned char *secret, unsigned int secretSz)</div><div class="ttdoc">This function sets a new dtls cookie secret.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>ForceZero </dd>
<dd>
<a class="el" href="group__Random.html#ga9a289fb3f58f4a5f7e15c2b5a1b0d7c6" title="Copies a sz bytes of pseudorandom data to output. Will reseed rng if needed (blocking).">wc_RNG_GenerateBlock</a> </dd></dl>

</div>
</div>
<a id="ae20963c699c42a41fa799262bdd55579" name="ae20963c699c42a41fa799262bdd55579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20963c699c42a41fa799262bdd55579">&#9670;&#160;</a></span>wolfSSL_EnableCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_EnableCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables CRL certificate revocation. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS the function and subroutines returned with no errors. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure is NULL. </dd>
<dd>
MEMORY_E returned if the allocation of memory failed. </dd>
<dd>
SSL_FAILURE returned if the InitCRL function does not return successfully. </dd>
<dd>
NOT_COMPILED_IN HAVE_CRL was not enabled during the compiling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">options</td><td>an integer that is used to determine the setting of crlCheckAll member of the WOLFSSL_CERT_MANAGER structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ae20963c699c42a41fa799262bdd55579">wolfSSL_EnableCRL</a>(ssl, WOLFSSL_CRL_CHECKALL) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case. SSL_SUCCESS was not returned by this function or</span></div>
<div class="line">a subroutine</div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ae20963c699c42a41fa799262bdd55579"><div class="ttname"><a href="#ae20963c699c42a41fa799262bdd55579">wolfSSL_EnableCRL</a></div><div class="ttdeci">int wolfSSL_EnableCRL(WOLFSSL *ssl, int options)</div><div class="ttdoc">Enables CRL certificate revocation.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#gaa0caa567b553f8417bca591cd18c9a25" title="Turns on Certificate Revocation List checking when verifying certificates with the Certificate Manage...">wolfSSL_CertManagerEnableCRL</a> </dd>
<dd>
InitCRL </dd></dl>

</div>
</div>
<a id="a1c18a7ff26ebcb9453dc2f6616b8950b" name="a1c18a7ff26ebcb9453dc2f6616b8950b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c18a7ff26ebcb9453dc2f6616b8950b">&#9670;&#160;</a></span>wolfSSL_EnableOCSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_EnableOCSP </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables OCSP certificate verification. The value of options if formed by or’ing one or more of the following options: WOLFSSL_OCSP_URL_OVERRIDE - use the override URL instead of the URL in certificates. The override URL is specified using the <a class="el" href="#ade9a3efc38ede0e8c8f5c0caeb8e20ad" title="This function manually sets the URL for OCSP to use. By default, OCSP will use the URL found in the i...">wolfSSL_CTX_SetOCSP_OverrideURL()</a> function. WOLFSSL_OCSP_CHECKALL - Set all OCSP checks on WOLFSSL_OCSP_NO_NONCE - Set nonce option for creating OCSP requests. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function and subroutines executes without errors. </dd>
<dd>
BAD_FUNC_ARG returned if an argument in this function or any subroutine receives an invalid argument value. </dd>
<dd>
MEMORY_E returned if there was an error allocating memory for a structure or other variable. </dd>
<dd>
NOT_COMPILED_IN returned if wolfSSL was not compiled with the HAVE_OCSP option.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">options</td><td>an integer type passed to wolfSSL_CertMangerENableOCSP() used for settings check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">int</span> options; <span class="comment">// initialize to option constant</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> ret = <a class="code hl_function" href="#a1c18a7ff26ebcb9453dc2f6616b8950b">wolfSSL_EnableOCSP</a>(ssl, options);</div>
<div class="line"><span class="keywordflow">if</span>(ret != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// OCSP is not enabled</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a1c18a7ff26ebcb9453dc2f6616b8950b"><div class="ttname"><a href="#a1c18a7ff26ebcb9453dc2f6616b8950b">wolfSSL_EnableOCSP</a></div><div class="ttdeci">int wolfSSL_EnableOCSP(WOLFSSL *ssl, int options)</div><div class="ttdoc">This function enables OCSP certificate verification. The value of options if formed by or’ing one or ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga05b1f36d81c5cf5316336a2f54d53e68" title="Turns on OCSP if it’s turned off and if compiled with the set option available.">wolfSSL_CertManagerEnableOCSP</a> </dd></dl>

</div>
</div>
<a id="a48e4dcab8f599fec761f55a3c91a0e7b" name="a48e4dcab8f599fec761f55a3c91a0e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e4dcab8f599fec761f55a3c91a0e7b">&#9670;&#160;</a></span>wolfSSL_get_ephemeral_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_ephemeral_key </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keyAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns pointer to loaded key as ASN.1/DER. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Key returned successfully </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointer </td></tr>
    <tr><td class="paramname">keyAlgo</td><td>enum wc_PkType like WC_PK_TYPE_DH and WC_PK_TYPE_ECDH </td></tr>
    <tr><td class="paramname">key</td><td>key buffer pointer </td></tr>
    <tr><td class="paramname">keySz</td><td>key size pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad3b2ce849382c9f86275de47af4c38c5" title="This function sets a fixed / static ephemeral key for testing only.">wolfSSL_set_ephemeral_key</a> </dd></dl>

</div>
</div>
<a id="a9370b0972916f388d2eab0342521ded3" name="a9370b0972916f388d2eab0342521ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370b0972916f388d2eab0342521ded3">&#9670;&#160;</a></span>wolfSSL_get_negotiated_client_cert_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_negotiated_client_cert_type </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the result of the client certificate type negotiation done in ClientHello and ServerHello. WOLFSSL_SUCCESS is returned as a return value if no negotiation occurs and WOLFSSL_CERT_TYPE_UNKNOWN is returned as the certificate type. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if a negotiated certificate type could be got </dd>
<dd>
BAD_FUNC_ARG if NULL was passed for ctx or tp </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>WOLFSSL object pointer </td></tr>
    <tr><td class="paramname">tp</td><td>A buffer where a certificate type is to be returned. One of three certificate types will be returned: WOLFSSL_CERT_TYPE_RPK, WOLFSSL_CERT_TYPE_X509 or WOLFSSL_CERT_TYPE_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> tp;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#a9370b0972916f388d2eab0342521ded3">wolfSSL_get_negotiated_client_cert_type</a>(ssl, &amp;tp);</div>
<div class="ttc" id="assl_8h_html_a9370b0972916f388d2eab0342521ded3"><div class="ttname"><a href="#a9370b0972916f388d2eab0342521ded3">wolfSSL_get_negotiated_client_cert_type</a></div><div class="ttdeci">int wolfSSL_get_negotiated_client_cert_type(WOLFSSL *ssl, int *tp)</div><div class="ttdoc">This function returns the result of the client certificate type negotiation done in ClientHello and S...</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga40c884153d93bc6aa261c6b96915a236" title="In case this function is called in a client side, set certificate types that can be sent to its peer....">wolfSSL_set_client_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga4e0b234edb4864ccc33928fae38eef78" title="In case this function is called in a client side, set certificate types that can be sent to its peer....">wolfSSL_CTX_set_client_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga134f244a4a790fde86e244b7e3df6723" title="In case this function is called in a server side, set certificate types that can be sent to its peer....">wolfSSL_set_server_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#gaceca8dcac1454ec6cf310597bd8b6895" title="In case this function is called in a server side, set certificate types that can be sent to its peer....">wolfSSL_CTX_set_server_cert_type</a> </dd>
<dd>
<a class="el" href="#a2a965b3cc8d874fff75fcdef43961220" title="This function returns the result of the server certificate type negotiation done in ClientHello and S...">wolfSSL_get_negotiated_server_cert_type</a> </dd></dl>

</div>
</div>
<a id="a2a965b3cc8d874fff75fcdef43961220" name="a2a965b3cc8d874fff75fcdef43961220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a965b3cc8d874fff75fcdef43961220">&#9670;&#160;</a></span>wolfSSL_get_negotiated_server_cert_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_negotiated_server_cert_type </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the result of the server certificate type negotiation done in ClientHello and ServerHello. WOLFSSL_SUCCESS is returned as a return value if no negotiation occurs and WOLFSSL_CERT_TYPE_UNKNOWN is returned as the certificate type. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS if a negotiated certificate type could be got </dd>
<dd>
BAD_FUNC_ARG if NULL was passed for ctx or tp </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>WOLFSSL object pointer </td></tr>
    <tr><td class="paramname">tp</td><td>A buffer where a certificate type is to be returned. One of three certificate types will be returned: WOLFSSL_CERT_TYPE_RPK, WOLFSSL_CERT_TYPE_X509 or WOLFSSL_CERT_TYPE_UNKNOWN. <em>Example</em> <div class="fragment"><div class="line">  <span class="keywordtype">int</span> ret;</div>
<div class="line">  WOLFSSL* ssl;</div>
<div class="line">  <span class="keywordtype">int</span> tp;</div>
<div class="line">　...</div>
<div class="line"> </div>
<div class="line">  ret = <a class="code hl_function" href="#a2a965b3cc8d874fff75fcdef43961220">wolfSSL_get_negotiated_server_cert_type</a>(ssl, &amp;tp);</div>
<div class="ttc" id="assl_8h_html_a2a965b3cc8d874fff75fcdef43961220"><div class="ttname"><a href="#a2a965b3cc8d874fff75fcdef43961220">wolfSSL_get_negotiated_server_cert_type</a></div><div class="ttdeci">int wolfSSL_get_negotiated_server_cert_type(WOLFSSL *ssl, int *tp)</div><div class="ttdoc">This function returns the result of the server certificate type negotiation done in ClientHello and S...</div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga40c884153d93bc6aa261c6b96915a236" title="In case this function is called in a client side, set certificate types that can be sent to its peer....">wolfSSL_set_client_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga4e0b234edb4864ccc33928fae38eef78" title="In case this function is called in a client side, set certificate types that can be sent to its peer....">wolfSSL_CTX_set_client_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga134f244a4a790fde86e244b7e3df6723" title="In case this function is called in a server side, set certificate types that can be sent to its peer....">wolfSSL_set_server_cert_type</a> </dd>
<dd>
<a class="el" href="group__Setup.html#gaceca8dcac1454ec6cf310597bd8b6895" title="In case this function is called in a server side, set certificate types that can be sent to its peer....">wolfSSL_CTX_set_server_cert_type</a> </dd>
<dd>
<a class="el" href="#a9370b0972916f388d2eab0342521ded3" title="This function returns the result of the client certificate type negotiation done in ClientHello and S...">wolfSSL_get_negotiated_client_cert_type</a> </dd></dl>

</div>
</div>
<a id="a22d011e8be92a7e5c025fd0da355c12e" name="a22d011e8be92a7e5c025fd0da355c12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d011e8be92a7e5c025fd0da355c12e">&#9670;&#160;</a></span>wolfSSL_get_psk_callback_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_get_psk_callback_ctx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a PSK user context in the WOLFSSL structure options member. </p>
<dl class="section return"><dt>Returns</dt><dd>void pointer to user PSK context</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a25324f17616aca4bf3b70fd872a83031" title="Sets a PSK user context in the WOLFSSL structure options member.">wolfSSL_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#ac8862b6583b25e63d7279929f9f96ffc" title="Sets a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a579ed69665d9aa441c281b5716198ca4" title="Get a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_get_psk_callback_ctx</a> </dd></dl>

</div>
</div>
<a id="a04528c30cd8cedcdddea74cddd3694f8" name="a04528c30cd8cedcdddea74cddd3694f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04528c30cd8cedcdddea74cddd3694f8">&#9670;&#160;</a></span>wolfSSL_GetAeadMacSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetAeadMacSize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated aead mac size from the handshake. For cipher type WOLFSSL_AEAD_TYPE. </p>
<dl class="section return"><dt>Returns</dt><dd>size If successful the call will return the size in bytes of the aead mac size. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize</a> </dd></dl>

</div>
</div>
<a id="a36b767ad63997d29a4d209f6e2c9560e" name="a36b767ad63997d29a4d209f6e2c9560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b767ad63997d29a4d209f6e2c9560e">&#9670;&#160;</a></span>wolfSSL_GetBulkCipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetBulkCipher </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated bulk cipher algorithm from the handshake. </p>
<dl class="section return"><dt>Returns</dt><dd>If successful the call will return one of the following: wolfssl_cipher_null, wolfssl_des, wolfssl_triple_des, wolfssl_aes, wolfssl_aes_gcm, wolfssl_aes_ccm, wolfssl_camellia. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666" title="Allows caller to determine the negotiated cipher block size from the handshake.">wolfSSL_GetCipherBlockSize</a> </dd>
<dd>
<a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize</a> </dd></dl>

</div>
</div>
<a id="a96a5d42c23ca6f18d8abb3440c986666" name="a96a5d42c23ca6f18d8abb3440c986666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a5d42c23ca6f18d8abb3440c986666">&#9670;&#160;</a></span>wolfSSL_GetCipherBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetCipherBlockSize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated cipher block size from the handshake. </p>
<dl class="section return"><dt>Returns</dt><dd>size If successful the call will return the size in bytes of the cipher block size. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize</a> </dd></dl>

</div>
</div>
<a id="a8d1d6965af541819903d254759433043" name="a8d1d6965af541819903d254759433043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1d6965af541819903d254759433043">&#9670;&#160;</a></span>wolfSSL_GetCipherType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetCipherType </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated cipher type from the handshake. </p>
<dl class="section return"><dt>Returns</dt><dd>If successful the call will return one of the following: WOLFSSL_BLOCK_TYPE, WOLFSSL_STREAM_TYPE, WOLFSSL_AEAD_TYPE. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#a081b82271e2a276bef3434b15f65f5dc" title="Allows caller to determine the negotiated (h)mac type from the handshake. For cipher types except WOL...">wolfSSL_GetHmacType</a> </dd></dl>

</div>
</div>
<a id="a9e777589542c2074cd63353478b3ced7" name="a9e777589542c2074cd63353478b3ced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e777589542c2074cd63353478b3ced7">&#9670;&#160;</a></span>wolfSSL_GetClientWriteIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_GetClientWriteIV </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the client write IV (initialization vector) from the handshake process. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the IV. The size of the IV can be obtained from <a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666" title="Allows caller to determine the negotiated cipher block size from the handshake.">wolfSSL_GetCipherBlockSize()</a>. </dd>
<dd>
NULL will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666" title="Allows caller to determine the negotiated cipher block size from the handshake.">wolfSSL_GetCipherBlockSize()</a> </dd>
<dd>
<a class="el" href="#a7ac2b35288c4437dec64fdea3c1bcae0" title="Allows retrieval of the client write key from the handshake process.">wolfSSL_GetClientWriteKey()</a> </dd></dl>

</div>
</div>
<a id="a7ac2b35288c4437dec64fdea3c1bcae0" name="a7ac2b35288c4437dec64fdea3c1bcae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac2b35288c4437dec64fdea3c1bcae0">&#9670;&#160;</a></span>wolfSSL_GetClientWriteKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_GetClientWriteKey </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the client write key from the handshake process. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the key. The size of the key can be obtained from <a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize()</a>. </dd>
<dd>
NULL will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize</a> </dd>
<dd>
<a class="el" href="#a9e777589542c2074cd63353478b3ced7" title="Allows retrieval of the client write IV (initialization vector) from the handshake process.">wolfSSL_GetClientWriteIV</a> </dd></dl>

</div>
</div>
<a id="a9cb89582080d65c25d65e70d9cec646c" name="a9cb89582080d65c25d65e70d9cec646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb89582080d65c25d65e70d9cec646c">&#9670;&#160;</a></span>wolfSSL_GetDecryptVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetDecryptVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Atomic User Record Processing Decrypt/Verify Callback Context previously stored with <a class="el" href="#a93021a9151fd3af1121b0380e87403d1" title="Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to ctx.">wolfSSL_SetDecryptVerifyCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5f636c2e3517c2bb054d5bb50924b352" title="Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback. The callback should r...">wolfSSL_CTX_SetDecryptVerifyCb</a> </dd>
<dd>
<a class="el" href="#a93021a9151fd3af1121b0380e87403d1" title="Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to ctx.">wolfSSL_SetDecryptVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="ac731df86e30f87e7823a7da59b461adb" name="ac731df86e30f87e7823a7da59b461adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731df86e30f87e7823a7da59b461adb">&#9670;&#160;</a></span>wolfSSL_GetEccSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetEccSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with <a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb" title="Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetEccSignCb</a> </dd>
<dd>
<a class="el" href="#a3f65634376fab1d6d61c6d998b2cc3ab" title="Allows caller to set the Public Key Ecc Signing Callback Context to ctx.">wolfSSL_SetEccSignCtx</a> </dd></dl>

</div>
</div>
<a id="ace78694804dc9bc862904b78ef73d40d" name="ace78694804dc9bc862904b78ef73d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace78694804dc9bc862904b78ef73d40d">&#9670;&#160;</a></span>wolfSSL_GetEccVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetEccVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key Ecc Verification Callback Context previously stored with <a class="el" href="#a1c89bf6fc378bfbf8c0559b4e6c820e1" title="Allows caller to set the Public Key Ecc Verification Callback Context to ctx.">wolfSSL_SetEccVerifyCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab58ec34fc70378f3be1a8035637091eb" title="Allows caller to set the Public Key Callback for ECC Verification. The callback should return 0 for s...">wolfSSL_CTX_SetEccVerifyCb</a> </dd>
<dd>
<a class="el" href="#a1c89bf6fc378bfbf8c0559b4e6c820e1" title="Allows caller to set the Public Key Ecc Verification Callback Context to ctx.">wolfSSL_SetEccVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="aa551e5b8c1a784fef36bff7c436ff9e2" name="aa551e5b8c1a784fef36bff7c436ff9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa551e5b8c1a784fef36bff7c436ff9e2">&#9670;&#160;</a></span>wolfSSL_GetHmacSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetHmacSize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOLFSSL_AEAD_TYPE. </p>
<dl class="section return"><dt>Returns</dt><dd>size If successful the call will return the size in bytes of the (h)mac size. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#a081b82271e2a276bef3434b15f65f5dc" title="Allows caller to determine the negotiated (h)mac type from the handshake. For cipher types except WOL...">wolfSSL_GetHmacType</a> </dd></dl>

</div>
</div>
<a id="a081b82271e2a276bef3434b15f65f5dc" name="a081b82271e2a276bef3434b15f65f5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081b82271e2a276bef3434b15f65f5dc">&#9670;&#160;</a></span>wolfSSL_GetHmacType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetHmacType </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine the negotiated (h)mac type from the handshake. For cipher types except WOLFSSL_AEAD_TYPE. </p>
<dl class="section return"><dt>Returns</dt><dd>If successful the call will return one of the following: MD5, SHA, SHA256, SHA384. </dd>
<dd>
BAD_FUNC_ARG may be returned for an error state. </dd>
<dd>
SSL_FATAL_ERROR may also be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2" title="Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOL...">wolfSSL_GetHmacSize</a> </dd></dl>

</div>
</div>
<a id="a6bcf1af4dd68c8f611fd18a21bca320f" name="a6bcf1af4dd68c8f611fd18a21bca320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcf1af4dd68c8f611fd18a21bca320f">&#9670;&#160;</a></span>wolfSSL_GetKeySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetKeySize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the key size from the handshake process. </p>
<dl class="section return"><dt>Returns</dt><dd>size If successful the call will return the key size in bytes. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7ac2b35288c4437dec64fdea3c1bcae0" title="Allows retrieval of the client write key from the handshake process.">wolfSSL_GetClientWriteKey</a> </dd>
<dd>
<a class="el" href="#ab37a6477e56341a08aa1d45cff857904" title="Allows retrieval of the server write key from the handshake process.">wolfSSL_GetServerWriteKey</a> </dd></dl>

</div>
</div>
<a id="a84e59d1c4a3f24ff5ece668e922d7548" name="a84e59d1c4a3f24ff5ece668e922d7548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e59d1c4a3f24ff5ece668e922d7548">&#9670;&#160;</a></span>wolfSSL_GetMacEncryptCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetMacEncryptCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously stored with <a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.">wolfSSL_SetMacEncryptCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac48d6f657d683557e23f9ce388488039" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback. The callback should retu...">wolfSSL_CTX_SetMacEncryptCb</a> </dd>
<dd>
<a class="el" href="#abf7ef9ed1a7b36f3c98447a28cd075c4" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx.">wolfSSL_SetMacEncryptCtx</a> </dd></dl>

</div>
</div>
<a id="ad75c66c5d37687c682db42754e3b4404" name="ad75c66c5d37687c682db42754e3b4404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75c66c5d37687c682db42754e3b4404">&#9670;&#160;</a></span>wolfSSL_GetMacSecret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_GetMacSecret </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>verify</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the Hmac/Mac secret from the handshake process. The verify parameter specifies whether this is for verification of a peer message. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the secret. The size of the secret can be obtained from <a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2" title="Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOL...">wolfSSL_GetHmacSize()</a>. </dd>
<dd>
NULL will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">verify</td><td>specifies whether this is for verification of a peer message.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2" title="Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOL...">wolfSSL_GetHmacSize</a> </dd></dl>

</div>
</div>
<a id="a9ff204f2e651c5b998351a2cbb2ee1ff" name="a9ff204f2e651c5b998351a2cbb2ee1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff204f2e651c5b998351a2cbb2ee1ff">&#9670;&#160;</a></span>wolfSSL_GetMaxOutputSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetMaxOutputSize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum record layer size for plaintext data. This will correspond to either the maximum SSL/TLS record size as specified by the protocol standard, the maximum TLS fragment size as set by the TLS Max Fragment Length extension. This function is helpful when the application has called <a class="el" href="#ac79dd3857ce4c179fcd1c449e4ec9b15" title="Returns the record layer size of the plaintext input. This is helpful when an application wants to kn...">wolfSSL_GetOutputSize()</a> and received a INPUT_SIZE_E error. This function must be called after the SSL/TLS handshake has been completed. </p>
<dl class="section return"><dt>Returns</dt><dd>size Upon success, the maximum output size will be returned </dd>
<dd>
BAD_FUNC_ARG will be returned upon invalid function argument, or if the SSL/TLS handshake has not been completed yet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac79dd3857ce4c179fcd1c449e4ec9b15" title="Returns the record layer size of the plaintext input. This is helpful when an application wants to kn...">wolfSSL_GetOutputSize</a> </dd></dl>

</div>
</div>
<a id="a9c180621143adc0d002e51e5626d9820" name="a9c180621143adc0d002e51e5626d9820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c180621143adc0d002e51e5626d9820">&#9670;&#160;</a></span>wolfSSL_GetObjectSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetObjectSize </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the size of the WOLFSSL object and will be dependent on build options and settings. If SHOW_SIZES has been defined when building wolfSSL, this function will also print the sizes of individual objects within the WOLFSSL object (Suites, Ciphers, etc.) to stdout. </p>
<dl class="section return"><dt>Returns</dt><dd>size This function returns the size of the WOLFSSL object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> size = 0;</div>
<div class="line">size = <a class="code hl_function" href="#a9c180621143adc0d002e51e5626d9820">wolfSSL_GetObjectSize</a>();</div>
<div class="line">printf(“sizeof(WOLFSSL) = %d\n”, size);</div>
<div class="ttc" id="assl_8h_html_a9c180621143adc0d002e51e5626d9820"><div class="ttname"><a href="#a9c180621143adc0d002e51e5626d9820">wolfSSL_GetObjectSize</a></div><div class="ttdeci">int wolfSSL_GetObjectSize(void)</div><div class="ttdoc">This function returns the size of the WOLFSSL object and will be dependent on build options and setti...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd></dl>

</div>
</div>
<a id="ac79dd3857ce4c179fcd1c449e4ec9b15" name="ac79dd3857ce4c179fcd1c449e4ec9b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79dd3857ce4c179fcd1c449e4ec9b15">&#9670;&#160;</a></span>wolfSSL_GetOutputSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetOutputSize </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the record layer size of the plaintext input. This is helpful when an application wants to know how many bytes will be sent across the Transport layer, given a specified plaintext input size. This function must be called after the SSL/TLS handshake has been completed. </p>
<dl class="section return"><dt>Returns</dt><dd>size Upon success, the requested size will be returned </dd>
<dd>
INPUT_SIZE_E will be returned if the input size is greater than the maximum TLS fragment size (see <a class="el" href="#a9ff204f2e651c5b998351a2cbb2ee1ff" title="Returns the maximum record layer size for plaintext data. This will correspond to either the maximum ...">wolfSSL_GetMaxOutputSize()</a>) </dd>
<dd>
BAD_FUNC_ARG will be returned upon invalid function argument, or if the SSL/TLS handshake has not been completed yet</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">inSz</td><td>size of plaintext data.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9ff204f2e651c5b998351a2cbb2ee1ff" title="Returns the maximum record layer size for plaintext data. This will correspond to either the maximum ...">wolfSSL_GetMaxOutputSize</a> </dd></dl>

</div>
</div>
<a id="af53698613a37216625d15568d2035f0a" name="af53698613a37216625d15568d2035f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53698613a37216625d15568d2035f0a">&#9670;&#160;</a></span>wolfSSL_GetRNG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WC_RNG * wolfSSL_GetRNG </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the random number. </p>
<dl class="section return"><dt>Returns</dt><dd>rng upon success. </dd>
<dd>
NULL if ssl is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#af53698613a37216625d15568d2035f0a">wolfSSL_GetRNG</a>(ssl);</div>
<div class="ttc" id="assl_8h_html_af53698613a37216625d15568d2035f0a"><div class="ttname"><a href="#af53698613a37216625d15568d2035f0a">wolfSSL_GetRNG</a></div><div class="ttdeci">WC_RNG * wolfSSL_GetRNG(WOLFSSL *ssl)</div><div class="ttdoc">This function retrieves the random number.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_CTX_new_rng </dd></dl>

</div>
</div>
<a id="a6610b35607255d7cdaf911e681f8559a" name="a6610b35607255d7cdaf911e681f8559a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6610b35607255d7cdaf911e681f8559a">&#9670;&#160;</a></span>wolfSSL_GetRsaDecCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetRsaDecCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key RSA Private Decrypt Callback Context previously stored with <a class="el" href="#a5e7d5db6deee59da336e3d399a62fb8f" title="Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx.">wolfSSL_SetRsaDecCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#af2d8a09019d57278c2f2079df3a9112d" title="Allows caller to set the Public Key Callback for RSA Private Decrypt. The callback should return the ...">wolfSSL_CTX_SetRsaDecCb</a> </dd>
<dd>
<a class="el" href="#a5e7d5db6deee59da336e3d399a62fb8f" title="Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx.">wolfSSL_SetRsaDecCtx</a> </dd></dl>

</div>
</div>
<a id="abce00333fd98f987d37b2ea6bc391c33" name="abce00333fd98f987d37b2ea6bc391c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce00333fd98f987d37b2ea6bc391c33">&#9670;&#160;</a></span>wolfSSL_GetRsaEncCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetRsaEncCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key RSA Public Encrypt Callback Context previously stored with <a class="el" href="#a1ffa93301f06d864f5e41f99104a4a2e" title="Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx.">wolfSSL_SetRsaEncCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8669fb775ff5541e6e4713ebb5e56f42" title="Allows caller to set the Public Key Callback for RSA Public Encrypt. The callback should return 0 for...">wolfSSL_CTX_SetRsaEncCb</a> </dd>
<dd>
<a class="el" href="#a1ffa93301f06d864f5e41f99104a4a2e" title="Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx.">wolfSSL_SetRsaEncCtx</a> </dd></dl>

</div>
</div>
<a id="a02c1b4c6be145f901e7abb2c3910b93c" name="a02c1b4c6be145f901e7abb2c3910b93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c1b4c6be145f901e7abb2c3910b93c">&#9670;&#160;</a></span>wolfSSL_GetRsaSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetRsaSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key RSA Signing Callback Context previously stored with <a class="el" href="#aff1829c6e4c7ed720774ed3a92881f1c" title="Allows caller to set the Public Key RSA Signing Callback Context to ctx.">wolfSSL_SetRsaSignCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters. </td></tr>
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a456c256848365be4a742b99b5a5cb84b" title="Allows caller to set the Public Key Callback for RSA Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetRsaSignCb</a> </dd>
<dd>
<a class="el" href="#aff1829c6e4c7ed720774ed3a92881f1c" title="Allows caller to set the Public Key RSA Signing Callback Context to ctx.">wolfSSL_SetRsaSignCtx</a> </dd></dl>

</div>
</div>
<a id="a0b3febe7a64aeb29f35674bcb32a3e8d" name="a0b3febe7a64aeb29f35674bcb32a3e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3febe7a64aeb29f35674bcb32a3e8d">&#9670;&#160;</a></span>wolfSSL_GetRsaVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetRsaVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to retrieve the Public Key RSA Verification Callback Context previously stored with <a class="el" href="#ae85c95865fb414c3f38d76cd2ac23606" title="Allows caller to set the Public Key RSA Verification Callback Context to ctx.">wolfSSL_SetRsaVerifyCtx()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the context. </dd>
<dd>
NULL will be returned for a blank context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a50a079dcac754ad333f983b943a9f587" title="Allows caller to set the Public Key Callback for RSA Verification. The callback should return the num...">wolfSSL_CTX_SetRsaVerifyCb</a> </dd>
<dd>
<a class="el" href="#ae85c95865fb414c3f38d76cd2ac23606" title="Allows caller to set the Public Key RSA Verification Callback Context to ctx.">wolfSSL_SetRsaVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="a77b2ad773cf98838d102cadfe6dee0e6" name="a77b2ad773cf98838d102cadfe6dee0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b2ad773cf98838d102cadfe6dee0e6">&#9670;&#160;</a></span>wolfSSL_GetServerWriteIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_GetServerWriteIV </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the server write IV (initialization vector) from the handshake process. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the IV. The size of the IV can be obtained from <a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666" title="Allows caller to determine the negotiated cipher block size from the handshake.">wolfSSL_GetCipherBlockSize()</a>. </dd>
<dd>
NULL will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a96a5d42c23ca6f18d8abb3440c986666" title="Allows caller to determine the negotiated cipher block size from the handshake.">wolfSSL_GetCipherBlockSize</a> </dd>
<dd>
<a class="el" href="#a7ac2b35288c4437dec64fdea3c1bcae0" title="Allows retrieval of the client write key from the handshake process.">wolfSSL_GetClientWriteKey</a> </dd></dl>

</div>
</div>
<a id="ab37a6477e56341a08aa1d45cff857904" name="ab37a6477e56341a08aa1d45cff857904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37a6477e56341a08aa1d45cff857904">&#9670;&#160;</a></span>wolfSSL_GetServerWriteKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * wolfSSL_GetServerWriteKey </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the server write key from the handshake process. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a valid pointer to the key. The size of the key can be obtained from <a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize()</a>. </dd>
<dd>
NULL will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6bcf1af4dd68c8f611fd18a21bca320f" title="Allows retrieval of the key size from the handshake process.">wolfSSL_GetKeySize</a> </dd>
<dd>
<a class="el" href="#a77b2ad773cf98838d102cadfe6dee0e6" title="Allows retrieval of the server write IV (initialization vector) from the handshake process.">wolfSSL_GetServerWriteIV</a> </dd></dl>

</div>
</div>
<a id="a2eee66c89a1e3288a75068faf329e47c" name="a2eee66c89a1e3288a75068faf329e47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee66c89a1e3288a75068faf329e47c">&#9670;&#160;</a></span>wolfSSL_GetSide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetSide </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows retrieval of the side of this WOLFSSL connection. </p>
<dl class="section return"><dt>Returns</dt><dd>success If successful the call will return either WOLFSSL_SERVER_END or WOLFSSL_CLIENT_END depending on the side of WOLFSSL object. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7ac2b35288c4437dec64fdea3c1bcae0" title="Allows retrieval of the client write key from the handshake process.">wolfSSL_GetClientWriteKey</a> </dd>
<dd>
<a class="el" href="#ab37a6477e56341a08aa1d45cff857904" title="Allows retrieval of the server write key from the handshake process.">wolfSSL_GetServerWriteKey</a> </dd></dl>

</div>
</div>
<a id="a82d11d0414fbd4b8e06f7ecbd2ac0295" name="a82d11d0414fbd4b8e06f7ecbd2ac0295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d11d0414fbd4b8e06f7ecbd2ac0295">&#9670;&#160;</a></span>wolfSSL_is_static_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_is_static_memory </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_MEM_CONN_STATS *</td>          <td class="paramname"><span class="paramname"><em>mem_stats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wolfSSL_is_static_memory is used to gather information about a SSL’s static memory usage. The return value indicates if static memory is being used and WOLFSSL_MEM_CONN_STATS will be filled out if and only if the flag WOLFMEM_TRACK_STATS was passed to the parent CTX when loading in static memory. </p>
<dl class="section return"><dt>Returns</dt><dd>1 is returned if using static memory for the CTX is true. </dd>
<dd>
0 is returned if not using static memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">mem_stats</td><td>structure to contain static memory usage.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL_MEM_CONN_STATS mem_stats;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="group__Memory.html#ga82d11d0414fbd4b8e06f7ecbd2ac0295">wolfSSL_is_static_memory</a>(ssl, mem_stats);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 1) {</div>
<div class="line">    <span class="comment">// handle case when is static memory</span></div>
<div class="line">    <span class="comment">// investigate elements in mem_stats if WOLFMEM_TRACK_STATS flag</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="agroup__Memory_html_ga82d11d0414fbd4b8e06f7ecbd2ac0295"><div class="ttname"><a href="group__Memory.html#ga82d11d0414fbd4b8e06f7ecbd2ac0295">wolfSSL_is_static_memory</a></div><div class="ttdeci">int wolfSSL_is_static_memory(WOLFSSL *ssl, WOLFSSL_MEM_CONN_STATS *mem_stats)</div><div class="ttdoc">wolfSSL_is_static_memory is used to gather information about a SSL’s static memory usage....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="#abfbe388005d1f6474e4a21131127369a" title="This function does not change any of the connections behavior and is used only for gathering informat...">wolfSSL_CTX_is_static_memory</a> </dd></dl>

</div>
</div>
<a id="a100e012b65e6f52ff52498aca3ca9828" name="a100e012b65e6f52ff52498aca3ca9828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100e012b65e6f52ff52498aca3ca9828">&#9670;&#160;</a></span>wolfSSL_IsTLSv1_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_IsTLSv1_1 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to determine if the negotiated protocol version is at least TLS version 1.1 or greater. </p>
<dl class="section return"><dt>Returns</dt><dd>true/false If successful the call will return 1 for true or 0 for false. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2eee66c89a1e3288a75068faf329e47c" title="Allows retrieval of the side of this WOLFSSL connection.">wolfSSL_GetSide</a> </dd></dl>

</div>
</div>
<a id="ae7e4756ce11b1803379dc9a121b2b954" name="ae7e4756ce11b1803379dc9a121b2b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e4756ce11b1803379dc9a121b2b954">&#9670;&#160;</a></span>wolfSSL_LoadCRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_LoadCRL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>monitor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper function that ends up calling LoadCRL to load the certificate for revocation checking. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS returned if the function and all of the subroutines executed without error. </dd>
<dd>
SSL_FATAL_ERROR returned if one of the subroutines does not return successfully. </dd>
<dd>
BAD_FUNC_ARG if the WOLFSSL_CERT_MANAGER or the WOLFSSL structure are NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">path</td><td>a constant character pointer that holds the path to the crl file. </td></tr>
    <tr><td class="paramname">type</td><td>an integer representing the type of certificate. </td></tr>
    <tr><td class="paramname">monitor</td><td>an integer variable used to verify the monitor path if requested.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* crlPemDir;</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ae7e4756ce11b1803379dc9a121b2b954">wolfSSL_LoadCRL</a>(ssl, crlPemDir, SSL_FILETYPE_PEM, 0) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case. Did not return SSL_SUCCESS.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ae7e4756ce11b1803379dc9a121b2b954"><div class="ttname"><a href="#ae7e4756ce11b1803379dc9a121b2b954">wolfSSL_LoadCRL</a></div><div class="ttdeci">int wolfSSL_LoadCRL(WOLFSSL *ssl, const char *path, int type, int monitor)</div><div class="ttdoc">A wrapper function that ends up calling LoadCRL to load the certificate for revocation checking.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga407833060925d7dd8366db3ca557ce8e" title="Error checks and passes through to LoadCRL() in order to load the cert into the CRL for revocation ch...">wolfSSL_CertManagerLoadCRL</a> </dd>
<dd>
<a class="el" href="group__CertManager.html#gaa0caa567b553f8417bca591cd18c9a25" title="Turns on Certificate Revocation List checking when verifying certificates with the Certificate Manage...">wolfSSL_CertManagerEnableCRL</a> </dd>
<dd>
LoadCRL </dd></dl>

</div>
</div>
<a id="a61e37b570331e89d27ef01988c57d5aa" name="a61e37b570331e89d27ef01988c57d5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e37b570331e89d27ef01988c57d5aa">&#9670;&#160;</a></span>wolfSSL_RSA_sign_generic_padding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_RSA_sign_generic_padding </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>mLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>sigRet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>sigLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_RSA *</td>          <td class="paramname"><span class="paramname"><em>rsa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>padding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a message with the chosen message digest, padding, and RSA key. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS on success and c on error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Hash NID </td></tr>
    <tr><td class="paramname">m</td><td>Message to sign. Most likely this will be the digest of the message to sign </td></tr>
    <tr><td class="paramname">mLen</td><td>Length of message to sign </td></tr>
    <tr><td class="paramname">sigRet</td><td>Output buffer </td></tr>
    <tr><td class="paramname">sigLen</td><td>On Input: length of sigRet buffer On Output: length of data written to sigRet </td></tr>
    <tr><td class="paramname">rsa</td><td>RSA key used to sign the input </td></tr>
    <tr><td class="paramname">flag</td><td>1: Output the signature 0: Output the value that the unpadded signature should be compared to. Note: for RSA_PKCS1_PSS_PADDING the wc_RsaPSS_CheckPadding_ex function should be used to check the output of a <em>Verify</em> function. </td></tr>
    <tr><td class="paramname">padding</td><td>Padding to use. Only RSA_PKCS1_PSS_PADDING and RSA_PKCS1_PADDING are currently supported for signing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e568d0d4f32e2de793feab3204695d1" name="a1e568d0d4f32e2de793feab3204695d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e568d0d4f32e2de793feab3204695d1">&#9670;&#160;</a></span>wolfSSL_send_SessionTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_send_SessionTicket </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends a session ticket to the client after a TLS v1.3 handhsake has been established. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS returned if a new session ticket was sent. </dd>
<dd>
BAD_FUNC_ARG returned if WOLFSSL structure is NULL, or not using TLS v1.3. </dd>
<dd>
SIDE_ERROR returned if not a server. </dd>
<dd>
NOT_READY_ERROR returned if the handshake has not completed. </dd>
<dd>
WOLFSSL_FATAL_ERROR returned if creating or sending message fails.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#a1e568d0d4f32e2de793feab3204695d1">wolfSSL_send_SessionTicket</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// New session ticket not sent.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a1e568d0d4f32e2de793feab3204695d1"><div class="ttname"><a href="#a1e568d0d4f32e2de793feab3204695d1">wolfSSL_send_SessionTicket</a></div><div class="ttdeci">int wolfSSL_send_SessionTicket(WOLFSSL *ssl)</div><div class="ttdoc">This function sends a session ticket to the client after a TLS v1.3 handhsake has been established.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__IO.html#gab67e2593987cfe2a20c660440c087576" title="This function copies the ticket member of the Session structure to the buffer. If buf is NULL and buf...">wolfSSL_get_SessionTicket</a> </dd>
<dd>
CallbackSessionTicket </dd>
<dd>
sessionTicketCB </dd></dl>

</div>
</div>
<a id="a00368a4d60ecb4f606103ec94c353e3f" name="a00368a4d60ecb4f606103ec94c353e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00368a4d60ecb4f606103ec94c353e3f">&#9670;&#160;</a></span>wolfSSL_SESSION_get_max_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int wolfSSL_SESSION_get_max_early_data </td>
          <td>(</td>
          <td class="paramtype">const WOLFSSL_SESSION *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum size of Early Data from a session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>the WOLFSSL_SESSION instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of max_early_data that was configured in the WOLFSSL* the session was derived from.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga8f2489e4651943fcc2dd45196377a2b1" title="This function sets the maximum amount of early data that a TLS v1.3 client or server is willing to ex...">wolfSSL_set_max_early_data</a> </dd>
<dd>
<a class="el" href="group__IO.html#gade058c507ad769c52e508e5ddf7c2a94" title="This function writes early data to the server on resumption. Call this function instead of wolfSSL_co...">wolfSSL_write_early_data</a> </dd>
<dd>
<a class="el" href="group__IO.html#ga218900890eae44f86614e3c54f0f02ab" title="This function reads any early data from a client on resumption. Call this function instead of wolfSSL...">wolfSSL_read_early_data</a> </dd></dl>

</div>
</div>
<a id="ad3b2ce849382c9f86275de47af4c38c5" name="ad3b2ce849382c9f86275de47af4c38c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b2ce849382c9f86275de47af4c38c5">&#9670;&#160;</a></span>wolfSSL_set_ephemeral_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_ephemeral_key </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keyAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>keySz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a fixed / static ephemeral key for testing only. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Key loaded successfully </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>A WOLFSSL object pointer </td></tr>
    <tr><td class="paramname">keyAlgo</td><td>enum wc_PkType like WC_PK_TYPE_DH and WC_PK_TYPE_ECDH </td></tr>
    <tr><td class="paramname">key</td><td>key file path (if keySz == 0) or actual key buffer (PEM or ASN.1) </td></tr>
    <tr><td class="paramname">keySz</td><td>key size (should be 0 for "key" arg is file path) </td></tr>
    <tr><td class="paramname">format</td><td>WOLFSSL_FILETYPE_ASN1 or WOLFSSL_FILETYPE_PEM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a48e4dcab8f599fec761f55a3c91a0e7b" title="This function returns pointer to loaded key as ASN.1/DER.">wolfSSL_get_ephemeral_key</a> </dd></dl>

</div>
</div>
<a id="a25324f17616aca4bf3b70fd872a83031" name="a25324f17616aca4bf3b70fd872a83031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25324f17616aca4bf3b70fd872a83031">&#9670;&#160;</a></span>wolfSSL_set_psk_callback_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_psk_callback_ctx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>psk_ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a PSK user context in the WOLFSSL structure options member. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS or WOLFSSL_FAILURE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">psk_ctx</td><td>void pointer to user PSK context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22d011e8be92a7e5c025fd0da355c12e" title="Get a PSK user context in the WOLFSSL structure options member.">wolfSSL_get_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#ac8862b6583b25e63d7279929f9f96ffc" title="Sets a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_callback_ctx</a> </dd>
<dd>
<a class="el" href="#a579ed69665d9aa441c281b5716198ca4" title="Get a PSK user context in the WOLFSSL_CTX structure.">wolfSSL_CTX_get_psk_callback_ctx</a> </dd></dl>

</div>
</div>
<a id="a7eccdf80887061a222c904e0531bf516" name="a7eccdf80887061a222c904e0531bf516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eccdf80887061a222c904e0531bf516">&#9670;&#160;</a></span>wolfSSL_set_psk_client_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_set_psk_client_callback </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_psk_client_callback</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PSK client side callback. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer to type wc_psk_client_callback. Return value is the key length on success or zero on error. unsigned int (<em>wc_psk_client_callback) PSK client callback parameters: WOLFSSL</em> ssl - Pointer to the wolfSSL structure const char* hint - A stored string that could be displayed to provide a hint to the user. char* identity - The ID will be stored here. unsigned int id_max_len - Size of the ID buffer. unsigned char* key - The key will be stored here. unsigned int key_max_len - The max size of the key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keyword">static</span> WC_INLINE <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_psk_client_cb(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">char</span>* hint,</div>
<div class="line"><span class="keywordtype">char</span>* identity, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_max_len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* key,</div>
<div class="line">Unsigned <span class="keywordtype">int</span> key_max_len){</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(ssl){</div>
<div class="line"><a class="code hl_function" href="#a7eccdf80887061a222c904e0531bf516">wolfSSL_set_psk_client_callback</a>(ssl, my_psk_client_cb);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// could not set callback</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a7eccdf80887061a222c904e0531bf516"><div class="ttname"><a href="#a7eccdf80887061a222c904e0531bf516">wolfSSL_set_psk_client_callback</a></div><div class="ttdeci">void wolfSSL_set_psk_client_callback(WOLFSSL *ssl, wc_psk_client_callback)</div><div class="ttdoc">Sets the PSK client side callback.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#afb48159280dafa4a58a0f9f7da96cb65" title="The function sets the client_psk_cb member of the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_client_callback</a> </dd>
<dd>
<a class="el" href="#aa22b4232a9bc1e4f2d4ea10c71af8521" title="This function sets the psk callback for the server side in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_server_callback</a> </dd>
<dd>
<a class="el" href="#a2fb471b8b706f1c85fa53c46220c9d5d" title="Sets the psk callback for the server side by setting the WOLFSSL structure options members.">wolfSSL_set_psk_server_callback</a> </dd></dl>

</div>
</div>
<a id="a2fb471b8b706f1c85fa53c46220c9d5d" name="a2fb471b8b706f1c85fa53c46220c9d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb471b8b706f1c85fa53c46220c9d5d">&#9670;&#160;</a></span>wolfSSL_set_psk_server_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_set_psk_server_callback </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wc_psk_server_callback</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the psk callback for the server side by setting the WOLFSSL structure options members. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer for the callback and will be stored in the WOLFSSL structure. Return value is the key length on success or zero on error. unsigned int (<em>wc_psk_server_callback) PSK server callback parameters WOLFSSL</em> ssl - Pointer to the wolfSSL structure char* identity - The ID will be stored here. unsigned char* key - The key will be stored here. unsigned int key_max_len - The max size of the key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">…</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_psk_server_cb(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">char</span>* identity,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* key, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_max_len)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Function body.</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(ssl != NULL &amp;&amp; cb != NULL){</div>
<div class="line">    <a class="code hl_function" href="#a2fb471b8b706f1c85fa53c46220c9d5d">wolfSSL_set_psk_server_callback</a>(ssl, my_psk_server_cb);</div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a2fb471b8b706f1c85fa53c46220c9d5d"><div class="ttname"><a href="#a2fb471b8b706f1c85fa53c46220c9d5d">wolfSSL_set_psk_server_callback</a></div><div class="ttdeci">void wolfSSL_set_psk_server_callback(WOLFSSL *ssl, wc_psk_server_callback cb)</div><div class="ttdoc">Sets the psk callback for the server side by setting the WOLFSSL structure options members.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7eccdf80887061a222c904e0531bf516" title="Sets the PSK client side callback.">wolfSSL_set_psk_client_callback</a> </dd>
<dd>
<a class="el" href="#aa22b4232a9bc1e4f2d4ea10c71af8521" title="This function sets the psk callback for the server side in the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_server_callback</a> </dd>
<dd>
<a class="el" href="#afb48159280dafa4a58a0f9f7da96cb65" title="The function sets the client_psk_cb member of the WOLFSSL_CTX structure.">wolfSSL_CTX_set_psk_client_callback</a> </dd>
<dd>
<a class="el" href="group__CertsKeys.html#ga4dba2642424095dff3b5c6df7ddec52d" title="This function returns the psk identity hint.">wolfSSL_get_psk_identity_hint</a> </dd>
<dd>
wc_psk_server_callback </dd>
<dd>
InitSuites </dd></dl>

</div>
</div>
<a id="a1b29e3dd5cd00ad2802f081109cb3da1" name="a1b29e3dd5cd00ad2802f081109cb3da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b29e3dd5cd00ad2802f081109cb3da1">&#9670;&#160;</a></span>wolfSSL_set_session_secret_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_session_secret_cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SessionSecretCb</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the session secret callback function. The SessionSecretCb type has the signature: int (<em>SessionSecretCb)(WOLFSSL</em> ssl, void* secret, int* secretSz, void* ctx). The sessionSecretCb member of the WOLFSSL struct is set to the parameter cb. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the execution of the function did not return an error. </dd>
<dd>
SSL_FATAL_ERROR returned if the WOLFSSL structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a SessionSecretCb type that is a function pointer with the above signature. </td></tr>
    <tr><td class="paramname">ctx</td><td>a pointer to the user context to be stored</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="comment">// Signature of SessionSecretCb</span></div>
<div class="line"><span class="keywordtype">int</span> SessionSecretCB (WOLFSSL* ssl, <span class="keywordtype">void</span>* secret, <span class="keywordtype">int</span>* secretSz,</div>
<div class="line"><span class="keywordtype">void</span>* ctx) = SessionSecretCb;</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="#a1b29e3dd5cd00ad2802f081109cb3da1">wolfSSL_set_session_secret_cb</a>(ssl, SessionSecretCB, (<span class="keywordtype">void</span>*)ssl-&gt;ctx){</div>
<div class="line">    <span class="comment">// Function body.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a1b29e3dd5cd00ad2802f081109cb3da1"><div class="ttname"><a href="#a1b29e3dd5cd00ad2802f081109cb3da1">wolfSSL_set_session_secret_cb</a></div><div class="ttdeci">int wolfSSL_set_session_secret_cb(WOLFSSL *ssl, SessionSecretCb cb, void *ctx)</div><div class="ttdoc">This function sets the session secret callback function. The SessionSecretCb type has the signature: ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>SessionSecretCb </dd></dl>

</div>
</div>
<a id="a30b45a56db4091b9d9aec551ba659786" name="a30b45a56db4091b9d9aec551ba659786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b45a56db4091b9d9aec551ba659786">&#9670;&#160;</a></span>wolfSSL_set_SessionTicket_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_SessionTicket_cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackSessionTicket</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the session ticket callback. The type CallbackSessionTicket is a function pointer with the signature of: int (<em>CallbackSessionTicket)(WOLFSSL</em>, const unsigned char*, int, void*) </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer to the type CallbackSessionTicket. </td></tr>
    <tr><td class="paramname">ctx</td><td>a void pointer to the session_ticket_ctx member of the WOLFSSL structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> sessionTicketCB(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ticket, <span class="keywordtype">int</span> ticketSz,</div>
<div class="line">            <span class="keywordtype">void</span>* ctx){ … }</div>
<div class="line"><a class="code hl_function" href="#a30b45a56db4091b9d9aec551ba659786">wolfSSL_set_SessionTicket_cb</a>(ssl, sessionTicketCB, (<span class="keywordtype">void</span>*)”initial session”);</div>
<div class="ttc" id="assl_8h_html_a30b45a56db4091b9d9aec551ba659786"><div class="ttname"><a href="#a30b45a56db4091b9d9aec551ba659786">wolfSSL_set_SessionTicket_cb</a></div><div class="ttdeci">int wolfSSL_set_SessionTicket_cb(WOLFSSL *ssl, CallbackSessionTicket cb, void *ctx)</div><div class="ttdoc">This function sets the session ticket callback. The type CallbackSessionTicket is a function pointer ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__IO.html#gab67e2593987cfe2a20c660440c087576" title="This function copies the ticket member of the Session structure to the buffer. If buf is NULL and buf...">wolfSSL_get_SessionTicket</a> </dd>
<dd>
CallbackSessionTicket </dd>
<dd>
sessionTicketCB </dd></dl>

</div>
</div>
<a id="a761a40b527f38ba2df833fe8b51a8408" name="a761a40b527f38ba2df833fe8b51a8408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761a40b527f38ba2df833fe8b51a8408">&#9670;&#160;</a></span>wolfSSL_SetCRL_Cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetCRL_Cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbMissingCRL</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CRL callback in the WOLFSSL_CERT_MANAGER structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function or subroutine executes without error. The cbMissingCRL member of the WOLFSSL_CERT_MANAGER is set. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL or WOLFSSL_CERT_MANAGER structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer to CbMissingCRL.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">void</span> cb(<span class="keyword">const</span> <span class="keywordtype">char</span>* url) <span class="comment">// required signature</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Function body</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> crlCb = <a class="code hl_function" href="#a761a40b527f38ba2df833fe8b51a8408">wolfSSL_SetCRL_Cb</a>(ssl, cb);</div>
<div class="line"><span class="keywordflow">if</span>(crlCb != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// The callback was not set properly</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a761a40b527f38ba2df833fe8b51a8408"><div class="ttname"><a href="#a761a40b527f38ba2df833fe8b51a8408">wolfSSL_SetCRL_Cb</a></div><div class="ttdeci">int wolfSSL_SetCRL_Cb(WOLFSSL *ssl, CbMissingCRL cb)</div><div class="ttdoc">Sets the CRL callback in the WOLFSSL_CERT_MANAGER structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>CbMissingCRL </dd>
<dd>
<a class="el" href="group__CertManager.html#ga4929fe270fdc7cf0bdfca82d2c8a88ef" title="This function sets the CRL Certificate Manager callback. If HAVE_CRL is defined and a matching CRL re...">wolfSSL_CertManagerSetCRL_Cb</a> </dd></dl>

</div>
</div>
<a id="a93021a9151fd3af1121b0380e87403d1" name="a93021a9151fd3af1121b0380e87403d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93021a9151fd3af1121b0380e87403d1">&#9670;&#160;</a></span>wolfSSL_SetDecryptVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetDecryptVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5f636c2e3517c2bb054d5bb50924b352" title="Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback. The callback should r...">wolfSSL_CTX_SetDecryptVerifyCb</a> </dd>
<dd>
<a class="el" href="#a9cb89582080d65c25d65e70d9cec646c" title="Allows caller to retrieve the Atomic User Record Processing Decrypt/Verify Callback Context previousl...">wolfSSL_GetDecryptVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="a706356ae2ac664740d36b2a53abe5c36" name="a706356ae2ac664740d36b2a53abe5c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706356ae2ac664740d36b2a53abe5c36">&#9670;&#160;</a></span>wolfSSL_SetDevId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetDevId </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>devId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Device Id at the WOLFSSL session level. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG if ssl is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">devId</td><td>ID to use with crypto callbacks or async hardware. Set to INVALID_DEVID (-2) if not used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> DevId = -2;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#a706356ae2ac664740d36b2a53abe5c36">wolfSSL_SetDevId</a>(ssl, devId);</div>
<div class="ttc" id="assl_8h_html_a706356ae2ac664740d36b2a53abe5c36"><div class="ttname"><a href="#a706356ae2ac664740d36b2a53abe5c36">wolfSSL_SetDevId</a></div><div class="ttdeci">int wolfSSL_SetDevId(WOLFSSL *ssl, int devId)</div><div class="ttdoc">This function sets the Device Id at the WOLFSSL session level.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4eb1f02e6f8e0d20e7739c81478f0930" title="This function sets the Device Id at the WOLFSSL_CTX context level.">wolfSSL_CTX_SetDevId</a> </dd>
<dd>
<a class="el" href="#a0950b92f3358093047d4e2a7bd744b9e" title="This function retrieves the Device Id.">wolfSSL_CTX_GetDevId</a> </dd></dl>

</div>
</div>
<a id="a3f65634376fab1d6d61c6d998b2cc3ab" name="a3f65634376fab1d6d61c6d998b2cc3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f65634376fab1d6d61c6d998b2cc3ab">&#9670;&#160;</a></span>wolfSSL_SetEccSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetEccSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Ecc Signing Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL object, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">ctx</td><td>a pointer to the user context to be stored</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aee3ccfce4e8b5aa1a2ccfbb447365dfb" title="Allows caller to set the Public Key Callback for ECC Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetEccSignCb</a> </dd>
<dd>
<a class="el" href="#ac731df86e30f87e7823a7da59b461adb" title="Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with wolfSSL_...">wolfSSL_GetEccSignCtx</a> </dd></dl>

</div>
</div>
<a id="a1c89bf6fc378bfbf8c0559b4e6c820e1" name="a1c89bf6fc378bfbf8c0559b4e6c820e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c89bf6fc378bfbf8c0559b4e6c820e1">&#9670;&#160;</a></span>wolfSSL_SetEccVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetEccVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key Ecc Verification Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab58ec34fc70378f3be1a8035637091eb" title="Allows caller to set the Public Key Callback for ECC Verification. The callback should return 0 for s...">wolfSSL_CTX_SetEccVerifyCb</a> </dd>
<dd>
<a class="el" href="#ace78694804dc9bc862904b78ef73d40d" title="Allows caller to retrieve the Public Key Ecc Verification Callback Context previously stored with wol...">wolfSSL_GetEccVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="a15e9a047ad453f7c4bd66177fb2fe9dd" name="a15e9a047ad453f7c4bd66177fb2fe9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e9a047ad453f7c4bd66177fb2fe9dd">&#9670;&#160;</a></span>wolfSSL_SetFuzzerCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetFuzzerCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackFuzzer</td>          <td class="paramname"><span class="paramname"><em>cbf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>fCtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the fuzzer callback. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cbf</td><td>a CallbackFuzzer type that is a function pointer of the form: int (<em>CallbackFuzzer)(WOLFSSL</em> ssl, const unsigned char* buf, int sz, int type, void* fuzzCtx); </td></tr>
    <tr><td class="paramname">fCtx</td><td>a void pointer type that will be set to the fuzzerCtx member of the WOLFSSL structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">void</span>* fCtx;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> callbackFuzzerCB(WOLFSSL* ssl, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">int</span> sz,</div>
<div class="line">            <span class="keywordtype">int</span> type, <span class="keywordtype">void</span>* fuzzCtx){</div>
<div class="line"><span class="comment">// function definition</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><a class="code hl_function" href="#a15e9a047ad453f7c4bd66177fb2fe9dd">wolfSSL_SetFuzzerCb</a>(ssl, callbackFuzzerCB, fCtx);</div>
<div class="ttc" id="assl_8h_html_a15e9a047ad453f7c4bd66177fb2fe9dd"><div class="ttname"><a href="#a15e9a047ad453f7c4bd66177fb2fe9dd">wolfSSL_SetFuzzerCb</a></div><div class="ttdeci">void wolfSSL_SetFuzzerCb(WOLFSSL *ssl, CallbackFuzzer cbf, void *fCtx)</div><div class="ttdoc">This function sets the fuzzer callback.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>CallbackFuzzer </dd></dl>

</div>
</div>
<a id="a84b8004f9fda96c4d2257b5b13372ff9" name="a84b8004f9fda96c4d2257b5b13372ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8004f9fda96c4d2257b5b13372ff9">&#9670;&#160;</a></span>wolfSSL_SetHsDoneCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetHsDoneCb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandShakeDoneCb</td>          <td class="paramname"><span class="paramname"><em>cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handshake done callback. The hsDoneCb and hsDoneCtx members of the WOLFSSL structure are set in this function. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without an error. The hsDoneCb and hsDoneCtx members of the WOLFSSL struct are set. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>a function pointer of type HandShakeDoneCb with the signature of the form: int (<em>HandShakeDoneCb)(WOLFSSL</em>, void*); </td></tr>
    <tr><td class="paramname">user_ctx</td><td>a void pointer to the user registered context.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> myHsDoneCb(WOLFSSL* ssl, <span class="keywordtype">void</span>* user_ctx){</div>
<div class="line">    <span class="comment">// callback function</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><a class="code hl_function" href="#a84b8004f9fda96c4d2257b5b13372ff9">wolfSSL_SetHsDoneCb</a>(ssl, myHsDoneCb, NULL);</div>
<div class="ttc" id="assl_8h_html_a84b8004f9fda96c4d2257b5b13372ff9"><div class="ttname"><a href="#a84b8004f9fda96c4d2257b5b13372ff9">wolfSSL_SetHsDoneCb</a></div><div class="ttdeci">int wolfSSL_SetHsDoneCb(WOLFSSL *ssl, HandShakeDoneCb cb, void *user_ctx)</div><div class="ttdoc">This function sets the handshake done callback. The hsDoneCb and hsDoneCtx members of the WOLFSSL str...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>HandShakeDoneCb </dd></dl>

</div>
</div>
<a id="abf7ef9ed1a7b36f3c98447a28cd075c4" name="abf7ef9ed1a7b36f3c98447a28cd075c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7ef9ed1a7b36f3c98447a28cd075c4">&#9670;&#160;</a></span>wolfSSL_SetMacEncryptCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetMacEncryptCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac48d6f657d683557e23f9ce388488039" title="Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback. The callback should retu...">wolfSSL_CTX_SetMacEncryptCb</a> </dd>
<dd>
<a class="el" href="#a84e59d1c4a3f24ff5ece668e922d7548" title="Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously s...">wolfSSL_GetMacEncryptCtx</a> </dd></dl>

</div>
</div>
<a id="a6eb9a96acfa1bedbcdbc4e89fbb8a43a" name="a6eb9a96acfa1bedbcdbc4e89fbb8a43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb9a96acfa1bedbcdbc4e89fbb8a43a">&#9670;&#160;</a></span>wolfSSL_SetOCSP_Cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetOCSP_Cb </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbOCSPIO</td>          <td class="paramname"><span class="paramname"><em>ioCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CbOCSPRespFree</td>          <td class="paramname"><span class="paramname"><em>respFreeCb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ioCbCtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the OCSP callback in the WOLFSSL_CERT_MANAGER structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executes without error. The ocspIOCb, ocspRespFreeCb, and ocspIOCtx members of the CM are set. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL or WOLFSSL_CERT_MANAGER structures are NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">ioCb</td><td>a function pointer to type CbOCSPIO. </td></tr>
    <tr><td class="paramname">respFreeCb</td><td>a function pointer to type CbOCSPRespFree which is the call to free the response memory. </td></tr>
    <tr><td class="paramname">ioCbCtx</td><td>a void pointer that will be held in the ocspIOCtx member of the CM.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">int</span> OCSPIO_CB(<span class="keywordtype">void</span>* , <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">int</span> , <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* , <span class="keywordtype">int</span>,</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>**){  <span class="comment">// must have this signature</span></div>
<div class="line"><span class="comment">// Function Body</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">void</span> OCSPRespFree_CB(<span class="keywordtype">void</span>* , <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ){ <span class="comment">// must have this signature</span></div>
<div class="line">    <span class="comment">// function body</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">void</span>* ioCbCtx;</div>
<div class="line">CbOCSPRespFree CB_OCSPRespFree;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#a6eb9a96acfa1bedbcdbc4e89fbb8a43a">wolfSSL_SetOCSP_Cb</a>(ssl, OCSPIO_CB( pass args ), CB_OCSPRespFree,</div>
<div class="line">            ioCbCtx) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Callback not set</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a6eb9a96acfa1bedbcdbc4e89fbb8a43a"><div class="ttname"><a href="#a6eb9a96acfa1bedbcdbc4e89fbb8a43a">wolfSSL_SetOCSP_Cb</a></div><div class="ttdeci">int wolfSSL_SetOCSP_Cb(WOLFSSL *ssl, CbOCSPIO ioCb, CbOCSPRespFree respFreeCb, void *ioCbCtx)</div><div class="ttdoc">This function sets the OCSP callback in the WOLFSSL_CERT_MANAGER structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#ga40598eacaa03af2e003e95f57ddd30a9" title="The function sets the OCSP callback in the WOLFSSL_CERT_MANAGER.">wolfSSL_CertManagerSetOCSP_Cb</a> </dd>
<dd>
CbOCSPIO </dd>
<dd>
CbOCSPRespFree </dd></dl>

</div>
</div>
<a id="adecc0f6f1d5156e7e0e2ca364fffecd4" name="adecc0f6f1d5156e7e0e2ca364fffecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecc0f6f1d5156e7e0e2ca364fffecd4">&#9670;&#160;</a></span>wolfSSL_SetOCSP_OverrideURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetOCSP_OverrideURL </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>url</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the ocspOverrideURL member in the WOLFSSL_CERT_MANAGER structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned on successful execution of the function. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL struct is NULL or if a unpermitted argument was passed to a subroutine. </dd>
<dd>
MEMORY_E returned if there was an error allocating memory in the subroutine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">url</td><td>a constant char pointer to the url that will be stored in the ocspOverrideURL member of the WOLFSSL_CERT_MANAGER structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">char</span> url[URLSZ];</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#adecc0f6f1d5156e7e0e2ca364fffecd4">wolfSSL_SetOCSP_OverrideURL</a>(ssl, url)){</div>
<div class="line">    <span class="comment">// The override url is set to the new value</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_adecc0f6f1d5156e7e0e2ca364fffecd4"><div class="ttname"><a href="#adecc0f6f1d5156e7e0e2ca364fffecd4">wolfSSL_SetOCSP_OverrideURL</a></div><div class="ttdeci">int wolfSSL_SetOCSP_OverrideURL(WOLFSSL *ssl, const char *url)</div><div class="ttdoc">This function sets the ocspOverrideURL member in the WOLFSSL_CERT_MANAGER structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertManager.html#gaae16a6566a0a4ac899ca94e8b9869158" title="The function copies the url to the ocspOverrideURL member of the WOLFSSL_CERT_MANAGER structure.">wolfSSL_CertManagerSetOCSPOverrideURL</a> </dd></dl>

</div>
</div>
<a id="a5e7d5db6deee59da336e3d399a62fb8f" name="a5e7d5db6deee59da336e3d399a62fb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7d5db6deee59da336e3d399a62fb8f">&#9670;&#160;</a></span>wolfSSL_SetRsaDecCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetRsaDecCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key RSA Private Decrypt Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#af2d8a09019d57278c2f2079df3a9112d" title="Allows caller to set the Public Key Callback for RSA Private Decrypt. The callback should return the ...">wolfSSL_CTX_SetRsaDecCb</a> </dd>
<dd>
<a class="el" href="#a6610b35607255d7cdaf911e681f8559a" title="Allows caller to retrieve the Public Key RSA Private Decrypt Callback Context previously stored with ...">wolfSSL_GetRsaDecCtx</a> </dd></dl>

</div>
</div>
<a id="a1ffa93301f06d864f5e41f99104a4a2e" name="a1ffa93301f06d864f5e41f99104a4a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa93301f06d864f5e41f99104a4a2e">&#9670;&#160;</a></span>wolfSSL_SetRsaEncCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetRsaEncCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key RSA Public Encrypt Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8669fb775ff5541e6e4713ebb5e56f42" title="Allows caller to set the Public Key Callback for RSA Public Encrypt. The callback should return 0 for...">wolfSSL_CTX_SetRsaEncCb</a> </dd>
<dd>
<a class="el" href="#abce00333fd98f987d37b2ea6bc391c33" title="Allows caller to retrieve the Public Key RSA Public Encrypt Callback Context previously stored with w...">wolfSSL_GetRsaEncCtx</a> </dd></dl>

</div>
</div>
<a id="aff1829c6e4c7ed720774ed3a92881f1c" name="aff1829c6e4c7ed720774ed3a92881f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1829c6e4c7ed720774ed3a92881f1c">&#9670;&#160;</a></span>wolfSSL_SetRsaSignCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetRsaSignCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key RSA Signing Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No Returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a456c256848365be4a742b99b5a5cb84b" title="Allows caller to set the Public Key Callback for RSA Signing. The callback should return 0 for succes...">wolfSSL_CTX_SetRsaSignCb</a> </dd>
<dd>
<a class="el" href="#a02c1b4c6be145f901e7abb2c3910b93c" title="Allows caller to retrieve the Public Key RSA Signing Callback Context previously stored with wolfSSL_...">wolfSSL_GetRsaSignCtx</a> </dd></dl>

</div>
</div>
<a id="ae85c95865fb414c3f38d76cd2ac23606" name="ae85c95865fb414c3f38d76cd2ac23606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85c95865fb414c3f38d76cd2ac23606">&#9670;&#160;</a></span>wolfSSL_SetRsaVerifyCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetRsaVerifyCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Public Key RSA Verification Callback Context to ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a50a079dcac754ad333f983b943a9f587" title="Allows caller to set the Public Key Callback for RSA Verification. The callback should return the num...">wolfSSL_CTX_SetRsaVerifyCb</a> </dd>
<dd>
<a class="el" href="#a0b3febe7a64aeb29f35674bcb32a3e8d" title="Allows caller to retrieve the Public Key RSA Verification Callback Context previously stored with wol...">wolfSSL_GetRsaVerifyCtx</a> </dd></dl>

</div>
</div>
<a id="acdba6b6ac9c948dd82c3d3a8ed256595" name="acdba6b6ac9c948dd82c3d3a8ed256595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdba6b6ac9c948dd82c3d3a8ed256595">&#9670;&#160;</a></span>wolfSSL_SetTlsHmacInner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SetTlsHmacInner </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>inner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>verify</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows caller to set the Hmac Inner vector for message sending/receiving. The result is written to inner which should be at least <a class="el" href="#aa551e5b8c1a784fef36bff7c436ff9e2" title="Allows caller to determine the negotiated (h)mac size from the handshake. For cipher types except WOL...">wolfSSL_GetHmacSize()</a> bytes. The size of the message is specified by sz, content is the type of message, and verify specifies whether this is a verification of a peer message. Valid for cipher types excluding WOLFSSL_AEAD_TYPE. </p>
<dl class="section return"><dt>Returns</dt><dd>1 upon success. </dd>
<dd>
BAD_FUNC_ARG will be returned for an error state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a36b767ad63997d29a4d209f6e2c9560e" title="Allows caller to determine the negotiated bulk cipher algorithm from the handshake.">wolfSSL_GetBulkCipher</a> </dd>
<dd>
<a class="el" href="#a081b82271e2a276bef3434b15f65f5dc" title="Allows caller to determine the negotiated (h)mac type from the handshake. For cipher types except WOL...">wolfSSL_GetHmacType</a> </dd></dl>

</div>
</div>
<a id="a5210e395ecc885734ab8c883b62629a6" name="a5210e395ecc885734ab8c883b62629a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5210e395ecc885734ab8c883b62629a6">&#9670;&#160;</a></span>wolfSSL_SNI_GetFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_SNI_GetFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>clientHello</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>helloSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>sni</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>inOutSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side to retrieve the Server Name Indication provided by the client from the Client Hello message sent by the client to start a session. It does not requires context or session setup to retrieve the SNI. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of this cases: buffer is NULL, bufferSz &lt;= 0, sni is NULL, inOutSz is NULL or &lt;= 0 </dd>
<dd>
BUFFER_ERROR is the error returned when there is a malformed Client Hello message. </dd>
<dd>
INCOMPLETE_DATA is the error returned when there is not enough data to complete the extraction.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>pointer to the data provided by the client (Client Hello). </td></tr>
    <tr><td class="paramname">bufferSz</td><td>size of the Client Hello message. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been retrieved from the buffer. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">sni</td><td>pointer to where the output is going to be stored. </td></tr>
    <tr><td class="paramname">inOutSz</td><td>pointer to the output size, this value will be updated to MIN("SNI's length", inOutSz).</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[1024] = {0};</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> result[32]   = {0};</div>
<div class="line"><span class="keywordtype">int</span>           length       = 32;</div>
<div class="line"><span class="comment">// read Client Hello to buffer...</span></div>
<div class="line">ret = <a class="code hl_function" href="#a5210e395ecc885734ab8c883b62629a6">wolfSSL_SNI_GetFromBuffer</a>(buffer, <span class="keyword">sizeof</span>(buffer), 0, result, &amp;length));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni retrieve failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a5210e395ecc885734ab8c883b62629a6"><div class="ttname"><a href="#a5210e395ecc885734ab8c883b62629a6">wolfSSL_SNI_GetFromBuffer</a></div><div class="ttdeci">int wolfSSL_SNI_GetFromBuffer(const unsigned char *clientHello, unsigned int helloSz, unsigned char type, unsigned char *sni, unsigned int *inOutSz)</div><div class="ttdoc">This function is called on the server side to retrieve the Server Name Indication provided by the cli...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a871070b101b579dc4663217b1c3fbcd4" title="This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; paramet...">wolfSSL_UseSNI</a> </dd>
<dd>
<a class="el" href="#a7e2d400ffb4172eb91e284951a4ae091" title="This function enables the use of Server Name Indication for SSL objects created from the SSL context ...">wolfSSL_CTX_UseSNI</a> </dd>
<dd>
<a class="el" href="#a9c1a89c721bf16874bf84f1e77042d6c" title="This function is called on the server side to retrieve the Server Name Indication provided by the cli...">wolfSSL_SNI_GetRequest</a> </dd></dl>

</div>
</div>
<a id="a9c1a89c721bf16874bf84f1e77042d6c" name="a9c1a89c721bf16874bf84f1e77042d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1a89c721bf16874bf84f1e77042d6c">&#9670;&#160;</a></span>wolfSSL_SNI_GetRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short wolfSSL_SNI_GetRequest </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side to retrieve the Server Name Indication provided by the client in a SSL session. </p>
<dl class="section return"><dt>Returns</dt><dd>size the size of the provided SNI data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been retrieved in data. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the data provided by the client.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a871070b101b579dc4663217b1c3fbcd4">wolfSSL_UseSNI</a>(ssl, 0, <span class="stringliteral">&quot;www.yassl.com&quot;</span>, strlen(<span class="stringliteral">&quot;www.yassl.com&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni usage failed</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__IO.html#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a>(ssl) == SSL_SUCCESS) {</div>
<div class="line">    <span class="keywordtype">void</span> *data = NULL;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> size = <a class="code hl_function" href="#a9c1a89c721bf16874bf84f1e77042d6c">wolfSSL_SNI_GetRequest</a>(ssl, 0, &amp;data);</div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a871070b101b579dc4663217b1c3fbcd4"><div class="ttname"><a href="#a871070b101b579dc4663217b1c3fbcd4">wolfSSL_UseSNI</a></div><div class="ttdeci">int wolfSSL_UseSNI(WOLFSSL *ssl, unsigned char type, const void *data, unsigned short size)</div><div class="ttdoc">This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; paramet...</div></div>
<div class="ttc" id="assl_8h_html_a9c1a89c721bf16874bf84f1e77042d6c"><div class="ttname"><a href="#a9c1a89c721bf16874bf84f1e77042d6c">wolfSSL_SNI_GetRequest</a></div><div class="ttdeci">unsigned short wolfSSL_SNI_GetRequest(WOLFSSL *ssl, unsigned char type, void **data)</div><div class="ttdoc">This function is called on the server side to retrieve the Server Name Indication provided by the cli...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a871070b101b579dc4663217b1c3fbcd4" title="This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; paramet...">wolfSSL_UseSNI</a> </dd>
<dd>
<a class="el" href="#a7e2d400ffb4172eb91e284951a4ae091" title="This function enables the use of Server Name Indication for SSL objects created from the SSL context ...">wolfSSL_CTX_UseSNI</a> </dd></dl>

</div>
</div>
<a id="aed8ec1ab75309570c4464449f8ce747a" name="aed8ec1ab75309570c4464449f8ce747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8ec1ab75309570c4464449f8ce747a">&#9670;&#160;</a></span>wolfSSL_SNI_SetOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SNI_SetOptions </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side to configure the behavior of the SSL session using Server Name Indication in the SSL object passed in the 'ssl' parameter. The options are explained below. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been passed in data. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">options</td><td>a bitwise semaphore with the chosen options. The available options are: enum { WOLFSSL_SNI_CONTINUE_ON_MISMATCH = 0x01, WOLFSSL_SNI_ANSWER_ON_MISMATCH = 0x02 }; Normally the server will abort the handshake by sending a fatal-level unrecognized_name(112) alert if the hostname provided by the client mismatch with the servers. </td></tr>
    <tr><td class="paramname">WOLFSSL_SNI_CONTINUE_ON_MISMATCH</td><td>With this option set, the server will not send a SNI response instead of aborting the session. </td></tr>
    <tr><td class="paramname">WOLFSSL_SNI_ANSWER_ON_MISMATCH</td><td>- With this option set, the server will send a SNI response as if the host names match instead of aborting the session.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a871070b101b579dc4663217b1c3fbcd4">wolfSSL_UseSNI</a>(ssl, 0, <span class="stringliteral">&quot;www.yassl.com&quot;</span>, strlen(<span class="stringliteral">&quot;www.yassl.com&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni usage failed</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="#aed8ec1ab75309570c4464449f8ce747a">wolfSSL_SNI_SetOptions</a>(ssl, WOLFSSL_SNI_HOST_NAME,</div>
<div class="line">    WOLFSSL_SNI_CONTINUE_ON_MISMATCH);</div>
<div class="ttc" id="assl_8h_html_aed8ec1ab75309570c4464449f8ce747a"><div class="ttname"><a href="#aed8ec1ab75309570c4464449f8ce747a">wolfSSL_SNI_SetOptions</a></div><div class="ttdeci">void wolfSSL_SNI_SetOptions(WOLFSSL *ssl, unsigned char type, unsigned char options)</div><div class="ttdoc">This function is called on the server side to configure the behavior of the SSL session using Server ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="#a871070b101b579dc4663217b1c3fbcd4" title="This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; paramet...">wolfSSL_UseSNI</a> </dd>
<dd>
<a class="el" href="#af82999bc9cefc1b7c9b8922145348d83" title="This function is called on the server side to configure the behavior of the SSL sessions using Server...">wolfSSL_CTX_SNI_SetOptions</a> </dd></dl>

</div>
</div>
<a id="af845f62f7fb9a03a829e273a847fd617" name="af845f62f7fb9a03a829e273a847fd617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af845f62f7fb9a03a829e273a847fd617">&#9670;&#160;</a></span>wolfSSL_tls_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_tls_export </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to export a serialized TLS session. This function is for exporting a serialized state of the connection. In most cases wolfSSL_get1_session should be used instead of wolfSSL_tls_export. Additional debug info can be displayed with the macro WOLFSSL_SESSION_EXPORT_DEBUG defined. WARNING: buf contains sensitive information about the state and is best to be encrypted before storing if stored. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written into buffer 'buf'</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>WOLFSSL structure to export the session from </td></tr>
    <tr><td class="paramname">buf</td><td>output of serialized session </td></tr>
    <tr><td class="paramname">sz</td><td>size in bytes set in 'buf'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8" title="The wolfSSL_dtls_import() function is used to parse in a serialized session state....">wolfSSL_dtls_import</a> </dd>
<dd>
<a class="el" href="#ab67ddb8c518619de3c8987f6a7064464" title="Used to import a serialized TLS session. This function is for importing the state of the connection....">wolfSSL_tls_import</a> </dd></dl>

</div>
</div>
<a id="ab67ddb8c518619de3c8987f6a7064464" name="ab67ddb8c518619de3c8987f6a7064464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67ddb8c518619de3c8987f6a7064464">&#9670;&#160;</a></span>wolfSSL_tls_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_tls_import </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to import a serialized TLS session. This function is for importing the state of the connection. WARNING: buf contains sensitive information about the state and is best to be encrypted before storing if stored. Additional debug info can be displayed with the macro WOLFSSL_SESSION_EXPORT_DEBUG defined. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from buffer 'buf'</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>WOLFSSL structure to import the session into </td></tr>
    <tr><td class="paramname">buf</td><td>serialized session </td></tr>
    <tr><td class="paramname">sz</td><td>size of buffer 'buf'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a42edf8e49a9aee400c06cf6a2a2f04d8" title="The wolfSSL_dtls_import() function is used to parse in a serialized session state....">wolfSSL_dtls_import</a> </dd>
<dd>
<a class="el" href="#af845f62f7fb9a03a829e273a847fd617" title="Used to export a serialized TLS session. This function is for exporting a serialized state of the con...">wolfSSL_tls_export</a> </dd></dl>

</div>
</div>
<a id="ae3a413f6cab23dd667c7cbb06ae252cb" name="ae3a413f6cab23dd667c7cbb06ae252cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a413f6cab23dd667c7cbb06ae252cb">&#9670;&#160;</a></span>wolfSSL_UseMaxFragment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseMaxFragment </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>mfl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Maximum Fragment Length in the SSL object passed in the 'ssl' parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ssl is NULL, mfl is out of range. </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">mfl</td><td>indicates which is the Maximum Fragment Length requested for the session. The available options are: enum { WOLFSSL_MFL_2_9 = 1, 512 bytes WOLFSSL_MFL_2_10 = 2, 1024 bytes WOLFSSL_MFL_2_11 = 3, 2048 bytes WOLFSSL_MFL_2_12 = 4, 4096 bytes WOLFSSL_MFL_2_13 = 5, 8192 bytes wolfSSL ONLY!!! };</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#ae3a413f6cab23dd667c7cbb06ae252cb">wolfSSL_UseMaxFragment</a>(ssl, WOLFSSL_MFL_2_11);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// max fragment usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_ae3a413f6cab23dd667c7cbb06ae252cb"><div class="ttname"><a href="#ae3a413f6cab23dd667c7cbb06ae252cb">wolfSSL_UseMaxFragment</a></div><div class="ttdeci">int wolfSSL_UseMaxFragment(WOLFSSL *ssl, unsigned char mfl)</div><div class="ttdoc">This function is called on the client side to enable the use of Maximum Fragment Length in the SSL ob...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="#afcca49dd1e71d97ec4702430a682bbcb" title="This function is called on the client side to enable the use of Maximum Fragment Length for SSL objec...">wolfSSL_CTX_UseMaxFragment</a> </dd></dl>

</div>
</div>
<a id="acbdb1a796d11f083f1782c001cdc6016" name="acbdb1a796d11f083f1782c001cdc6016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdb1a796d11f083f1782c001cdc6016">&#9670;&#160;</a></span>wolfSSL_UseOCSPStapling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseOCSPStapling </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>status_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stapling eliminates the need to contact the CA. Stapling lowers the cost of certificate revocation check presented in OCSP. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if TLSX_UseCertificateStatusRequest executes without error. </dd>
<dd>
MEMORY_E returned if there is an error with the allocation of memory. </dd>
<dd>
BAD_FUNC_ARG returned if there is an argument that has a NULL or otherwise unacceptable value passed into the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">status_type</td><td>a byte type that is passed through to TLSX_UseCertificateStatusRequest() and stored in the CertificateStatusRequest structure. </td></tr>
    <tr><td class="paramname">options</td><td>a byte type that is passed through to TLSX_UseCertificateStatusRequest() and stored in the CertificateStatusRequest structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#acbdb1a796d11f083f1782c001cdc6016">wolfSSL_UseOCSPStapling</a>(ssl, WOLFSSL_CSR2_OCSP,</div>
<div class="line">WOLFSSL_CSR2_OCSP_USE_NONCE) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failed case.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_acbdb1a796d11f083f1782c001cdc6016"><div class="ttname"><a href="#acbdb1a796d11f083f1782c001cdc6016">wolfSSL_UseOCSPStapling</a></div><div class="ttdeci">int wolfSSL_UseOCSPStapling(WOLFSSL *ssl, unsigned char status_type, unsigned char options)</div><div class="ttdoc">Stapling eliminates the need to contact the CA. Stapling lowers the cost of certificate revocation ch...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_UseCertificateStatusRequest </dd>
<dd>
<a class="el" href="#a5a9469c796b581328a7de8c16d9cfcec" title="This function requests the certificate status during the handshake.">wolfSSL_CTX_UseOCSPStapling</a> </dd></dl>

</div>
</div>
<a id="a37cbc7ec1e1fd4445c7bd59c09bae5ad" name="a37cbc7ec1e1fd4445c7bd59c09bae5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cbc7ec1e1fd4445c7bd59c09bae5ad">&#9670;&#160;</a></span>wolfSSL_UseOCSPStaplingV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseOCSPStaplingV2 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>status_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the status type and options for OCSP. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS - returned if the function and subroutines executed without error. </dd>
<dd>
MEMORY_E - returned if there was an allocation of memory error. </dd>
<dd>
BAD_FUNC_ARG - returned if a NULL or otherwise unaccepted argument was passed to the function or a subroutine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">status_type</td><td>a byte type that loads the OCSP status type. </td></tr>
    <tr><td class="paramname">options</td><td>a byte type that holds the OCSP options, set in <a class="el" href="#aed8ec1ab75309570c4464449f8ce747a" title="This function is called on the server side to configure the behavior of the SSL session using Server ...">wolfSSL_SNI_SetOptions()</a> and <a class="el" href="#af82999bc9cefc1b7c9b8922145348d83" title="This function is called on the server side to configure the behavior of the SSL sessions using Server...">wolfSSL_CTX_SNI_SetOptions()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if (<a class="code hl_function" href="#a37cbc7ec1e1fd4445c7bd59c09bae5ad">wolfSSL_UseOCSPStaplingV2</a>(ssl, WOLFSSL_CSR2_OCSP_MULTI, 0) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Did not execute properly. Failure case code block.</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a37cbc7ec1e1fd4445c7bd59c09bae5ad"><div class="ttname"><a href="#a37cbc7ec1e1fd4445c7bd59c09bae5ad">wolfSSL_UseOCSPStaplingV2</a></div><div class="ttdeci">int wolfSSL_UseOCSPStaplingV2(WOLFSSL *ssl, unsigned char status_type, unsigned char options)</div><div class="ttdoc">The function sets the status type and options for OCSP.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_UseCertificatStatusRequestV2 </dd>
<dd>
<a class="el" href="#aed8ec1ab75309570c4464449f8ce747a" title="This function is called on the server side to configure the behavior of the SSL session using Server ...">wolfSSL_SNI_SetOptions</a> </dd>
<dd>
<a class="el" href="#af82999bc9cefc1b7c9b8922145348d83" title="This function is called on the server side to configure the behavior of the SSL sessions using Server...">wolfSSL_CTX_SNI_SetOptions</a> </dd></dl>

</div>
</div>
<a id="a871070b101b579dc4663217b1c3fbcd4" name="a871070b101b579dc4663217b1c3fbcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871070b101b579dc4663217b1c3fbcd4">&#9670;&#160;</a></span>wolfSSL_UseSNI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseSNI </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the use of Server Name Indication in the SSL object passed in the 'ssl' parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL client and wolfSSL server will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ssl is NULL, data is NULL, type is a unknown value. (see below) </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>indicates which type of server name is been passed in data. The known types are: enum { WOLFSSL_SNI_HOST_NAME = 0 }; </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the server name data. </td></tr>
    <tr><td class="paramname">size</td><td>size of the server name data.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a871070b101b579dc4663217b1c3fbcd4">wolfSSL_UseSNI</a>(ssl, WOLFSSL_SNI_HOST_NAME, <span class="stringliteral">&quot;www.yassl.com&quot;</span>,</div>
<div class="line">    strlen(<span class="stringliteral">&quot;www.yassl.com&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// sni usage failed</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="#a7e2d400ffb4172eb91e284951a4ae091" title="This function enables the use of Server Name Indication for SSL objects created from the SSL context ...">wolfSSL_CTX_UseSNI</a> </dd></dl>

</div>
</div>
<a id="a99a3ea2538789b78859e8ae750b802e0" name="a99a3ea2538789b78859e8ae750b802e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a3ea2538789b78859e8ae750b802e0">&#9670;&#160;</a></span>wolfSSL_UseSupportedCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseSupportedCurve </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word16</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Supported Elliptic Curves Extension in the SSL object passed in the 'ssl' parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ssl is NULL, name is a unknown value. (see below) </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>indicates which curve will be supported for the session. The available options are: enum { WOLFSSL_ECC_SECP160R1 = 0x10, WOLFSSL_ECC_SECP192R1 = 0x13, WOLFSSL_ECC_SECP224R1 = 0x15, WOLFSSL_ECC_SECP256R1 = 0x17, WOLFSSL_ECC_SECP384R1 = 0x18, WOLFSSL_ECC_SECP521R1 = 0x19 };</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a99a3ea2538789b78859e8ae750b802e0">wolfSSL_UseSupportedCurve</a>(ssl, WOLFSSL_ECC_SECP256R1);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// Elliptic Curve Extension usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a99a3ea2538789b78859e8ae750b802e0"><div class="ttname"><a href="#a99a3ea2538789b78859e8ae750b802e0">wolfSSL_UseSupportedCurve</a></div><div class="ttdeci">int wolfSSL_UseSupportedCurve(WOLFSSL *ssl, word16 name)</div><div class="ttdoc">This function is called on the client side to enable the use of Supported Elliptic Curves Extension i...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new</a> </dd>
<dd>
<a class="el" href="#a49ebc57d8029df946efdf15dffaace1f" title="This function is called on the client side to enable the use of Supported Elliptic Curves Extension f...">wolfSSL_CTX_UseSupportedCurve</a> </dd></dl>

</div>
</div>
<a id="a8555f9cc188902fe3d3ca8bc9d466a4c" name="a8555f9cc188902fe3d3ca8bc9d466a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8555f9cc188902fe3d3ca8bc9d466a4c">&#9670;&#160;</a></span>wolfSSL_UseTruncatedHMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseTruncatedHMAC </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side to enable the use of Truncated HMAC in the SSL object passed in the 'ssl' parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
BAD_FUNC_ARG is the error that will be returned in one of these cases: ssl is NULL </dd>
<dd>
MEMORY_E is the error returned when there is not enough memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to a SSL object, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a></td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL_CTX* ctx = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line"><span class="keywordflow">if</span> (ctx == NULL) {</div>
<div class="line">    <span class="comment">// context creation failed</span></div>
<div class="line">}</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordflow">if</span> (ssl == NULL) {</div>
<div class="line">    <span class="comment">// ssl creation failed</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#a8555f9cc188902fe3d3ca8bc9d466a4c">wolfSSL_UseTruncatedHMAC</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// truncated HMAC usage failed</span></div>
<div class="line">}</div>
<div class="ttc" id="assl_8h_html_a8555f9cc188902fe3d3ca8bc9d466a4c"><div class="ttname"><a href="#a8555f9cc188902fe3d3ca8bc9d466a4c">wolfSSL_UseTruncatedHMAC</a></div><div class="ttdeci">int wolfSSL_UseTruncatedHMAC(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on the client side to enable the use of Truncated HMAC in the SSL object pass...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new</a> </dd>
<dd>
<a class="el" href="#afcca49dd1e71d97ec4702430a682bbcb" title="This function is called on the client side to enable the use of Maximum Fragment Length for SSL objec...">wolfSSL_CTX_UseMaxFragment</a> </dd></dl>

</div>
</div>
<a id="ac98ca659773439f65dc8be41761cf9a7" name="ac98ca659773439f65dc8be41761cf9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98ca659773439f65dc8be41761cf9a7">&#9670;&#160;</a></span>wolfSSL_X509_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_X509_free </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_X509 *</td>          <td class="paramname"><span class="paramname"><em>x509</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees a WOLFSSL_X509 structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x509</td><td>a pointer to the WOLFSSL_X509 struct.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_X509* x509 = (WOLFSSL_X509*)XMALOC(<span class="keyword">sizeof</span>(WOLFSSL_X509), NULL,</div>
<div class="line">DYNAMIC_TYPE_X509) ;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ac98ca659773439f65dc8be41761cf9a7">wolfSSL_X509_free</a>(x509);</div>
<div class="ttc" id="assl_8h_html_ac98ca659773439f65dc8be41761cf9a7"><div class="ttname"><a href="#ac98ca659773439f65dc8be41761cf9a7">wolfSSL_X509_free</a></div><div class="ttdeci">void wolfSSL_X509_free(WOLFSSL_X509 *x509)</div><div class="ttdoc">This function frees a WOLFSSL_X509 structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CertsKeys.html#ga094e24903d9b63818ebdb64f63e8c737" title="Gets the X509 signature and stores it in the buffer.">wolfSSL_X509_get_signature</a> </dd>
<dd>
<a class="el" href="group__CertsKeys.html#ga04d06491c573578766b8de240192b3fa" title="This function retrieves the version of the X509 certificate.">wolfSSL_X509_version</a> </dd>
<dd>
<a class="el" href="group__CertsKeys.html#ga79f67a09528310251b65329bca9fe832" title="This function gets the DER encoded certificate in the WOLFSSL_X509 struct.">wolfSSL_X509_get_der</a> </dd>
<dd>
<a class="el" href="group__openSSL.html#gaf28dd542c2da23d9c2a9346e6a22ea52" title="Retrieves the peer’s certificate serial number. The serial number buffer (in) should be at least 32 b...">wolfSSL_X509_get_serial_number</a> </dd>
<dd>
<a class="el" href="group__CertsKeys.html#gab1e237c4e59d8a0b73b9fc0d733bd8cf" title="This function the certificate &quot;not before&quot; validity encoded as a byte array.">wolfSSL_X509_notBefore</a> </dd>
<dd>
<a class="el" href="group__CertsKeys.html#ga35ade256eac252caa7f42d4c2dbe9ae3" title="This function the certificate &quot;not after&quot; validity encoded as a byte array.">wolfSSL_X509_notAfter</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
