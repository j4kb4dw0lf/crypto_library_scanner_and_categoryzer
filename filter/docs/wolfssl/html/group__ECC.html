<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: Algorithms - ECC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Algorithms - ECC </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6d0f268d7b0d7ad4b3fac490c1397fc8" id="r_ga6d0f268d7b0d7ad4b3fac490c1397fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a> (WC_RNG *rng, int keysize, ecc_key *key)</td></tr>
<tr class="memdesc:ga6d0f268d7b0d7ad4b3fac490c1397fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new ecc_key and stores it in key.  <br /></td></tr>
<tr class="memitem:gaa8e76458324962efb703a7102473cebd" id="r_gaa8e76458324962efb703a7102473cebd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8e76458324962efb703a7102473cebd">wc_ecc_make_key_ex</a> (WC_RNG *rng, int keysize, ecc_key *key, int curve_id)</td></tr>
<tr class="memdesc:gaa8e76458324962efb703a7102473cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new ecc_key and stores it in key.  <br /></td></tr>
<tr class="memitem:ga95e451a312f105efde2c4c3e8dfa433f" id="r_ga95e451a312f105efde2c4c3e8dfa433f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95e451a312f105efde2c4c3e8dfa433f">wc_ecc_check_key</a> (ecc_key *key)</td></tr>
<tr class="memdesc:ga95e451a312f105efde2c4c3e8dfa433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sanity checks on ecc key validity.  <br /></td></tr>
<tr class="memitem:gac1e0c1089cf94c596485ac36d811abc5" id="r_gac1e0c1089cf94c596485ac36d811abc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1e0c1089cf94c596485ac36d811abc5">wc_ecc_key_free</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gac1e0c1089cf94c596485ac36d811abc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an ecc_key key after it has been used.  <br /></td></tr>
<tr class="memitem:gac4c90785cdf60171aaa73e2e02481637" id="r_gac4c90785cdf60171aaa73e2e02481637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4c90785cdf60171aaa73e2e02481637">wc_ecc_shared_secret</a> (ecc_key *private_key, ecc_key *public_key, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:gac4c90785cdf60171aaa73e2e02481637"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new secret key using a local private key and a received public key. It stores this shared secret key in the buffer out and updates outlen to hold the number of bytes written to the output buffer.  <br /></td></tr>
<tr class="memitem:gab49f07573edb8ad3eb168c866594ca05" id="r_gab49f07573edb8ad3eb168c866594ca05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab49f07573edb8ad3eb168c866594ca05">wc_ecc_shared_secret_ex</a> (ecc_key *private_key, ecc_point *point, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:gab49f07573edb8ad3eb168c866594ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ECC shared secret between private key and public point.  <br /></td></tr>
<tr class="memitem:ga94996d8a8db851ea9c61f252131b51c4" id="r_ga94996d8a8db851ea9c61f252131b51c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94996d8a8db851ea9c61f252131b51c4">wc_ecc_sign_hash</a> (const byte *in, word32 inlen, byte *out, word32 *outlen, WC_RNG *rng, ecc_key *key)</td></tr>
<tr class="memdesc:ga94996d8a8db851ea9c61f252131b51c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message digest using an ecc_key object to guarantee authenticity.  <br /></td></tr>
<tr class="memitem:gacab051d94dc346cb2df5f3a209dded1e" id="r_gacab051d94dc346cb2df5f3a209dded1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacab051d94dc346cb2df5f3a209dded1e">wc_ecc_sign_hash_ex</a> (const byte *in, word32 inlen, WC_RNG *rng, ecc_key *key, mp_int *r, mp_int *s)</td></tr>
<tr class="memdesc:gacab051d94dc346cb2df5f3a209dded1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a message digest.  <br /></td></tr>
<tr class="memitem:ga7bff199922e080b6733aa2dd342f5cb7" id="r_ga7bff199922e080b6733aa2dd342f5cb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7bff199922e080b6733aa2dd342f5cb7">wc_ecc_verify_hash</a> (const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</td></tr>
<tr class="memdesc:ga7bff199922e080b6733aa2dd342f5cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer through stat, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <br /></td></tr>
<tr class="memitem:ga5b1bb1c6ce3f9238c8f23a3e516952bb" id="r_ga5b1bb1c6ce3f9238c8f23a3e516952bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb">wc_ecc_verify_hash_ex</a> (mp_int *r, mp_int *s, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</td></tr>
<tr class="memdesc:ga5b1bb1c6ce3f9238c8f23a3e516952bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use stat.  <br /></td></tr>
<tr class="memitem:gaaa0c3f56e07df66db857966e26106e18" id="r_gaaa0c3f56e07df66db857966e26106e18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gaaa0c3f56e07df66db857966e26106e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ecc_key object for future use with message verification or key negotiation.  <br /></td></tr>
<tr class="memitem:gae59c1deab699da68ecc68c102285990b" id="r_gae59c1deab699da68ecc68c102285990b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae59c1deab699da68ecc68c102285990b">wc_ecc_init_ex</a> (ecc_key *key, void *heap, int devId)</td></tr>
<tr class="memdesc:gae59c1deab699da68ecc68c102285990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ecc_key object for future use with message verification or key negotiation.  <br /></td></tr>
<tr class="memitem:ga5030ddca65344898ae556dcdde0958df" id="r_ga5030ddca65344898ae556dcdde0958df"><td class="memItemLeft" align="right" valign="top">ecc_key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5030ddca65344898ae556dcdde0958df">wc_ecc_key_new</a> (void *heap)</td></tr>
<tr class="memdesc:ga5030ddca65344898ae556dcdde0958df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses a user defined heap and allocates space for the key structure.  <br /></td></tr>
<tr class="memitem:gac18946c6b472d27e4be56740d71880bd" id="r_gac18946c6b472d27e4be56740d71880bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac18946c6b472d27e4be56740d71880bd">wc_ecc_free</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gac18946c6b472d27e4be56740d71880bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an ecc_key object after it has been used.  <br /></td></tr>
<tr class="memitem:ga5b4a7aa3018bd18ca7b9235010b13626" id="r_ga5b4a7aa3018bd18ca7b9235010b13626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b4a7aa3018bd18ca7b9235010b13626">wc_ecc_fp_free</a> (void)</td></tr>
<tr class="memdesc:ga5b4a7aa3018bd18ca7b9235010b13626"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the fixed-point cache, which can be used with ecc to speed up computation times. To use this functionality, FP_ECC (fixed-point ecc), should be defined. Threaded applications should call this function before exiting the thread.  <br /></td></tr>
<tr class="memitem:ga9696066946daccbf59c35dbf164be89b" id="r_ga9696066946daccbf59c35dbf164be89b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9696066946daccbf59c35dbf164be89b">wc_ecc_is_valid_idx</a> (int n)</td></tr>
<tr class="memdesc:ga9696066946daccbf59c35dbf164be89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an ECC idx is valid.  <br /></td></tr>
<tr class="memitem:ga0f5af518bb0c72b8ba1047be3adc6f07" id="r_ga0f5af518bb0c72b8ba1047be3adc6f07"><td class="memItemLeft" align="right" valign="top">ecc_point *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a> (void)</td></tr>
<tr class="memdesc:ga0f5af518bb0c72b8ba1047be3adc6f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new ECC point.  <br /></td></tr>
<tr class="memitem:gaf56f44972208a70b5a897261567eb8b9" id="r_gaf56f44972208a70b5a897261567eb8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf56f44972208a70b5a897261567eb8b9">wc_ecc_del_point</a> (ecc_point *p)</td></tr>
<tr class="memdesc:gaf56f44972208a70b5a897261567eb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an ECC point from memory.  <br /></td></tr>
<tr class="memitem:ga402a981bb51a35788fda0b183f34f430" id="r_ga402a981bb51a35788fda0b183f34f430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga402a981bb51a35788fda0b183f34f430">wc_ecc_copy_point</a> (ecc_point *p, ecc_point *r)</td></tr>
<tr class="memdesc:ga402a981bb51a35788fda0b183f34f430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the value of one point to another one.  <br /></td></tr>
<tr class="memitem:ga15f05f3dc6e2221ff6651a41da4ad9d6" id="r_ga15f05f3dc6e2221ff6651a41da4ad9d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6">wc_ecc_cmp_point</a> (ecc_point *a, ecc_point *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>)</td></tr>
<tr class="memdesc:ga15f05f3dc6e2221ff6651a41da4ad9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the value of a point with another one.  <br /></td></tr>
<tr class="memitem:gad0284c4ea20805e8e7eeb4d3054f8879" id="r_gad0284c4ea20805e8e7eeb4d3054f8879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad0284c4ea20805e8e7eeb4d3054f8879">wc_ecc_point_is_at_infinity</a> (ecc_point *p)</td></tr>
<tr class="memdesc:gad0284c4ea20805e8e7eeb4d3054f8879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error.  <br /></td></tr>
<tr class="memitem:ga458a55243d54350363c0b4615d02dafd" id="r_ga458a55243d54350363c0b4615d02dafd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga458a55243d54350363c0b4615d02dafd">wc_ecc_mulmod</a> (mp_int *k, ecc_point *G, ecc_point *R, mp_int *a, mp_int *modulus, int map)</td></tr>
<tr class="memdesc:ga458a55243d54350363c0b4615d02dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ECC Fixed Point multiplication.  <br /></td></tr>
<tr class="memitem:ga8ec718ac07b173a6e9f4dd5405bcbd57" id="r_ga8ec718ac07b173a6e9f4dd5405bcbd57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ec718ac07b173a6e9f4dd5405bcbd57">wc_ecc_export_x963</a> (ecc_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:ga8ec718ac07b173a6e9f4dd5405bcbd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen.  <br /></td></tr>
<tr class="memitem:ga4880d9d5c603856ad2714de4d864bc71" id="r_ga4880d9d5c603856ad2714de4d864bc71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4880d9d5c603856ad2714de4d864bc71">wc_ecc_export_x963_ex</a> (ecc_key *key, byte *out, word32 *outLen, int compressed)</td></tr>
<tr class="memdesc:ga4880d9d5c603856ad2714de4d864bc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. This function allows the additional option of compressing the certificate through the compressed parameter. When this parameter is true, the key will be stored in ANSI X9.63 compressed format.  <br /></td></tr>
<tr class="memitem:ga1c4116facdbb32a302c7f03cd20adac7" id="r_ga1c4116facdbb32a302c7f03cd20adac7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c4116facdbb32a302c7f03cd20adac7">wc_ecc_import_x963</a> (const byte *in, word32 inLen, ecc_key *key)</td></tr>
<tr class="memdesc:ga1c4116facdbb32a302c7f03cd20adac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public ECC key from a buffer containing the key stored in ANSI X9.63 format. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <br /></td></tr>
<tr class="memitem:gafc1bedd2b71b7d4ed72d1d01c62b7859" id="r_gafc1bedd2b71b7d4ed72d1d01c62b7859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859">wc_ecc_import_private_key</a> (const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ecc_key *key)</td></tr>
<tr class="memdesc:gafc1bedd2b71b7d4ed72d1d01c62b7859"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public/private ECC key pair from a buffer containing the raw private key, and a second buffer containing the ANSI X9.63 formatted public key. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <br /></td></tr>
<tr class="memitem:ga78967e166f0aa6de07dc5e4b870155c4" id="r_ga78967e166f0aa6de07dc5e4b870155c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga78967e166f0aa6de07dc5e4b870155c4">wc_ecc_rs_to_sig</a> (const char *r, const char *s, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:ga78967e166f0aa6de07dc5e4b870155c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature. This function also stores the length written to the output buffer, out, in outlen.  <br /></td></tr>
<tr class="memitem:gaabd246d8560804e89c3c17c02708ccbf" id="r_gaabd246d8560804e89c3c17c02708ccbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaabd246d8560804e89c3c17c02708ccbf">wc_ecc_import_raw</a> (ecc_key *key, const char *qx, const char *qy, const char *d, const char *curveName)</td></tr>
<tr class="memdesc:gaabd246d8560804e89c3c17c02708ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills an ecc_key structure with the raw components of an ECC signature.  <br /></td></tr>
<tr class="memitem:gaff92a6958d7493d07534089312cf3c74" id="r_gaff92a6958d7493d07534089312cf3c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaff92a6958d7493d07534089312cf3c74">wc_ecc_export_private_only</a> (ecc_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gaff92a6958d7493d07534089312cf3c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports only the private key from an ecc_key structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen.  <br /></td></tr>
<tr class="memitem:gaaacd531f73fb2a5070d154e75795e298" id="r_gaaacd531f73fb2a5070d154e75795e298"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaacd531f73fb2a5070d154e75795e298">wc_ecc_export_point_der</a> (const int curve_idx, ecc_point *point, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gaaacd531f73fb2a5070d154e75795e298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export point to der.  <br /></td></tr>
<tr class="memitem:ga79c33de66f5ae16a005bcee4b0679af0" id="r_ga79c33de66f5ae16a005bcee4b0679af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79c33de66f5ae16a005bcee4b0679af0">wc_ecc_import_point_der</a> (byte *in, word32 inLen, const int curve_idx, ecc_point *point)</td></tr>
<tr class="memdesc:ga79c33de66f5ae16a005bcee4b0679af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import point from der format.  <br /></td></tr>
<tr class="memitem:ga95af657f43c1ee93d3900d2a47cdd69f" id="r_ga95af657f43c1ee93d3900d2a47cdd69f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95af657f43c1ee93d3900d2a47cdd69f">wc_ecc_size</a> (ecc_key *key)</td></tr>
<tr class="memdesc:ga95af657f43c1ee93d3900d2a47cdd69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the key size of an ecc_key structure in octets.  <br /></td></tr>
<tr class="memitem:gaf145568b65104e008a7311cffb11b562" id="r_gaf145568b65104e008a7311cffb11b562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf145568b65104e008a7311cffb11b562">wc_ecc_sig_size_calc</a> (int sz)</td></tr>
<tr class="memdesc:gaf145568b65104e008a7311cffb11b562"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash.  <br /></td></tr>
<tr class="memitem:gafbedbdc67061a9912c49def9824fd3ba" id="r_gafbedbdc67061a9912c49def9824fd3ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbedbdc67061a9912c49def9824fd3ba">wc_ecc_sig_size</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gafbedbdc67061a9912c49def9824fd3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash.  <br /></td></tr>
<tr class="memitem:ga7bdbf99825033f3a72ca10d3412bfbdc" id="r_ga7bdbf99825033f3a72ca10d3412bfbdc"><td class="memItemLeft" align="right" valign="top">ecEncCtx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a> (int flags, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga7bdbf99825033f3a72ca10d3412bfbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates and initializes space for a new ECC context object to allow secure message exchange with ECC.  <br /></td></tr>
<tr class="memitem:ga704e43c4cb0dac4e24fd2a413776f361" id="r_ga704e43c4cb0dac4e24fd2a413776f361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga704e43c4cb0dac4e24fd2a413776f361">wc_ecc_ctx_free</a> (ecEncCtx *)</td></tr>
<tr class="memdesc:ga704e43c4cb0dac4e24fd2a413776f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the ecEncCtx object used for encrypting and decrypting messages.  <br /></td></tr>
<tr class="memitem:gab70c7e43da7725ffddcd0da19758448c" id="r_gab70c7e43da7725ffddcd0da19758448c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab70c7e43da7725ffddcd0da19758448c">wc_ecc_ctx_reset</a> (ecEncCtx *ctx, WC_RNG *rng)</td></tr>
<tr class="memdesc:gab70c7e43da7725ffddcd0da19758448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets an ecEncCtx structure to avoid having to free and allocate a new context object.  <br /></td></tr>
<tr class="memitem:ga71eb3904a72e85b649aef3846cc4efeb" id="r_ga71eb3904a72e85b649aef3846cc4efeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71eb3904a72e85b649aef3846cc4efeb">wc_ecc_ctx_set_algo</a> (ecEncCtx *ctx, byte encAlgo, byte kdfAlgo, byte macAlgo)</td></tr>
<tr class="memdesc:ga71eb3904a72e85b649aef3846cc4efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can optionally be called after wc_ecc_ctx_new. It sets the encryption, KDF, and MAC algorithms into an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:gad6955a4dc899acc9aa0a5186b07b39bd" id="r_gad6955a4dc899acc9aa0a5186b07b39bd"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a> (ecEncCtx *)</td></tr>
<tr class="memdesc:gad6955a4dc899acc9aa0a5186b07b39bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the salt of an ecEncCtx object. This function should only be called when the ecEncCtx's state is ecSRV_INIT or ecCLI_INIT.  <br /></td></tr>
<tr class="memitem:ga97cddc33a77f01610a0523a65ba4616b" id="r_ga97cddc33a77f01610a0523a65ba4616b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97cddc33a77f01610a0523a65ba4616b">wc_ecc_ctx_set_peer_salt</a> (ecEncCtx *ctx, const byte *salt)</td></tr>
<tr class="memdesc:ga97cddc33a77f01610a0523a65ba4616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the peer salt of an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga0a2b5c65696e88e5ba844244c3d3733b" id="r_ga0a2b5c65696e88e5ba844244c3d3733b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0a2b5c65696e88e5ba844244c3d3733b">wc_ecc_ctx_set_kdf_salt</a> (ecEncCtx *ctx, const byte *salt, word32 sz)</td></tr>
<tr class="memdesc:ga0a2b5c65696e88e5ba844244c3d3733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the salt pointer and length to use with KDF into the ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga9e16a5e6f2da3a9a15ffbcfacc0cdd03" id="r_ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e16a5e6f2da3a9a15ffbcfacc0cdd03">wc_ecc_ctx_set_info</a> (ecEncCtx *ctx, const byte *info, int sz)</td></tr>
<tr class="memdesc:ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional information for an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga8d3cb6594810b8800fa567534117b7e0" id="r_ga8d3cb6594810b8800fa567534117b7e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d3cb6594810b8800fa567534117b7e0">wc_ecc_encrypt</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</td></tr>
<tr class="memdesc:ga8d3cb6594810b8800fa567534117b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:gad21887dbd46653ab137968663baa9368" id="r_gad21887dbd46653ab137968663baa9368"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad21887dbd46653ab137968663baa9368">wc_ecc_encrypt_ex</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx, int compressed)</td></tr>
<tr class="memdesc:gad21887dbd46653ab137968663baa9368"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:ga04a37c183aa782be024f704c3e1d9336" id="r_ga04a37c183aa782be024f704c3e1d9336"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04a37c183aa782be024f704c3e1d9336">wc_ecc_decrypt</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</td></tr>
<tr class="memdesc:ga04a37c183aa782be024f704c3e1d9336"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:ga83efa53f7f2e43256ed3be8c199f9e7e" id="r_ga83efa53f7f2e43256ed3be8c199f9e7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83efa53f7f2e43256ed3be8c199f9e7e">wc_ecc_set_nonblock</a> (ecc_key *key, ecc_nb_ctx_t *ctx)</td></tr>
<tr class="memdesc:ga83efa53f7f2e43256ed3be8c199f9e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ECC support for non-blocking operations. Supported for Single Precision (SP) math with the following build options: WOLFSSL_SP_NONBLOCK WOLFSSL_SP_SMALL WOLFSSL_SP_NO_MALLOC WC_ECC_NONBLOCK.  <br /></td></tr>
<tr class="memitem:ga408ce10bc52e6fe1ed92493aa61d0cd6" id="r_ga408ce10bc52e6fe1ed92493aa61d0cd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga408ce10bc52e6fe1ed92493aa61d0cd6">wc_ecc_set_curve</a> (ecc_key *key, int keysize, int curve_id)</td></tr>
<tr class="memdesc:ga408ce10bc52e6fe1ed92493aa61d0cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a curve which has larger key than specified size or the curve matched curve ID, set a curve with smaller key size to the key.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga95e451a312f105efde2c4c3e8dfa433f" name="ga95e451a312f105efde2c4c3e8dfa433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e451a312f105efde2c4c3e8dfa433f">&#9670;&#160;</a></span>wc_ecc_check_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_check_key </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sanity checks on ecc key validity. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Success, key is OK. </dd>
<dd>
BAD_FUNC_ARG Returns if key is NULL. </dd>
<dd>
ECC_INF_E Returns if wc_ecc_point_is_at_infinity returns 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to key to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> check_result;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div>
<div class="line">check_result = <a class="code hl_function" href="#ga95e451a312f105efde2c4c3e8dfa433f">wc_ecc_check_key</a>(&amp;key);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (check_result == MP_OKAY)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key check succeeded</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// key check failed</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga6d0f268d7b0d7ad4b3fac490c1397fc8"><div class="ttname"><a href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a></div><div class="ttdeci">int wc_ecc_make_key(WC_RNG *rng, int keysize, ecc_key *key)</div><div class="ttdoc">This function generates a new ecc_key and stores it in key.</div></div>
<div class="ttc" id="agroup__ECC_html_ga95e451a312f105efde2c4c3e8dfa433f"><div class="ttname"><a href="#ga95e451a312f105efde2c4c3e8dfa433f">wc_ecc_check_key</a></div><div class="ttdeci">int wc_ecc_check_key(ecc_key *key)</div><div class="ttdoc">Perform sanity checks on ecc key validity.</div></div>
<div class="ttc" id="agroup__ECC_html_gaaa0c3f56e07df66db857966e26106e18"><div class="ttname"><a href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a></div><div class="ttdeci">int wc_ecc_init(ecc_key *key)</div><div class="ttdoc">This function initializes an ecc_key object for future use with message verification or key negotiati...</div></div>
<div class="ttc" id="agroup__Random_html_ga1a87307fac65d3c2a47ffb743020f83c"><div class="ttname"><a href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a></div><div class="ttdeci">int wc_InitRng(WC_RNG *)</div><div class="ttdoc">Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad0284c4ea20805e8e7eeb4d3054f8879" title="Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error.">wc_ecc_point_is_at_infinity</a> </dd></dl>

</div>
</div>
<a id="ga15f05f3dc6e2221ff6651a41da4ad9d6" name="ga15f05f3dc6e2221ff6651a41da4ad9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f05f3dc6e2221ff6651a41da4ad9d6">&#9670;&#160;</a></span>wc_ecc_cmp_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_cmp_point </td>
          <td>(</td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the value of a point with another one. </p>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG One or both arguments are NULL. </dd>
<dd>
MP_EQ The points are equal. </dd>
<dd>
ret Either MP_LT or MP_GT and signifies that the points are not equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First point to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second point to compare.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* point;</div>
<div class="line">ecc_point* point_to_compare;</div>
<div class="line"><span class="keywordtype">int</span> cmp_result;</div>
<div class="line"> </div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line">point_to_compare = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line">cmp_result = <a class="code hl_function" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6">wc_ecc_cmp_point</a>(point, point_to_compare);</div>
<div class="line"><span class="keywordflow">if</span> (cmp_result == BAD_FUNC_ARG)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// arguments are invalid</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp_result == MP_EQ)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Points are equal</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Points are not equal</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga0f5af518bb0c72b8ba1047be3adc6f07"><div class="ttname"><a href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a></div><div class="ttdeci">ecc_point * wc_ecc_new_point(void)</div><div class="ttdoc">Allocate a new ECC point.</div></div>
<div class="ttc" id="agroup__ECC_html_ga15f05f3dc6e2221ff6651a41da4ad9d6"><div class="ttname"><a href="#ga15f05f3dc6e2221ff6651a41da4ad9d6">wc_ecc_cmp_point</a></div><div class="ttdeci">int wc_ecc_cmp_point(ecc_point *a, ecc_point *b)</div><div class="ttdoc">Compare the value of a point with another one.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0f5af518bb0c72b8ba1047be3adc6f07" title="Allocate a new ECC point.">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="#gaf56f44972208a70b5a897261567eb8b9" title="Free an ECC point from memory.">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="#ga402a981bb51a35788fda0b183f34f430" title="Copy the value of one point to another one.">wc_ecc_copy_point</a> </dd></dl>

</div>
</div>
<a id="ga402a981bb51a35788fda0b183f34f430" name="ga402a981bb51a35788fda0b183f34f430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402a981bb51a35788fda0b183f34f430">&#9670;&#160;</a></span>wc_ecc_copy_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_copy_point </td>
          <td>(</td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the value of one point to another one. </p>
<dl class="section return"><dt>Returns</dt><dd>ECC_BAD_ARG_E Error thrown when p or r is null. </dd>
<dd>
MP_OKAY Point copied successfully </dd>
<dd>
ret Error from internal functions. Can be...</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to copy. </td></tr>
    <tr><td class="paramname">r</td><td>The created point.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* point;</div>
<div class="line">ecc_point* copied_point;</div>
<div class="line"><span class="keywordtype">int</span> copy_return;</div>
<div class="line"> </div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line">copy_return = <a class="code hl_function" href="#ga402a981bb51a35788fda0b183f34f430">wc_ecc_copy_point</a>(point, copied_point);</div>
<div class="line"><span class="keywordflow">if</span> (copy_return != MP_OKAY)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga402a981bb51a35788fda0b183f34f430"><div class="ttname"><a href="#ga402a981bb51a35788fda0b183f34f430">wc_ecc_copy_point</a></div><div class="ttdeci">int wc_ecc_copy_point(ecc_point *p, ecc_point *r)</div><div class="ttdoc">Copy the value of one point to another one.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0f5af518bb0c72b8ba1047be3adc6f07" title="Allocate a new ECC point.">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6" title="Compare the value of a point with another one.">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="#gaf56f44972208a70b5a897261567eb8b9" title="Free an ECC point from memory.">wc_ecc_del_point</a> </dd></dl>

</div>
</div>
<a id="ga704e43c4cb0dac4e24fd2a413776f361" name="ga704e43c4cb0dac4e24fd2a413776f361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga704e43c4cb0dac4e24fd2a413776f361">&#9670;&#160;</a></span>wc_ecc_ctx_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_ecc_ctx_free </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the ecEncCtx object used for encrypting and decrypting messages. </p>
<dl class="section return"><dt>Returns</dt><dd>none Returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx object to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">ctx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div>
<div class="line"><span class="comment">// do secure communication</span></div>
<div class="line">...</div>
<div class="line">wc_ecc_ctx_free(&amp;ctx);</div>
<div class="ttc" id="agroup__ECC_html_ga7bdbf99825033f3a72ca10d3412bfbdc"><div class="ttname"><a href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a></div><div class="ttdeci">ecEncCtx * wc_ecc_ctx_new(int flags, WC_RNG *rng)</div><div class="ttdoc">This function allocates and initializes space for a new ECC context object to allow secure message ex...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="gad6955a4dc899acc9aa0a5186b07b39bd" name="gad6955a4dc899acc9aa0a5186b07b39bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6955a4dc899acc9aa0a5186b07b39bd">&#9670;&#160;</a></span>wc_ecc_ctx_get_own_salt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const byte * wc_ecc_ctx_get_own_salt </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the salt of an ecEncCtx object. This function should only be called when the ecEncCtx's state is ecSRV_INIT or ecCLI_INIT. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On success, returns the ecEncCtx salt </dd>
<dd>
NULL Returned if the ecEncCtx object is NULL, or the ecEncCtx's state is not ecSRV_INIT or ecCLI_INIT. In the latter two cases, this function also sets the ecEncCtx's state to ecSRV_BAD_STATE or ecCLI_BAD_STATE, respectively</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx object from which to get the salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">byte</span>* salt;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">ctx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div>
<div class="line">salt = <a class="code hl_function" href="#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a>(&amp;ctx);</div>
<div class="line"><span class="keywordflow">if</span>(salt == NULL) {</div>
<div class="line">    <span class="comment">// error getting salt</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gad6955a4dc899acc9aa0a5186b07b39bd"><div class="ttname"><a href="#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a></div><div class="ttdeci">const byte * wc_ecc_ctx_get_own_salt(ecEncCtx *)</div><div class="ttdoc">This function returns the salt of an ecEncCtx object. This function should only be called when the ec...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd>
<dd>
<a class="el" href="#ga97cddc33a77f01610a0523a65ba4616b" title="This function sets the peer salt of an ecEncCtx object.">wc_ecc_ctx_set_peer_salt</a> </dd>
<dd>
<a class="el" href="#ga0a2b5c65696e88e5ba844244c3d3733b" title="This function sets the salt pointer and length to use with KDF into the ecEncCtx object.">wc_ecc_ctx_set_kdf_salt</a> </dd></dl>

</div>
</div>
<a id="ga7bdbf99825033f3a72ca10d3412bfbdc" name="ga7bdbf99825033f3a72ca10d3412bfbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bdbf99825033f3a72ca10d3412bfbdc">&#9670;&#160;</a></span>wc_ecc_ctx_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecEncCtx * wc_ecc_ctx_new </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allocates and initializes space for a new ECC context object to allow secure message exchange with ECC. </p>
<dl class="section return"><dt>Returns</dt><dd>Success On successfully generating a new ecEncCtx object, returns a pointer to that object </dd>
<dd>
NULL Returned if the function fails to generate a new ecEncCtx object</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>indicate whether this is a server or client context Options are: REQ_RESP_CLIENT, and REQ_RESP_SERVER </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to a RNG object with which to generate a salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">ctx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span>(ctx == NULL) {</div>
<div class="line">    <span class="comment">// error generating new ecEncCtx object</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8d3cb6594810b8800fa567534117b7e0" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt</a> </dd>
<dd>
<a class="el" href="#gad21887dbd46653ab137968663baa9368" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt_ex</a> </dd>
<dd>
<a class="el" href="#ga04a37c183aa782be024f704c3e1d9336" title="This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...">wc_ecc_decrypt</a> </dd></dl>

</div>
</div>
<a id="gab70c7e43da7725ffddcd0da19758448c" name="gab70c7e43da7725ffddcd0da19758448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab70c7e43da7725ffddcd0da19758448c">&#9670;&#160;</a></span>wc_ecc_ctx_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_ctx_reset </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets an ecEncCtx structure to avoid having to free and allocate a new context object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned if the ecEncCtx structure is successfully reset </dd>
<dd>
BAD_FUNC_ARG Returned if either rng or ctx is NULL </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a new salt for the ECC object</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx object to reset </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to an RNG object with which to generate a new salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">ctx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div>
<div class="line"><span class="comment">// do secure communication</span></div>
<div class="line">...</div>
<div class="line">wc_ecc_ctx_reset(&amp;ctx, &amp;rng);</div>
<div class="line"><span class="comment">// do more secure communication</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga71eb3904a72e85b649aef3846cc4efeb" name="ga71eb3904a72e85b649aef3846cc4efeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71eb3904a72e85b649aef3846cc4efeb">&#9670;&#160;</a></span>wc_ecc_ctx_set_algo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_ctx_set_algo </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>encAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>kdfAlgo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>macAlgo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can optionally be called after wc_ecc_ctx_new. It sets the encryption, KDF, and MAC algorithms into an ecEncCtx object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the information for the ecEncCtx object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given ecEncCtx object is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx for which to set the info </td></tr>
    <tr><td class="paramname">encAlgo</td><td>encryption algorithm to use. </td></tr>
    <tr><td class="paramname">kdfAlgo</td><td>KDF algorithm to use. </td></tr>
    <tr><td class="paramname">macAlgo</td><td>MAC algorithm to use.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line"><span class="comment">// initialize ctx</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga71eb3904a72e85b649aef3846cc4efeb">wc_ecc_ctx_set_algo</a>(&amp;ctx, ecAES_128_CTR, ecHKDF_SHA256, ecHMAC_SHA256))) {</div>
<div class="line">    <span class="comment">// error setting info</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga71eb3904a72e85b649aef3846cc4efeb"><div class="ttname"><a href="#ga71eb3904a72e85b649aef3846cc4efeb">wc_ecc_ctx_set_algo</a></div><div class="ttdeci">int wc_ecc_ctx_set_algo(ecEncCtx *ctx, byte encAlgo, byte kdfAlgo, byte macAlgo)</div><div class="ttdoc">This function can optionally be called after wc_ecc_ctx_new. It sets the encryption,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga9e16a5e6f2da3a9a15ffbcfacc0cdd03" name="ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e16a5e6f2da3a9a15ffbcfacc0cdd03">&#9670;&#160;</a></span>wc_ecc_ctx_set_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_ctx_set_info </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional information for an ecEncCtx object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the information for the ecEncCtx object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given ecEncCtx object is NULL, the input info is NULL or it's size is invalid</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx for which to set the info </td></tr>
    <tr><td class="paramname">info</td><td>pointer to a buffer containing the info to set </td></tr>
    <tr><td class="paramname">sz</td><td>size of the info buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* ctx;</div>
<div class="line"><span class="keywordtype">byte</span> info[] = { initialize with information };</div>
<div class="line"><span class="comment">// initialize ctx, get salt,</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga9e16a5e6f2da3a9a15ffbcfacc0cdd03">wc_ecc_ctx_set_info</a>(&amp;ctx, info, <span class="keyword">sizeof</span>(info))) {</div>
<div class="line">    <span class="comment">// error setting info</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"><div class="ttname"><a href="#ga9e16a5e6f2da3a9a15ffbcfacc0cdd03">wc_ecc_ctx_set_info</a></div><div class="ttdeci">int wc_ecc_ctx_set_info(ecEncCtx *ctx, const byte *info, int sz)</div><div class="ttdoc">This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional inf...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bdbf99825033f3a72ca10d3412bfbdc" title="This function allocates and initializes space for a new ECC context object to allow secure message ex...">wc_ecc_ctx_new</a> </dd></dl>

</div>
</div>
<a id="ga0a2b5c65696e88e5ba844244c3d3733b" name="ga0a2b5c65696e88e5ba844244c3d3733b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2b5c65696e88e5ba844244c3d3733b">&#9670;&#160;</a></span>wc_ecc_ctx_set_kdf_salt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_ctx_set_kdf_salt </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the salt pointer and length to use with KDF into the ecEncCtx object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the salt for the ecEncCtx object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given ecEncCtx object is NULL or if the given salt is NULL and length is not NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx for which to set the salt </td></tr>
    <tr><td class="paramname">salt</td><td>pointer to salt buffer </td></tr>
    <tr><td class="paramname">sz</td><td>length salt in bytes</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* srvCtx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">byte</span> cliSalt[] = { fixed salt data };</div>
<div class="line">word32 cliSaltLen = (word32)<span class="keyword">sizeof</span>(cliSalt);</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">cliCtx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_SERVER, &amp;rng);</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga0a2b5c65696e88e5ba844244c3d3733b">wc_ecc_ctx_set_kdf_salt</a>(&amp;cliCtx, cliSalt, cliSaltLen);</div>
<div class="ttc" id="agroup__ECC_html_ga0a2b5c65696e88e5ba844244c3d3733b"><div class="ttname"><a href="#ga0a2b5c65696e88e5ba844244c3d3733b">wc_ecc_ctx_set_kdf_salt</a></div><div class="ttdeci">int wc_ecc_ctx_set_kdf_salt(ecEncCtx *ctx, const byte *salt, word32 sz)</div><div class="ttdoc">This function sets the salt pointer and length to use with KDF into the ecEncCtx object.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad6955a4dc899acc9aa0a5186b07b39bd" title="This function returns the salt of an ecEncCtx object. This function should only be called when the ec...">wc_ecc_ctx_get_own_salt</a> </dd>
<dd>
wc_ecc_ctx_get_peer_salt </dd></dl>

</div>
</div>
<a id="ga97cddc33a77f01610a0523a65ba4616b" name="ga97cddc33a77f01610a0523a65ba4616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cddc33a77f01610a0523a65ba4616b">&#9670;&#160;</a></span>wc_ecc_ctx_set_peer_salt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_ctx_set_peer_salt </td>
          <td>(</td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>salt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the peer salt of an ecEncCtx object. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the peer salt for the ecEncCtx object. </dd>
<dd>
BAD_FUNC_ARG Returned if the given ecEncCtx object is NULL or has an invalid protocol, or if the given salt is NULL </dd>
<dd>
BAD_ENC_STATE_E Returned if the ecEncCtx's state is ecSRV_SALT_GET or ecCLI_SALT_GET. In the latter two cases, this function also sets the ecEncCtx's state to ecSRV_BAD_STATE or ecCLI_BAD_STATE, respectively</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>pointer to the ecEncCtx for which to set the salt </td></tr>
    <tr><td class="paramname">salt</td><td>pointer to the peer's salt</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecEncCtx* cliCtx, srvCtx;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">byte</span>* cliSalt, srvSalt;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">cliCtx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_CLIENT, &amp;rng);</div>
<div class="line">srvCtx = <a class="code hl_function" href="#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a>(REQ_RESP_SERVER, &amp;rng);</div>
<div class="line"> </div>
<div class="line">cliSalt = <a class="code hl_function" href="#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a>(&amp;cliCtx);</div>
<div class="line">srvSalt = <a class="code hl_function" href="#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a>(&amp;srvCtx);</div>
<div class="line">ret = <a class="code hl_function" href="#ga97cddc33a77f01610a0523a65ba4616b">wc_ecc_ctx_set_peer_salt</a>(&amp;cliCtx, srvSalt);</div>
<div class="ttc" id="agroup__ECC_html_ga97cddc33a77f01610a0523a65ba4616b"><div class="ttname"><a href="#ga97cddc33a77f01610a0523a65ba4616b">wc_ecc_ctx_set_peer_salt</a></div><div class="ttdeci">int wc_ecc_ctx_set_peer_salt(ecEncCtx *ctx, const byte *salt)</div><div class="ttdoc">This function sets the peer salt of an ecEncCtx object.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad6955a4dc899acc9aa0a5186b07b39bd" title="This function returns the salt of an ecEncCtx object. This function should only be called when the ec...">wc_ecc_ctx_get_own_salt</a> </dd>
<dd>
<a class="el" href="#ga0a2b5c65696e88e5ba844244c3d3733b" title="This function sets the salt pointer and length to use with KDF into the ecEncCtx object.">wc_ecc_ctx_set_kdf_salt</a> </dd></dl>

</div>
</div>
<a id="ga04a37c183aa782be024f704c3e1d9336" name="ga04a37c183aa782be024f704c3e1d9336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a37c183aa782be024f704c3e1d9336">&#9670;&#160;</a></span>wc_ecc_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_decrypt </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>privKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>pubKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>msgSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully decrypting the input message </dd>
<dd>
BAD_FUNC_ARG Returned if privKey, pubKey, msg, msgSz, out, or outSz are NULL, or the ctx object specifies an unsupported encryption type </dd>
<dd>
BAD_ENC_STATE_E Returned if the ctx object given is in a state that is not appropriate for decryption </dd>
<dd>
BUFFER_E Returned if the supplied output buffer is too small to store the decrypted plaintext </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory for the shared secret key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privKey</td><td>pointer to the ecc_key object containing the private key to use for decryption </td></tr>
    <tr><td class="paramname">pubKey</td><td>pointer to the ecc_key object containing the public key of the peer with whom one wishes to communicate </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to the buffer holding the ciphertext to decrypt </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the decrypted plaintext </td></tr>
    <tr><td class="paramname">outSz</td><td>pointer to a word32 object containing the available size in the out buffer. Upon successfully decrypting the ciphertext, holds the number of bytes written to the output buffer </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional: pointer to an ecEncCtx object specifying different decryption algorithms to use</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> cipher[] = { initialize with</div>
<div class="line">ciphertext to decrypt. Ensure padded to block size };</div>
<div class="line"><span class="keywordtype">byte</span> plain[<span class="keyword">sizeof</span>(cipher)];</div>
<div class="line">word32 plainSz = <span class="keyword">sizeof</span>(plain);</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key cli, serv;</div>
<div class="line"><span class="comment">// initialize cli with private key</span></div>
<div class="line"><span class="comment">// initialize serv with received public key</span></div>
<div class="line">ecEncCtx* cliCtx, servCtx;</div>
<div class="line"><span class="comment">// initialize cliCtx and servCtx</span></div>
<div class="line"><span class="comment">// exchange salts</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga04a37c183aa782be024f704c3e1d9336">wc_ecc_decrypt</a>(&amp;cli, &amp;serv, cipher, <span class="keyword">sizeof</span>(cipher),</div>
<div class="line">plain, &amp;plainSz, cliCtx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(ret != 0) {</div>
<div class="line">    <span class="comment">// error decrypting message</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga04a37c183aa782be024f704c3e1d9336"><div class="ttname"><a href="#ga04a37c183aa782be024f704c3e1d9336">wc_ecc_decrypt</a></div><div class="ttdeci">int wc_ecc_decrypt(ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</div><div class="ttdoc">This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8d3cb6594810b8800fa567534117b7e0" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt</a> </dd>
<dd>
<a class="el" href="#gad21887dbd46653ab137968663baa9368" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt_ex</a> </dd></dl>

</div>
</div>
<a id="gaf56f44972208a70b5a897261567eb8b9" name="gaf56f44972208a70b5a897261567eb8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56f44972208a70b5a897261567eb8b9">&#9670;&#160;</a></span>wc_ecc_del_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_ecc_del_point </td>
          <td>(</td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an ECC point from memory. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to free.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* point;</div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line"><span class="keywordflow">if</span> (point == NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle point creation error</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Do stuff with point</span></div>
<div class="line"><a class="code hl_function" href="#gaf56f44972208a70b5a897261567eb8b9">wc_ecc_del_point</a>(point);</div>
<div class="ttc" id="agroup__ECC_html_gaf56f44972208a70b5a897261567eb8b9"><div class="ttname"><a href="#gaf56f44972208a70b5a897261567eb8b9">wc_ecc_del_point</a></div><div class="ttdeci">void wc_ecc_del_point(ecc_point *p)</div><div class="ttdoc">Free an ECC point from memory.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0f5af518bb0c72b8ba1047be3adc6f07" title="Allocate a new ECC point.">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6" title="Compare the value of a point with another one.">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="#ga402a981bb51a35788fda0b183f34f430" title="Copy the value of one point to another one.">wc_ecc_copy_point</a> </dd></dl>

</div>
</div>
<a id="ga8d3cb6594810b8800fa567534117b7e0" name="ga8d3cb6594810b8800fa567534117b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3cb6594810b8800fa567534117b7e0">&#9670;&#160;</a></span>wc_ecc_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_encrypt </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>privKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>pubKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>msgSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully encrypting the input message </dd>
<dd>
BAD_FUNC_ARG Returned if privKey, pubKey, msg, msgSz, out, or outSz are NULL, or the ctx object specifies an unsupported encryption type </dd>
<dd>
BAD_ENC_STATE_E Returned if the ctx object given is in a state that is not appropriate for encryption </dd>
<dd>
BUFFER_E Returned if the supplied output buffer is too small to store the encrypted ciphertext </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory for the shared secret key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privKey</td><td>pointer to the ecc_key object containing the private key to use for encryption </td></tr>
    <tr><td class="paramname">pubKey</td><td>pointer to the ecc_key object containing the public key of the peer with whom one wishes to communicate </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to the buffer holding the message to encrypt </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of the buffer to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the encrypted ciphertext </td></tr>
    <tr><td class="paramname">outSz</td><td>pointer to a word32 object containing the available size in the out buffer. Upon successfully encrypting the message, holds the number of bytes written to the output buffer </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional: pointer to an ecEncCtx object specifying different encryption algorithms to use</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> msg[] = { initialize with msg to encrypt. Ensure padded to block size };</div>
<div class="line"><span class="keywordtype">byte</span> out[<span class="keyword">sizeof</span>(msg)];</div>
<div class="line">word32 outSz = <span class="keyword">sizeof</span>(out);</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key cli, serv;</div>
<div class="line"><span class="comment">// initialize cli with private key</span></div>
<div class="line"><span class="comment">// initialize serv with received public key</span></div>
<div class="line"> </div>
<div class="line">ecEncCtx* cliCtx, servCtx;</div>
<div class="line"><span class="comment">// initialize cliCtx and servCtx</span></div>
<div class="line"><span class="comment">// exchange salts</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga8d3cb6594810b8800fa567534117b7e0">wc_ecc_encrypt</a>(&amp;cli, &amp;serv, msg, <span class="keyword">sizeof</span>(msg), out, &amp;outSz, cliCtx);</div>
<div class="line"><span class="keywordflow">if</span>(ret != 0) {</div>
<div class="line">    <span class="comment">// error encrypting message</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga8d3cb6594810b8800fa567534117b7e0"><div class="ttname"><a href="#ga8d3cb6594810b8800fa567534117b7e0">wc_ecc_encrypt</a></div><div class="ttdeci">int wc_ecc_encrypt(ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</div><div class="ttdoc">This function encrypts the given input message from msg to out. This function takes an optional ctx o...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad21887dbd46653ab137968663baa9368" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt_ex</a> </dd>
<dd>
<a class="el" href="#ga04a37c183aa782be024f704c3e1d9336" title="This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...">wc_ecc_decrypt</a> </dd></dl>

</div>
</div>
<a id="gad21887dbd46653ab137968663baa9368" name="gad21887dbd46653ab137968663baa9368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad21887dbd46653ab137968663baa9368">&#9670;&#160;</a></span>wc_ecc_encrypt_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_encrypt_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>privKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>pubKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>msgSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecEncCtx *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>compressed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully encrypting the input message </dd>
<dd>
BAD_FUNC_ARG Returned if privKey, pubKey, msg, msgSz, out, or outSz are NULL, or the ctx object specifies an unsupported encryption type </dd>
<dd>
BAD_ENC_STATE_E Returned if the ctx object given is in a state that is not appropriate for encryption </dd>
<dd>
BUFFER_E Returned if the supplied output buffer is too small to store the encrypted ciphertext </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory for the shared secret key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privKey</td><td>pointer to the ecc_key object containing the private key to use for encryption </td></tr>
    <tr><td class="paramname">pubKey</td><td>pointer to the ecc_key object containing the public key of the peer with whom one wishes to communicate </td></tr>
    <tr><td class="paramname">msg</td><td>pointer to the buffer holding the message to encrypt </td></tr>
    <tr><td class="paramname">msgSz</td><td>size of the buffer to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the encrypted ciphertext </td></tr>
    <tr><td class="paramname">outSz</td><td>pointer to a word32 object containing the available size in the out buffer. Upon successfully encrypting the message, holds the number of bytes written to the output buffer </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional: pointer to an ecEncCtx object specifying different encryption algorithms to use </td></tr>
    <tr><td class="paramname">compressed</td><td>Public key field is to be output in compressed format.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> msg[] = { initialize with msg to encrypt. Ensure padded to block size };</div>
<div class="line"><span class="keywordtype">byte</span> out[<span class="keyword">sizeof</span>(msg)];</div>
<div class="line">word32 outSz = <span class="keyword">sizeof</span>(out);</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key cli, serv;</div>
<div class="line"><span class="comment">// initialize cli with private key</span></div>
<div class="line"><span class="comment">// initialize serv with received public key</span></div>
<div class="line"> </div>
<div class="line">ecEncCtx* cliCtx, servCtx;</div>
<div class="line"><span class="comment">// initialize cliCtx and servCtx</span></div>
<div class="line"><span class="comment">// exchange salts</span></div>
<div class="line">ret = <a class="code hl_function" href="#gad21887dbd46653ab137968663baa9368">wc_ecc_encrypt_ex</a>(&amp;cli, &amp;serv, msg, <span class="keyword">sizeof</span>(msg), out, &amp;outSz, cliCtx,</div>
<div class="line">    1);</div>
<div class="line"><span class="keywordflow">if</span>(ret != 0) {</div>
<div class="line">    <span class="comment">// error encrypting message</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gad21887dbd46653ab137968663baa9368"><div class="ttname"><a href="#gad21887dbd46653ab137968663baa9368">wc_ecc_encrypt_ex</a></div><div class="ttdeci">int wc_ecc_encrypt_ex(ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx, int compressed)</div><div class="ttdoc">This function encrypts the given input message from msg to out. This function takes an optional ctx o...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8d3cb6594810b8800fa567534117b7e0" title="This function encrypts the given input message from msg to out. This function takes an optional ctx o...">wc_ecc_encrypt</a> </dd>
<dd>
<a class="el" href="#ga04a37c183aa782be024f704c3e1d9336" title="This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as ...">wc_ecc_decrypt</a> </dd></dl>

</div>
</div>
<a id="gaaacd531f73fb2a5070d154e75795e298" name="gaaacd531f73fb2a5070d154e75795e298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacd531f73fb2a5070d154e75795e298">&#9670;&#160;</a></span>wc_ecc_export_point_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_export_point_der </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>curve_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export point to der. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
ECC_BAD_ARG_E Returns if curve_idx is less than 0 or invalid. Also returns when </dd>
<dd>
LENGTH_ONLY_E outLen is set but nothing else. </dd>
<dd>
BUFFER_E Returns if outLen is less than 1 + 2 * the curve size. </dd>
<dd>
MEMORY_E Returns if there is a problem allocating memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve_idx</td><td>Index of the curve used from ecc_sets. </td></tr>
    <tr><td class="paramname">point</td><td>Point to export to der. </td></tr>
    <tr><td class="paramname">out</td><td>Destination for the output. </td></tr>
    <tr><td class="paramname">outLen</td><td>Maxsize allowed for output, destination for final size of output</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> curve_idx;</div>
<div class="line">ecc_point* point;</div>
<div class="line"><span class="keywordtype">byte</span> out[];</div>
<div class="line">word32 outLen;</div>
<div class="line"><a class="code hl_function" href="#gaaacd531f73fb2a5070d154e75795e298">wc_ecc_export_point_der</a>(curve_idx, point, out, &amp;outLen);</div>
<div class="ttc" id="agroup__ECC_html_gaaacd531f73fb2a5070d154e75795e298"><div class="ttname"><a href="#gaaacd531f73fb2a5070d154e75795e298">wc_ecc_export_point_der</a></div><div class="ttdeci">int wc_ecc_export_point_der(const int curve_idx, ecc_point *point, byte *out, word32 *outLen)</div><div class="ttdoc">Export point to der.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga79c33de66f5ae16a005bcee4b0679af0" title="Import point from der format.">wc_ecc_import_point_der</a> </dd></dl>

</div>
</div>
<a id="gaff92a6958d7493d07534089312cf3c74" name="gaff92a6958d7493d07534089312cf3c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff92a6958d7493d07534089312cf3c74">&#9670;&#160;</a></span>wc_ecc_export_private_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_export_private_only </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports only the private key from an ecc_key structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the private key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error initializing space to store the parameters of the ecc_key </dd>
<dd>
ASN_PARSE_E Returned if the input curveName is not defined in ecc_sets </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_READ_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_TO_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MEM may be returned if there is an error processing the input parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an ecc_key structure from which to export the private key </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the private key </td></tr>
    <tr><td class="paramname">outLen</td><td>pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the private key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> priv[ECC_KEY_SIZE];</div>
<div class="line">word32 privSz = <span class="keyword">sizeof</span>(priv);</div>
<div class="line">ret = <a class="code hl_function" href="#gaff92a6958d7493d07534089312cf3c74">wc_ecc_export_private_only</a>(&amp;key, priv, &amp;privSz);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gaff92a6958d7493d07534089312cf3c74"><div class="ttname"><a href="#gaff92a6958d7493d07534089312cf3c74">wc_ecc_export_private_only</a></div><div class="ttdeci">int wc_ecc_export_private_only(ecc_key *key, byte *out, word32 *outLen)</div><div class="ttdoc">This function exports only the private key from an ecc_key structure. It stores the private key in th...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859" title="This function imports a public/private ECC key pair from a buffer containing the raw private key,...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="ga8ec718ac07b173a6e9f4dd5405bcbd57" name="ga8ec718ac07b173a6e9f4dd5405bcbd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec718ac07b173a6e9f4dd5405bcbd57">&#9670;&#160;</a></span>wc_ecc_export_x963()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_export_x963 </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully exporting the ecc_key </dd>
<dd>
LENGTH_ONLY_E Returned if the output buffer evaluates to NULL, but the other two input parameters are valid. Indicates that the function is only returning the length required to store the key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters are NULL, or the key is unsupported (has an invalid index) </dd>
<dd>
BUFFER_E Returned if the output buffer is too small to store the ecc key. If the output buffer is too small, the size needed will be returned in outLen </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_READ_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_TO_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MEM may be returned if there is an error processing the ecc_key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object to export </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the ANSI X9.63 formatted key </td></tr>
    <tr><td class="paramname">outLen</td><td>size of the output buffer. On successfully storing the key, will hold the bytes written to the output buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> buff[1024];</div>
<div class="line">word32 buffSz = <span class="keyword">sizeof</span>(buff);</div>
<div class="line"> </div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga8ec718ac07b173a6e9f4dd5405bcbd57">wc_ecc_export_x963</a>(&amp;key, buff, &amp;buffSz);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga8ec718ac07b173a6e9f4dd5405bcbd57"><div class="ttname"><a href="#ga8ec718ac07b173a6e9f4dd5405bcbd57">wc_ecc_export_x963</a></div><div class="ttdeci">int wc_ecc_export_x963(ecc_key *key, byte *out, word32 *outLen)</div><div class="ttdoc">This function exports the ECC key from the ecc_key structure, storing the result in out....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4880d9d5c603856ad2714de4d864bc71" title="This function exports the ECC key from the ecc_key structure, storing the result in out....">wc_ecc_export_x963_ex</a> </dd>
<dd>
<a class="el" href="#ga1c4116facdbb32a302c7f03cd20adac7" title="This function imports a public ECC key from a buffer containing the key stored in ANSI X9....">wc_ecc_import_x963</a> </dd></dl>

</div>
</div>
<a id="ga4880d9d5c603856ad2714de4d864bc71" name="ga4880d9d5c603856ad2714de4d864bc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4880d9d5c603856ad2714de4d864bc71">&#9670;&#160;</a></span>wc_ecc_export_x963_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_export_x963_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>compressed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. This function allows the additional option of compressing the certificate through the compressed parameter. When this parameter is true, the key will be stored in ANSI X9.63 compressed format. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully exporting the ecc_key </dd>
<dd>
NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key was requested in compressed format </dd>
<dd>
LENGTH_ONLY_E Returned if the output buffer evaluates to NULL, but the other two input parameters are valid. Indicates that the function is only returning the length required to store the key </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters are NULL, or the key is unsupported (has an invalid index) </dd>
<dd>
BUFFER_E Returned if the output buffer is too small to store the ecc key. If the output buffer is too small, the size needed will be returned in outLen </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory with XMALLOC </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_READ_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_TO_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MEM may be returned if there is an error processing the ecc_key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object to export </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the ANSI X9.63 formatted key </td></tr>
    <tr><td class="paramname">outLen</td><td>size of the output buffer. On successfully storing the key, will hold the bytes written to the output buffer </td></tr>
    <tr><td class="paramname">compressed</td><td>indicator of whether to store the key in compressed format. 1==compressed, 0==uncompressed</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> buff[1024];</div>
<div class="line">word32 buffSz = <span class="keyword">sizeof</span>(buff);</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga4880d9d5c603856ad2714de4d864bc71">wc_ecc_export_x963_ex</a>(&amp;key, buff, &amp;buffSz, 1);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga4880d9d5c603856ad2714de4d864bc71"><div class="ttname"><a href="#ga4880d9d5c603856ad2714de4d864bc71">wc_ecc_export_x963_ex</a></div><div class="ttdeci">int wc_ecc_export_x963_ex(ecc_key *key, byte *out, word32 *outLen, int compressed)</div><div class="ttdoc">This function exports the ECC key from the ecc_key structure, storing the result in out....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8ec718ac07b173a6e9f4dd5405bcbd57" title="This function exports the ECC key from the ecc_key structure, storing the result in out....">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="#ga1c4116facdbb32a302c7f03cd20adac7" title="This function imports a public ECC key from a buffer containing the key stored in ANSI X9....">wc_ecc_import_x963</a> </dd></dl>

</div>
</div>
<a id="ga5b4a7aa3018bd18ca7b9235010b13626" name="ga5b4a7aa3018bd18ca7b9235010b13626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b4a7aa3018bd18ca7b9235010b13626">&#9670;&#160;</a></span>wc_ecc_fp_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_ecc_fp_free </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees the fixed-point cache, which can be used with ecc to speed up computation times. To use this functionality, FP_ECC (fixed-point ecc), should be defined. Threaded applications should call this function before exiting the thread. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key and perform secure exchanges</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">wc_ecc_fp_free();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac18946c6b472d27e4be56740d71880bd" title="This function frees an ecc_key object after it has been used.">wc_ecc_free</a> </dd></dl>

</div>
</div>
<a id="gac18946c6b472d27e4be56740d71880bd" name="gac18946c6b472d27e4be56740d71880bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18946c6b472d27e4be56740d71880bd">&#9670;&#160;</a></span>wc_ecc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_free </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees an ecc_key object after it has been used. </p>
<dl class="section return"><dt>Returns</dt><dd>int integer returned indicating wolfSSL error or success status.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// initialize key and perform secure exchanges</span></div>
<div class="line">...</div>
<div class="line">wc_ecc_free(&amp;key);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaa0c3f56e07df66db857966e26106e18" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd></dl>

</div>
</div>
<a id="ga79c33de66f5ae16a005bcee4b0679af0" name="ga79c33de66f5ae16a005bcee4b0679af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79c33de66f5ae16a005bcee4b0679af0">&#9670;&#160;</a></span>wc_ecc_import_point_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_import_point_der </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>curve_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import point from der format. </p>
<dl class="section return"><dt>Returns</dt><dd>ECC_BAD_ARG_E Returns if any arguments are null or if inLen is even. </dd>
<dd>
MEMORY_E Returns if there is an error initializing </dd>
<dd>
NOT_COMPILED_IN Returned if HAVE_COMP_KEY is not true and in is a compressed cert </dd>
<dd>
MP_OKAY Successful operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>der buffer to import point from. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of der buffer. </td></tr>
    <tr><td class="paramname">curve_idx</td><td>Index of curve. </td></tr>
    <tr><td class="paramname">point</td><td>Destination for point.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> in[];</div>
<div class="line">word32 inLen;</div>
<div class="line"><span class="keywordtype">int</span> curve_idx;</div>
<div class="line">ecc_point* point;</div>
<div class="line"><a class="code hl_function" href="#ga79c33de66f5ae16a005bcee4b0679af0">wc_ecc_import_point_der</a>(in, inLen, curve_idx, point);</div>
<div class="ttc" id="agroup__ECC_html_ga79c33de66f5ae16a005bcee4b0679af0"><div class="ttname"><a href="#ga79c33de66f5ae16a005bcee4b0679af0">wc_ecc_import_point_der</a></div><div class="ttdeci">int wc_ecc_import_point_der(byte *in, word32 inLen, const int curve_idx, ecc_point *point)</div><div class="ttdoc">Import point from der format.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaacd531f73fb2a5070d154e75795e298" title="Export point to der.">wc_ecc_export_point_der</a> </dd></dl>

</div>
</div>
<a id="gafc1bedd2b71b7d4ed72d1d01c62b7859" name="gafc1bedd2b71b7d4ed72d1d01c62b7859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc1bedd2b71b7d4ed72d1d01c62b7859">&#9670;&#160;</a></span>wc_ecc_import_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_import_private_key </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>privSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>pubSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public/private ECC key pair from a buffer containing the raw private key, and a second buffer containing the ANSI X9.63 formatted public key. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the ecc_key NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key is stored in compressed format </dd>
<dd>
ECC_BAD_ARG_E Returned if in or key evaluate to NULL, or the inLen is even (according to the x9.63 standard, the key must be odd) </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the ECC key; may indicate that the ECC key is not stored in valid ANSI X9.63 format </dd>
<dd>
IS_POINT_E Returned if the public key exported is not a point on the ECC curve </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_READ_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_TO_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MEM may be returned if there is an error processing the ecc_key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>pointer to the buffer containing the raw private key </td></tr>
    <tr><td class="paramname">privSz</td><td>size of the private key buffer </td></tr>
    <tr><td class="paramname">pub</td><td>pointer to the buffer containing the ANSI x9.63 formatted ECC public key </td></tr>
    <tr><td class="paramname">pubSz</td><td>length of the public key input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object in which to store the imported private/public key pair</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> pub[] = { initialize with ANSI X9.63 formatted key };</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with the raw <span class="keyword">private</span> key };</div>
<div class="line"> </div>
<div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859">wc_ecc_import_private_key</a>(priv, <span class="keyword">sizeof</span>(priv), pub, <span class="keyword">sizeof</span>(pub),</div>
<div class="line">&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gafc1bedd2b71b7d4ed72d1d01c62b7859"><div class="ttname"><a href="#gafc1bedd2b71b7d4ed72d1d01c62b7859">wc_ecc_import_private_key</a></div><div class="ttdeci">int wc_ecc_import_private_key(const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ecc_key *key)</div><div class="ttdoc">This function imports a public/private ECC key pair from a buffer containing the raw private key,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8ec718ac07b173a6e9f4dd5405bcbd57" title="This function exports the ECC key from the ecc_key structure, storing the result in out....">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859" title="This function imports a public/private ECC key pair from a buffer containing the raw private key,...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="gaabd246d8560804e89c3c17c02708ccbf" name="gaabd246d8560804e89c3c17c02708ccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabd246d8560804e89c3c17c02708ccbf">&#9670;&#160;</a></span>wc_ecc_import_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_import_raw </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>qx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>qy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>curveName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fills an ecc_key structure with the raw components of an ECC signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully importing into the ecc_key structure </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error initializing space to store the parameters of the ecc_key </dd>
<dd>
ASN_PARSE_E Returned if the input curveName is not defined in ecc_sets </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_READ_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_TO_E may be returned if there is an error processing the input parameters </dd>
<dd>
MP_MEM may be returned if there is an error processing the input parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an ecc_key structure to fill </td></tr>
    <tr><td class="paramname">qx</td><td>pointer to a buffer containing the x component of the base point as an ASCII hex string </td></tr>
    <tr><td class="paramname">qy</td><td>pointer to a buffer containing the y component of the base point as an ASCII hex string </td></tr>
    <tr><td class="paramname">d</td><td>pointer to a buffer containing the private key as an ASCII hex string </td></tr>
    <tr><td class="paramname">curveName</td><td>pointer to a string containing the ECC curve name, as found in ecc_sets</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> qx[] = { initialize with x component of base point };</div>
<div class="line"><span class="keywordtype">char</span> qy[] = { initialize with y component of base point };</div>
<div class="line"><span class="keywordtype">char</span> d[]  = { initialize with <span class="keyword">private</span> key };</div>
<div class="line">ret = <a class="code hl_function" href="#gaabd246d8560804e89c3c17c02708ccbf">wc_ecc_import_raw</a>(&amp;key,qx, qy, d, <span class="stringliteral">&quot;ECC-256&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error initializing key with given inputs</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gaabd246d8560804e89c3c17c02708ccbf"><div class="ttname"><a href="#gaabd246d8560804e89c3c17c02708ccbf">wc_ecc_import_raw</a></div><div class="ttdeci">int wc_ecc_import_raw(ecc_key *key, const char *qx, const char *qy, const char *d, const char *curveName)</div><div class="ttdoc">This function fills an ecc_key structure with the raw components of an ECC signature.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859" title="This function imports a public/private ECC key pair from a buffer containing the raw private key,...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="ga1c4116facdbb32a302c7f03cd20adac7" name="ga1c4116facdbb32a302c7f03cd20adac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c4116facdbb32a302c7f03cd20adac7">&#9670;&#160;</a></span>wc_ecc_import_x963()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_import_x963 </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public ECC key from a buffer containing the key stored in ANSI X9.63 format. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the ecc_key </dd>
<dd>
NOT_COMPILED_IN Returned if the HAVE_COMP_KEY was not enabled at compile time, but the key is stored in compressed format </dd>
<dd>
ECC_BAD_ARG_E Returned if in or key evaluate to NULL, or the inLen is even (according to the x9.63 standard, the key must be odd) </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the ECC key; may indicate that the ECC key is not stored in valid ANSI X9.63 format </dd>
<dd>
IS_POINT_E Returned if the public key exported is not a point on the ECC curve </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_READ_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_TO_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MEM may be returned if there is an error processing the ecc_key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the ANSI x9.63 formatted ECC key </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object in which to store the imported key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> buff[] = { initialize with ANSI X9.63 formatted key };</div>
<div class="line"> </div>
<div class="line">ecc_key pubKey;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;pubKey);</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga1c4116facdbb32a302c7f03cd20adac7">wc_ecc_import_x963</a>(buff, <span class="keyword">sizeof</span>(buff), &amp;pubKey);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga1c4116facdbb32a302c7f03cd20adac7"><div class="ttname"><a href="#ga1c4116facdbb32a302c7f03cd20adac7">wc_ecc_import_x963</a></div><div class="ttdeci">int wc_ecc_import_x963(const byte *in, word32 inLen, ecc_key *key)</div><div class="ttdoc">This function imports a public ECC key from a buffer containing the key stored in ANSI X9....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8ec718ac07b173a6e9f4dd5405bcbd57" title="This function exports the ECC key from the ecc_key structure, storing the result in out....">wc_ecc_export_x963</a> </dd>
<dd>
<a class="el" href="#gafc1bedd2b71b7d4ed72d1d01c62b7859" title="This function imports a public/private ECC key pair from a buffer containing the raw private key,...">wc_ecc_import_private_key</a> </dd></dl>

</div>
</div>
<a id="gaaa0c3f56e07df66db857966e26106e18" name="gaaa0c3f56e07df66db857966e26106e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa0c3f56e07df66db857966e26106e18">&#9670;&#160;</a></span>wc_ecc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_init </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an ecc_key object for future use with message verification or key negotiation. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the ecc_key object </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object to initialize</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd>
<dd>
<a class="el" href="#gac18946c6b472d27e4be56740d71880bd" title="This function frees an ecc_key object after it has been used.">wc_ecc_free</a> </dd></dl>

</div>
</div>
<a id="gae59c1deab699da68ecc68c102285990b" name="gae59c1deab699da68ecc68c102285990b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59c1deab699da68ecc68c102285990b">&#9670;&#160;</a></span>wc_ecc_init_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_init_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>devId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an ecc_key object for future use with message verification or key negotiation. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the ecc_key object </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object to initialize </td></tr>
    <tr><td class="paramname">heap</td><td>pointer to a heap identifier </td></tr>
    <tr><td class="paramname">devId</td><td>ID to use with crypto callbacks or async hardware. Set to INVALID_DEVID (-2) if not used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="#gae59c1deab699da68ecc68c102285990b">wc_ecc_init_ex</a>(&amp;key, heap, devId);</div>
<div class="ttc" id="agroup__ECC_html_gae59c1deab699da68ecc68c102285990b"><div class="ttname"><a href="#gae59c1deab699da68ecc68c102285990b">wc_ecc_init_ex</a></div><div class="ttdeci">int wc_ecc_init_ex(ecc_key *key, void *heap, int devId)</div><div class="ttdoc">This function initializes an ecc_key object for future use with message verification or key negotiati...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd>
<dd>
<a class="el" href="#gac18946c6b472d27e4be56740d71880bd" title="This function frees an ecc_key object after it has been used.">wc_ecc_free</a> </dd>
<dd>
<a class="el" href="#gaaa0c3f56e07df66db857966e26106e18" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd></dl>

</div>
</div>
<a id="ga9696066946daccbf59c35dbf164be89b" name="ga9696066946daccbf59c35dbf164be89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9696066946daccbf59c35dbf164be89b">&#9670;&#160;</a></span>wc_ecc_is_valid_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_is_valid_idx </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an ECC idx is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>1 Return if valid. </dd>
<dd>
0 Return if not valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The idx number to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> is_valid;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key);</div>
<div class="line">is_valid = <a class="code hl_function" href="#ga9696066946daccbf59c35dbf164be89b">wc_ecc_is_valid_idx</a>(key.idx);</div>
<div class="line"><span class="keywordflow">if</span> (is_valid == 1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// idx is valid</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_valid == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// idx is not valid</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga9696066946daccbf59c35dbf164be89b"><div class="ttname"><a href="#ga9696066946daccbf59c35dbf164be89b">wc_ecc_is_valid_idx</a></div><div class="ttdeci">int wc_ecc_is_valid_idx(int n)</div><div class="ttdoc">Checks if an ECC idx is valid.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="gac1e0c1089cf94c596485ac36d811abc5" name="gac1e0c1089cf94c596485ac36d811abc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e0c1089cf94c596485ac36d811abc5">&#9670;&#160;</a></span>wc_ecc_key_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_ecc_key_free </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees an ecc_key key after it has been used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key structure to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// initialize key and perform ECC operations</span></div>
<div class="line">...</div>
<div class="line">wc_ecc_key_free(&amp;key);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5030ddca65344898ae556dcdde0958df" title="This function uses a user defined heap and allocates space for the key structure.">wc_ecc_key_new</a> </dd>
<dd>
<a class="el" href="#gae59c1deab699da68ecc68c102285990b" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init_ex</a> </dd></dl>

</div>
</div>
<a id="ga5030ddca65344898ae556dcdde0958df" name="ga5030ddca65344898ae556dcdde0958df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5030ddca65344898ae556dcdde0958df">&#9670;&#160;</a></span>wc_ecc_key_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecc_key * wc_ecc_key_new </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses a user defined heap and allocates space for the key structure. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the ecc_key object </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga5030ddca65344898ae556dcdde0958df">wc_ecc_key_new</a>(&amp;heap);</div>
<div class="ttc" id="agroup__ECC_html_ga5030ddca65344898ae556dcdde0958df"><div class="ttname"><a href="#ga5030ddca65344898ae556dcdde0958df">wc_ecc_key_new</a></div><div class="ttdeci">ecc_key * wc_ecc_key_new(void *heap)</div><div class="ttdoc">This function uses a user defined heap and allocates space for the key structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd>
<dd>
<a class="el" href="#gac1e0c1089cf94c596485ac36d811abc5" title="This function frees an ecc_key key after it has been used.">wc_ecc_key_free</a> </dd>
<dd>
<a class="el" href="#gaaa0c3f56e07df66db857966e26106e18" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd></dl>

</div>
</div>
<a id="ga6d0f268d7b0d7ad4b3fac490c1397fc8" name="ga6d0f268d7b0d7ad4b3fac490c1397fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">&#9670;&#160;</a></span>wc_ecc_make_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_make_key </td>
          <td>(</td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keysize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new ecc_key and stores it in key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
ECC_BAD_ARG_E Returned if rng or key evaluate to NULL </dd>
<dd>
BAD_FUNC_ARG Returned if the specified key size is not in the correct range of supported keys </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory while computing the ecc key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MEM may be returned if there is an error while computing the ecc key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>pointer to an initialized RNG object with which to generate the key </td></tr>
    <tr><td class="paramname">keysize</td><td>desired length for the ecc_key </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the ecc_key for which to generate a key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key); <span class="comment">// initialize 32 byte ecc key</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaa0c3f56e07df66db857966e26106e18" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd>
<dd>
<a class="el" href="#gac4c90785cdf60171aaa73e2e02481637" title="This function generates a new secret key using a local private key and a received public key....">wc_ecc_shared_secret</a> </dd></dl>

</div>
</div>
<a id="gaa8e76458324962efb703a7102473cebd" name="gaa8e76458324962efb703a7102473cebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8e76458324962efb703a7102473cebd">&#9670;&#160;</a></span>wc_ecc_make_key_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_make_key_ex </td>
          <td>(</td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keysize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>curve_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new ecc_key and stores it in key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on success. </dd>
<dd>
ECC_BAD_ARG_E Returned if rng or key evaluate to NULL </dd>
<dd>
BAD_FUNC_ARG Returned if the specified key size is not in the correct range of supported keys </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory while computing the ecc key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the ecc key </dd>
<dd>
MP_MEM may be returned if there is an error while computing the ecc key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Pointer to store the created key. </td></tr>
    <tr><td class="paramname">keysize</td><td>size of key to be created in bytes, set based on curveId </td></tr>
    <tr><td class="paramname">rng</td><td>Rng to be used in key creation </td></tr>
    <tr><td class="paramname">curve_id</td><td>Curve to use for key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><span class="keywordtype">int</span> curveId = ECC_SECP521R1;</div>
<div class="line"><span class="keywordtype">int</span> keySize = wc_ecc_get_curve_size_from_id(curveId);</div>
<div class="line">ret = <a class="code hl_function" href="#gaa8e76458324962efb703a7102473cebd">wc_ecc_make_key_ex</a>(&amp;rng, keySize, &amp;key, curveId);</div>
<div class="line"><span class="keywordflow">if</span> (ret != MP_OKAY) {</div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gaa8e76458324962efb703a7102473cebd"><div class="ttname"><a href="#gaa8e76458324962efb703a7102473cebd">wc_ecc_make_key_ex</a></div><div class="ttdeci">int wc_ecc_make_key_ex(WC_RNG *rng, int keysize, ecc_key *key, int curve_id)</div><div class="ttdoc">This function generates a new ecc_key and stores it in key.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd>
<dd>
wc_ecc_get_curve_size_from_id </dd></dl>

</div>
</div>
<a id="ga458a55243d54350363c0b4615d02dafd" name="ga458a55243d54350363c0b4615d02dafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458a55243d54350363c0b4615d02dafd">&#9670;&#160;</a></span>wc_ecc_mulmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_mulmod </td>
          <td>(</td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform ECC Fixed Point multiplication. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Returns on successful operation. </dd>
<dd>
MP_INIT_E Returned if there is an error initializing an integer for use with the multiple precision integer (mp_int) library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The multiplicand. </td></tr>
    <tr><td class="paramname">G</td><td>Base point to multiply. </td></tr>
    <tr><td class="paramname">R</td><td>Destination of product. </td></tr>
    <tr><td class="paramname">modulus</td><td>The modulus for the curve. </td></tr>
    <tr><td class="paramname">map</td><td>If non-zero maps the point back to affine coordinates, otherwise it's left in jacobian-montgomery form.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* base;</div>
<div class="line">ecc_point* destination;</div>
<div class="line"><span class="comment">// Initialize points</span></div>
<div class="line">base = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line">destination = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line"><span class="comment">// Setup other arguments</span></div>
<div class="line">mp_int multiplicand;</div>
<div class="line">mp_int modulus;</div>
<div class="line"><span class="keywordtype">int</span> map;</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga0f5af518bb0c72b8ba1047be3adc6f07" name="ga0f5af518bb0c72b8ba1047be3adc6f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5af518bb0c72b8ba1047be3adc6f07">&#9670;&#160;</a></span>wc_ecc_new_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecc_point * wc_ecc_new_point </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new ECC point. </p>
<dl class="section return"><dt>Returns</dt><dd>p A newly allocated point. </dd>
<dd>
NULL Returns NULL on error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* point;</div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line"><span class="keywordflow">if</span> (point == NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle point creation error</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Do stuff with point</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf56f44972208a70b5a897261567eb8b9" title="Free an ECC point from memory.">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6" title="Compare the value of a point with another one.">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="#ga402a981bb51a35788fda0b183f34f430" title="Copy the value of one point to another one.">wc_ecc_copy_point</a> </dd></dl>

</div>
</div>
<a id="gad0284c4ea20805e8e7eeb4d3054f8879" name="gad0284c4ea20805e8e7eeb4d3054f8879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0284c4ea20805e8e7eeb4d3054f8879">&#9670;&#160;</a></span>wc_ecc_point_is_at_infinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_point_is_at_infinity </td>
          <td>(</td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error. </p>
<dl class="section return"><dt>Returns</dt><dd>1 p is at infinity. </dd>
<dd>
0 p is not at infinity. </dd>
<dd>
&lt;0 Error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_point* point;</div>
<div class="line"><span class="keywordtype">int</span> is_infinity;</div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line"> </div>
<div class="line">is_infinity = <a class="code hl_function" href="#gad0284c4ea20805e8e7eeb4d3054f8879">wc_ecc_point_is_at_infinity</a>(point);</div>
<div class="line"><span class="keywordflow">if</span> (is_infinity &lt; 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_infinity == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Point is not at infinity</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_infinity == 1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Point is at infinity</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gad0284c4ea20805e8e7eeb4d3054f8879"><div class="ttname"><a href="#gad0284c4ea20805e8e7eeb4d3054f8879">wc_ecc_point_is_at_infinity</a></div><div class="ttdeci">int wc_ecc_point_is_at_infinity(ecc_point *p)</div><div class="ttdoc">Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0f5af518bb0c72b8ba1047be3adc6f07" title="Allocate a new ECC point.">wc_ecc_new_point</a> </dd>
<dd>
<a class="el" href="#gaf56f44972208a70b5a897261567eb8b9" title="Free an ECC point from memory.">wc_ecc_del_point</a> </dd>
<dd>
<a class="el" href="#ga15f05f3dc6e2221ff6651a41da4ad9d6" title="Compare the value of a point with another one.">wc_ecc_cmp_point</a> </dd>
<dd>
<a class="el" href="#ga402a981bb51a35788fda0b183f34f430" title="Copy the value of one point to another one.">wc_ecc_copy_point</a> </dd></dl>

</div>
</div>
<a id="ga78967e166f0aa6de07dc5e4b870155c4" name="ga78967e166f0aa6de07dc5e4b870155c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78967e166f0aa6de07dc5e4b870155c4">&#9670;&#160;</a></span>wc_ecc_rs_to_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_rs_to_sig </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature. This function also stores the length written to the output buffer, out, in outlen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully converting the signature </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input parameters evaluate to NULL, or if the input buffer is not large enough to hold the DER-encoded ECDSA signature </dd>
<dd>
MP_INIT_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_READ_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_CMP_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MUL_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_ADD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_TO_E may be returned if there is an error processing the ecc_key </dd>
<dd>
MP_MEM may be returned if there is an error processing the ecc_key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the buffer containing the R portion of the signature as a string </td></tr>
    <tr><td class="paramname">s</td><td>pointer to the buffer containing the S portion of the signature as a string </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the DER-encoded ECDSA signature </td></tr>
    <tr><td class="paramname">outlen</td><td>length of the output buffer available. Will store the bytes written to the buffer after successfully converting the signature to ECDSA format</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, generate R and S</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> r[] = { initialize with R };</div>
<div class="line"><span class="keywordtype">char</span> s[] = { initialize with S };</div>
<div class="line"><span class="keywordtype">byte</span> sig[<a class="code hl_function" href="#gafbedbdc67061a9912c49def9824fd3ba">wc_ecc_sig_size</a>(key)];</div>
<div class="line"><span class="comment">// signature size will be 2 * ECC key size + ~10 bytes for ASN.1 overhead</span></div>
<div class="line">word32 sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line">ret = <a class="code hl_function" href="#ga78967e166f0aa6de07dc5e4b870155c4">wc_ecc_rs_to_sig</a>(r, s, sig, &amp;sigSz);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error converting parameters to signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga78967e166f0aa6de07dc5e4b870155c4"><div class="ttname"><a href="#ga78967e166f0aa6de07dc5e4b870155c4">wc_ecc_rs_to_sig</a></div><div class="ttdeci">int wc_ecc_rs_to_sig(const char *r, const char *s, byte *out, word32 *outlen)</div><div class="ttdoc">This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature....</div></div>
<div class="ttc" id="agroup__ECC_html_gafbedbdc67061a9912c49def9824fd3ba"><div class="ttname"><a href="#gafbedbdc67061a9912c49def9824fd3ba">wc_ecc_sig_size</a></div><div class="ttdeci">int wc_ecc_sig_size(ecc_key *key)</div><div class="ttdoc">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga94996d8a8db851ea9c61f252131b51c4" title="This function signs a message digest using an ecc_key object to guarantee authenticity.">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#gafbedbdc67061a9912c49def9824fd3ba" title="This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ...">wc_ecc_sig_size</a> </dd></dl>

</div>
</div>
<a id="ga408ce10bc52e6fe1ed92493aa61d0cd6" name="ga408ce10bc52e6fe1ed92493aa61d0cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga408ce10bc52e6fe1ed92493aa61d0cd6">&#9670;&#160;</a></span>wc_ecc_set_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_set_curve </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keysize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>curve_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a curve which has larger key than specified size or the curve matched curve ID, set a curve with smaller key size to the key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysize</td><td>Key size in bytes </td></tr>
    <tr><td class="paramname">curve_id</td><td>Curve ID <pre class="fragment">                                                                                               _Example_
</pre> <div class="fragment"><div class="line"> <span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key ecc;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;ecc);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">    ret = <a class="code hl_function" href="#ga408ce10bc52e6fe1ed92493aa61d0cd6">wc_ecc_set_curve</a>(&amp;ecc, 32, ECC_SECP256R1));</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="ttc" id="agroup__ECC_html_ga408ce10bc52e6fe1ed92493aa61d0cd6"><div class="ttname"><a href="#ga408ce10bc52e6fe1ed92493aa61d0cd6">wc_ecc_set_curve</a></div><div class="ttdeci">int wc_ecc_set_curve(ecc_key *key, int keysize, int curve_id)</div><div class="ttdoc">Compare a curve which has larger key than specified size or the curve matched curve ID,...</div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83efa53f7f2e43256ed3be8c199f9e7e" name="ga83efa53f7f2e43256ed3be8c199f9e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83efa53f7f2e43256ed3be8c199f9e7e">&#9670;&#160;</a></span>wc_ecc_set_nonblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_set_nonblock </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_nb_ctx_t *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable ECC support for non-blocking operations. Supported for Single Precision (SP) math with the following build options: WOLFSSL_SP_NONBLOCK WOLFSSL_SP_SMALL WOLFSSL_SP_NO_MALLOC WC_ECC_NONBLOCK. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully setting the callback context the input message</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the ecc_key object </td></tr>
    <tr><td class="paramname">ctx</td><td>pointer to ecc_nb_ctx_t structure with stack data cache for SP</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ecc_key ecc;</div>
<div class="line">ecc_nb_ctx_t nb_ctx;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;ecc);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#ga83efa53f7f2e43256ed3be8c199f9e7e">wc_ecc_set_nonblock</a>(&amp;ecc, &amp;nb_ctx);</div>
<div class="line">    <span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">            ret = <a class="code hl_function" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb">wc_ecc_verify_hash_ex</a>(</div>
<div class="line">                &amp;r, &amp;s,       <span class="comment">// r/s as mp_int</span></div>
<div class="line">                hash, hashSz, <span class="comment">// computed hash digest</span></div>
<div class="line">                &amp;verify_res,  <span class="comment">// verification result 1=success</span></div>
<div class="line">                &amp;key</div>
<div class="line">            );</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// TODO: Real-time work can be called here</span></div>
<div class="line">        } <span class="keywordflow">while</span> (ret == FP_WOULDBLOCK);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="#gac18946c6b472d27e4be56740d71880bd">wc_ecc_free</a>(&amp;key);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga5b1bb1c6ce3f9238c8f23a3e516952bb"><div class="ttname"><a href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb">wc_ecc_verify_hash_ex</a></div><div class="ttdeci">int wc_ecc_verify_hash_ex(mp_int *r, mp_int *s, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</div><div class="ttdoc">Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...</div></div>
<div class="ttc" id="agroup__ECC_html_ga83efa53f7f2e43256ed3be8c199f9e7e"><div class="ttname"><a href="#ga83efa53f7f2e43256ed3be8c199f9e7e">wc_ecc_set_nonblock</a></div><div class="ttdeci">int wc_ecc_set_nonblock(ecc_key *key, ecc_nb_ctx_t *ctx)</div><div class="ttdoc">Enable ECC support for non-blocking operations. Supported for Single Precision (SP) math with the fol...</div></div>
<div class="ttc" id="agroup__ECC_html_gac18946c6b472d27e4be56740d71880bd"><div class="ttname"><a href="#gac18946c6b472d27e4be56740d71880bd">wc_ecc_free</a></div><div class="ttdeci">int wc_ecc_free(ecc_key *key)</div><div class="ttdoc">This function frees an ecc_key object after it has been used.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac4c90785cdf60171aaa73e2e02481637" name="gac4c90785cdf60171aaa73e2e02481637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c90785cdf60171aaa73e2e02481637">&#9670;&#160;</a></span>wc_ecc_shared_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_shared_secret </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>public_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new secret key using a local private key and a received public key. It stores this shared secret key in the buffer out and updates outlen to hold the number of bytes written to the output buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a shared secret key </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL </dd>
<dd>
ECC_BAD_ARG_E Returned if the type of the private key given as argument, private_key, is not ECC_PRIVATEKEY, or if the public and private key types (given by ecc-&gt;dp) are not equivalent </dd>
<dd>
MEMORY_E Returned if there is an error generating a new ecc point </dd>
<dd>
BUFFER_E Returned if the generated shared secret key is too long to store in the provided buffer </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the shared key </dd>
<dd>
MP_MEM may be returned if there is an error while computing the shared key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>pointer to the ecc_key structure containing the local private key </td></tr>
    <tr><td class="paramname">public_key</td><td>pointer to the ecc_key structure containing the received public key </td></tr>
    <tr><td class="paramname">out</td><td>pointer to an output buffer in which to store the generated shared secret key </td></tr>
    <tr><td class="paramname">outlen</td><td>pointer to the word32 object containing the length of the output buffer. Will be overwritten with the length written to the output buffer upon successfully generating a shared secret key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key priv, pub;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">byte</span> secret[1024]; <span class="comment">// can hold 1024 byte shared secret key</span></div>
<div class="line">word32 secretSz = <span class="keyword">sizeof</span>(secret);</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;priv); <span class="comment">// initialize key</span></div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;priv); <span class="comment">// make public/private key pair</span></div>
<div class="line"><span class="comment">// receive public key, and initialise into pub</span></div>
<div class="line">ret = <a class="code hl_function" href="#gac4c90785cdf60171aaa73e2e02481637">wc_ecc_shared_secret</a>(&amp;priv, &amp;pub, secret, &amp;secretSz);</div>
<div class="line"><span class="comment">// generate secret key</span></div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error generating shared secret key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gac4c90785cdf60171aaa73e2e02481637"><div class="ttname"><a href="#gac4c90785cdf60171aaa73e2e02481637">wc_ecc_shared_secret</a></div><div class="ttdeci">int wc_ecc_shared_secret(ecc_key *private_key, ecc_key *public_key, byte *out, word32 *outlen)</div><div class="ttdoc">This function generates a new secret key using a local private key and a received public key....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaa0c3f56e07df66db857966e26106e18" title="This function initializes an ecc_key object for future use with message verification or key negotiati...">wc_ecc_init</a> </dd>
<dd>
<a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd></dl>

</div>
</div>
<a id="gab49f07573edb8ad3eb168c866594ca05" name="gab49f07573edb8ad3eb168c866594ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab49f07573edb8ad3eb168c866594ca05">&#9670;&#160;</a></span>wc_ecc_shared_secret_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_shared_secret_ex </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>private_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_point *</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ECC shared secret between private key and public point. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Indicates success. </dd>
<dd>
BAD_FUNC_ARG Error returned when any arguments are null. </dd>
<dd>
ECC_BAD_ARG_E Error returned if private_key-&gt;type is not ECC_PRIVATEKEY or private_key-&gt;idx fails to validate. </dd>
<dd>
BUFFER_E Error when outlen is too small. </dd>
<dd>
MEMORY_E Error to create a new point. </dd>
<dd>
MP_VAL possible when an initialization failure occurs. </dd>
<dd>
MP_MEM possible when an initialization failure occurs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">private_key</td><td>The private ECC key. </td></tr>
    <tr><td class="paramname">point</td><td>The point to use (public key). </td></tr>
    <tr><td class="paramname">out</td><td>Output destination of the shared secret. Conforms to EC-DH from ANSI X9.63. </td></tr>
    <tr><td class="paramname">outlen</td><td>Input the max size and output the resulting size of the shared secret.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line">ecc_point* point;</div>
<div class="line"><span class="keywordtype">byte</span> shared_secret[];</div>
<div class="line"><span class="keywordtype">int</span> secret_size;</div>
<div class="line"><span class="keywordtype">int</span> result;</div>
<div class="line"> </div>
<div class="line">point = <a class="code hl_function" href="#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a>();</div>
<div class="line"> </div>
<div class="line">result = <a class="code hl_function" href="#gab49f07573edb8ad3eb168c866594ca05">wc_ecc_shared_secret_ex</a>(&amp;key, point,</div>
<div class="line">&amp;shared_secret, &amp;secret_size);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (result != MP_OKAY)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gab49f07573edb8ad3eb168c866594ca05"><div class="ttname"><a href="#gab49f07573edb8ad3eb168c866594ca05">wc_ecc_shared_secret_ex</a></div><div class="ttdeci">int wc_ecc_shared_secret_ex(ecc_key *private_key, ecc_point *point, byte *out, word32 *outlen)</div><div class="ttdoc">Create an ECC shared secret between private key and public point.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a> </dd></dl>

</div>
</div>
<a id="gafbedbdc67061a9912c49def9824fd3ba" name="gafbedbdc67061a9912c49def9824fd3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbedbdc67061a9912c49def9824fd3ba">&#9670;&#160;</a></span>wc_ecc_sig_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_sig_size </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Given a valid key, returns the maximum signature size, in octets </dd>
<dd>
0 Returned if the given key is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an ecc_key structure for which to get the signature size</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sigSz;</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line">sigSz = <a class="code hl_function" href="#gafbedbdc67061a9912c49def9824fd3ba">wc_ecc_sig_size</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> ( sigSz == 0) {</div>
<div class="line">    <span class="comment">// error determining sig size</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga94996d8a8db851ea9c61f252131b51c4" title="This function signs a message digest using an ecc_key object to guarantee authenticity.">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#gaf145568b65104e008a7311cffb11b562" title="This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ...">wc_ecc_sig_size_calc</a> </dd></dl>

</div>
</div>
<a id="gaf145568b65104e008a7311cffb11b562" name="gaf145568b65104e008a7311cffb11b562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf145568b65104e008a7311cffb11b562">&#9670;&#160;</a></span>wc_ecc_sig_size_calc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_sig_size_calc </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the maximum signature size, in octets</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>size</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sigSz = <a class="code hl_function" href="#gaf145568b65104e008a7311cffb11b562">wc_ecc_sig_size_calc</a>(32);</div>
<div class="line"><span class="keywordflow">if</span> ( sigSz == 0) {</div>
<div class="line">    <span class="comment">// error determining sig size</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gaf145568b65104e008a7311cffb11b562"><div class="ttname"><a href="#gaf145568b65104e008a7311cffb11b562">wc_ecc_sig_size_calc</a></div><div class="ttdeci">int wc_ecc_sig_size_calc(int sz)</div><div class="ttdoc">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga94996d8a8db851ea9c61f252131b51c4" title="This function signs a message digest using an ecc_key object to guarantee authenticity.">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#gafbedbdc67061a9912c49def9824fd3ba" title="This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ...">wc_ecc_sig_size</a> </dd></dl>

</div>
</div>
<a id="ga94996d8a8db851ea9c61f252131b51c4" name="ga94996d8a8db851ea9c61f252131b51c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94996d8a8db851ea9c61f252131b51c4">&#9670;&#160;</a></span>wc_ecc_sign_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_sign_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs a message digest using an ecc_key object to guarantee authenticity. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a signature for the message digest </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature </dd>
<dd>
ECC_BAD_ARG_E Returned if the input key is not a private key, or if the ECC OID is invalid </dd>
<dd>
RNG_FAILURE_E Returned if the rng cannot successfully generate a satisfactory key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer containing the message hash to sign </td></tr>
    <tr><td class="paramname">inlen</td><td>length of the message hash to sign </td></tr>
    <tr><td class="paramname">out</td><td>buffer in which to store the generated signature </td></tr>
    <tr><td class="paramname">outlen</td><td>max length of the output buffer. Will store the bytes written to out upon successfully generating a message signature </td></tr>
    <tr><td class="paramname">key</td><td>pointer to a private ECC key with which to generate the signature</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret, sigSz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[512]; <span class="comment">// will hold generated signature</span></div>
<div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line"><span class="keywordtype">byte</span> digest[] = { <span class="comment">// initialize with message hash };</span></div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key); <span class="comment">// make public/private key pair</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga94996d8a8db851ea9c61f252131b51c4">wc_ecc_sign_hash</a>(digest, <span class="keyword">sizeof</span>(digest), sig, &amp;sigSz, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error generating message signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga94996d8a8db851ea9c61f252131b51c4"><div class="ttname"><a href="#ga94996d8a8db851ea9c61f252131b51c4">wc_ecc_sign_hash</a></div><div class="ttdeci">int wc_ecc_sign_hash(const byte *in, word32 inlen, byte *out, word32 *outlen, WC_RNG *rng, ecc_key *key)</div><div class="ttdoc">This function signs a message digest using an ecc_key object to guarantee authenticity.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bff199922e080b6733aa2dd342f5cb7" title="This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer thro...">wc_ecc_verify_hash</a> </dd></dl>

</div>
</div>
<a id="gacab051d94dc346cb2df5f3a209dded1e" name="gacab051d94dc346cb2df5f3a209dded1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacab051d94dc346cb2df5f3a209dded1e">&#9670;&#160;</a></span>wc_ecc_sign_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_sign_hash_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a message digest. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY Returned upon successfully generating a signature for the message digest </dd>
<dd>
ECC_BAD_ARG_E Returned if the input key is not a private key, or if the ECC IDX is invalid, or if any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature </dd>
<dd>
RNG_FAILURE_E Returned if the rng cannot successfully generate a satisfactory key </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The message digest to sign. </td></tr>
    <tr><td class="paramname">inlen</td><td>The length of the digest. </td></tr>
    <tr><td class="paramname">rng</td><td>Pointer to WC_RNG struct. </td></tr>
    <tr><td class="paramname">key</td><td>A private ECC key. </td></tr>
    <tr><td class="paramname">r</td><td>The destination for r component of the signature. </td></tr>
    <tr><td class="paramname">s</td><td>The destination for s component of the signature.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret, sigSz;</div>
<div class="line">mp_int r; <span class="comment">// destination for r component of signature.</span></div>
<div class="line">mp_int s; <span class="comment">// destination for s component of signature.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[512]; <span class="comment">// will hold generated signature</span></div>
<div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line"><span class="keywordtype">byte</span> digest[] = { initialize with message hash };</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line">mp_init(&amp;r); <span class="comment">// initialize r component</span></div>
<div class="line">mp_init(&amp;s); <span class="comment">// initialize s component</span></div>
<div class="line"><a class="code hl_function" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a>(&amp;rng, 32, &amp;key); <span class="comment">// make public/private key pair</span></div>
<div class="line">ret = <a class="code hl_function" href="#gacab051d94dc346cb2df5f3a209dded1e">wc_ecc_sign_hash_ex</a>(digest, <span class="keyword">sizeof</span>(digest), &amp;rng, &amp;key, &amp;r, &amp;s);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ( ret != MP_OKAY ) {</div>
<div class="line">    <span class="comment">// error generating message signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_gacab051d94dc346cb2df5f3a209dded1e"><div class="ttname"><a href="#gacab051d94dc346cb2df5f3a209dded1e">wc_ecc_sign_hash_ex</a></div><div class="ttdeci">int wc_ecc_sign_hash_ex(const byte *in, word32 inlen, WC_RNG *rng, ecc_key *key, mp_int *r, mp_int *s)</div><div class="ttdoc">Sign a message digest.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a> </dd></dl>

</div>
</div>
<a id="ga95af657f43c1ee93d3900d2a47cdd69f" name="ga95af657f43c1ee93d3900d2a47cdd69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95af657f43c1ee93d3900d2a47cdd69f">&#9670;&#160;</a></span>wc_ecc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_size </td>
          <td>(</td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the key size of an ecc_key structure in octets. </p>
<dl class="section return"><dt>Returns</dt><dd>Given a valid key, returns the key size in octets </dd>
<dd>
0 Returned if the given key is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to an ecc_key structure for which to get the key size</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> keySz;</div>
<div class="line">ecc_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line">keySz = <a class="code hl_function" href="#ga95af657f43c1ee93d3900d2a47cdd69f">wc_ecc_size</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> ( keySz == 0) {</div>
<div class="line">    <span class="comment">// error determining key size</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga95af657f43c1ee93d3900d2a47cdd69f"><div class="ttname"><a href="#ga95af657f43c1ee93d3900d2a47cdd69f">wc_ecc_size</a></div><div class="ttdeci">int wc_ecc_size(ecc_key *key)</div><div class="ttdoc">This function returns the key size of an ecc_key structure in octets.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6d0f268d7b0d7ad4b3fac490c1397fc8" title="This function generates a new ecc_key and stores it in key.">wc_ecc_make_key</a> </dd></dl>

</div>
</div>
<a id="ga7bff199922e080b6733aa2dd342f5cb7" name="ga7bff199922e080b6733aa2dd342f5cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bff199922e080b6733aa2dd342f5cb7">&#9670;&#160;</a></span>wc_ecc_verify_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_verify_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>stat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer through stat, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully performing the signature verification. Note: This does not mean that the signature is verified. The authenticity information is stored instead in stat </dd>
<dd>
BAD_FUNC_ARG Returned any of the input parameters evaluate to NULL </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory </dd>
<dd>
MP_INIT_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_READ_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_CMP_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_INVMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_EXPTMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MUL_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_ADD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MULMOD_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_TO_E may be returned if there is an error while computing the message signature </dd>
<dd>
MP_MEM may be returned if there is an error while computing the message signature</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>pointer to the buffer containing the signature to verify </td></tr>
    <tr><td class="paramname">siglen</td><td>length of the signature to verify </td></tr>
    <tr><td class="paramname">hash</td><td>pointer to the buffer containing the hash of the message verified </td></tr>
    <tr><td class="paramname">hashlen</td><td>length of the hash of the message verified </td></tr>
    <tr><td class="paramname">stat</td><td>pointer to the result of the verification. 1 indicates the message was successfully verified </td></tr>
    <tr><td class="paramname">key</td><td>pointer to a public ECC key with which to verify the signature</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ecc_key key;</div>
<div class="line"><span class="keywordtype">int</span> ret, verified = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[1024] { initialize with received signature };</div>
<div class="line"><span class="keywordtype">byte</span> digest[] = { initialize with message hash };</div>
<div class="line"><span class="comment">// initialize key with received public key</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga7bff199922e080b6733aa2dd342f5cb7">wc_ecc_verify_hash</a>(sig, <span class="keyword">sizeof</span>(sig), digest,<span class="keyword">sizeof</span>(digest),</div>
<div class="line">&amp;verified, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error performing verification</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( verified == 0 ) {</div>
<div class="line">    <span class="comment">// the signature is invalid</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ECC_html_ga7bff199922e080b6733aa2dd342f5cb7"><div class="ttname"><a href="#ga7bff199922e080b6733aa2dd342f5cb7">wc_ecc_verify_hash</a></div><div class="ttdeci">int wc_ecc_verify_hash(const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</div><div class="ttdoc">This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer thro...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga94996d8a8db851ea9c61f252131b51c4" title="This function signs a message digest using an ecc_key object to guarantee authenticity.">wc_ecc_sign_hash</a> </dd>
<dd>
<a class="el" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb" title="Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the re...">wc_ecc_verify_hash_ex</a> </dd></dl>

</div>
</div>
<a id="ga5b1bb1c6ce3f9238c8f23a3e516952bb" name="ga5b1bb1c6ce3f9238c8f23a3e516952bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb">&#9670;&#160;</a></span>wc_ecc_verify_hash_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ecc_verify_hash_ex </td>
          <td>(</td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mp_int *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>stat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ecc_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use stat. </p>
<dl class="section return"><dt>Returns</dt><dd>MP_OKAY If successful (even if the signature is not valid) </dd>
<dd>
ECC_BAD_ARG_E Returns if arguments are null or if key-idx is invalid. </dd>
<dd>
MEMORY_E Error allocating ints or points.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The signature R component to verify </td></tr>
    <tr><td class="paramname">s</td><td>The signature S component to verify </td></tr>
    <tr><td class="paramname">hash</td><td>The hash (message digest) that was signed </td></tr>
    <tr><td class="paramname">hashlen</td><td>The length of the hash (octets) </td></tr>
    <tr><td class="paramname">stat</td><td>Result of signature, 1==valid, 0==invalid </td></tr>
    <tr><td class="paramname">key</td><td>The corresponding public ECC key</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">mp_int r;</div>
<div class="line">mp_int s;</div>
<div class="line"><span class="keywordtype">int</span> stat;</div>
<div class="line"><span class="keywordtype">byte</span> hash[] = { Some hash }</div>
<div class="line">ecc_key key;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga5b1bb1c6ce3f9238c8f23a3e516952bb">wc_ecc_verify_hash_ex</a>(&amp;r, &amp;s, hash, hashlen, &amp;stat, &amp;key) == MP_OKAY)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Check stat</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bff199922e080b6733aa2dd342f5cb7" title="This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer thro...">wc_ecc_verify_hash</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
