<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: dox_comments/header_files/ecc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_82d3bead6ddd9c04b5e63bcd98737c37.html">dox_comments</a></li><li class="navelem"><a href="dir_7d9839bdafa3337ea612d454307fbf29.html">header_files</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ecc.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="ecc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6d0f268d7b0d7ad4b3fac490c1397fc8" id="r_ga6d0f268d7b0d7ad4b3fac490c1397fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga6d0f268d7b0d7ad4b3fac490c1397fc8">wc_ecc_make_key</a> (WC_RNG *rng, int keysize, ecc_key *key)</td></tr>
<tr class="memdesc:ga6d0f268d7b0d7ad4b3fac490c1397fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new ecc_key and stores it in key.  <br /></td></tr>
<tr class="memitem:gaa8e76458324962efb703a7102473cebd" id="r_gaa8e76458324962efb703a7102473cebd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaa8e76458324962efb703a7102473cebd">wc_ecc_make_key_ex</a> (WC_RNG *rng, int keysize, ecc_key *key, int curve_id)</td></tr>
<tr class="memdesc:gaa8e76458324962efb703a7102473cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new ecc_key and stores it in key.  <br /></td></tr>
<tr class="memitem:ga95e451a312f105efde2c4c3e8dfa433f" id="r_ga95e451a312f105efde2c4c3e8dfa433f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga95e451a312f105efde2c4c3e8dfa433f">wc_ecc_check_key</a> (ecc_key *key)</td></tr>
<tr class="memdesc:ga95e451a312f105efde2c4c3e8dfa433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sanity checks on ecc key validity.  <br /></td></tr>
<tr class="memitem:gac1e0c1089cf94c596485ac36d811abc5" id="r_gac1e0c1089cf94c596485ac36d811abc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gac1e0c1089cf94c596485ac36d811abc5">wc_ecc_key_free</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gac1e0c1089cf94c596485ac36d811abc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an ecc_key key after it has been used.  <br /></td></tr>
<tr class="memitem:gac4c90785cdf60171aaa73e2e02481637" id="r_gac4c90785cdf60171aaa73e2e02481637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gac4c90785cdf60171aaa73e2e02481637">wc_ecc_shared_secret</a> (ecc_key *private_key, ecc_key *public_key, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:gac4c90785cdf60171aaa73e2e02481637"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new secret key using a local private key and a received public key. It stores this shared secret key in the buffer out and updates outlen to hold the number of bytes written to the output buffer.  <br /></td></tr>
<tr class="memitem:gab49f07573edb8ad3eb168c866594ca05" id="r_gab49f07573edb8ad3eb168c866594ca05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gab49f07573edb8ad3eb168c866594ca05">wc_ecc_shared_secret_ex</a> (ecc_key *private_key, ecc_point *point, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:gab49f07573edb8ad3eb168c866594ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ECC shared secret between private key and public point.  <br /></td></tr>
<tr class="memitem:ga94996d8a8db851ea9c61f252131b51c4" id="r_ga94996d8a8db851ea9c61f252131b51c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga94996d8a8db851ea9c61f252131b51c4">wc_ecc_sign_hash</a> (const byte *in, word32 inlen, byte *out, word32 *outlen, WC_RNG *rng, ecc_key *key)</td></tr>
<tr class="memdesc:ga94996d8a8db851ea9c61f252131b51c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message digest using an ecc_key object to guarantee authenticity.  <br /></td></tr>
<tr class="memitem:gacab051d94dc346cb2df5f3a209dded1e" id="r_gacab051d94dc346cb2df5f3a209dded1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gacab051d94dc346cb2df5f3a209dded1e">wc_ecc_sign_hash_ex</a> (const byte *in, word32 inlen, WC_RNG *rng, ecc_key *key, mp_int *r, mp_int *s)</td></tr>
<tr class="memdesc:gacab051d94dc346cb2df5f3a209dded1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a message digest.  <br /></td></tr>
<tr class="memitem:ga7bff199922e080b6733aa2dd342f5cb7" id="r_ga7bff199922e080b6733aa2dd342f5cb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga7bff199922e080b6733aa2dd342f5cb7">wc_ecc_verify_hash</a> (const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</td></tr>
<tr class="memdesc:ga7bff199922e080b6733aa2dd342f5cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the ECC signature of a hash to ensure authenticity. It returns the answer through stat, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <br /></td></tr>
<tr class="memitem:ga5b1bb1c6ce3f9238c8f23a3e516952bb" id="r_ga5b1bb1c6ce3f9238c8f23a3e516952bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga5b1bb1c6ce3f9238c8f23a3e516952bb">wc_ecc_verify_hash_ex</a> (mp_int *r, mp_int *s, const byte *hash, word32 hashlen, int *stat, ecc_key *key)</td></tr>
<tr class="memdesc:ga5b1bb1c6ce3f9238c8f23a3e516952bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an ECC signature. Result is written to stat. 1 is valid, 0 is invalid. Note: Do not use the return value to test for valid. Only use stat.  <br /></td></tr>
<tr class="memitem:gaaa0c3f56e07df66db857966e26106e18" id="r_gaaa0c3f56e07df66db857966e26106e18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaaa0c3f56e07df66db857966e26106e18">wc_ecc_init</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gaaa0c3f56e07df66db857966e26106e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ecc_key object for future use with message verification or key negotiation.  <br /></td></tr>
<tr class="memitem:gae59c1deab699da68ecc68c102285990b" id="r_gae59c1deab699da68ecc68c102285990b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gae59c1deab699da68ecc68c102285990b">wc_ecc_init_ex</a> (ecc_key *key, void *heap, int devId)</td></tr>
<tr class="memdesc:gae59c1deab699da68ecc68c102285990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ecc_key object for future use with message verification or key negotiation.  <br /></td></tr>
<tr class="memitem:ga5030ddca65344898ae556dcdde0958df" id="r_ga5030ddca65344898ae556dcdde0958df"><td class="memItemLeft" align="right" valign="top">ecc_key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga5030ddca65344898ae556dcdde0958df">wc_ecc_key_new</a> (void *heap)</td></tr>
<tr class="memdesc:ga5030ddca65344898ae556dcdde0958df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses a user defined heap and allocates space for the key structure.  <br /></td></tr>
<tr class="memitem:gac18946c6b472d27e4be56740d71880bd" id="r_gac18946c6b472d27e4be56740d71880bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gac18946c6b472d27e4be56740d71880bd">wc_ecc_free</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gac18946c6b472d27e4be56740d71880bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an ecc_key object after it has been used.  <br /></td></tr>
<tr class="memitem:ga5b4a7aa3018bd18ca7b9235010b13626" id="r_ga5b4a7aa3018bd18ca7b9235010b13626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga5b4a7aa3018bd18ca7b9235010b13626">wc_ecc_fp_free</a> (void)</td></tr>
<tr class="memdesc:ga5b4a7aa3018bd18ca7b9235010b13626"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the fixed-point cache, which can be used with ecc to speed up computation times. To use this functionality, FP_ECC (fixed-point ecc), should be defined. Threaded applications should call this function before exiting the thread.  <br /></td></tr>
<tr class="memitem:ga9696066946daccbf59c35dbf164be89b" id="r_ga9696066946daccbf59c35dbf164be89b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga9696066946daccbf59c35dbf164be89b">wc_ecc_is_valid_idx</a> (int n)</td></tr>
<tr class="memdesc:ga9696066946daccbf59c35dbf164be89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an ECC idx is valid.  <br /></td></tr>
<tr class="memitem:ga0f5af518bb0c72b8ba1047be3adc6f07" id="r_ga0f5af518bb0c72b8ba1047be3adc6f07"><td class="memItemLeft" align="right" valign="top">ecc_point *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga0f5af518bb0c72b8ba1047be3adc6f07">wc_ecc_new_point</a> (void)</td></tr>
<tr class="memdesc:ga0f5af518bb0c72b8ba1047be3adc6f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new ECC point.  <br /></td></tr>
<tr class="memitem:gaf56f44972208a70b5a897261567eb8b9" id="r_gaf56f44972208a70b5a897261567eb8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaf56f44972208a70b5a897261567eb8b9">wc_ecc_del_point</a> (ecc_point *p)</td></tr>
<tr class="memdesc:gaf56f44972208a70b5a897261567eb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an ECC point from memory.  <br /></td></tr>
<tr class="memitem:ga402a981bb51a35788fda0b183f34f430" id="r_ga402a981bb51a35788fda0b183f34f430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga402a981bb51a35788fda0b183f34f430">wc_ecc_copy_point</a> (ecc_point *p, ecc_point *r)</td></tr>
<tr class="memdesc:ga402a981bb51a35788fda0b183f34f430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the value of one point to another one.  <br /></td></tr>
<tr class="memitem:ga15f05f3dc6e2221ff6651a41da4ad9d6" id="r_ga15f05f3dc6e2221ff6651a41da4ad9d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga15f05f3dc6e2221ff6651a41da4ad9d6">wc_ecc_cmp_point</a> (ecc_point *a, ecc_point *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>)</td></tr>
<tr class="memdesc:ga15f05f3dc6e2221ff6651a41da4ad9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the value of a point with another one.  <br /></td></tr>
<tr class="memitem:gad0284c4ea20805e8e7eeb4d3054f8879" id="r_gad0284c4ea20805e8e7eeb4d3054f8879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gad0284c4ea20805e8e7eeb4d3054f8879">wc_ecc_point_is_at_infinity</a> (ecc_point *p)</td></tr>
<tr class="memdesc:gad0284c4ea20805e8e7eeb4d3054f8879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a point is at infinity. Returns 1 if point is at infinity, 0 if not, &lt; 0 on error.  <br /></td></tr>
<tr class="memitem:ga458a55243d54350363c0b4615d02dafd" id="r_ga458a55243d54350363c0b4615d02dafd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga458a55243d54350363c0b4615d02dafd">wc_ecc_mulmod</a> (mp_int *k, ecc_point *G, ecc_point *R, mp_int *a, mp_int *modulus, int map)</td></tr>
<tr class="memdesc:ga458a55243d54350363c0b4615d02dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ECC Fixed Point multiplication.  <br /></td></tr>
<tr class="memitem:ga8ec718ac07b173a6e9f4dd5405bcbd57" id="r_ga8ec718ac07b173a6e9f4dd5405bcbd57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8ec718ac07b173a6e9f4dd5405bcbd57">wc_ecc_export_x963</a> (ecc_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:ga8ec718ac07b173a6e9f4dd5405bcbd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen.  <br /></td></tr>
<tr class="memitem:ga4880d9d5c603856ad2714de4d864bc71" id="r_ga4880d9d5c603856ad2714de4d864bc71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga4880d9d5c603856ad2714de4d864bc71">wc_ecc_export_x963_ex</a> (ecc_key *key, byte *out, word32 *outLen, int compressed)</td></tr>
<tr class="memdesc:ga4880d9d5c603856ad2714de4d864bc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the ECC key from the ecc_key structure, storing the result in out. The key will be stored in ANSI X9.63 format. It stores the bytes written to the output buffer in outLen. This function allows the additional option of compressing the certificate through the compressed parameter. When this parameter is true, the key will be stored in ANSI X9.63 compressed format.  <br /></td></tr>
<tr class="memitem:ga1c4116facdbb32a302c7f03cd20adac7" id="r_ga1c4116facdbb32a302c7f03cd20adac7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga1c4116facdbb32a302c7f03cd20adac7">wc_ecc_import_x963</a> (const byte *in, word32 inLen, ecc_key *key)</td></tr>
<tr class="memdesc:ga1c4116facdbb32a302c7f03cd20adac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public ECC key from a buffer containing the key stored in ANSI X9.63 format. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <br /></td></tr>
<tr class="memitem:gafc1bedd2b71b7d4ed72d1d01c62b7859" id="r_gafc1bedd2b71b7d4ed72d1d01c62b7859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gafc1bedd2b71b7d4ed72d1d01c62b7859">wc_ecc_import_private_key</a> (const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ecc_key *key)</td></tr>
<tr class="memdesc:gafc1bedd2b71b7d4ed72d1d01c62b7859"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public/private ECC key pair from a buffer containing the raw private key, and a second buffer containing the ANSI X9.63 formatted public key. This function will handle both compressed and uncompressed keys, as long as compressed keys are enabled at compile time through the HAVE_COMP_KEY option.  <br /></td></tr>
<tr class="memitem:ga78967e166f0aa6de07dc5e4b870155c4" id="r_ga78967e166f0aa6de07dc5e4b870155c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga78967e166f0aa6de07dc5e4b870155c4">wc_ecc_rs_to_sig</a> (const char *r, const char *s, byte *out, word32 *outlen)</td></tr>
<tr class="memdesc:ga78967e166f0aa6de07dc5e4b870155c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the R and S portions of an ECC signature into a DER-encoded ECDSA signature. This function also stores the length written to the output buffer, out, in outlen.  <br /></td></tr>
<tr class="memitem:gaabd246d8560804e89c3c17c02708ccbf" id="r_gaabd246d8560804e89c3c17c02708ccbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaabd246d8560804e89c3c17c02708ccbf">wc_ecc_import_raw</a> (ecc_key *key, const char *qx, const char *qy, const char *d, const char *curveName)</td></tr>
<tr class="memdesc:gaabd246d8560804e89c3c17c02708ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills an ecc_key structure with the raw components of an ECC signature.  <br /></td></tr>
<tr class="memitem:gaff92a6958d7493d07534089312cf3c74" id="r_gaff92a6958d7493d07534089312cf3c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaff92a6958d7493d07534089312cf3c74">wc_ecc_export_private_only</a> (ecc_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gaff92a6958d7493d07534089312cf3c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports only the private key from an ecc_key structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen.  <br /></td></tr>
<tr class="memitem:gaaacd531f73fb2a5070d154e75795e298" id="r_gaaacd531f73fb2a5070d154e75795e298"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaaacd531f73fb2a5070d154e75795e298">wc_ecc_export_point_der</a> (const int curve_idx, ecc_point *point, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gaaacd531f73fb2a5070d154e75795e298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export point to der.  <br /></td></tr>
<tr class="memitem:ga79c33de66f5ae16a005bcee4b0679af0" id="r_ga79c33de66f5ae16a005bcee4b0679af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga79c33de66f5ae16a005bcee4b0679af0">wc_ecc_import_point_der</a> (byte *in, word32 inLen, const int curve_idx, ecc_point *point)</td></tr>
<tr class="memdesc:ga79c33de66f5ae16a005bcee4b0679af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import point from der format.  <br /></td></tr>
<tr class="memitem:ga95af657f43c1ee93d3900d2a47cdd69f" id="r_ga95af657f43c1ee93d3900d2a47cdd69f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga95af657f43c1ee93d3900d2a47cdd69f">wc_ecc_size</a> (ecc_key *key)</td></tr>
<tr class="memdesc:ga95af657f43c1ee93d3900d2a47cdd69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the key size of an ecc_key structure in octets.  <br /></td></tr>
<tr class="memitem:gaf145568b65104e008a7311cffb11b562" id="r_gaf145568b65104e008a7311cffb11b562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gaf145568b65104e008a7311cffb11b562">wc_ecc_sig_size_calc</a> (int sz)</td></tr>
<tr class="memdesc:gaf145568b65104e008a7311cffb11b562"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash.  <br /></td></tr>
<tr class="memitem:gafbedbdc67061a9912c49def9824fd3ba" id="r_gafbedbdc67061a9912c49def9824fd3ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gafbedbdc67061a9912c49def9824fd3ba">wc_ecc_sig_size</a> (ecc_key *key)</td></tr>
<tr class="memdesc:gafbedbdc67061a9912c49def9824fd3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the worst case size for an ECC signature, given by: (keySz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ. The actual signature size can be computed with wc_ecc_sign_hash.  <br /></td></tr>
<tr class="memitem:ga7bdbf99825033f3a72ca10d3412bfbdc" id="r_ga7bdbf99825033f3a72ca10d3412bfbdc"><td class="memItemLeft" align="right" valign="top">ecEncCtx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga7bdbf99825033f3a72ca10d3412bfbdc">wc_ecc_ctx_new</a> (int flags, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga7bdbf99825033f3a72ca10d3412bfbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates and initializes space for a new ECC context object to allow secure message exchange with ECC.  <br /></td></tr>
<tr class="memitem:ga704e43c4cb0dac4e24fd2a413776f361" id="r_ga704e43c4cb0dac4e24fd2a413776f361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga704e43c4cb0dac4e24fd2a413776f361">wc_ecc_ctx_free</a> (ecEncCtx *)</td></tr>
<tr class="memdesc:ga704e43c4cb0dac4e24fd2a413776f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees the ecEncCtx object used for encrypting and decrypting messages.  <br /></td></tr>
<tr class="memitem:gab70c7e43da7725ffddcd0da19758448c" id="r_gab70c7e43da7725ffddcd0da19758448c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gab70c7e43da7725ffddcd0da19758448c">wc_ecc_ctx_reset</a> (ecEncCtx *ctx, WC_RNG *rng)</td></tr>
<tr class="memdesc:gab70c7e43da7725ffddcd0da19758448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets an ecEncCtx structure to avoid having to free and allocate a new context object.  <br /></td></tr>
<tr class="memitem:ga71eb3904a72e85b649aef3846cc4efeb" id="r_ga71eb3904a72e85b649aef3846cc4efeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga71eb3904a72e85b649aef3846cc4efeb">wc_ecc_ctx_set_algo</a> (ecEncCtx *ctx, byte encAlgo, byte kdfAlgo, byte macAlgo)</td></tr>
<tr class="memdesc:ga71eb3904a72e85b649aef3846cc4efeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can optionally be called after wc_ecc_ctx_new. It sets the encryption, KDF, and MAC algorithms into an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:gad6955a4dc899acc9aa0a5186b07b39bd" id="r_gad6955a4dc899acc9aa0a5186b07b39bd"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gad6955a4dc899acc9aa0a5186b07b39bd">wc_ecc_ctx_get_own_salt</a> (ecEncCtx *)</td></tr>
<tr class="memdesc:gad6955a4dc899acc9aa0a5186b07b39bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the salt of an ecEncCtx object. This function should only be called when the ecEncCtx's state is ecSRV_INIT or ecCLI_INIT.  <br /></td></tr>
<tr class="memitem:ga97cddc33a77f01610a0523a65ba4616b" id="r_ga97cddc33a77f01610a0523a65ba4616b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga97cddc33a77f01610a0523a65ba4616b">wc_ecc_ctx_set_peer_salt</a> (ecEncCtx *ctx, const byte *salt)</td></tr>
<tr class="memdesc:ga97cddc33a77f01610a0523a65ba4616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the peer salt of an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga0a2b5c65696e88e5ba844244c3d3733b" id="r_ga0a2b5c65696e88e5ba844244c3d3733b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga0a2b5c65696e88e5ba844244c3d3733b">wc_ecc_ctx_set_kdf_salt</a> (ecEncCtx *ctx, const byte *salt, word32 sz)</td></tr>
<tr class="memdesc:ga0a2b5c65696e88e5ba844244c3d3733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the salt pointer and length to use with KDF into the ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga9e16a5e6f2da3a9a15ffbcfacc0cdd03" id="r_ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga9e16a5e6f2da3a9a15ffbcfacc0cdd03">wc_ecc_ctx_set_info</a> (ecEncCtx *ctx, const byte *info, int sz)</td></tr>
<tr class="memdesc:ga9e16a5e6f2da3a9a15ffbcfacc0cdd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can optionally be called before or after wc_ecc_ctx_set_peer_salt. It sets optional information for an ecEncCtx object.  <br /></td></tr>
<tr class="memitem:ga8d3cb6594810b8800fa567534117b7e0" id="r_ga8d3cb6594810b8800fa567534117b7e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga8d3cb6594810b8800fa567534117b7e0">wc_ecc_encrypt</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</td></tr>
<tr class="memdesc:ga8d3cb6594810b8800fa567534117b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:gad21887dbd46653ab137968663baa9368" id="r_gad21887dbd46653ab137968663baa9368"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#gad21887dbd46653ab137968663baa9368">wc_ecc_encrypt_ex</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx, int compressed)</td></tr>
<tr class="memdesc:gad21887dbd46653ab137968663baa9368"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the given input message from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:ga04a37c183aa782be024f704c3e1d9336" id="r_ga04a37c183aa782be024f704c3e1d9336"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga04a37c183aa782be024f704c3e1d9336">wc_ecc_decrypt</a> (ecc_key *privKey, ecc_key *pubKey, const byte *msg, word32 msgSz, byte *out, word32 *outSz, ecEncCtx *ctx)</td></tr>
<tr class="memdesc:ga04a37c183aa782be024f704c3e1d9336"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decrypts the ciphertext from msg to out. This function takes an optional ctx object as parameter. When supplied, encryption proceeds based on the ecEncCtx's encAlgo, kdfAlgo, and macAlgo. If ctx is not supplied, processing completes with the default algorithms, ecAES_128_CBC, ecHKDF_SHA256 and ecHMAC_SHA256. This function requires that the messages are padded according to the encryption type specified by ctx.  <br /></td></tr>
<tr class="memitem:ga83efa53f7f2e43256ed3be8c199f9e7e" id="r_ga83efa53f7f2e43256ed3be8c199f9e7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga83efa53f7f2e43256ed3be8c199f9e7e">wc_ecc_set_nonblock</a> (ecc_key *key, ecc_nb_ctx_t *ctx)</td></tr>
<tr class="memdesc:ga83efa53f7f2e43256ed3be8c199f9e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ECC support for non-blocking operations. Supported for Single Precision (SP) math with the following build options: WOLFSSL_SP_NONBLOCK WOLFSSL_SP_SMALL WOLFSSL_SP_NO_MALLOC WC_ECC_NONBLOCK.  <br /></td></tr>
<tr class="memitem:ga408ce10bc52e6fe1ed92493aa61d0cd6" id="r_ga408ce10bc52e6fe1ed92493aa61d0cd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ECC.html#ga408ce10bc52e6fe1ed92493aa61d0cd6">wc_ecc_set_curve</a> (ecc_key *key, int keysize, int curve_id)</td></tr>
<tr class="memdesc:ga408ce10bc52e6fe1ed92493aa61d0cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a curve which has larger key than specified size or the curve matched curve ID, set a curve with smaller key size to the key.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
