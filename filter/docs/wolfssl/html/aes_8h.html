<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: dox_comments/header_files/aes.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_82d3bead6ddd9c04b5e63bcd98737c37.html">dox_comments</a></li><li class="navelem"><a href="dir_7d9839bdafa3337ea612d454307fbf29.html">header_files</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">aes.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="aes_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad52b440a630fb94e4250a37b7682ab3b" id="r_gad52b440a630fb94e4250a37b7682ab3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gad52b440a630fb94e4250a37b7682ab3b">wc_AesSetKey</a> (Aes *aes, const byte *key, word32 len, const byte *iv, int dir)</td></tr>
<tr class="memdesc:gad52b440a630fb94e4250a37b7682ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an AES structure by setting the key and then setting the initialization vector.  <br /></td></tr>
<tr class="memitem:ga58d80e002c87e2d5d1c8b01f0a7156fc" id="r_ga58d80e002c87e2d5d1c8b01f0a7156fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga58d80e002c87e2d5d1c8b01f0a7156fc">wc_AesSetIV</a> (Aes *aes, const byte *iv)</td></tr>
<tr class="memdesc:ga58d80e002c87e2d5d1c8b01f0a7156fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the initialization vector for a particular AES object. The AES object should be initialized before calling this function.  <br /></td></tr>
<tr class="memitem:gaed1e38cd30d917165183fc68dd4b218b" id="r_gaed1e38cd30d917165183fc68dd4b218b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaed1e38cd30d917165183fc68dd4b218b">wc_AesCbcEncrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz)</td></tr>
<tr class="memdesc:gaed1e38cd30d917165183fc68dd4b218b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts a plaintext message from the input buffer in, and places the resulting cipher text in the output buffer out using cipher block chaining with AES. This function requires that the AES object has been initialized by calling AesSetKey before a message is able to be encrypted. This function assumes that the input message is AES block length aligned, and expects the input length to be a multiple of the block length, which will optionally be checked and enforced if WOLFSSL_AES_CBC_LENGTH_CHECKS is defined in the build configuration. In order to assure block-multiple input, PKCS#7 style padding should be added beforehand. This differs from the OpenSSL AES-CBC methods which add the padding for you. To make the wolfSSL and corresponding OpenSSL functions interoperate, one should specify the -nopad option in the OpenSSL command line function so that it behaves like the wolfSSL AesCbcEncrypt method and does not add extra padding during encryption.  <br /></td></tr>
<tr class="memitem:ga35713fdddf94f25ca7bd1a60249b041c" id="r_ga35713fdddf94f25ca7bd1a60249b041c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga35713fdddf94f25ca7bd1a60249b041c">wc_AesCbcDecrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz)</td></tr>
<tr class="memdesc:ga35713fdddf94f25ca7bd1a60249b041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypts a cipher from the input buffer in, and places the resulting plain text in the output buffer out using cipher block chaining with AES. This function requires that the AES structure has been initialized by calling AesSetKey before a message is able to be decrypted. This function assumes that the original message was AES block length aligned, and expects the input length to be a multiple of the block length, which will optionally be checked and enforced if WOLFSSL_AES_CBC_LENGTH_CHECKS is defined in the build configuration. This differs from the OpenSSL AES-CBC methods, which add PKCS#7 padding automatically, and so do not require block-multiple input. To make the wolfSSL function and equivalent OpenSSL functions interoperate, one should specify the -nopad option in the OpenSSL command line function so that it behaves like the wolfSSL AesCbcEncrypt method and does not create errors during decryption.  <br /></td></tr>
<tr class="memitem:gabe7557f4867c7d8f84cecaa000fe43a1" id="r_gabe7557f4867c7d8f84cecaa000fe43a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gabe7557f4867c7d8f84cecaa000fe43a1">wc_AesCtrEncrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz)</td></tr>
<tr class="memdesc:gabe7557f4867c7d8f84cecaa000fe43a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts/Decrypts a message from the input buffer in, and places the resulting cipher text in the output buffer out using CTR mode with AES. This function is only enabled if WOLFSSL_AES_COUNTER is enabled at compile time. The AES structure should be initialized through AesSetKey before calling this function. Note that this function is used for both decryption and encryption. <em>NOTE:</em> Regarding using same API for encryption and decryption. User should differentiate between Aes structures for encrypt/decrypt.  <br /></td></tr>
<tr class="memitem:gadf98e960a0f388486fed8b4b576c7514" id="r_gadf98e960a0f388486fed8b4b576c7514"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gadf98e960a0f388486fed8b4b576c7514">wc_AesEncryptDirect</a> (Aes *aes, byte *out, const byte *in)</td></tr>
<tr class="memdesc:gadf98e960a0f388486fed8b4b576c7514"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a one-block encrypt of the input block, in, into the output block, out. It uses the key of the provided AES structure, which should be initialized with wc_AesSetKey before calling this function. wc_AesSetKey should have been called with the iv set to NULL. This is only enabled if the configure option WOLFSSL_AES_DIRECT is enabled. <b>Warning:</b> In nearly all use cases ECB mode is considered to be less secure. Please avoid using ECB API’s directly whenever possible.  <br /></td></tr>
<tr class="memitem:gac03c7c2d8fc31cb4bc4d26d8dcb10fd2" id="r_gac03c7c2d8fc31cb4bc4d26d8dcb10fd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gac03c7c2d8fc31cb4bc4d26d8dcb10fd2">wc_AesDecryptDirect</a> (Aes *aes, byte *out, const byte *in)</td></tr>
<tr class="memdesc:gac03c7c2d8fc31cb4bc4d26d8dcb10fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a one-block decrypt of the input block, in, into the output block, out. It uses the key of the provided AES structure, which should be initialized with wc_AesSetKey before calling this function. wc_AesSetKey should have been called with the iv set to NULL. This is only enabled if the configure option WOLFSSL_AES_DIRECT is enabled. <b>Warning:</b> In nearly all use cases ECB mode is considered to be less secure. Please avoid using ECB API’s directly whenever possible.  <br /></td></tr>
<tr class="memitem:gafc1e71615652e4870a7c3de627be5e9b" id="r_gafc1e71615652e4870a7c3de627be5e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gafc1e71615652e4870a7c3de627be5e9b">wc_AesSetKeyDirect</a> (Aes *aes, const byte *key, word32 len, const byte *iv, int dir)</td></tr>
<tr class="memdesc:gafc1e71615652e4870a7c3de627be5e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set the AES keys for CTR mode with AES. It initializes an AES object with the given key, iv (initialization vector), and encryption dir (direction). It is only enabled if the configure option WOLFSSL_AES_DIRECT is enabled. Currently wc_AesSetKeyDirect uses wc_AesSetKey internally. <b>Warning:</b> In nearly all use cases ECB mode is considered to be less secure. Please avoid using ECB API’s directly whenever possible.  <br /></td></tr>
<tr class="memitem:ga4d88b09e44908284d49ecbbfe389816b" id="r_ga4d88b09e44908284d49ecbbfe389816b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga4d88b09e44908284d49ecbbfe389816b">wc_AesGcmSetKey</a> (Aes *aes, const byte *key, word32 len)</td></tr>
<tr class="memdesc:ga4d88b09e44908284d49ecbbfe389816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set the key for AES GCM (Galois/Counter Mode). It initializes an AES object with the given key. It is only enabled if the configure option HAVE_AESGCM is enabled at compile time.  <br /></td></tr>
<tr class="memitem:ga8ca2509cefd6a9d4b446c1ee38140fe1" id="r_ga8ca2509cefd6a9d4b446c1ee38140fe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga8ca2509cefd6a9d4b446c1ee38140fe1">wc_AesGcmEncrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz, const byte *iv, word32 ivSz, byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga8ca2509cefd6a9d4b446c1ee38140fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the input message, held in the buffer in, and stores the resulting cipher text in the output buffer out. It requires a new iv (initialization vector) for each call to encrypt. It also encodes the input authentication vector, authIn, into the authentication tag, authTag.  <br /></td></tr>
<tr class="memitem:ga3abce2439b7cf22adbf5c800a9b79d7d" id="r_ga3abce2439b7cf22adbf5c800a9b79d7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga3abce2439b7cf22adbf5c800a9b79d7d">wc_AesGcmDecrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz, const byte *iv, word32 ivSz, const byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga3abce2439b7cf22adbf5c800a9b79d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decrypts the input cipher text, held in the buffer in, and stores the resulting message text in the output buffer out. It also checks the input authentication vector, authIn, against the supplied authentication tag, authTag. If a nonzero error code is returned, the output data is undefined. However, callers must unconditionally zeroize the output buffer to guard against leakage of cleartext data.  <br /></td></tr>
<tr class="memitem:gae42e0250f7ec82cf1dce498d59b5f725" id="r_gae42e0250f7ec82cf1dce498d59b5f725"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gae42e0250f7ec82cf1dce498d59b5f725">wc_GmacSetKey</a> (Gmac *gmac, const byte *key, word32 len)</td></tr>
<tr class="memdesc:gae42e0250f7ec82cf1dce498d59b5f725"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes and sets the key for a GMAC object to be used for Galois Message Authentication.  <br /></td></tr>
<tr class="memitem:gaeb328cdd7c9ff7433198a0c4b19416af" id="r_gaeb328cdd7c9ff7433198a0c4b19416af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaeb328cdd7c9ff7433198a0c4b19416af">wc_GmacUpdate</a> (Gmac *gmac, const byte *iv, word32 ivSz, const byte *authIn, word32 authInSz, byte *authTag, word32 authTagSz)</td></tr>
<tr class="memdesc:gaeb328cdd7c9ff7433198a0c4b19416af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates the Gmac hash of the authIn input and stores the result in the authTag buffer. After running wc_GmacUpdate, one should compare the generated authTag to a known authentication tag to verify the authenticity of a message.  <br /></td></tr>
<tr class="memitem:ga093c15adc447598d0a8def1676ee9939" id="r_ga093c15adc447598d0a8def1676ee9939"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga093c15adc447598d0a8def1676ee9939">wc_AesCcmSetKey</a> (Aes *aes, const byte *key, word32 keySz)</td></tr>
<tr class="memdesc:ga093c15adc447598d0a8def1676ee9939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the key for an AES object using CCM (Counter with CBC-MAC). It takes a pointer to an AES structure and initializes it with supplied key.  <br /></td></tr>
<tr class="memitem:ga5742b8232c72e07262d8daff5b6da21c" id="r_ga5742b8232c72e07262d8daff5b6da21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga5742b8232c72e07262d8daff5b6da21c">wc_AesCcmEncrypt</a> (Aes *aes, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga5742b8232c72e07262d8daff5b6da21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the input message, in, into the output buffer, out, using CCM (Counter with CBC-MAC). It subsequently calculates and stores the authorization tag, authTag, from the authIn input.  <br /></td></tr>
<tr class="memitem:ga74f0c4e47cecadaf02c1e5a756fcb0e2" id="r_ga74f0c4e47cecadaf02c1e5a756fcb0e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga74f0c4e47cecadaf02c1e5a756fcb0e2">wc_AesCcmDecrypt</a> (Aes *aes, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, const byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga74f0c4e47cecadaf02c1e5a756fcb0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decrypts the input cipher text, in, into the output buffer, out, using CCM (Counter with CBC-MAC). It subsequently calculates the authorization tag, authTag, from the authIn input. If a nonzero error code is returned, the output data is undefined. However, callers must unconditionally zeroize the output buffer to guard against leakage of cleartext data.  <br /></td></tr>
<tr class="memitem:ga01b5393003225bd3ed93c5e3bb73a184" id="r_ga01b5393003225bd3ed93c5e3bb73a184"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga01b5393003225bd3ed93c5e3bb73a184">wc_AesXtsInit</a> (XtsAes *aes, void *heap, int devId)</td></tr>
<tr class="memdesc:ga01b5393003225bd3ed93c5e3bb73a184"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to initialize an AES-XTS context. It is up to user to call wc_AesXtsFree on aes key when done.  <br /></td></tr>
<tr class="memitem:ga8b89849095c6d10b248dd2ccf6dff5e7" id="r_ga8b89849095c6d10b248dd2ccf6dff5e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga8b89849095c6d10b248dd2ccf6dff5e7">wc_AesXtsSetKeyNoInit</a> (XtsAes *aes, const byte *key, word32 len, int dir)</td></tr>
<tr class="memdesc:ga8b89849095c6d10b248dd2ccf6dff5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to help with setting keys to correct encrypt or decrypt type, after first calling <a class="el" href="group__AES.html#ga01b5393003225bd3ed93c5e3bb73a184" title="This is to initialize an AES-XTS context. It is up to user to call wc_AesXtsFree on aes key when done...">wc_AesXtsInit()</a>. It is up to user to call wc_AesXtsFree on aes key when done.  <br /></td></tr>
<tr class="memitem:gaa1a5c32613382ca969ef11b875752f51" id="r_gaa1a5c32613382ca969ef11b875752f51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaa1a5c32613382ca969ef11b875752f51">wc_AesXtsSetKey</a> (XtsAes *aes, const byte *key, word32 len, int dir, void *heap, int devId)</td></tr>
<tr class="memdesc:gaa1a5c32613382ca969ef11b875752f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to help with setting keys to correct encrypt or decrypt type. It is up to user to call wc_AesXtsFree on aes key when done.  <br /></td></tr>
<tr class="memitem:gaf06ea9dce97f3bda7d1ce373c6a917c3" id="r_gaf06ea9dce97f3bda7d1ce373c6a917c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaf06ea9dce97f3bda7d1ce373c6a917c3">wc_AesXtsEncryptSector</a> (XtsAes *aes, byte *out, const byte *in, word32 sz, word64 sector)</td></tr>
<tr class="memdesc:gaf06ea9dce97f3bda7d1ce373c6a917c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same process as wc_AesXtsEncrypt but uses a word64 type as the tweak value instead of a byte array. This just converts the word64 to a byte array and calls wc_AesXtsEncrypt.  <br /></td></tr>
<tr class="memitem:ga656aa1de00e3d73649726a9303ac863d" id="r_ga656aa1de00e3d73649726a9303ac863d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga656aa1de00e3d73649726a9303ac863d">wc_AesXtsDecryptSector</a> (XtsAes *aes, byte *out, const byte *in, word32 sz, word64 sector)</td></tr>
<tr class="memdesc:ga656aa1de00e3d73649726a9303ac863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same process as wc_AesXtsDecrypt but uses a word64 type as the tweak value instead of a byte array. This just converts the word64 to a byte array.  <br /></td></tr>
<tr class="memitem:ga0372af5fdae94d196c977e28c3e35a81" id="r_ga0372af5fdae94d196c977e28c3e35a81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga0372af5fdae94d196c977e28c3e35a81">wc_AesXtsEncrypt</a> (XtsAes *aes, byte *out, const byte *in, word32 sz, const byte *i, word32 iSz)</td></tr>
<tr class="memdesc:ga0372af5fdae94d196c977e28c3e35a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES with XTS mode. (XTS) XEX encryption with Tweak and cipher text Stealing.  <br /></td></tr>
<tr class="memitem:gad3aea81076e797ce28aa77e9cd610779" id="r_gad3aea81076e797ce28aa77e9cd610779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gad3aea81076e797ce28aa77e9cd610779">wc_AesXtsDecrypt</a> (XtsAes *aes, byte *out, const byte *in, word32 sz, const byte *i, word32 iSz)</td></tr>
<tr class="memdesc:gad3aea81076e797ce28aa77e9cd610779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same process as encryption but Aes key is AES_DECRYPTION type.  <br /></td></tr>
<tr class="memitem:ga8d63d909dd415e2954daec23cb4851ab" id="r_ga8d63d909dd415e2954daec23cb4851ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga8d63d909dd415e2954daec23cb4851ab">wc_AesXtsFree</a> (XtsAes *aes)</td></tr>
<tr class="memdesc:ga8d63d909dd415e2954daec23cb4851ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to free up any resources used by the XtsAes structure.  <br /></td></tr>
<tr class="memitem:ga430f0c344e8e8132bceec748483212c1" id="r_ga430f0c344e8e8132bceec748483212c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga430f0c344e8e8132bceec748483212c1">wc_AesInit</a> (Aes *aes, void *heap, int devId)</td></tr>
<tr class="memdesc:ga430f0c344e8e8132bceec748483212c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Aes structure. Sets heap hint to be used and ID for use with async hardware. It is up to the user to call wc_AesFree on the Aes structure when done.  <br /></td></tr>
<tr class="memitem:ga976e1b14c12dca0a43aebe9f70339739" id="r_ga976e1b14c12dca0a43aebe9f70339739"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga976e1b14c12dca0a43aebe9f70339739">wc_AesFree</a> (Aes *aes)</td></tr>
<tr class="memdesc:ga976e1b14c12dca0a43aebe9f70339739"><td class="mdescLeft">&#160;</td><td class="mdescRight">free resources associated with the Aes structure when applicable. Internally may sometimes be a no-op but still recommended to call in all cases as a general best-practice (IE if application code is ported for use on new environments where the call is applicable).  <br /></td></tr>
<tr class="memitem:ga92c53cbd730d329fe59a15b372495d3a" id="r_ga92c53cbd730d329fe59a15b372495d3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga92c53cbd730d329fe59a15b372495d3a">wc_AesCfbEncrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz)</td></tr>
<tr class="memdesc:ga92c53cbd730d329fe59a15b372495d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES with CFB mode.  <br /></td></tr>
<tr class="memitem:ga311d4f8105b7f3b1d5a3b46fca440b6d" id="r_ga311d4f8105b7f3b1d5a3b46fca440b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga311d4f8105b7f3b1d5a3b46fca440b6d">wc_AesCfbDecrypt</a> (Aes *aes, byte *out, const byte *in, word32 sz)</td></tr>
<tr class="memdesc:ga311d4f8105b7f3b1d5a3b46fca440b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES with CFB mode.  <br /></td></tr>
<tr class="memitem:ga49ecb8fde33e33ad2287e4d28b74a5c7" id="r_ga49ecb8fde33e33ad2287e4d28b74a5c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga49ecb8fde33e33ad2287e4d28b74a5c7">wc_AesSivEncrypt</a> (const byte *key, word32 keySz, const byte *assoc, word32 assocSz, const byte *nonce, word32 nonceSz, const byte *in, word32 inSz, byte *siv, byte *out)</td></tr>
<tr class="memdesc:ga49ecb8fde33e33ad2287e4d28b74a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs SIV (synthetic initialization vector) encryption as described in RFC 5297.  <br /></td></tr>
<tr class="memitem:ga91be158d881bb0c56fa3a03660917da6" id="r_ga91be158d881bb0c56fa3a03660917da6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga91be158d881bb0c56fa3a03660917da6">wc_AesSivDecrypt</a> (const byte *key, word32 keySz, const byte *assoc, word32 assocSz, const byte *nonce, word32 nonceSz, const byte *in, word32 inSz, byte *siv, byte *out)</td></tr>
<tr class="memdesc:ga91be158d881bb0c56fa3a03660917da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs SIV (synthetic initialization vector) decryption as described in RFC 5297. If a nonzero error code is returned, the output data is undefined. However, callers must unconditionally zeroize the output buffer to guard against leakage of cleartext data.  <br /></td></tr>
<tr class="memitem:ga0f183ab13031accc6325eba552c113e1" id="r_ga0f183ab13031accc6325eba552c113e1"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga0f183ab13031accc6325eba552c113e1">wc_AesEaxEncryptAuth</a> (const byte *key, word32 keySz, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga0f183ab13031accc6325eba552c113e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs AES EAX encryption and authentication as described in "EAX: A Conventional Authenticated-Encryption Mode" (<a href="https://eprint.iacr.org/2003/069">https://eprint.iacr.org/2003/069</a>). It is a "one-shot" API that performs all encryption and authentication operations in one function call.  <br /></td></tr>
<tr class="memitem:ga06d085c91a969020b4d6977dc6d08ef2" id="r_ga06d085c91a969020b4d6977dc6d08ef2"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga06d085c91a969020b4d6977dc6d08ef2">wc_AesEaxDecryptAuth</a> (const byte *key, word32 keySz, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, const byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga06d085c91a969020b4d6977dc6d08ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs AES EAX decryption and authentication as described in "EAX: A Conventional Authenticated-Encryption Mode" (<a href="https://eprint.iacr.org/2003/069">https://eprint.iacr.org/2003/069</a>). It is a "one-shot" API that performs all decryption and authentication operations in one function call. If a nonzero error code is returned, the output data is undefined. However, callers must unconditionally zeroize the output buffer to guard against leakage of cleartext data.  <br /></td></tr>
<tr class="memitem:ga828f06a8a61fcaae275559f64f9bcf34" id="r_ga828f06a8a61fcaae275559f64f9bcf34"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a> (AesEax *eax, const byte *key, word32 keySz, const byte *nonce, word32 nonceSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga828f06a8a61fcaae275559f64f9bcf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an AesEax object for use in authenticated encryption or decryption. This function must be called on an AesEax object before using it with any of the AES EAX incremental API functions. It does not need to be called if using the one-shot EAX API functions. All AesEax instances initialized with this function need to be freed with a call to <a class="el" href="group__AES.html#gad4d997173c1afc8abba8140c635b0ca0" title="This frees up any resources, specifically keys, used by the Aes instance inside the AesEax wrapper st...">wc_AesEaxFree()</a> when done using the instance.  <br /></td></tr>
<tr class="memitem:ga22db03a2c23b9a24eef4191391c85147" id="r_ga22db03a2c23b9a24eef4191391c85147"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga22db03a2c23b9a24eef4191391c85147">wc_AesEaxEncryptUpdate</a> (AesEax *eax, byte *out, const byte *in, word32 inSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga22db03a2c23b9a24eef4191391c85147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses AES EAX to encrypt input data, and optionally, add more input data to the authentication stream. <code>eax</code> must have been previously initialized with a call to <a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a>.  <br /></td></tr>
<tr class="memitem:ga43fa6d7e6e0f22bd0c10fc15abfb054b" id="r_ga43fa6d7e6e0f22bd0c10fc15abfb054b"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga43fa6d7e6e0f22bd0c10fc15abfb054b">wc_AesEaxDecryptUpdate</a> (AesEax *eax, byte *out, const byte *in, word32 inSz, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga43fa6d7e6e0f22bd0c10fc15abfb054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses AES EAX to decrypt input data, and optionally, add more input data to the authentication stream. <code>eax</code> must have been previously initialized with a call to <a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a>.  <br /></td></tr>
<tr class="memitem:ga8420179c682c323a07913b5172965478" id="r_ga8420179c682c323a07913b5172965478"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga8420179c682c323a07913b5172965478">wc_AesEaxAuthDataUpdate</a> (AesEax *eax, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:ga8420179c682c323a07913b5172965478"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds input data to the authentication stream. <code>eax</code> must have been previously initialized with a call to <a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a>.  <br /></td></tr>
<tr class="memitem:ga7142a20798bd52058da5a89ab2c41a91" id="r_ga7142a20798bd52058da5a89ab2c41a91"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga7142a20798bd52058da5a89ab2c41a91">wc_AesEaxEncryptFinal</a> (AesEax *eax, byte *authTag, word32 authTagSz)</td></tr>
<tr class="memdesc:ga7142a20798bd52058da5a89ab2c41a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finalizes the encrypt AEAD operation, producing an auth tag over the current authentication stream. <code>eax</code> must have been previously initialized with a call to <a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a>. When done using the <code>AesEax</code> context structure, make sure to free it using <a class="el" href="group__AES.html#gad4d997173c1afc8abba8140c635b0ca0">wc_AesEaxFree</a>.  <br /></td></tr>
<tr class="memitem:gaad5366b06f2e8b07674d06451bf08082" id="r_gaad5366b06f2e8b07674d06451bf08082"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaad5366b06f2e8b07674d06451bf08082">wc_AesEaxDecryptFinal</a> (AesEax *eax, const byte *authIn, word32 authInSz)</td></tr>
<tr class="memdesc:gaad5366b06f2e8b07674d06451bf08082"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finalizes the decrypt AEAD operation, finalizing the auth tag computation and checking it for validity against the user supplied tag. <code>eax</code> must have been previously initialized with a call to <a class="el" href="group__AES.html#ga828f06a8a61fcaae275559f64f9bcf34">wc_AesEaxInit</a>. When done using the <code>AesEax</code> context structure, make sure to free it using <a class="el" href="group__AES.html#gad4d997173c1afc8abba8140c635b0ca0">wc_AesEaxFree</a>.  <br /></td></tr>
<tr class="memitem:gad4d997173c1afc8abba8140c635b0ca0" id="r_gad4d997173c1afc8abba8140c635b0ca0"><td class="memItemLeft" align="right" valign="top">WOLFSSL_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gad4d997173c1afc8abba8140c635b0ca0">wc_AesEaxFree</a> (AesEax *eax)</td></tr>
<tr class="memdesc:gad4d997173c1afc8abba8140c635b0ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This frees up any resources, specifically keys, used by the Aes instance inside the AesEax wrapper struct. It should be called on the AesEax struct after it has been initialized with wc_AesEaxInit, and all desired EAX operations are complete.  <br /></td></tr>
<tr class="memitem:gaba13cae6b85c2ea43cfbd8b9100ab05e" id="r_gaba13cae6b85c2ea43cfbd8b9100ab05e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaba13cae6b85c2ea43cfbd8b9100ab05e">wc_AesCtsEncrypt</a> (const byte *key, word32 keySz, byte *out, const byte *in, word32 inSz, const byte *iv)</td></tr>
<tr class="memdesc:gaba13cae6b85c2ea43cfbd8b9100ab05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs AES encryption using Ciphertext Stealing (CTS) mode. It is a one-shot API that handles all operations in a single call.  <br /></td></tr>
<tr class="memitem:ga4a2a1f1c4e587134fdcf03ba1faf2e4b" id="r_ga4a2a1f1c4e587134fdcf03ba1faf2e4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#ga4a2a1f1c4e587134fdcf03ba1faf2e4b">wc_AesCtsDecrypt</a> (const byte *key, word32 keySz, byte *out, const byte *in, word32 inSz, const byte *iv)</td></tr>
<tr class="memdesc:ga4a2a1f1c4e587134fdcf03ba1faf2e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs AES decryption using Ciphertext Stealing (CTS) mode. It is a one-shot API that handles all operations in a single call.  <br /></td></tr>
<tr class="memitem:gaed7ca64828d8429b7c140941561c57a5" id="r_gaed7ca64828d8429b7c140941561c57a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaed7ca64828d8429b7c140941561c57a5">wc_AesCtsEncryptUpdate</a> (Aes *aes, byte *out, word32 *outSz, const byte *in, word32 inSz)</td></tr>
<tr class="memdesc:gaed7ca64828d8429b7c140941561c57a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs an update step of the AES CTS encryption. It processes a chunk of plaintext and stores intermediate data.  <br /></td></tr>
<tr class="memitem:gac64d26302b62805366927f15fc36daef" id="r_gac64d26302b62805366927f15fc36daef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gac64d26302b62805366927f15fc36daef">wc_AesCtsEncryptFinal</a> (Aes *aes, byte *out, word32 *outSz)</td></tr>
<tr class="memdesc:gac64d26302b62805366927f15fc36daef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finalizes the AES CTS encryption operation. It processes any remaining plaintext and completes the encryption.  <br /></td></tr>
<tr class="memitem:gaf192cb665cccec364e60be89e5cd4b5b" id="r_gaf192cb665cccec364e60be89e5cd4b5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaf192cb665cccec364e60be89e5cd4b5b">wc_AesCtsDecryptUpdate</a> (Aes *aes, byte *out, word32 *outSz, const byte *in, word32 inSz)</td></tr>
<tr class="memdesc:gaf192cb665cccec364e60be89e5cd4b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs an update step of the AES CTS decryption. It processes a chunk of ciphertext and stores intermediate data.  <br /></td></tr>
<tr class="memitem:gaa1f9afc8880044a57b9e404653581871" id="r_gaa1f9afc8880044a57b9e404653581871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AES.html#gaa1f9afc8880044a57b9e404653581871">wc_AesCtsDecryptFinal</a> (Aes *aes, byte *out, word32 *outSz)</td></tr>
<tr class="memdesc:gaa1f9afc8880044a57b9e404653581871"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finalizes the AES CTS decryption operation. It processes any remaining ciphertext and completes the decryption.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
