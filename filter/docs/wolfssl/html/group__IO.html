<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: wolfSSL Connection, Session, and I/O</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">wolfSSL Connection, Session, and I/O </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga762a42460ba55d5fc8265acc535573b9" id="r_ga762a42460ba55d5fc8265acc535573b9"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga762a42460ba55d5fc8265acc535573b9">wolfSSL_get_verify_depth</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga762a42460ba55d5fc8265acc535573b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the maximum chain depth allowed, which is 9 by default, for a valid session i.e. there is a non-null session object (ssl).  <br /></td></tr>
<tr class="memitem:ga15a272d692a7cab4d991c5b1cf9d49cf" id="r_ga15a272d692a7cab4d991c5b1cf9d49cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15a272d692a7cab4d991c5b1cf9d49cf">wolfSSL_get_cipher_list</a> (int priority)</td></tr>
<tr class="memdesc:ga15a272d692a7cab4d991c5b1cf9d49cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of cipher at priority level passed in.  <br /></td></tr>
<tr class="memitem:gadb0f97124908e6fa173259ccccc678da" id="r_gadb0f97124908e6fa173259ccccc678da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb0f97124908e6fa173259ccccc678da">wolfSSL_get_ciphers</a> (char *buf, int len)</td></tr>
<tr class="memdesc:gadb0f97124908e6fa173259ccccc678da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the ciphers enabled in wolfSSL.  <br /></td></tr>
<tr class="memitem:ga7d30914ff0d7476576faea4115228703" id="r_ga7d30914ff0d7476576faea4115228703"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7d30914ff0d7476576faea4115228703">wolfSSL_get_cipher_name</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga7d30914ff0d7476576faea4115228703"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_cipher_name_internal.  <br /></td></tr>
<tr class="memitem:gacc9ea6f4b1ca94ebd240a0752a9600f8" id="r_gacc9ea6f4b1ca94ebd240a0752a9600f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc9ea6f4b1ca94ebd240a0752a9600f8">wolfSSL_get_fd</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:gacc9ea6f4b1ca94ebd240a0752a9600f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the read file descriptor (fd) used as the input facility for the SSL connection. Typically this will be a socket file descriptor.  <br /></td></tr>
<tr class="memitem:ga956eb1db5163203c2c5948cf2a7fe924" id="r_ga956eb1db5163203c2c5948cf2a7fe924"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga956eb1db5163203c2c5948cf2a7fe924">wolfSSL_get_wfd</a> (const WOLFSSL *)</td></tr>
<tr class="memdesc:ga956eb1db5163203c2c5948cf2a7fe924"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the write file descriptor (fd) used as the output facility for the SSL connection. Typically this will be a socket file descriptor.  <br /></td></tr>
<tr class="memitem:ga1b5127f98989a255a2d7aa346a677a12" id="r_ga1b5127f98989a255a2d7aa346a677a12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b5127f98989a255a2d7aa346a677a12">wolfSSL_get_using_nonblock</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga1b5127f98989a255a2d7aa346a677a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the application to determine if wolfSSL is using non-blocking I/O. If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0. After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call <a class="el" href="group__Setup.html#ga64025d60f962a3c1ea267dc195eab8e7" title="This function informs the WOLFSSL object that the underlying I/O is non-blocking. After an applicatio...">wolfSSL_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.  <br /></td></tr>
<tr class="memitem:gad6cbb3cb90e4d606e9507e4ec06197df" id="r_gad6cbb3cb90e4d606e9507e4ec06197df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a> (WOLFSSL *ssl, const void *data, int sz)</td></tr>
<tr class="memdesc:gad6cbb3cb90e4d606e9507e4ec06197df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. When using (D)TLSv1.3 and early data feature is compiled in, this function progresses the handshake only up to the point when it is possible to send data. Next invocations of wolfSSL_Connect()/wolfSSL_Accept()/wolfSSL_read() will complete the handshake. <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will only return once the buffer data of size sz has been completely written or an error occurred.  <br /></td></tr>
<tr class="memitem:ga80c3ccd3c0441c77307df3afe88a5c35" id="r_ga80c3ccd3c0441c77307df3afe88a5c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a> (WOLFSSL *ssl, void *data, int sz)</td></tr>
<tr class="memdesc:ga80c3ccd3c0441c77307df3afe88a5c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data. The bytes read are removed from the internal receive buffer. If necessary <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_read() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:gaf7f748e1605c2d37119105d61a592290" id="r_gaf7f748e1605c2d37119105d61a592290"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7f748e1605c2d37119105d61a592290">wolfSSL_peek</a> (WOLFSSL *ssl, void *data, int sz)</td></tr>
<tr class="memdesc:gaf7f748e1605c2d37119105d61a592290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data. This function is identical to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that the data in the internal SSL session receive buffer is not removed or modified. If necessary, like <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>, <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> / <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_peek() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:gaf0cfc676947d7eabd67ec1a4661ed625" id="r_gaf0cfc676947d7eabd67ec1a4661ed625"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:gaf0cfc676947d7eabd67ec1a4661ed625"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred.  <br /></td></tr>
<tr class="memitem:gaacf169259b58f3441614c6a992d89afd" id="r_gaacf169259b58f3441614c6a992d89afd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaacf169259b58f3441614c6a992d89afd">wolfDTLS_accept_stateless</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaacf169259b58f3441614c6a992d89afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and statelessly listens for an SSL client to initiate the DTLS handshake.  <br /></td></tr>
<tr class="memitem:ga1eea65c61599bf523a87f1d8f82a4cef" id="r_ga1eea65c61599bf523a87f1d8f82a4cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef">wolfSSL_send</a> (WOLFSSL *ssl, const void *data, int sz, int flags)</td></tr>
<tr class="memdesc:ga1eea65c61599bf523a87f1d8f82a4cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified flags for the underlying write operation. If necessary <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_send to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will only return once the buffer data of size sz has been completely written or an error occurred.  <br /></td></tr>
<tr class="memitem:gaa47f91e3700231c0ac95d29663cb46d3" id="r_gaa47f91e3700231c0ac95d29663cb46d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3">wolfSSL_recv</a> (WOLFSSL *ssl, void *data, int sz, int flags)</td></tr>
<tr class="memdesc:gaa47f91e3700231c0ac95d29663cb46d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data using the specified flags for the underlying recv operation. The bytes read are removed from the internal receive buffer. This function is identical to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that it allows the application to set the recv flags for the underlying read operation. If necessary <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_recv() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will trigger processing of the next record.  <br /></td></tr>
<tr class="memitem:ga29e520b2f3fbc6b9c2fbe774b5516b83" id="r_ga29e520b2f3fbc6b9c2fbe774b5516b83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga29e520b2f3fbc6b9c2fbe774b5516b83">wolfSSL_get_alert_history</a> (WOLFSSL *ssl, WOLFSSL_ALERT_HISTORY *h)</td></tr>
<tr class="memdesc:ga29e520b2f3fbc6b9c2fbe774b5516b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the alert history.  <br /></td></tr>
<tr class="memitem:gaad042d5e0b1e7c2635b6caa12619e0f1" id="r_gaad042d5e0b1e7c2635b6caa12619e0f1"><td class="memItemLeft" align="right" valign="top">WOLFSSL_SESSION *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad042d5e0b1e7c2635b6caa12619e0f1">wolfSSL_get_session</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaad042d5e0b1e7c2635b6caa12619e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">When NO_SESSION_CACHE_REF is defined this function returns a pointer to the current session (WOLFSSL_SESSION) used in ssl. This function returns a non-persistent pointer to the WOLFSSL_SESSION object. The pointer returned will be freed when wolfSSL_free is called. This call should only be used to inspect or modify the current session. For session resumption it is recommended to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a>. For backwards compatibility when NO_SESSION_CACHE_REF is not defined this function returns a persistent session object pointer that is stored in the local cache. The cache size is finite and there is a risk that the session object will be overwritten by another ssl connection by the time the application calls <a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session()</a> on it. It is recommended to define NO_SESSION_CACHE_REF in your application and to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a> for session resumption.  <br /></td></tr>
<tr class="memitem:ga4a1a3b8e4350d41d9f5e485e315bccc9" id="r_ga4a1a3b8e4350d41d9f5e485e315bccc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a1a3b8e4350d41d9f5e485e315bccc9">wolfSSL_flush_sessions</a> (WOLFSSL_CTX *ctx, long tm)</td></tr>
<tr class="memdesc:ga4a1a3b8e4350d41d9f5e485e315bccc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function flushes session from the session cache which have expired. The time, tm, is used for the time comparison. Note that wolfSSL currently uses a static table for sessions, so no flushing is needed. As such, this function is currently just a stub. This function provides OpenSSL compatibility (SSL_flush_sessions) when wolfSSL is compiled with the OpenSSL compatibility layer.  <br /></td></tr>
<tr class="memitem:ga54930dd8cf9ac220eb44ad274d341795" id="r_ga54930dd8cf9ac220eb44ad274d341795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga54930dd8cf9ac220eb44ad274d341795">wolfSSL_GetSessionIndex</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga54930dd8cf9ac220eb44ad274d341795"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the session index of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gab4a7dcdbfd357dced461795383b04bf2" id="r_gab4a7dcdbfd357dced461795383b04bf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4a7dcdbfd357dced461795383b04bf2">wolfSSL_GetSessionAtIndex</a> (int idx, WOLFSSL_SESSION *session)</td></tr>
<tr class="memdesc:gab4a7dcdbfd357dced461795383b04bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the session at specified index of the session cache and copies it into memory. The WOLFSSL_SESSION structure holds the session information.  <br /></td></tr>
<tr class="memitem:ga0115589990495d8f79c18bda0363d84c" id="r_ga0115589990495d8f79c18bda0363d84c"><td class="memItemLeft" align="right" valign="top">WOLFSSL_X509_CHAIN *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0115589990495d8f79c18bda0363d84c">wolfSSL_SESSION_get_peer_chain</a> (WOLFSSL_SESSION *session)</td></tr>
<tr class="memdesc:ga0115589990495d8f79c18bda0363d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the peer certificate chain from the WOLFSSL_SESSION struct.  <br /></td></tr>
<tr class="memitem:ga423dba3e8ffd23f2a3eb38555368792b" id="r_ga423dba3e8ffd23f2a3eb38555368792b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga423dba3e8ffd23f2a3eb38555368792b">wolfSSL_pending</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga423dba3e8ffd23f2a3eb38555368792b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of bytes which are buffered and available in the SSL object to be read by <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>.  <br /></td></tr>
<tr class="memitem:ga20fc275712951d213a148883ecdf285e" id="r_ga20fc275712951d213a148883ecdf285e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20fc275712951d213a148883ecdf285e">wolfSSL_save_session_cache</a> (const char *fname)</td></tr>
<tr class="memdesc:ga20fc275712951d213a148883ecdf285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persists the session cache to file. It doesn’t use memsave because of additional memory use.  <br /></td></tr>
<tr class="memitem:ga12e7e6b57f8b1edb62a37e2ea63eb056" id="r_ga12e7e6b57f8b1edb62a37e2ea63eb056"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12e7e6b57f8b1edb62a37e2ea63eb056">wolfSSL_restore_session_cache</a> (const char *fname)</td></tr>
<tr class="memdesc:ga12e7e6b57f8b1edb62a37e2ea63eb056"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the persistent session cache from file. It does not use memstore because of additional memory use.  <br /></td></tr>
<tr class="memitem:ga184b8366465a5cf8d477d2a45e89eaf9" id="r_ga184b8366465a5cf8d477d2a45e89eaf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga184b8366465a5cf8d477d2a45e89eaf9">wolfSSL_memsave_session_cache</a> (void *mem, int sz)</td></tr>
<tr class="memdesc:ga184b8366465a5cf8d477d2a45e89eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function persists session cache to memory.  <br /></td></tr>
<tr class="memitem:ga1d2b0be768745cb1383ad126e7af2576" id="r_ga1d2b0be768745cb1383ad126e7af2576"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d2b0be768745cb1383ad126e7af2576">wolfSSL_memrestore_session_cache</a> (const void *mem, int sz)</td></tr>
<tr class="memdesc:ga1d2b0be768745cb1383ad126e7af2576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restores the persistent session cache from memory.  <br /></td></tr>
<tr class="memitem:ga788f4e18e0e6ed15480c857e90def619" id="r_ga788f4e18e0e6ed15480c857e90def619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga788f4e18e0e6ed15480c857e90def619">wolfSSL_get_session_cache_memsize</a> (void)</td></tr>
<tr class="memdesc:ga788f4e18e0e6ed15480c857e90def619"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns how large the session cache save buffer should be.  <br /></td></tr>
<tr class="memitem:gaa432304c3c7019ccbe6d98ee89d0c839" id="r_gaa432304c3c7019ccbe6d98ee89d0c839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa432304c3c7019ccbe6d98ee89d0c839">wolfSSL_session_reused</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaa432304c3c7019ccbe6d98ee89d0c839"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the resuming member of the options struct. The flag indicates whether or not to reuse a session. If not, a new session must be established.  <br /></td></tr>
<tr class="memitem:gaf9c570fbc6f9556a10b593ca21799000" id="r_gaf9c570fbc6f9556a10b593ca21799000"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9c570fbc6f9556a10b593ca21799000">wolfSSL_get_version</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaf9c570fbc6f9556a10b593ca21799000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SSL version being used as a string.  <br /></td></tr>
<tr class="memitem:ga62ba4ad3eec03f749e1613b9c1f67538" id="r_ga62ba4ad3eec03f749e1613b9c1f67538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga62ba4ad3eec03f749e1613b9c1f67538">wolfSSL_get_current_cipher_suite</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga62ba4ad3eec03f749e1613b9c1f67538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current cipher suit an ssl session is using.  <br /></td></tr>
<tr class="memitem:ga51203855db9824ea018e24386498eddb" id="r_ga51203855db9824ea018e24386498eddb"><td class="memItemLeft" align="right" valign="top">WOLFSSL_CIPHER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51203855db9824ea018e24386498eddb">wolfSSL_get_current_cipher</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga51203855db9824ea018e24386498eddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to the current cipher in the ssl session.  <br /></td></tr>
<tr class="memitem:ga8529c4da0a7bd779ab3c72f846b3b208" id="r_ga8529c4da0a7bd779ab3c72f846b3b208"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8529c4da0a7bd779ab3c72f846b3b208">wolfSSL_CIPHER_get_name</a> (const WOLFSSL_CIPHER *cipher)</td></tr>
<tr class="memdesc:ga8529c4da0a7bd779ab3c72f846b3b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function matches the cipher suite in the SSL object with the available suites and returns the string representation.  <br /></td></tr>
<tr class="memitem:ga21ac3732347588a968b7dad64719afdc" id="r_ga21ac3732347588a968b7dad64719afdc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21ac3732347588a968b7dad64719afdc">wolfSSL_get_cipher</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga21ac3732347588a968b7dad64719afdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function matches the cipher suite in the SSL object with the available suites.  <br /></td></tr>
<tr class="memitem:ga47aba7e83d2d12a6c39c4e9204b406b2" id="r_ga47aba7e83d2d12a6c39c4e9204b406b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47aba7e83d2d12a6c39c4e9204b406b2">wolfSSL_BIO_get_mem_data</a> (WOLFSSL_BIO *bio, void *p)</td></tr>
<tr class="memdesc:ga47aba7e83d2d12a6c39c4e9204b406b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set a byte pointer to the start of the internal memory buffer.  <br /></td></tr>
<tr class="memitem:gab635da3ded1fc28fd481534d19973aa1" id="r_gab635da3ded1fc28fd481534d19973aa1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab635da3ded1fc28fd481534d19973aa1">wolfSSL_BIO_set_fd</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, int fd, int flag)</td></tr>
<tr class="memdesc:gab635da3ded1fc28fd481534d19973aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file descriptor for bio to use.  <br /></td></tr>
<tr class="memitem:gae7056bcc5de43dbb8fa46756e076204c" id="r_gae7056bcc5de43dbb8fa46756e076204c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae7056bcc5de43dbb8fa46756e076204c">wolfSSL_BIO_set_close</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long flag)</td></tr>
<tr class="memdesc:gae7056bcc5de43dbb8fa46756e076204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the close flag, used to indicate that the i/o stream should be closed when the BIO is freed.  <br /></td></tr>
<tr class="memitem:ga3d82acbf5d99c8fbd2f86faed1061fa8" id="r_ga3d82acbf5d99c8fbd2f86faed1061fa8"><td class="memItemLeft" align="right" valign="top">WOLFSSL_BIO_METHOD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d82acbf5d99c8fbd2f86faed1061fa8">wolfSSL_BIO_s_socket</a> (void)</td></tr>
<tr class="memdesc:ga3d82acbf5d99c8fbd2f86faed1061fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a BIO_SOCKET type WOLFSSL_BIO_METHOD.  <br /></td></tr>
<tr class="memitem:ga435ac1cfd706cd6a0fe0a3f1e93f312b" id="r_ga435ac1cfd706cd6a0fe0a3f1e93f312b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga435ac1cfd706cd6a0fe0a3f1e93f312b">wolfSSL_BIO_set_write_buf_size</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>, long size)</td></tr>
<tr class="memdesc:ga435ac1cfd706cd6a0fe0a3f1e93f312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the size of write buffer for a WOLFSSL_BIO. If write buffer has been previously set this function will free it when resetting the size. It is similar to wolfSSL_BIO_reset in that it resets read and write indexes to 0.  <br /></td></tr>
<tr class="memitem:ga4cb35fa0dce83567376cae66fa729ec2" id="r_ga4cb35fa0dce83567376cae66fa729ec2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4cb35fa0dce83567376cae66fa729ec2">wolfSSL_BIO_make_bio_pair</a> (WOLFSSL_BIO *b1, WOLFSSL_BIO *b2)</td></tr>
<tr class="memdesc:ga4cb35fa0dce83567376cae66fa729ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to pair two bios together. A pair of bios acts similar to a two way pipe writing to one can be read by the other and vice versa. It is expected that both bios be in the same thread, this function is not thread safe. Freeing one of the two bios removes both from being paired. If a write buffer size was not previously set for either of the bios it is set to a default size of 17000 (WOLFSSL_BIO_SIZE) before being paired.  <br /></td></tr>
<tr class="memitem:ga25b97c0b11e93443ed2993a8150f687b" id="r_ga25b97c0b11e93443ed2993a8150f687b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25b97c0b11e93443ed2993a8150f687b">wolfSSL_BIO_ctrl_reset_read_request</a> (WOLFSSL_BIO *bio)</td></tr>
<tr class="memdesc:ga25b97c0b11e93443ed2993a8150f687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the read request flag back to 0.  <br /></td></tr>
<tr class="memitem:ga2c24a537e06600eceb84aa4aa06ce120" id="r_ga2c24a537e06600eceb84aa4aa06ce120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c24a537e06600eceb84aa4aa06ce120">wolfSSL_BIO_nread0</a> (WOLFSSL_BIO *bio, char **buf)</td></tr>
<tr class="memdesc:ga2c24a537e06600eceb84aa4aa06ce120"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a buffer pointer for reading from. Unlike wolfSSL_BIO_nread the internal read index is not advanced by the number returned from the function call. Reading past the value returned can result in reading out of array bounds.  <br /></td></tr>
<tr class="memitem:gacc6c4298d00869eac022d26aa5c4f102" id="r_gacc6c4298d00869eac022d26aa5c4f102"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc6c4298d00869eac022d26aa5c4f102">wolfSSL_BIO_nread</a> (WOLFSSL_BIO *bio, char **buf, int num)</td></tr>
<tr class="memdesc:gacc6c4298d00869eac022d26aa5c4f102"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get a buffer pointer for reading from. The internal read index is advanced by the number returned from the function call with buf being pointed to the beginning of the buffer to read from. In the case that less bytes are in the read buffer than the value requested with num the lesser value is returned. Reading past the value returned can result in reading out of array bounds.  <br /></td></tr>
<tr class="memitem:ga8c34600ab60aba3073f8fccd10f20acd" id="r_ga8c34600ab60aba3073f8fccd10f20acd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c34600ab60aba3073f8fccd10f20acd">wolfSSL_BIO_nwrite</a> (WOLFSSL_BIO *bio, char **buf, int num)</td></tr>
<tr class="memdesc:ga8c34600ab60aba3073f8fccd10f20acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the buffer for writing as many bytes as returned by the function. Writing more bytes to the pointer returned then the value returned can result in writing out of bounds.  <br /></td></tr>
<tr class="memitem:ga87c06554b6c8af8870bee7e4a0b6165a" id="r_ga87c06554b6c8af8870bee7e4a0b6165a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga87c06554b6c8af8870bee7e4a0b6165a">wolfSSL_BIO_reset</a> (WOLFSSL_BIO *bio)</td></tr>
<tr class="memdesc:ga87c06554b6c8af8870bee7e4a0b6165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets bio to an initial state. As an example for type BIO_BIO this resets the read and write index.  <br /></td></tr>
<tr class="memitem:ga8908842d47bd3cbc996e77fd7c1e0ba4" id="r_ga8908842d47bd3cbc996e77fd7c1e0ba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8908842d47bd3cbc996e77fd7c1e0ba4">wolfSSL_BIO_seek</a> (WOLFSSL_BIO *bio, int ofs)</td></tr>
<tr class="memdesc:ga8908842d47bd3cbc996e77fd7c1e0ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adjusts the file pointer to the offset given. This is the offset from the head of the file.  <br /></td></tr>
<tr class="memitem:ga5debc444a59805b60dfaf575710c3605" id="r_ga5debc444a59805b60dfaf575710c3605"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5debc444a59805b60dfaf575710c3605">wolfSSL_BIO_write_filename</a> (WOLFSSL_BIO *bio, char *name)</td></tr>
<tr class="memdesc:ga5debc444a59805b60dfaf575710c3605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set and write to a file. WIll overwrite any data currently in the file and is set to close the file when the bio is freed.  <br /></td></tr>
<tr class="memitem:ga1be0050703a8b74913831481b90e45cc" id="r_ga1be0050703a8b74913831481b90e45cc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1be0050703a8b74913831481b90e45cc">wolfSSL_BIO_set_mem_eof_return</a> (WOLFSSL_BIO *bio, int v)</td></tr>
<tr class="memdesc:ga1be0050703a8b74913831481b90e45cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the end of file value. Common value is -1 so as not to get confused with expected positive values.  <br /></td></tr>
<tr class="memitem:ga349b08d62d70fd03153237c8dd658479" id="r_ga349b08d62d70fd03153237c8dd658479"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga349b08d62d70fd03153237c8dd658479">wolfSSL_BIO_get_mem_ptr</a> (WOLFSSL_BIO *bio, WOLFSSL_BUF_MEM **m)</td></tr>
<tr class="memdesc:ga349b08d62d70fd03153237c8dd658479"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a getter function for WOLFSSL_BIO memory pointer.  <br /></td></tr>
<tr class="memitem:gaa3b1592df3acdace68187bd21c92554e" id="r_gaa3b1592df3acdace68187bd21c92554e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa3b1592df3acdace68187bd21c92554e">wolfSSL_lib_version</a> (void)</td></tr>
<tr class="memdesc:gaa3b1592df3acdace68187bd21c92554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current library version.  <br /></td></tr>
<tr class="memitem:ga19621cde181fbc016432c221169a476c" id="r_ga19621cde181fbc016432c221169a476c"><td class="memItemLeft" align="right" valign="top">word32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19621cde181fbc016432c221169a476c">wolfSSL_lib_version_hex</a> (void)</td></tr>
<tr class="memdesc:ga19621cde181fbc016432c221169a476c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current library version in hexadecimal notation.  <br /></td></tr>
<tr class="memitem:gaf6780235ee9a7abe3f704a585eb77849" id="r_gaf6780235ee9a7abe3f704a585eb77849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6780235ee9a7abe3f704a585eb77849">wolfSSL_negotiate</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gaf6780235ee9a7abe3f704a585eb77849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the actual connect or accept based on the side of the SSL method. If called from the client side then an <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> is done while a <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> is performed if called from the server side.  <br /></td></tr>
<tr class="memitem:ga5c2a07e4372fea5b1f5fe8ad32186dd3" id="r_ga5c2a07e4372fea5b1f5fe8ad32186dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3">wolfSSL_connect_cert</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5c2a07e4372fea5b1f5fe8ad32186dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates an SSL/TLS handshake with a server only long enough to get the peer’s certificate chain. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will only return once the peer’s certificate chain has been received.  <br /></td></tr>
<tr class="memitem:ga0a34c427432d689f5d99f134b2865b90" id="r_ga0a34c427432d689f5d99f134b2865b90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0a34c427432d689f5d99f134b2865b90">wolfSSL_writev</a> (WOLFSSL *ssl, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ga0a34c427432d689f5d99f134b2865b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates writev semantics but doesn’t actually do block at a time because of SSL_write() behavior and because front adds may be small. Makes porting into software that uses writev easier.  <br /></td></tr>
<tr class="memitem:ga4455005c48c3bb24584984ea11dd54a0" id="r_ga4455005c48c3bb24584984ea11dd54a0"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4455005c48c3bb24584984ea11dd54a0">wolfSSL_SNI_Status</a> (WOLFSSL *ssl, unsigned char type)</td></tr>
<tr class="memdesc:ga4455005c48c3bb24584984ea11dd54a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of an SNI object.  <br /></td></tr>
<tr class="memitem:ga8b482a054414e3411c8d4f45f3683f3c" id="r_ga8b482a054414e3411c8d4f45f3683f3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b482a054414e3411c8d4f45f3683f3c">wolfSSL_UseSecureRenegotiation</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga8b482a054414e3411c8d4f45f3683f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function forces secure renegotiation for the supplied WOLFSSL structure. This is not recommended.  <br /></td></tr>
<tr class="memitem:ga7ba02472014a68d0717ca9243d9dd646" id="r_ga7ba02472014a68d0717ca9243d9dd646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ba02472014a68d0717ca9243d9dd646">wolfSSL_Rehandshake</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga7ba02472014a68d0717ca9243d9dd646"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function executes a secure renegotiation handshake; this is user forced as wolfSSL discourages this functionality.  <br /></td></tr>
<tr class="memitem:gae22e32f06e5b1f22116c794b3dc28577" id="r_gae22e32f06e5b1f22116c794b3dc28577"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae22e32f06e5b1f22116c794b3dc28577">wolfSSL_UseSessionTicket</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gae22e32f06e5b1f22116c794b3dc28577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force provided WOLFSSL structure to use session ticket. The constant HAVE_SESSION_TICKET should be defined and the constant NO_WOLFSSL_CLIENT should not be defined to use this function.  <br /></td></tr>
<tr class="memitem:gab67e2593987cfe2a20c660440c087576" id="r_gab67e2593987cfe2a20c660440c087576"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab67e2593987cfe2a20c660440c087576">wolfSSL_get_SessionTicket</a> (WOLFSSL *ssl, unsigned char *buf, word32 *bufSz)</td></tr>
<tr class="memdesc:gab67e2593987cfe2a20c660440c087576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the ticket member of the Session structure to the buffer. If buf is NULL and bufSz is non-NULL, bufSz will be set to the ticket length.  <br /></td></tr>
<tr class="memitem:ga49f87f9acd032dbbd43fa43113aa331c" id="r_ga49f87f9acd032dbbd43fa43113aa331c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga49f87f9acd032dbbd43fa43113aa331c">wolfSSL_set_SessionTicket</a> (WOLFSSL *ssl, const unsigned char *buf, word32 bufSz)</td></tr>
<tr class="memdesc:ga49f87f9acd032dbbd43fa43113aa331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ticket member of the WOLFSSL_SESSION structure within the WOLFSSL struct. The buffer passed into the function is copied to memory.  <br /></td></tr>
<tr class="memitem:ga0085f8baa71150d0264766e4a2b6c784" id="r_ga0085f8baa71150d0264766e4a2b6c784"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0085f8baa71150d0264766e4a2b6c784">wolfSSL_PrintSessionStats</a> (void)</td></tr>
<tr class="memdesc:ga0085f8baa71150d0264766e4a2b6c784"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the statistics from the session.  <br /></td></tr>
<tr class="memitem:gaaaf142daad76403f27d7d5d2b6261420" id="r_gaaaf142daad76403f27d7d5d2b6261420"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaaf142daad76403f27d7d5d2b6261420">wolfSSL_get_session_stats</a> (unsigned int *active, unsigned int *total, unsigned int *peak, unsigned int *maxSessions)</td></tr>
<tr class="memdesc:gaaaf142daad76403f27d7d5d2b6261420"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the statistics for the session.  <br /></td></tr>
<tr class="memitem:gaf05ea9cba44df853314417db7a774e99" id="r_gaf05ea9cba44df853314417db7a774e99"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf05ea9cba44df853314417db7a774e99">wolfSSL_BIO_set_fp</a> (WOLFSSL_BIO *bio, XFILE fp, int c)</td></tr>
<tr class="memdesc:gaf05ea9cba44df853314417db7a774e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to set the internal file pointer for a BIO.  <br /></td></tr>
<tr class="memitem:gac2e81c60581f1ba7b5fd3984c37ced23" id="r_gac2e81c60581f1ba7b5fd3984c37ced23"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2e81c60581f1ba7b5fd3984c37ced23">wolfSSL_BIO_get_fp</a> (WOLFSSL_BIO *bio, XFILE *fp)</td></tr>
<tr class="memdesc:gac2e81c60581f1ba7b5fd3984c37ced23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get the internal file pointer for a BIO.  <br /></td></tr>
<tr class="memitem:ga344b890cf2459ab7860924ac059ac927" id="r_ga344b890cf2459ab7860924ac059ac927"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga344b890cf2459ab7860924ac059ac927">wolfSSL_BIO_ctrl_pending</a> (WOLFSSL_BIO *<a class="el" href="random_8h.html#ac5f0c3220b340f4f78d34bca64c6c699">b</a>)</td></tr>
<tr class="memdesc:ga344b890cf2459ab7860924ac059ac927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pending bytes to read. If BIO type is BIO_BIO then is the number to read from pair. If BIO contains an SSL object then is pending data from SSL object (wolfSSL_pending(ssl)). If is BIO_MEMORY type then returns the size of memory buffer.  <br /></td></tr>
<tr class="memitem:gadea64abddfb32623d439ced576afb498" id="r_gadea64abddfb32623d439ced576afb498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadea64abddfb32623d439ced576afb498">wolfSSL_set_jobject</a> (WOLFSSL *ssl, void *objPtr)</td></tr>
<tr class="memdesc:gadea64abddfb32623d439ced576afb498"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the jObjectRef member of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga89aed85f25618a8a012ae855d07e2023" id="r_ga89aed85f25618a8a012ae855d07e2023"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89aed85f25618a8a012ae855d07e2023">wolfSSL_get_jobject</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga89aed85f25618a8a012ae855d07e2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the jObjectRef member of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:ga5b8f41cca120758d1860c7bc959755dd" id="r_ga5b8f41cca120758d1860c7bc959755dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd">wolfSSL_connect</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5b8f41cca120758d1860c7bc959755dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates an SSL/TLS handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended.  <br /></td></tr>
<tr class="memitem:ga38ef7eb0a15b65f3b68d2490dd0535a0" id="r_ga38ef7eb0a15b65f3b68d2490dd0535a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38ef7eb0a15b65f3b68d2490dd0535a0">wolfSSL_update_keys</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga38ef7eb0a15b65f3b68d2490dd0535a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys. A KeyUpdate message is sent to the peer and new keys are calculated for encryption. The peer will send back a KeyUpdate message and the new decryption keys will then be calculated. This function can only be called after a handshake has been completed.  <br /></td></tr>
<tr class="memitem:ga2f38357d4d7fba294745516caa8f4180" id="r_ga2f38357d4d7fba294745516caa8f4180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f38357d4d7fba294745516caa8f4180">wolfSSL_key_update_response</a> (WOLFSSL *ssl, int *required)</td></tr>
<tr class="memdesc:ga2f38357d4d7fba294745516caa8f4180"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on a TLS v1.3 client or server wolfSSL to determine whether a rollover of keys is in progress. When <a class="el" href="#ga38ef7eb0a15b65f3b68d2490dd0535a0" title="This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys....">wolfSSL_update_keys()</a> is called, a KeyUpdate message is sent and the encryption key is updated. The decryption key is updated when the response is received.  <br /></td></tr>
<tr class="memitem:ga5bdfe1a09ee4d55d3e73f0bfec790d13" id="r_ga5bdfe1a09ee4d55d3e73f0bfec790d13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5bdfe1a09ee4d55d3e73f0bfec790d13">wolfSSL_request_certificate</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga5bdfe1a09ee4d55d3e73f0bfec790d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests a client certificate from the TLS v1.3 client. This is useful when a web server is serving some pages that require client authentication and others that don't. A maximum of 256 requests can be sent on a connection.  <br /></td></tr>
<tr class="memitem:ga2c85ff2299e5cb41d809dfdce9115d38" id="r_ga2c85ff2299e5cb41d809dfdce9115d38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c85ff2299e5cb41d809dfdce9115d38">wolfSSL_connect_TLSv13</a> (WOLFSSL *)</td></tr>
<tr class="memdesc:ga2c85ff2299e5cb41d809dfdce9115d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the client side and initiates a TLS v1.3 handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended.  <br /></td></tr>
<tr class="memitem:ga8344dc66a938e474d2f79bc4947d92cc" id="r_ga8344dc66a938e474d2f79bc4947d92cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc">wolfSSL_accept_TLSv13</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga8344dc66a938e474d2f79bc4947d92cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred. Call this function when expecting a TLS v1.3 connection though older version ClientHello messages are supported.  <br /></td></tr>
<tr class="memitem:gade058c507ad769c52e508e5ddf7c2a94" id="r_gade058c507ad769c52e508e5ddf7c2a94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade058c507ad769c52e508e5ddf7c2a94">wolfSSL_write_early_data</a> (WOLFSSL *ssl, const void *data, int sz, int *outSz)</td></tr>
<tr class="memdesc:gade058c507ad769c52e508e5ddf7c2a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes early data to the server on resumption. Call this function instead of <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#ga2c85ff2299e5cb41d809dfdce9115d38" title="This function is called on the client side and initiates a TLS v1.3 handshake with a server....">wolfSSL_connect_TLSv13()</a> to connect to the server and send the data in the handshake. This function is only used with clients.  <br /></td></tr>
<tr class="memitem:ga218900890eae44f86614e3c54f0f02ab" id="r_ga218900890eae44f86614e3c54f0f02ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga218900890eae44f86614e3c54f0f02ab">wolfSSL_read_early_data</a> (WOLFSSL *ssl, void *data, int sz, int *outSz)</td></tr>
<tr class="memdesc:ga218900890eae44f86614e3c54f0f02ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads any early data from a client on resumption. Call this function instead of <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> or <a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13()</a> to accept a client and read any early data in the handshake. The function should be invoked until <a class="el" href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b" title="This function checks to see if the connection is established.">wolfSSL_is_init_finished()</a> returns true. Early data may be sent by the client in multiple messages. If there is no early data then the handshake will be processed as normal. This function is only used with servers.  <br /></td></tr>
<tr class="memitem:gac0ad4fa3f78e9c8438d656392afbd46b" id="r_gac0ad4fa3f78e9c8438d656392afbd46b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0ad4fa3f78e9c8438d656392afbd46b">wolfSSL_inject</a> (WOLFSSL *ssl, const void *data, int sz)</td></tr>
<tr class="memdesc:gac0ad4fa3f78e9c8438d656392afbd46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to inject data into the WOLFSSL object. This is useful when data needs to be read from a single place and demultiplexed into multiple connections. The caller should then call <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> to extract the plaintext data from the WOLFSSL object.  <br /></td></tr>
<tr class="memitem:gacad3fa14e99066bf182bdb9bbf174cf7" id="r_gacad3fa14e99066bf182bdb9bbf174cf7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacad3fa14e99066bf182bdb9bbf174cf7">wolfSSL_GetIOReadCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:gacad3fa14e99066bf182bdb9bbf174cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IOCB_ReadCtx member of the WOLFSSL struct.  <br /></td></tr>
<tr class="memitem:ga1ba8cfc5d1f1d0d0e568e802066a79a1" id="r_ga1ba8cfc5d1f1d0d0e568e802066a79a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ba8cfc5d1f1d0d0e568e802066a79a1">wolfSSL_GetIOWriteCtx</a> (WOLFSSL *ssl)</td></tr>
<tr class="memdesc:ga1ba8cfc5d1f1d0d0e568e802066a79a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IOCB_WriteCtx member of the WOLFSSL structure.  <br /></td></tr>
<tr class="memitem:gaa877d2207c64ec05a6c7f5270f494fdd" id="r_gaa877d2207c64ec05a6c7f5270f494fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa877d2207c64ec05a6c7f5270f494fdd">wolfSSL_SetIO_NetX</a> (WOLFSSL *ssl, NX_TCP_SOCKET *nxsocket, ULONG waitoption)</td></tr>
<tr class="memdesc:gaa877d2207c64ec05a6c7f5270f494fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the nxSocket and nxWait members of the nxCtx struct within the WOLFSSL structure.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gaacf169259b58f3441614c6a992d89afd" name="gaacf169259b58f3441614c6a992d89afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf169259b58f3441614c6a992d89afd">&#9670;&#160;</a></span>wolfDTLS_accept_stateless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfDTLS_accept_stateless </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side and statelessly listens for an SSL client to initiate the DTLS handshake. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_SUCCESS ClientHello containing a valid cookie was received. The connection can be continued with <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. </dd>
<dd>
WOLFSSL_FAILURE The I/O layer returned WANT_READ. This is either because there is no data to read and we are using non-blocking sockets or we sent a cookie request and we are waiting for a reply. The user should call wolfDTLS_accept_stateless again after data becomes available in the I/O layer. </dd>
<dd>
WOLFSSL_FATAL_ERROR A fatal error occurred. The ssl object should be free'd and allocated again to continue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">do {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaacf169259b58f3441614c6a992d89afd">wolfDTLS_accept_stateless</a>(ssl);</div>
<div class="line">    <span class="keywordflow">if</span> (ret == WOLFSSL_FATAL_ERROR)</div>
<div class="line">        <span class="comment">// re-allocate the ssl object with wolfSSL_free() and wolfSSL_new()</span></div>
<div class="line">} <span class="keywordflow">while</span> (ret != WOLFSSL_SUCCESS);</div>
<div class="line">ret = <a class="code hl_function" href="#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Debug_html_ga1bf9410113a0a1808c2c970b5a972610"><div class="ttname"><a href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a></div><div class="ttdeci">char * wolfSSL_ERR_error_string(unsigned long errNumber, char *data)</div><div class="ttdoc">This function converts an error code returned by wolfSSL_get_error() into a more human-readable error...</div></div>
<div class="ttc" id="agroup__Debug_html_gaafd5671d443fa684913ba5955a4eb591"><div class="ttname"><a href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a></div><div class="ttdeci">int wolfSSL_get_error(WOLFSSL *ssl, int ret)</div><div class="ttdoc">This function returns a unique error code describing why the previous API function call (wolfSSL_conn...</div></div>
<div class="ttc" id="agroup__IO_html_gaacf169259b58f3441614c6a992d89afd"><div class="ttname"><a href="#gaacf169259b58f3441614c6a992d89afd">wolfDTLS_accept_stateless</a></div><div class="ttdeci">int wolfDTLS_accept_stateless(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on the server side and statelessly listens for an SSL client to initiate the ...</div></div>
<div class="ttc" id="agroup__IO_html_gaf0cfc676947d7eabd67ec1a4661ed625"><div class="ttname"><a href="#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a></div><div class="ttdeci">int wolfSSL_accept(WOLFSSL *)</div><div class="ttdoc">This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd>
<dd>
<a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd></dl>

</div>
</div>
<a id="gaf0cfc676947d7eabd67ec1a4661ed625" name="gaf0cfc676947d7eabd67ec1a4661ed625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cfc676947d7eabd67ec1a4661ed625">&#9670;&#160;</a></span>wolfSSL_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_accept </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
SSL_FATAL_ERROR will be returned if an error occurred. To get a more detailed error code, call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaf0cfc676947d7eabd67ec1a4661ed625">wolfSSL_accept</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd></dl>

</div>
</div>
<a id="ga8344dc66a938e474d2f79bc4947d92cc" name="ga8344dc66a938e474d2f79bc4947d92cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8344dc66a938e474d2f79bc4947d92cc">&#9670;&#160;</a></span>wolfSSL_accept_TLSv13()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wolfSSL_accept_TLSv13 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS handshake. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_accept to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> will only return once the handshake has been finished or an error occurred. Call this function when expecting a TLS v1.3 connection though older version ClientHello messages are supported. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
SSL_FATAL_ERROR will be returned if an error occurred. To get a more detailed error code, call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga8344dc66a938e474d2f79bc4947d92cc">wolfSSL_accept_TLSv13</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga8344dc66a938e474d2f79bc4947d92cc"><div class="ttname"><a href="#ga8344dc66a938e474d2f79bc4947d92cc">wolfSSL_accept_TLSv13</a></div><div class="ttdeci">wolfSSL_accept_TLSv13(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#ga2c85ff2299e5cb41d809dfdce9115d38" title="This function is called on the client side and initiates a TLS v1.3 handshake with a server....">wolfSSL_connect_TLSv13</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd>
<dd>
<a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13</a> </dd>
<dd>
<a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd></dl>

</div>
</div>
<a id="ga344b890cf2459ab7860924ac059ac927" name="ga344b890cf2459ab7860924ac059ac927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga344b890cf2459ab7860924ac059ac927">&#9670;&#160;</a></span>wolfSSL_BIO_ctrl_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wolfSSL_BIO_ctrl_pending </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of pending bytes to read. If BIO type is BIO_BIO then is the number to read from pair. If BIO contains an SSL object then is pending data from SSL object (wolfSSL_pending(ssl)). If is BIO_MEMORY type then returns the size of memory buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 number of pending bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>pointer to the WOLFSSL_BIO structure that has already been created.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> pending;</div>
<div class="line">bio = wolfSSL_BIO_new();</div>
<div class="line">…</div>
<div class="line">pending = <a class="code hl_function" href="#ga344b890cf2459ab7860924ac059ac927">wolfSSL_BIO_ctrl_pending</a>(bio);</div>
<div class="ttc" id="agroup__IO_html_ga344b890cf2459ab7860924ac059ac927"><div class="ttname"><a href="#ga344b890cf2459ab7860924ac059ac927">wolfSSL_BIO_ctrl_pending</a></div><div class="ttdeci">size_t wolfSSL_BIO_ctrl_pending(WOLFSSL_BIO *b)</div><div class="ttdoc">Gets the number of pending bytes to read. If BIO type is BIO_BIO then is the number to read from pair...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4cb35fa0dce83567376cae66fa729ec2" title="This is used to pair two bios together. A pair of bios acts similar to a two way pipe writing to one ...">wolfSSL_BIO_make_bio_pair</a> </dd>
<dd>
wolfSSL_BIO_new </dd></dl>

</div>
</div>
<a id="ga25b97c0b11e93443ed2993a8150f687b" name="ga25b97c0b11e93443ed2993a8150f687b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b97c0b11e93443ed2993a8150f687b">&#9670;&#160;</a></span>wolfSSL_BIO_ctrl_reset_read_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_ctrl_reset_read_request </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set the read request flag back to 0. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully setting value. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set read request flag.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga25b97c0b11e93443ed2993a8150f687b">wolfSSL_BIO_ctrl_reset_read_request</a>(bio);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga25b97c0b11e93443ed2993a8150f687b"><div class="ttname"><a href="#ga25b97c0b11e93443ed2993a8150f687b">wolfSSL_BIO_ctrl_reset_read_request</a></div><div class="ttdeci">int wolfSSL_BIO_ctrl_reset_read_request(WOLFSSL_BIO *bio)</div><div class="ttdoc">This is used to set the read request flag back to 0.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new, wolfSSL_BIO_s_mem </dd>
<dd>
wolfSSL_BIO_new, wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="gac2e81c60581f1ba7b5fd3984c37ced23" name="gac2e81c60581f1ba7b5fd3984c37ced23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e81c60581f1ba7b5fd3984c37ced23">&#9670;&#160;</a></span>wolfSSL_BIO_get_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_BIO_get_fp </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get the internal file pointer for a BIO. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully getting file pointer. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set pair. </td></tr>
    <tr><td class="paramname">fp</td><td>file pointer to set in bio.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">XFILE fp;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_file());</div>
<div class="line">ret  = <a class="code hl_function" href="#gac2e81c60581f1ba7b5fd3984c37ced23">wolfSSL_BIO_get_fp</a>(bio, &amp;fp);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_gac2e81c60581f1ba7b5fd3984c37ced23"><div class="ttname"><a href="#gac2e81c60581f1ba7b5fd3984c37ced23">wolfSSL_BIO_get_fp</a></div><div class="ttdeci">long wolfSSL_BIO_get_fp(WOLFSSL_BIO *bio, XFILE *fp)</div><div class="ttdoc">This is used to get the internal file pointer for a BIO.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
<a class="el" href="#gaf05ea9cba44df853314417db7a774e99" title="This is used to set the internal file pointer for a BIO.">wolfSSL_BIO_set_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga47aba7e83d2d12a6c39c4e9204b406b2" name="ga47aba7e83d2d12a6c39c4e9204b406b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47aba7e83d2d12a6c39c4e9204b406b2">&#9670;&#160;</a></span>wolfSSL_BIO_get_mem_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_get_mem_data </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set a byte pointer to the start of the internal memory buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size On success the size of the buffer is returned </dd>
<dd>
SSL_FATAL_ERROR If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to get memory buffer of. </td></tr>
    <tr><td class="paramname">p</td><td>byte pointer to set to memory buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">byte</span>* p;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_mem());</div>
<div class="line">ret  = <a class="code hl_function" href="#ga47aba7e83d2d12a6c39c4e9204b406b2">wolfSSL_BIO_get_mem_data</a>(bio, &amp;p);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga47aba7e83d2d12a6c39c4e9204b406b2"><div class="ttname"><a href="#ga47aba7e83d2d12a6c39c4e9204b406b2">wolfSSL_BIO_get_mem_data</a></div><div class="ttdeci">int wolfSSL_BIO_get_mem_data(WOLFSSL_BIO *bio, void *p)</div><div class="ttdoc">This is used to set a byte pointer to the start of the internal memory buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
<a class="el" href="#gaf05ea9cba44df853314417db7a774e99" title="This is used to set the internal file pointer for a BIO.">wolfSSL_BIO_set_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga349b08d62d70fd03153237c8dd658479" name="ga349b08d62d70fd03153237c8dd658479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga349b08d62d70fd03153237c8dd658479">&#9670;&#160;</a></span>wolfSSL_BIO_get_mem_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_BIO_get_mem_ptr </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_BUF_MEM **</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a getter function for WOLFSSL_BIO memory pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully getting the pointer SSL_SUCCESS is returned (currently value of 1). </dd>
<dd>
SSL_FAILURE Returned if NULL arguments are passed in (currently value of 0).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>pointer to the WOLFSSL_BIO structure for getting memory pointer. </td></tr>
    <tr><td class="paramname">ptr</td><td>structure that is currently a char*. Is set to point to bio’s memory.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">WOLFSSL_BUF_MEM* pt;</div>
<div class="line"><span class="comment">// setup bio</span></div>
<div class="line"><a class="code hl_function" href="#ga349b08d62d70fd03153237c8dd658479">wolfSSL_BIO_get_mem_ptr</a>(bio, &amp;pt);</div>
<div class="line"><span class="comment">//use pt</span></div>
<div class="ttc" id="agroup__IO_html_ga349b08d62d70fd03153237c8dd658479"><div class="ttname"><a href="#ga349b08d62d70fd03153237c8dd658479">wolfSSL_BIO_get_mem_ptr</a></div><div class="ttdeci">long wolfSSL_BIO_get_mem_ptr(WOLFSSL_BIO *bio, WOLFSSL_BUF_MEM **m)</div><div class="ttdoc">This is a getter function for WOLFSSL_BIO memory pointer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd></dl>

</div>
</div>
<a id="ga4cb35fa0dce83567376cae66fa729ec2" name="ga4cb35fa0dce83567376cae66fa729ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cb35fa0dce83567376cae66fa729ec2">&#9670;&#160;</a></span>wolfSSL_BIO_make_bio_pair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_make_bio_pair </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to pair two bios together. A pair of bios acts similar to a two way pipe writing to one can be read by the other and vice versa. It is expected that both bios be in the same thread, this function is not thread safe. Freeing one of the two bios removes both from being paired. If a write buffer size was not previously set for either of the bios it is set to a default size of 17000 (WOLFSSL_BIO_SIZE) before being paired. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully pairing the two bios. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>WOLFSSL_BIO structure to set pair. </td></tr>
    <tr><td class="paramname">b2</td><td>second WOLFSSL_BIO structure to complete pair.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">WOLFSSL_BIO* bio2;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_bio());</div>
<div class="line">bio2 = wolfSSL_BIO_new(wolfSSL_BIO_s_bio());</div>
<div class="line">ret = <a class="code hl_function" href="#ga4cb35fa0dce83567376cae66fa729ec2">wolfSSL_BIO_make_bio_pair</a>(bio, bio2);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga4cb35fa0dce83567376cae66fa729ec2"><div class="ttname"><a href="#ga4cb35fa0dce83567376cae66fa729ec2">wolfSSL_BIO_make_bio_pair</a></div><div class="ttdeci">int wolfSSL_BIO_make_bio_pair(WOLFSSL_BIO *b1, WOLFSSL_BIO *b2)</div><div class="ttdoc">This is used to pair two bios together. A pair of bios acts similar to a two way pipe writing to one ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="gacc6c4298d00869eac022d26aa5c4f102" name="gacc6c4298d00869eac022d26aa5c4f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc6c4298d00869eac022d26aa5c4f102">&#9670;&#160;</a></span>wolfSSL_BIO_nread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_nread </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get a buffer pointer for reading from. The internal read index is advanced by the number returned from the function call with buf being pointed to the beginning of the buffer to read from. In the case that less bytes are in the read buffer than the value requested with num the lesser value is returned. Reading past the value returned can result in reading out of array bounds. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 on success return the number of bytes to read </dd>
<dd>
WOLFSSL_BIO_ERROR(-1) on error case with nothing to read return -1</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to set at beginning of read array. </td></tr>
    <tr><td class="paramname">num</td><td>number of bytes to try and read.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">char</span>* bufPt;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set up bio</span></div>
<div class="line">ret = <a class="code hl_function" href="#gacc6c4298d00869eac022d26aa5c4f102">wolfSSL_BIO_nread</a>(bio, &amp;bufPt, 10); <span class="comment">// try to read 10 bytes</span></div>
<div class="line"><span class="comment">// handle negative ret check</span></div>
<div class="line"><span class="comment">// read ret bytes from bufPt</span></div>
<div class="ttc" id="agroup__IO_html_gacc6c4298d00869eac022d26aa5c4f102"><div class="ttname"><a href="#gacc6c4298d00869eac022d26aa5c4f102">wolfSSL_BIO_nread</a></div><div class="ttdeci">int wolfSSL_BIO_nread(WOLFSSL_BIO *bio, char **buf, int num)</div><div class="ttdoc">This is used to get a buffer pointer for reading from. The internal read index is advanced by the num...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
<a class="el" href="#ga8c34600ab60aba3073f8fccd10f20acd" title="Gets a pointer to the buffer for writing as many bytes as returned by the function....">wolfSSL_BIO_nwrite</a> </dd></dl>

</div>
</div>
<a id="ga2c24a537e06600eceb84aa4aa06ce120" name="ga2c24a537e06600eceb84aa4aa06ce120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c24a537e06600eceb84aa4aa06ce120">&#9670;&#160;</a></span>wolfSSL_BIO_nread0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_nread0 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get a buffer pointer for reading from. Unlike wolfSSL_BIO_nread the internal read index is not advanced by the number returned from the function call. Reading past the value returned can result in reading out of array bounds. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 on success return the number of bytes to read</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to set at beginning of read array.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">char</span>* bufPt;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="comment">// set up bio</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga2c24a537e06600eceb84aa4aa06ce120">wolfSSL_BIO_nread0</a>(bio, &amp;bufPt); <span class="comment">// read as many bytes as possible</span></div>
<div class="line"><span class="comment">// handle negative ret check</span></div>
<div class="line"><span class="comment">// read ret bytes from bufPt</span></div>
<div class="ttc" id="agroup__IO_html_ga2c24a537e06600eceb84aa4aa06ce120"><div class="ttname"><a href="#ga2c24a537e06600eceb84aa4aa06ce120">wolfSSL_BIO_nread0</a></div><div class="ttdeci">int wolfSSL_BIO_nread0(WOLFSSL_BIO *bio, char **buf)</div><div class="ttdoc">This is used to get a buffer pointer for reading from. Unlike wolfSSL_BIO_nread the internal read ind...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_nwrite0 </dd></dl>

</div>
</div>
<a id="ga8c34600ab60aba3073f8fccd10f20acd" name="ga8c34600ab60aba3073f8fccd10f20acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c34600ab60aba3073f8fccd10f20acd">&#9670;&#160;</a></span>wolfSSL_BIO_nwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_nwrite </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the buffer for writing as many bytes as returned by the function. Writing more bytes to the pointer returned then the value returned can result in writing out of bounds. </p>
<dl class="section return"><dt>Returns</dt><dd>int Returns the number of bytes that can be written to the buffer pointer returned. </dd>
<dd>
WOLFSSL_BIO_UNSET(-2) in the case that is not part of a bio pair </dd>
<dd>
WOLFSSL_BIO_ERROR(-1) in the case that there is no more room to write to</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to buffer to write to. </td></tr>
    <tr><td class="paramname">num</td><td>number of bytes desired to be written.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">char</span>* bufPt;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="comment">// set up bio</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga8c34600ab60aba3073f8fccd10f20acd">wolfSSL_BIO_nwrite</a>(bio, &amp;bufPt, 10); <span class="comment">// try to write 10 bytes</span></div>
<div class="line"><span class="comment">// handle negative ret check</span></div>
<div class="line"><span class="comment">// write ret bytes to bufPt</span></div>
<div class="ttc" id="agroup__IO_html_ga8c34600ab60aba3073f8fccd10f20acd"><div class="ttname"><a href="#ga8c34600ab60aba3073f8fccd10f20acd">wolfSSL_BIO_nwrite</a></div><div class="ttdeci">int wolfSSL_BIO_nwrite(WOLFSSL_BIO *bio, char **buf, int num)</div><div class="ttdoc">Gets a pointer to the buffer for writing as many bytes as returned by the function....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_free </dd>
<dd>
<a class="el" href="#gacc6c4298d00869eac022d26aa5c4f102" title="This is used to get a buffer pointer for reading from. The internal read index is advanced by the num...">wolfSSL_BIO_nread</a> </dd></dl>

</div>
</div>
<a id="ga87c06554b6c8af8870bee7e4a0b6165a" name="ga87c06554b6c8af8870bee7e4a0b6165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87c06554b6c8af8870bee7e4a0b6165a">&#9670;&#160;</a></span>wolfSSL_BIO_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_reset </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets bio to an initial state. As an example for type BIO_BIO this resets the read and write index. </p>
<dl class="section return"><dt>Returns</dt><dd>0 On successfully resetting the bio. </dd>
<dd>
WOLFSSL_BIO_ERROR(-1) Returned on bad input or unsuccessful reset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to reset.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="comment">// setup bio</span></div>
<div class="line"><a class="code hl_function" href="#ga87c06554b6c8af8870bee7e4a0b6165a">wolfSSL_BIO_reset</a>(bio);</div>
<div class="line"><span class="comment">//use pt</span></div>
<div class="ttc" id="agroup__IO_html_ga87c06554b6c8af8870bee7e4a0b6165a"><div class="ttname"><a href="#ga87c06554b6c8af8870bee7e4a0b6165a">wolfSSL_BIO_reset</a></div><div class="ttdeci">int wolfSSL_BIO_reset(WOLFSSL_BIO *bio)</div><div class="ttdoc">Resets bio to an initial state. As an example for type BIO_BIO this resets the read and write index.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga3d82acbf5d99c8fbd2f86faed1061fa8" name="ga3d82acbf5d99c8fbd2f86faed1061fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d82acbf5d99c8fbd2f86faed1061fa8">&#9670;&#160;</a></span>wolfSSL_BIO_s_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_BIO_METHOD * wolfSSL_BIO_s_socket </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get a BIO_SOCKET type WOLFSSL_BIO_METHOD. </p>
<dl class="section return"><dt>Returns</dt><dd>WOLFSSL_BIO_METHOD pointer to a WOLFSSL_BIO_METHOD structure that is a socket type</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">bio = wolfSSL_BIO_new(<a class="code hl_function" href="#ga3d82acbf5d99c8fbd2f86faed1061fa8">wolfSSL_BIO_s_socket</a>);</div>
<div class="ttc" id="agroup__IO_html_ga3d82acbf5d99c8fbd2f86faed1061fa8"><div class="ttname"><a href="#ga3d82acbf5d99c8fbd2f86faed1061fa8">wolfSSL_BIO_s_socket</a></div><div class="ttdeci">WOLFSSL_BIO_METHOD * wolfSSL_BIO_s_socket(void)</div><div class="ttdoc">This is used to get a BIO_SOCKET type WOLFSSL_BIO_METHOD.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd></dl>

</div>
</div>
<a id="ga8908842d47bd3cbc996e77fd7c1e0ba4" name="ga8908842d47bd3cbc996e77fd7c1e0ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8908842d47bd3cbc996e77fd7c1e0ba4">&#9670;&#160;</a></span>wolfSSL_BIO_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_seek </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adjusts the file pointer to the offset given. This is the offset from the head of the file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 On successfully seeking. </dd>
<dd>
-1 If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set. </td></tr>
    <tr><td class="paramname">ofs</td><td>offset into file.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">XFILE fp;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_file());</div>
<div class="line">ret  = <a class="code hl_function" href="#gaf05ea9cba44df853314417db7a774e99">wolfSSL_BIO_set_fp</a>(bio, &amp;fp);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="line">ret  = <a class="code hl_function" href="#ga8908842d47bd3cbc996e77fd7c1e0ba4">wolfSSL_BIO_seek</a>(bio, 3);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga8908842d47bd3cbc996e77fd7c1e0ba4"><div class="ttname"><a href="#ga8908842d47bd3cbc996e77fd7c1e0ba4">wolfSSL_BIO_seek</a></div><div class="ttdeci">int wolfSSL_BIO_seek(WOLFSSL_BIO *bio, int ofs)</div><div class="ttdoc">This function adjusts the file pointer to the offset given. This is the offset from the head of the f...</div></div>
<div class="ttc" id="agroup__IO_html_gaf05ea9cba44df853314417db7a774e99"><div class="ttname"><a href="#gaf05ea9cba44df853314417db7a774e99">wolfSSL_BIO_set_fp</a></div><div class="ttdeci">long wolfSSL_BIO_set_fp(WOLFSSL_BIO *bio, XFILE fp, int c)</div><div class="ttdoc">This is used to set the internal file pointer for a BIO.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
<a class="el" href="#gaf05ea9cba44df853314417db7a774e99" title="This is used to set the internal file pointer for a BIO.">wolfSSL_BIO_set_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="gae7056bcc5de43dbb8fa46756e076204c" name="gae7056bcc5de43dbb8fa46756e076204c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7056bcc5de43dbb8fa46756e076204c">&#9670;&#160;</a></span>wolfSSL_BIO_set_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_set_close </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the close flag, used to indicate that the i/o stream should be closed when the BIO is freed. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS(1) upon success.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure. </td></tr>
    <tr><td class="paramname">flag</td><td>flag for behavior when closing i/o stream.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="comment">// setup bio</span></div>
<div class="line"><a class="code hl_function" href="#gae7056bcc5de43dbb8fa46756e076204c">wolfSSL_BIO_set_close</a>(bio, BIO_NOCLOSE);</div>
<div class="ttc" id="agroup__IO_html_gae7056bcc5de43dbb8fa46756e076204c"><div class="ttname"><a href="#gae7056bcc5de43dbb8fa46756e076204c">wolfSSL_BIO_set_close</a></div><div class="ttdeci">int wolfSSL_BIO_set_close(WOLFSSL_BIO *b, long flag)</div><div class="ttdoc">Sets the close flag, used to indicate that the i/o stream should be closed when the BIO is freed.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="gab635da3ded1fc28fd481534d19973aa1" name="gab635da3ded1fc28fd481534d19973aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab635da3ded1fc28fd481534d19973aa1">&#9670;&#160;</a></span>wolfSSL_BIO_set_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_BIO_set_fd </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the file descriptor for bio to use. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS(1) upon success.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set fd. </td></tr>
    <tr><td class="paramname">fd</td><td>file descriptor to use. </td></tr>
    <tr><td class="paramname">closeF</td><td>flag for behavior when closing fd.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> fd;</div>
<div class="line"><span class="comment">// setup bio</span></div>
<div class="line"><a class="code hl_function" href="#gab635da3ded1fc28fd481534d19973aa1">wolfSSL_BIO_set_fd</a>(bio, fd, BIO_NOCLOSE);</div>
<div class="ttc" id="agroup__IO_html_gab635da3ded1fc28fd481534d19973aa1"><div class="ttname"><a href="#gab635da3ded1fc28fd481534d19973aa1">wolfSSL_BIO_set_fd</a></div><div class="ttdeci">long wolfSSL_BIO_set_fd(WOLFSSL_BIO *b, int fd, int flag)</div><div class="ttdoc">Sets the file descriptor for bio to use.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="gaf05ea9cba44df853314417db7a774e99" name="gaf05ea9cba44df853314417db7a774e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05ea9cba44df853314417db7a774e99">&#9670;&#160;</a></span>wolfSSL_BIO_set_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_BIO_set_fp </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFILE</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set the internal file pointer for a BIO. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully setting file pointer. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set pair. </td></tr>
    <tr><td class="paramname">fp</td><td>file pointer to set in bio. </td></tr>
    <tr><td class="paramname">c</td><td>close file behavior flag.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line">XFILE fp;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_file());</div>
<div class="line">ret  = <a class="code hl_function" href="#gaf05ea9cba44df853314417db7a774e99">wolfSSL_BIO_set_fp</a>(bio, fp, BIO_CLOSE);</div>
<div class="line"><span class="comment">// check ret value</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
<a class="el" href="#gac2e81c60581f1ba7b5fd3984c37ced23" title="This is used to get the internal file pointer for a BIO.">wolfSSL_BIO_get_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga1be0050703a8b74913831481b90e45cc" name="ga1be0050703a8b74913831481b90e45cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be0050703a8b74913831481b90e45cc">&#9670;&#160;</a></span>wolfSSL_BIO_set_mem_eof_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_BIO_set_mem_eof_return </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set the end of file value. Common value is -1 so as not to get confused with expected positive values. </p>
<dl class="section return"><dt>Returns</dt><dd>0 returned on completion</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set end of file value. </td></tr>
    <tr><td class="paramname">v</td><td>value to set in bio.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_mem());</div>
<div class="line">ret  = <a class="code hl_function" href="#ga1be0050703a8b74913831481b90e45cc">wolfSSL_BIO_set_mem_eof_return</a>(bio, -1);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga1be0050703a8b74913831481b90e45cc"><div class="ttname"><a href="#ga1be0050703a8b74913831481b90e45cc">wolfSSL_BIO_set_mem_eof_return</a></div><div class="ttdeci">long wolfSSL_BIO_set_mem_eof_return(WOLFSSL_BIO *bio, int v)</div><div class="ttdoc">This is used to set the end of file value. Common value is -1 so as not to get confused with expected...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
<a class="el" href="#gaf05ea9cba44df853314417db7a774e99" title="This is used to set the internal file pointer for a BIO.">wolfSSL_BIO_set_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga435ac1cfd706cd6a0fe0a3f1e93f312b" name="ga435ac1cfd706cd6a0fe0a3f1e93f312b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435ac1cfd706cd6a0fe0a3f1e93f312b">&#9670;&#160;</a></span>wolfSSL_BIO_set_write_buf_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_set_write_buf_size </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set the size of write buffer for a WOLFSSL_BIO. If write buffer has been previously set this function will free it when resetting the size. It is similar to wolfSSL_BIO_reset in that it resets read and write indexes to 0. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully setting the write buffer. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set fd. </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio = wolfSSL_BIO_new(wolfSSL_BIO_s_mem());</div>
<div class="line">ret = <a class="code hl_function" href="#ga435ac1cfd706cd6a0fe0a3f1e93f312b">wolfSSL_BIO_set_write_buf_size</a>(bio, 15000);</div>
<div class="line"><span class="comment">// check return value</span></div>
<div class="ttc" id="agroup__IO_html_ga435ac1cfd706cd6a0fe0a3f1e93f312b"><div class="ttname"><a href="#ga435ac1cfd706cd6a0fe0a3f1e93f312b">wolfSSL_BIO_set_write_buf_size</a></div><div class="ttdeci">int wolfSSL_BIO_set_write_buf_size(WOLFSSL_BIO *b, long size)</div><div class="ttdoc">This is used to set the size of write buffer for a WOLFSSL_BIO. If write buffer has been previously s...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_mem </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga5debc444a59805b60dfaf575710c3605" name="ga5debc444a59805b60dfaf575710c3605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5debc444a59805b60dfaf575710c3605">&#9670;&#160;</a></span>wolfSSL_BIO_write_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_BIO_write_filename </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_BIO *</td>          <td class="paramname"><span class="paramname"><em>bio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to set and write to a file. WIll overwrite any data currently in the file and is set to close the file when the bio is freed. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS On successfully opening and setting file. </dd>
<dd>
SSL_FAILURE If an error case was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bio</td><td>WOLFSSL_BIO structure to set file. </td></tr>
    <tr><td class="paramname">name</td><td>name of file to write to.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_BIO* bio;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">bio  = wolfSSL_BIO_new(wolfSSL_BIO_s_file());</div>
<div class="line">ret  = <a class="code hl_function" href="#ga5debc444a59805b60dfaf575710c3605">wolfSSL_BIO_write_filename</a>(bio, “test.txt”);</div>
<div class="line"><span class="comment">// check ret value</span></div>
<div class="ttc" id="agroup__IO_html_ga5debc444a59805b60dfaf575710c3605"><div class="ttname"><a href="#ga5debc444a59805b60dfaf575710c3605">wolfSSL_BIO_write_filename</a></div><div class="ttdeci">int wolfSSL_BIO_write_filename(WOLFSSL_BIO *bio, char *name)</div><div class="ttdoc">This is used to set and write to a file. WIll overwrite any data currently in the file and is set to ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_BIO_new </dd>
<dd>
wolfSSL_BIO_s_file </dd>
<dd>
<a class="el" href="#gaf05ea9cba44df853314417db7a774e99" title="This is used to set the internal file pointer for a BIO.">wolfSSL_BIO_set_fp</a> </dd>
<dd>
wolfSSL_BIO_free </dd></dl>

</div>
</div>
<a id="ga8529c4da0a7bd779ab3c72f846b3b208" name="ga8529c4da0a7bd779ab3c72f846b3b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8529c4da0a7bd779ab3c72f846b3b208">&#9670;&#160;</a></span>wolfSSL_CIPHER_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wolfSSL_CIPHER_get_name </td>
          <td>(</td>
          <td class="paramtype">const WOLFSSL_CIPHER *</td>          <td class="paramname"><span class="paramname"><em>cipher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function matches the cipher suite in the SSL object with the available suites and returns the string representation. </p>
<dl class="section return"><dt>Returns</dt><dd>string This function returns the string representation of the matched cipher suite. </dd>
<dd>
none It will return “None” if there are no suites matched.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>a constant pointer to a WOLFSSL_CIPHER structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// gets cipher name in the format DHE_RSA ...</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* wolfSSL_get_cipher_name_internal(WOLFSSL* ssl){</div>
<div class="line">WOLFSSL_CIPHER* cipher;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fullName;</div>
<div class="line">…</div>
<div class="line">cipher = wolfSSL_get_curent_cipher(ssl);</div>
<div class="line">fullName = <a class="code hl_function" href="#ga8529c4da0a7bd779ab3c72f846b3b208">wolfSSL_CIPHER_get_name</a>(cipher);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(fullName){</div>
<div class="line">    <span class="comment">// sanity check on returned cipher</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga8529c4da0a7bd779ab3c72f846b3b208"><div class="ttname"><a href="#ga8529c4da0a7bd779ab3c72f846b3b208">wolfSSL_CIPHER_get_name</a></div><div class="ttdeci">const char * wolfSSL_CIPHER_get_name(const WOLFSSL_CIPHER *cipher)</div><div class="ttdoc">This function matches the cipher suite in the SSL object with the available suites and returns the st...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga21ac3732347588a968b7dad64719afdc" title="This function matches the cipher suite in the SSL object with the available suites.">wolfSSL_get_cipher</a> </dd>
<dd>
<a class="el" href="#ga51203855db9824ea018e24386498eddb" title="This function returns a pointer to the current cipher in the ssl session.">wolfSSL_get_current_cipher</a> </dd>
<dd>
wolfSSL_get_cipher_name_internal </dd>
<dd>
<a class="el" href="#ga7d30914ff0d7476576faea4115228703" title="This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_c...">wolfSSL_get_cipher_name</a> </dd></dl>

</div>
</div>
<a id="ga5b8f41cca120758d1860c7bc959755dd" name="ga5b8f41cca120758d1860c7bc959755dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8f41cca120758d1860c7bc959755dd">&#9670;&#160;</a></span>wolfSSL_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_connect </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side and initiates an SSL/TLS handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS If successful. </dd>
<dd>
SSL_FATAL_ERROR will be returned if an error occurred. To get a more detailed error code, call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga5b8f41cca120758d1860c7bc959755dd">wolfSSL_connect</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga5b8f41cca120758d1860c7bc959755dd"><div class="ttname"><a href="#ga5b8f41cca120758d1860c7bc959755dd">wolfSSL_connect</a></div><div class="ttdeci">int wolfSSL_connect(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on the client side and initiates an SSL/TLS handshake with a server....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd></dl>

</div>
</div>
<a id="ga5c2a07e4372fea5b1f5fe8ad32186dd3" name="ga5c2a07e4372fea5b1f5fe8ad32186dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3">&#9670;&#160;</a></span>wolfSSL_connect_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_connect_cert </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side and initiates an SSL/TLS handshake with a server only long enough to get the peer’s certificate chain. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3" title="This function is called on the client side and initiates an SSL/TLS handshake with a server only long...">wolfSSL_connect_cert()</a> will only return once the peer’s certificate chain has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
SSL_FAILURE will be returned if the SSL session parameter is NULL. </dd>
<dd>
SSL_FATAL_ERROR will be returned if an error occurred. To get a more detailed error code, call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3">wolfSSL_connect_cert</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga5c2a07e4372fea5b1f5fe8ad32186dd3"><div class="ttname"><a href="#ga5c2a07e4372fea5b1f5fe8ad32186dd3">wolfSSL_connect_cert</a></div><div class="ttdeci">int wolfSSL_connect_cert(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on the client side and initiates an SSL/TLS handshake with a server only long...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd>
<dd>
<a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd></dl>

</div>
</div>
<a id="ga2c85ff2299e5cb41d809dfdce9115d38" name="ga2c85ff2299e5cb41d809dfdce9115d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c85ff2299e5cb41d809dfdce9115d38">&#9670;&#160;</a></span>wolfSSL_connect_TLSv13()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_connect_TLSv13 </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on the client side and initiates a TLS v1.3 handshake with a server. When this function is called, the underlying communication channel has already been set up. <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_connect to continue the handshake. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition. If the underlying I/O is blocking, <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> will only return once the handshake has been finished or an error occurred. wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don't load CAs to verify the server you'll get a connect error, unable to verify (-155). It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling: SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0); before calling SSL_new(); Though it's not recommended. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS upon success. </dd>
<dd>
SSL_FATAL_ERROR will be returned if an error occurred. To get a more detailed error code, call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga2c85ff2299e5cb41d809dfdce9115d38">wolfSSL_connect_TLSv13</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga2c85ff2299e5cb41d809dfdce9115d38"><div class="ttname"><a href="#ga2c85ff2299e5cb41d809dfdce9115d38">wolfSSL_connect_TLSv13</a></div><div class="ttdeci">int wolfSSL_connect_TLSv13(WOLFSSL *)</div><div class="ttdoc">This function is called on the client side and initiates a TLS v1.3 handshake with a server....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd>
<dd>
<a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13</a> </dd>
<dd>
<a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd></dl>

</div>
</div>
<a id="ga4a1a3b8e4350d41d9f5e485e315bccc9" name="ga4a1a3b8e4350d41d9f5e485e315bccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a1a3b8e4350d41d9f5e485e315bccc9">&#9670;&#160;</a></span>wolfSSL_flush_sessions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_flush_sessions </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_CTX *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>tm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function flushes session from the session cache which have expired. The time, tm, is used for the time comparison. Note that wolfSSL currently uses a static table for sessions, so no flushing is needed. As such, this function is currently just a stub. This function provides OpenSSL compatibility (SSL_flush_sessions) when wolfSSL is compiled with the OpenSSL compatibility layer. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to a WOLFSSL_CTX structure, created using <a class="el" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45" title="This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.">wolfSSL_CTX_new()</a>. </td></tr>
    <tr><td class="paramname">tm</td><td>time used in session expiration comparison.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ssl;</div>
<div class="line">...</div>
<div class="line">wolfSSL_flush_sessions(ctx, time(0));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session</a> </dd></dl>

</div>
</div>
<a id="ga29e520b2f3fbc6b9c2fbe774b5516b83" name="ga29e520b2f3fbc6b9c2fbe774b5516b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e520b2f3fbc6b9c2fbe774b5516b83">&#9670;&#160;</a></span>wolfSSL_get_alert_history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_alert_history </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_ALERT_HISTORY *</td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the alert history. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned when the function completed successfully. Either there was alert history or there wasn’t, either way, the return value is SSL_SUCCESS.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">h</td><td>a pointer to a WOLFSSL_ALERT_HISTORY structure that will hold the WOLFSSL struct’s alert_history member’s value.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(protocol method);</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">WOLFSSL_ALERT_HISTORY* h;</div>
<div class="line">...</div>
<div class="line">wolfSSL_get_alert_history(ssl, h);</div>
<div class="line"><span class="comment">// h now has a copy of the ssl-&gt;alert_history  contents</span></div>
<div class="ttc" id="agroup__Setup_html_ga2bcaa81e9fd11074c6e504891370dd45"><div class="ttname"><a href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a></div><div class="ttdeci">WOLFSSL_CTX * wolfSSL_CTX_new(WOLFSSL_METHOD *)</div><div class="ttdoc">This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.</div></div>
<div class="ttc" id="agroup__Setup_html_gab6d54b7485d74962e57bc636008aa9a0"><div class="ttname"><a href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a></div><div class="ttdeci">WOLFSSL * wolfSSL_new(WOLFSSL_CTX *)</div><div class="ttdoc">This function creates a new SSL session, taking an already created SSL context as input.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error</a> </dd></dl>

</div>
</div>
<a id="ga21ac3732347588a968b7dad64719afdc" name="ga21ac3732347588a968b7dad64719afdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21ac3732347588a968b7dad64719afdc">&#9670;&#160;</a></span>wolfSSL_get_cipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wolfSSL_get_cipher </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function matches the cipher suite in the SSL object with the available suites. </p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the string value of the suite matched. It will return “None” if there are no suites matched.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef WOLFSSL_DTLS</span></div>
<div class="line">…</div>
<div class="line"><span class="comment">// make sure a valid suite is used</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga21ac3732347588a968b7dad64719afdc">wolfSSL_get_cipher</a>(ssl) == NULL){</div>
<div class="line">    WOLFSSL_MSG(“Can not match cipher suite imported”);</div>
<div class="line">    <span class="keywordflow">return</span> MATCH_SUITE_ERROR;</div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// WOLFSSL_DTLS</span></div>
<div class="ttc" id="agroup__IO_html_ga21ac3732347588a968b7dad64719afdc"><div class="ttname"><a href="#ga21ac3732347588a968b7dad64719afdc">wolfSSL_get_cipher</a></div><div class="ttdeci">const char * wolfSSL_get_cipher(WOLFSSL *)</div><div class="ttdoc">This function matches the cipher suite in the SSL object with the available suites.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8529c4da0a7bd779ab3c72f846b3b208" title="This function matches the cipher suite in the SSL object with the available suites and returns the st...">wolfSSL_CIPHER_get_name</a> </dd>
<dd>
<a class="el" href="#ga51203855db9824ea018e24386498eddb" title="This function returns a pointer to the current cipher in the ssl session.">wolfSSL_get_current_cipher</a> </dd></dl>

</div>
</div>
<a id="ga15a272d692a7cab4d991c5b1cf9d49cf" name="ga15a272d692a7cab4d991c5b1cf9d49cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a272d692a7cab4d991c5b1cf9d49cf">&#9670;&#160;</a></span>wolfSSL_get_cipher_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * wolfSSL_get_cipher_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of cipher at priority level passed in. </p>
<dl class="section return"><dt>Returns</dt><dd>string Success </dd>
<dd>
0 Priority is either out of bounds or not valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>Integer representing the priority level of a cipher.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;The cipher at 1 is %s&quot;</span>, <a class="code hl_function" href="#ga15a272d692a7cab4d991c5b1cf9d49cf">wolfSSL_get_cipher_list</a>(1));</div>
<div class="ttc" id="agroup__IO_html_ga15a272d692a7cab4d991c5b1cf9d49cf"><div class="ttname"><a href="#ga15a272d692a7cab4d991c5b1cf9d49cf">wolfSSL_get_cipher_list</a></div><div class="ttdeci">char * wolfSSL_get_cipher_list(int priority)</div><div class="ttdoc">Get the name of cipher at priority level passed in.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8529c4da0a7bd779ab3c72f846b3b208" title="This function matches the cipher suite in the SSL object with the available suites and returns the st...">wolfSSL_CIPHER_get_name</a> </dd>
<dd>
<a class="el" href="#ga51203855db9824ea018e24386498eddb" title="This function returns a pointer to the current cipher in the ssl session.">wolfSSL_get_current_cipher</a> </dd></dl>

</div>
</div>
<a id="ga7d30914ff0d7476576faea4115228703" name="ga7d30914ff0d7476576faea4115228703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d30914ff0d7476576faea4115228703">&#9670;&#160;</a></span>wolfSSL_get_cipher_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wolfSSL_get_cipher_name </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_cipher_name_internal. </p>
<dl class="section return"><dt>Returns</dt><dd>string This function returns the string representation of the cipher suite that was matched. </dd>
<dd>
NULL error or cipher not found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordtype">char</span>* cipherS = <a class="code hl_function" href="#ga7d30914ff0d7476576faea4115228703">wolfSSL_get_cipher_name</a>(ssl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(cipher == NULL){</div>
<div class="line">    <span class="comment">// There was not a cipher suite matched</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// There was a cipher suite matched</span></div>
<div class="line">    printf(“%s\n”, cipherS);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga7d30914ff0d7476576faea4115228703"><div class="ttname"><a href="#ga7d30914ff0d7476576faea4115228703">wolfSSL_get_cipher_name</a></div><div class="ttdeci">const char * wolfSSL_get_cipher_name(WOLFSSL *ssl)</div><div class="ttdoc">This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_c...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8529c4da0a7bd779ab3c72f846b3b208" title="This function matches the cipher suite in the SSL object with the available suites and returns the st...">wolfSSL_CIPHER_get_name</a> </dd>
<dd>
<a class="el" href="#ga51203855db9824ea018e24386498eddb" title="This function returns a pointer to the current cipher in the ssl session.">wolfSSL_get_current_cipher</a> </dd>
<dd>
wolfSSL_get_cipher_name_internal </dd></dl>

</div>
</div>
<a id="gadb0f97124908e6fa173259ccccc678da" name="gadb0f97124908e6fa173259ccccc678da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0f97124908e6fa173259ccccc678da">&#9670;&#160;</a></span>wolfSSL_get_ciphers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_ciphers </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the ciphers enabled in wolfSSL. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. </dd>
<dd>
BAD_FUNC_ARG returned if the buf parameter was NULL or if the len argument was less than or equal to zero. </dd>
<dd>
BUFFER_E returned if the buffer is not large enough and will overflow.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>a char pointer representing the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ShowCiphers(<span class="keywordtype">void</span>){</div>
<div class="line"><span class="keywordtype">char</span>* ciphers;</div>
<div class="line"><span class="keywordtype">int</span> ret = <a class="code hl_function" href="#gadb0f97124908e6fa173259ccccc678da">wolfSSL_get_ciphers</a>(ciphers, (<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(ciphers));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(ret == SSL_SUCCES){</div>
<div class="line">        printf(“%s\n”, ciphers);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gadb0f97124908e6fa173259ccccc678da"><div class="ttname"><a href="#gadb0f97124908e6fa173259ccccc678da">wolfSSL_get_ciphers</a></div><div class="ttdeci">int wolfSSL_get_ciphers(char *buf, int len)</div><div class="ttdoc">This function gets the ciphers enabled in wolfSSL.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>GetCipherNames </dd>
<dd>
<a class="el" href="#ga15a272d692a7cab4d991c5b1cf9d49cf" title="Get the name of cipher at priority level passed in.">wolfSSL_get_cipher_list</a> </dd>
<dd>
ShowCiphers </dd></dl>

</div>
</div>
<a id="ga51203855db9824ea018e24386498eddb" name="ga51203855db9824ea018e24386498eddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51203855db9824ea018e24386498eddb">&#9670;&#160;</a></span>wolfSSL_get_current_cipher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_CIPHER * wolfSSL_get_current_cipher </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a pointer to the current cipher in the ssl session. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns the address of the cipher member of the WOLFSSL struct. This is a pointer to the WOLFSSL_CIPHER structure. </dd>
<dd>
NULL returned if the WOLFSSL structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line">WOLFSSL_CIPHER* cipherCurr = <a class="code hl_function" href="#ga51203855db9824ea018e24386498eddb">wolfSSL_get_current_cipher</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(!cipherCurr){</div>
<div class="line">    <span class="comment">// Failure case.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The cipher was returned to cipherCurr</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga51203855db9824ea018e24386498eddb"><div class="ttname"><a href="#ga51203855db9824ea018e24386498eddb">wolfSSL_get_current_cipher</a></div><div class="ttdeci">WOLFSSL_CIPHER * wolfSSL_get_current_cipher(WOLFSSL *ssl)</div><div class="ttdoc">This function returns a pointer to the current cipher in the ssl session.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga21ac3732347588a968b7dad64719afdc" title="This function matches the cipher suite in the SSL object with the available suites.">wolfSSL_get_cipher</a> </dd>
<dd>
wolfSSL_get_cipher_name_internal </dd>
<dd>
<a class="el" href="#ga7d30914ff0d7476576faea4115228703" title="This function gets the cipher name in the format DHE-RSA by passing through argument to wolfSSL_get_c...">wolfSSL_get_cipher_name</a> </dd></dl>

</div>
</div>
<a id="ga62ba4ad3eec03f749e1613b9c1f67538" name="ga62ba4ad3eec03f749e1613b9c1f67538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ba4ad3eec03f749e1613b9c1f67538">&#9670;&#160;</a></span>wolfSSL_get_current_cipher_suite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_current_cipher_suite </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current cipher suit an ssl session is using. </p>
<dl class="section return"><dt>Returns</dt><dd>ssl-&gt;options.cipherSuite An integer representing the current cipher suite. </dd>
<dd>
0 The ssl session provided is null.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL session to check.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a>();</div>
<div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">WOLFSSL_METHOD method = <span class="comment">// Some wolfSSL method</span></div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga62ba4ad3eec03f749e1613b9c1f67538">wolfSSL_get_current_cipher_suite</a>(ssl) == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error getting cipher suite</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga62ba4ad3eec03f749e1613b9c1f67538"><div class="ttname"><a href="#ga62ba4ad3eec03f749e1613b9c1f67538">wolfSSL_get_current_cipher_suite</a></div><div class="ttdeci">int wolfSSL_get_current_cipher_suite(WOLFSSL *ssl)</div><div class="ttdoc">Returns the current cipher suit an ssl session is using.</div></div>
<div class="ttc" id="agroup__TLS_html_ga789ef74e34df659a62f06da2ea709737"><div class="ttname"><a href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a></div><div class="ttdeci">int wolfSSL_Init(void)</div><div class="ttdoc">Initializes the wolfSSL library for use. Must be called once per application and before any other cal...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8529c4da0a7bd779ab3c72f846b3b208" title="This function matches the cipher suite in the SSL object with the available suites and returns the st...">wolfSSL_CIPHER_get_name</a> </dd>
<dd>
<a class="el" href="#ga51203855db9824ea018e24386498eddb" title="This function returns a pointer to the current cipher in the ssl session.">wolfSSL_get_current_cipher</a> </dd>
<dd>
<a class="el" href="#ga15a272d692a7cab4d991c5b1cf9d49cf" title="Get the name of cipher at priority level passed in.">wolfSSL_get_cipher_list</a> </dd></dl>

</div>
</div>
<a id="gacc9ea6f4b1ca94ebd240a0752a9600f8" name="gacc9ea6f4b1ca94ebd240a0752a9600f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9ea6f4b1ca94ebd240a0752a9600f8">&#9670;&#160;</a></span>wolfSSL_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_fd </td>
          <td>(</td>
          <td class="paramtype">const WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the read file descriptor (fd) used as the input facility for the SSL connection. Typically this will be a socket file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>fd If successful the call will return the SSL session file descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sockfd;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">sockfd = <a class="code hl_function" href="#gacc9ea6f4b1ca94ebd240a0752a9600f8">wolfSSL_get_fd</a>(ssl);</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_gacc9ea6f4b1ca94ebd240a0752a9600f8"><div class="ttname"><a href="#gacc9ea6f4b1ca94ebd240a0752a9600f8">wolfSSL_get_fd</a></div><div class="ttdeci">int wolfSSL_get_fd(const WOLFSSL *)</div><div class="ttdoc">This function returns the read file descriptor (fd) used as the input facility for the SSL connection...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga3fea7387eeb7c90feeff9ae4e523bda7" title="This function assigns a file descriptor (fd) as the input/output facility for the SSL connection....">wolfSSL_set_fd</a> </dd>
<dd>
wolfSSL_set_read_fd </dd>
<dd>
wolfSSL_set_write_fd </dd></dl>

</div>
</div>
<a id="ga89aed85f25618a8a012ae855d07e2023" name="ga89aed85f25618a8a012ae855d07e2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89aed85f25618a8a012ae855d07e2023">&#9670;&#160;</a></span>wolfSSL_get_jobject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_get_jobject </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the jObjectRef member of the WOLFSSL structure. </p>
<dl class="section return"><dt>Returns</dt><dd>value If the WOLFSSL struct is not NULL, the function returns the jObjectRef value. </dd>
<dd>
NULL returned if the WOLFSSL struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = wolfSSL(ctx);</div>
<div class="line">...</div>
<div class="line">void* jobject = <a class="code hl_function" href="#ga89aed85f25618a8a012ae855d07e2023">wolfSSL_get_jobject</a>(ssl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(jobject != NULL){</div>
<div class="line">    <span class="comment">// Success case</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga89aed85f25618a8a012ae855d07e2023"><div class="ttname"><a href="#ga89aed85f25618a8a012ae855d07e2023">wolfSSL_get_jobject</a></div><div class="ttdeci">void * wolfSSL_get_jobject(WOLFSSL *ssl)</div><div class="ttdoc">This function returns the jObjectRef member of the WOLFSSL structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadea64abddfb32623d439ced576afb498" title="This function sets the jObjectRef member of the WOLFSSL structure.">wolfSSL_set_jobject</a> </dd></dl>

</div>
</div>
<a id="gaad042d5e0b1e7c2635b6caa12619e0f1" name="gaad042d5e0b1e7c2635b6caa12619e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad042d5e0b1e7c2635b6caa12619e0f1">&#9670;&#160;</a></span>wolfSSL_get_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_SESSION * wolfSSL_get_session </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When NO_SESSION_CACHE_REF is defined this function returns a pointer to the current session (WOLFSSL_SESSION) used in ssl. This function returns a non-persistent pointer to the WOLFSSL_SESSION object. The pointer returned will be freed when wolfSSL_free is called. This call should only be used to inspect or modify the current session. For session resumption it is recommended to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a>. For backwards compatibility when NO_SESSION_CACHE_REF is not defined this function returns a persistent session object pointer that is stored in the local cache. The cache size is finite and there is a risk that the session object will be overwritten by another ssl connection by the time the application calls <a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session()</a> on it. It is recommended to define NO_SESSION_CACHE_REF in your application and to use <a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session()</a> for session resumption. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer If successful the call will return a pointer to the the current SSL session object. </dd>
<dd>
NULL will be returned if ssl is NULL, the SSL session cache is disabled, wolfSSL doesn’t have the Session ID available, or mutex functions fail.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line">WOLFSSL_SESSION* session;</div>
<div class="line">...</div>
<div class="line">session = <a class="code hl_function" href="#gaad042d5e0b1e7c2635b6caa12619e0f1">wolfSSL_get_session</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (session == NULL) {</div>
<div class="line">    <span class="comment">// failed to get session pointer</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_gaad042d5e0b1e7c2635b6caa12619e0f1"><div class="ttname"><a href="#gaad042d5e0b1e7c2635b6caa12619e0f1">wolfSSL_get_session</a></div><div class="ttdeci">WOLFSSL_SESSION * wolfSSL_get_session(WOLFSSL *ssl)</div><div class="ttdoc">When NO_SESSION_CACHE_REF is defined this function returns a pointer to the current session (WOLFSSL_...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga99e714f7d0a93b81c667f787750e1994" title="This function returns the WOLFSSL_SESSION from the WOLFSSL structure as a reference type....">wolfSSL_get1_session</a> </dd>
<dd>
<a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session</a> </dd></dl>

</div>
</div>
<a id="ga788f4e18e0e6ed15480c857e90def619" name="ga788f4e18e0e6ed15480c857e90def619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga788f4e18e0e6ed15480c857e90def619">&#9670;&#160;</a></span>wolfSSL_get_session_cache_memsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_session_cache_memsize </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns how large the session cache save buffer should be. </p>
<dl class="section return"><dt>Returns</dt><dd>int This function returns an integer that represents the size of the session cache save buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sz = <span class="comment">// Minimum size for error checking;</span></div>
<div class="line">...</div>
<div class="line">if(sz &lt; <a class="code hl_function" href="#ga788f4e18e0e6ed15480c857e90def619">wolfSSL_get_session_cache_memsize</a>()){</div>
<div class="line">    <span class="comment">// Memory buffer is too small</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga788f4e18e0e6ed15480c857e90def619"><div class="ttname"><a href="#ga788f4e18e0e6ed15480c857e90def619">wolfSSL_get_session_cache_memsize</a></div><div class="ttdeci">int wolfSSL_get_session_cache_memsize(void)</div><div class="ttdoc">This function returns how large the session cache save buffer should be.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1d2b0be768745cb1383ad126e7af2576" title="This function restores the persistent session cache from memory.">wolfSSL_memrestore_session_cache</a> </dd></dl>

</div>
</div>
<a id="gaaaf142daad76403f27d7d5d2b6261420" name="gaaaf142daad76403f27d7d5d2b6261420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf142daad76403f27d7d5d2b6261420">&#9670;&#160;</a></span>wolfSSL_get_session_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_session_stats </td>
          <td>(</td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>active</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>total</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>peak</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>maxSessions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the statistics for the session. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function and subroutines return without error. The session stats have been successfully retrieved and printed. </dd>
<dd>
BAD_FUNC_ARG returned if the subroutine <a class="el" href="#gaaaf142daad76403f27d7d5d2b6261420" title="This function gets the statistics for the session.">wolfSSL_get_session_stats()</a> was passed an unacceptable argument. </dd>
<dd>
BAD_MUTEX_E returned if there was a mutex error in the subroutine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>a word32 pointer representing the total current sessions. </td></tr>
    <tr><td class="paramname">total</td><td>a word32 pointer representing the total sessions. </td></tr>
    <tr><td class="paramname">peak</td><td>a word32 pointer representing the peak sessions. </td></tr>
    <tr><td class="paramname">maxSessions</td><td>a word32 pointer representing the maximum sessions.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="#ga0085f8baa71150d0264766e4a2b6c784">wolfSSL_PrintSessionStats</a>(<span class="keywordtype">void</span>){</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#gaaaf142daad76403f27d7d5d2b6261420">wolfSSL_get_session_stats</a>(&amp;totalSessionsNow,</div>
<div class="line">&amp;totalSessionsSeen, &amp;peak, &amp;maxSessions);</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">return</span> ret;</div>
<div class="ttc" id="agroup__IO_html_ga0085f8baa71150d0264766e4a2b6c784"><div class="ttname"><a href="#ga0085f8baa71150d0264766e4a2b6c784">wolfSSL_PrintSessionStats</a></div><div class="ttdeci">int wolfSSL_PrintSessionStats(void)</div><div class="ttdoc">This function prints the statistics from the session.</div></div>
<div class="ttc" id="agroup__IO_html_gaaaf142daad76403f27d7d5d2b6261420"><div class="ttname"><a href="#gaaaf142daad76403f27d7d5d2b6261420">wolfSSL_get_session_stats</a></div><div class="ttdeci">int wolfSSL_get_session_stats(unsigned int *active, unsigned int *total, unsigned int *peak, unsigned int *maxSessions)</div><div class="ttdoc">This function gets the statistics for the session.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0085f8baa71150d0264766e4a2b6c784" title="This function prints the statistics from the session.">wolfSSL_PrintSessionStats</a> </dd></dl>

</div>
</div>
<a id="gab67e2593987cfe2a20c660440c087576" name="gab67e2593987cfe2a20c660440c087576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67e2593987cfe2a20c660440c087576">&#9670;&#160;</a></span>wolfSSL_get_SessionTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_SessionTicket </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>bufSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the ticket member of the Session structure to the buffer. If buf is NULL and bufSz is non-NULL, bufSz will be set to the ticket length. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. </dd>
<dd>
BAD_FUNC_ARG returned if ssl or bufSz is NULL, or if bufSz is non-NULL and buf is NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>a byte pointer representing the memory buffer. </td></tr>
    <tr><td class="paramname">bufSz</td><td>a word32 pointer representing the buffer size.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">byte</span>* buf;</div>
<div class="line">word32 bufSz;  <span class="comment">// Initialize with buf size</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gab67e2593987cfe2a20c660440c087576">wolfSSL_get_SessionTicket</a>(ssl, buf, bufSz) &lt;= 0){</div>
<div class="line">    <span class="comment">// Nothing was written to the buffer</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// the buffer holds the content from ssl-&gt;session-&gt;ticket</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gab67e2593987cfe2a20c660440c087576"><div class="ttname"><a href="#gab67e2593987cfe2a20c660440c087576">wolfSSL_get_SessionTicket</a></div><div class="ttdeci">int wolfSSL_get_SessionTicket(WOLFSSL *ssl, unsigned char *buf, word32 *bufSz)</div><div class="ttdoc">This function copies the ticket member of the Session structure to the buffer. If buf is NULL and buf...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae22e32f06e5b1f22116c794b3dc28577" title="Force provided WOLFSSL structure to use session ticket. The constant HAVE_SESSION_TICKET should be de...">wolfSSL_UseSessionTicket</a> </dd>
<dd>
<a class="el" href="#ga49f87f9acd032dbbd43fa43113aa331c" title="This function sets the ticket member of the WOLFSSL_SESSION structure within the WOLFSSL struct....">wolfSSL_set_SessionTicket</a> </dd></dl>

</div>
</div>
<a id="ga1b5127f98989a255a2d7aa346a677a12" name="ga1b5127f98989a255a2d7aa346a677a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5127f98989a255a2d7aa346a677a12">&#9670;&#160;</a></span>wolfSSL_get_using_nonblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_using_nonblock </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the application to determine if wolfSSL is using non-blocking I/O. If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0. After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call <a class="el" href="group__Setup.html#ga64025d60f962a3c1ea267dc195eab8e7" title="This function informs the WOLFSSL object that the underlying I/O is non-blocking. After an applicatio...">wolfSSL_set_using_nonblock()</a> on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out. </p>
<dl class="section return"><dt>Returns</dt><dd>0 underlying I/O is blocking. </dd>
<dd>
1 underlying I/O is non-blocking.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga1b5127f98989a255a2d7aa346a677a12">wolfSSL_get_using_nonblock</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 1) {</div>
<div class="line">    <span class="comment">// underlying I/O is non-blocking</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_ga1b5127f98989a255a2d7aa346a677a12"><div class="ttname"><a href="#ga1b5127f98989a255a2d7aa346a677a12">wolfSSL_get_using_nonblock</a></div><div class="ttdeci">int wolfSSL_get_using_nonblock(WOLFSSL *)</div><div class="ttdoc">This function allows the application to determine if wolfSSL is using non-blocking I/O....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga7dec51eac167358e439747b5050d5acd" title="This function sets the session to be used when the SSL object, ssl, is used to establish a SSL/TLS co...">wolfSSL_set_session</a> </dd></dl>

</div>
</div>
<a id="ga762a42460ba55d5fc8265acc535573b9" name="ga762a42460ba55d5fc8265acc535573b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762a42460ba55d5fc8265acc535573b9">&#9670;&#160;</a></span>wolfSSL_get_verify_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wolfSSL_get_verify_depth </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the maximum chain depth allowed, which is 9 by default, for a valid session i.e. there is a non-null session object (ssl). </p>
<dl class="section return"><dt>Returns</dt><dd>MAX_CHAIN_DEPTH returned if the WOLFSSL structure is not NULL. By default the value is 9. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">long sslDep = <a class="code hl_function" href="#ga762a42460ba55d5fc8265acc535573b9">wolfSSL_get_verify_depth</a>(ssl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(sslDep &gt; EXPECTED){</div>
<div class="line">    <span class="comment">// The verified depth is greater than what was expected</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The verified depth is smaller or equal to the expected value</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga762a42460ba55d5fc8265acc535573b9"><div class="ttname"><a href="#ga762a42460ba55d5fc8265acc535573b9">wolfSSL_get_verify_depth</a></div><div class="ttdeci">long wolfSSL_get_verify_depth(WOLFSSL *ssl)</div><div class="ttdoc">This function returns the maximum chain depth allowed, which is 9 by default, for a valid session i....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga5c8ab38f2c65aad78ac9dc9cb70416ba" title="This function gets the certificate chaining depth using the CTX structure.">wolfSSL_CTX_get_verify_depth</a> </dd></dl>

</div>
</div>
<a id="gaf9c570fbc6f9556a10b593ca21799000" name="gaf9c570fbc6f9556a10b593ca21799000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c570fbc6f9556a10b593ca21799000">&#9670;&#160;</a></span>wolfSSL_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wolfSSL_get_version </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SSL version being used as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>"SSLv3" Using SSLv3 </dd>
<dd>
"TLSv1" Using TLSv1 </dd>
<dd>
"TLSv1.1" Using TLSv1.1 </dd>
<dd>
"TLSv1.2" Using TLSv1.2 </dd>
<dd>
"TLSv1.3" Using TLSv1.3 </dd>
<dd>
"DTLS": Using DTLS </dd>
<dd>
"DTLSv1.2" Using DTLSv1.2 </dd>
<dd>
"unknown" There was a problem determining which version of TLS being used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a>();</div>
<div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">WOLFSSL_METHOD method = <span class="comment">// Some wolfSSL method</span></div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">printf(<a class="code hl_function" href="#gaf9c570fbc6f9556a10b593ca21799000">wolfSSL_get_version</a>(<span class="stringliteral">&quot;Using version: %s&quot;</span>, ssl));</div>
<div class="ttc" id="agroup__IO_html_gaf9c570fbc6f9556a10b593ca21799000"><div class="ttname"><a href="#gaf9c570fbc6f9556a10b593ca21799000">wolfSSL_get_version</a></div><div class="ttdeci">const char * wolfSSL_get_version(WOLFSSL *ssl)</div><div class="ttdoc">Returns the SSL version being used as a string.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa3b1592df3acdace68187bd21c92554e" title="This function returns the current library version.">wolfSSL_lib_version</a> </dd></dl>

</div>
</div>
<a id="ga956eb1db5163203c2c5948cf2a7fe924" name="ga956eb1db5163203c2c5948cf2a7fe924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956eb1db5163203c2c5948cf2a7fe924">&#9670;&#160;</a></span>wolfSSL_get_wfd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_get_wfd </td>
          <td>(</td>
          <td class="paramtype">const WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the write file descriptor (fd) used as the output facility for the SSL connection. Typically this will be a socket file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>fd If successful the call will return the SSL session file descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sockfd;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">sockfd = <a class="code hl_function" href="#ga956eb1db5163203c2c5948cf2a7fe924">wolfSSL_get_wfd</a>(ssl);</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_ga956eb1db5163203c2c5948cf2a7fe924"><div class="ttname"><a href="#ga956eb1db5163203c2c5948cf2a7fe924">wolfSSL_get_wfd</a></div><div class="ttdeci">int wolfSSL_get_wfd(const WOLFSSL *)</div><div class="ttdoc">This function returns the write file descriptor (fd) used as the output facility for the SSL connecti...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga3fea7387eeb7c90feeff9ae4e523bda7" title="This function assigns a file descriptor (fd) as the input/output facility for the SSL connection....">wolfSSL_set_fd</a> </dd>
<dd>
wolfSSL_set_read_fd </dd>
<dd>
wolfSSL_set_write_fd </dd></dl>

</div>
</div>
<a id="gacad3fa14e99066bf182bdb9bbf174cf7" name="gacad3fa14e99066bf182bdb9bbf174cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad3fa14e99066bf182bdb9bbf174cf7">&#9670;&#160;</a></span>wolfSSL_GetIOReadCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetIOReadCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IOCB_ReadCtx member of the WOLFSSL struct. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer This function returns a void pointer to the IOCB_ReadCtx member of the WOLFSSL structure. </dd>
<dd>
NULL returned if the WOLFSSL struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">void</span>* ioRead;</div>
<div class="line">...</div>
<div class="line">ioRead = <a class="code hl_function" href="#gacad3fa14e99066bf182bdb9bbf174cf7">wolfSSL_GetIOReadCtx</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span>(ioRead == NULL){</div>
<div class="line">    <span class="comment">// Failure case. The ssl object was NULL.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gacad3fa14e99066bf182bdb9bbf174cf7"><div class="ttname"><a href="#gacad3fa14e99066bf182bdb9bbf174cf7">wolfSSL_GetIOReadCtx</a></div><div class="ttdeci">void * wolfSSL_GetIOReadCtx(WOLFSSL *ssl)</div><div class="ttdoc">This function returns the IOCB_ReadCtx member of the WOLFSSL struct.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1ba8cfc5d1f1d0d0e568e802066a79a1" title="This function returns the IOCB_WriteCtx member of the WOLFSSL structure.">wolfSSL_GetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="wolfio_8h.html#a788b0750c9aab950a7891a6aad670ced" title="This function sets the flags for the receive callback to use for the given SSL session....">wolfSSL_SetIOReadFlags</a> </dd>
<dd>
<a class="el" href="wolfio_8h.html#a83422045a99df509ea3110896758db14" title="This function registers a context for the SSL session’s send callback function. By default,...">wolfSSL_SetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="wolfio_8h.html#a56e9756c6c60deeae2b43fb614e882c6" title="This function registers a context for the SSL session’s receive callback function....">wolfSSL_SetIOReadCtx</a> </dd>
<dd>
wolfSSL_CTX_SetIOSend </dd></dl>

</div>
</div>
<a id="ga1ba8cfc5d1f1d0d0e568e802066a79a1" name="ga1ba8cfc5d1f1d0d0e568e802066a79a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba8cfc5d1f1d0d0e568e802066a79a1">&#9670;&#160;</a></span>wolfSSL_GetIOWriteCtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wolfSSL_GetIOWriteCtx </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IOCB_WriteCtx member of the WOLFSSL structure. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer This function returns a void pointer to the IOCB_WriteCtx member of the WOLFSSL structure. </dd>
<dd>
NULL returned if the WOLFSSL struct is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">void</span>* ioWrite;</div>
<div class="line">...</div>
<div class="line">ioWrite = <a class="code hl_function" href="#ga1ba8cfc5d1f1d0d0e568e802066a79a1">wolfSSL_GetIOWriteCtx</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span>(ioWrite == NULL){</div>
<div class="line">    <span class="comment">// The function returned NULL.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga1ba8cfc5d1f1d0d0e568e802066a79a1"><div class="ttname"><a href="#ga1ba8cfc5d1f1d0d0e568e802066a79a1">wolfSSL_GetIOWriteCtx</a></div><div class="ttdeci">void * wolfSSL_GetIOWriteCtx(WOLFSSL *ssl)</div><div class="ttdoc">This function returns the IOCB_WriteCtx member of the WOLFSSL structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacad3fa14e99066bf182bdb9bbf174cf7" title="This function returns the IOCB_ReadCtx member of the WOLFSSL struct.">wolfSSL_GetIOReadCtx</a> </dd>
<dd>
<a class="el" href="wolfio_8h.html#a83422045a99df509ea3110896758db14" title="This function registers a context for the SSL session’s send callback function. By default,...">wolfSSL_SetIOWriteCtx</a> </dd>
<dd>
<a class="el" href="wolfio_8h.html#a56e9756c6c60deeae2b43fb614e882c6" title="This function registers a context for the SSL session’s receive callback function....">wolfSSL_SetIOReadCtx</a> </dd>
<dd>
wolfSSL_CTX_SetIOSend </dd></dl>

</div>
</div>
<a id="gab4a7dcdbfd357dced461795383b04bf2" name="gab4a7dcdbfd357dced461795383b04bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4a7dcdbfd357dced461795383b04bf2">&#9670;&#160;</a></span>wolfSSL_GetSessionAtIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetSessionAtIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WOLFSSL_SESSION *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the session at specified index of the session cache and copies it into memory. The WOLFSSL_SESSION structure holds the session information. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed successfully and no errors were thrown. </dd>
<dd>
BAD_MUTEX_E returned if there was an unlock or lock mutex error. </dd>
<dd>
SSL_FAILURE returned if the function did not execute successfully.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>an int type representing the session index. </td></tr>
    <tr><td class="paramname">session</td><td>a pointer to the WOLFSSL_SESSION structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> idx; <span class="comment">// The index to locate the session.</span></div>
<div class="line">WOLFSSL_SESSION* session;  <span class="comment">// Buffer to copy to.</span></div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#gab4a7dcdbfd357dced461795383b04bf2">wolfSSL_GetSessionAtIndex</a>(idx, session) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gab4a7dcdbfd357dced461795383b04bf2"><div class="ttname"><a href="#gab4a7dcdbfd357dced461795383b04bf2">wolfSSL_GetSessionAtIndex</a></div><div class="ttdeci">int wolfSSL_GetSessionAtIndex(int idx, WOLFSSL_SESSION *session)</div><div class="ttdoc">This function gets the session at specified index of the session cache and copies it into memory....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>UnLockMutex </dd>
<dd>
LockMutex </dd>
<dd>
<a class="el" href="#ga54930dd8cf9ac220eb44ad274d341795" title="This function gets the session index of the WOLFSSL structure.">wolfSSL_GetSessionIndex</a> </dd></dl>

</div>
</div>
<a id="ga54930dd8cf9ac220eb44ad274d341795" name="ga54930dd8cf9ac220eb44ad274d341795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54930dd8cf9ac220eb44ad274d341795">&#9670;&#160;</a></span>wolfSSL_GetSessionIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_GetSessionIndex </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the session index of the WOLFSSL structure. </p>
<dl class="section return"><dt>Returns</dt><dd>int The function returns an int type representing the sessionIndex within the WOLFSSL struct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX_new( protocol method );</div>
<div class="line">WOLFSSL* ssl = WOLFSSL_new(ctx);</div>
<div class="line">...</div>
<div class="line">int sesIdx = <a class="code hl_function" href="#ga54930dd8cf9ac220eb44ad274d341795">wolfSSL_GetSessionIndex</a>(ssl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(sesIdx &lt; 0 || sesIdx &gt; <span class="keyword">sizeof</span>(ssl-&gt;sessionIndex)/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)){</div>
<div class="line">    <span class="comment">// You have an out of bounds index number and something is not right.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga54930dd8cf9ac220eb44ad274d341795"><div class="ttname"><a href="#ga54930dd8cf9ac220eb44ad274d341795">wolfSSL_GetSessionIndex</a></div><div class="ttdeci">int wolfSSL_GetSessionIndex(WOLFSSL *ssl)</div><div class="ttdoc">This function gets the session index of the WOLFSSL structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab4a7dcdbfd357dced461795383b04bf2" title="This function gets the session at specified index of the session cache and copies it into memory....">wolfSSL_GetSessionAtIndex</a> </dd></dl>

</div>
</div>
<a id="gac0ad4fa3f78e9c8438d656392afbd46b" name="gac0ad4fa3f78e9c8438d656392afbd46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0ad4fa3f78e9c8438d656392afbd46b">&#9670;&#160;</a></span>wolfSSL_inject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_inject </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called to inject data into the WOLFSSL object. This is useful when data needs to be read from a single place and demultiplexed into multiple connections. The caller should then call <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> to extract the plaintext data from the WOLFSSL object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to inject into the ssl object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of bytes of data to inject.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG if any pointer parameter is NULL or sz &lt;= 0 </dd>
<dd>
APP_DATA_READY if there is application data left to read </dd>
<dd>
MEMORY_E if allocation fails </dd>
<dd>
WOLFSSL_SUCCESS on success</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span> buf[2000]</div>
<div class="line">sz = recv(fd, buf, <span class="keyword">sizeof</span>(buf), 0);</div>
<div class="line"><span class="keywordflow">if</span> (sz &lt;= 0)</div>
<div class="line">    <span class="comment">// error</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#gac0ad4fa3f78e9c8438d656392afbd46b">wolfSSL_inject</a>(ssl, buf, sz) != WOLFSSL_SUCCESS)</div>
<div class="line">    <span class="comment">// error</span></div>
<div class="line">sz = <a class="code hl_function" href="#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a>(ssl, buf, <span class="keyword">sizeof</span>(buf);</div>
<div class="ttc" id="agroup__IO_html_ga80c3ccd3c0441c77307df3afe88a5c35"><div class="ttname"><a href="#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a></div><div class="ttdeci">int wolfSSL_read(WOLFSSL *ssl, void *data, int sz)</div><div class="ttdoc">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....</div></div>
<div class="ttc" id="agroup__IO_html_gac0ad4fa3f78e9c8438d656392afbd46b"><div class="ttname"><a href="#gac0ad4fa3f78e9c8438d656392afbd46b">wolfSSL_inject</a></div><div class="ttdeci">int wolfSSL_inject(WOLFSSL *ssl, const void *data, int sz)</div><div class="ttdoc">This function is called to inject data into the WOLFSSL object. This is useful when data needs to be ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd></dl>

</div>
</div>
<a id="ga2f38357d4d7fba294745516caa8f4180" name="ga2f38357d4d7fba294745516caa8f4180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f38357d4d7fba294745516caa8f4180">&#9670;&#160;</a></span>wolfSSL_key_update_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_key_update_response </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>required</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on a TLS v1.3 client or server wolfSSL to determine whether a rollover of keys is in progress. When <a class="el" href="#ga38ef7eb0a15b65f3b68d2490dd0535a0" title="This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys....">wolfSSL_update_keys()</a> is called, a KeyUpdate message is sent and the encryption key is updated. The decryption key is updated when the response is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">required</td><td>0 when no key update response required. 1 when no key update response required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful. </dd>
<dd>
BAD_FUNC_ARG if ssl is NULL or not using TLS v1.3.</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">int</span> required;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga2f38357d4d7fba294745516caa8f4180">wolfSSL_key_update_response</a>(ssl, &amp;required);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// bad parameters</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (required) {</div>
<div class="line">    <span class="comment">// encrypt Key updated, awaiting response to change decrypt key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga2f38357d4d7fba294745516caa8f4180"><div class="ttname"><a href="#ga2f38357d4d7fba294745516caa8f4180">wolfSSL_key_update_response</a></div><div class="ttdeci">int wolfSSL_key_update_response(WOLFSSL *ssl, int *required)</div><div class="ttdoc">This function is called on a TLS v1.3 client or server wolfSSL to determine whether a rollover of key...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga38ef7eb0a15b65f3b68d2490dd0535a0" title="This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys....">wolfSSL_update_keys</a> </dd></dl>

</div>
</div>
<a id="gaa3b1592df3acdace68187bd21c92554e" name="gaa3b1592df3acdace68187bd21c92554e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b1592df3acdace68187bd21c92554e">&#9670;&#160;</a></span>wolfSSL_lib_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wolfSSL_lib_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current library version. </p>
<dl class="section return"><dt>Returns</dt><dd>LIBWOLFSSL_VERSION_STRING a const char pointer defining the version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> version[MAXSIZE];</div>
<div class="line">version = <a class="code hl_function" href="group__CertsKeys.html#gad17318a1c890b18829a9a1e204dd6f04">wolfSSL_KeepArrays</a>();</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(version != ExpectedVersion){</div>
<div class="line">    <span class="comment">// Handle the mismatch case</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__CertsKeys_html_gad17318a1c890b18829a9a1e204dd6f04"><div class="ttname"><a href="group__CertsKeys.html#gad17318a1c890b18829a9a1e204dd6f04">wolfSSL_KeepArrays</a></div><div class="ttdeci">void wolfSSL_KeepArrays(WOLFSSL *)</div><div class="ttdoc">Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. Calling this function befo...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>word32_wolfSSL_lib_version_hex </dd></dl>

</div>
</div>
<a id="ga19621cde181fbc016432c221169a476c" name="ga19621cde181fbc016432c221169a476c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19621cde181fbc016432c221169a476c">&#9670;&#160;</a></span>wolfSSL_lib_version_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word32 wolfSSL_lib_version_hex </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current library version in hexadecimal notation. </p>
<dl class="section return"><dt>Returns</dt><dd>LILBWOLFSSL_VERSION_HEX returns the hexadecimal version defined in wolfssl/version.h.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">word32 libV;</div>
<div class="line">libV = <a class="code hl_function" href="#ga19621cde181fbc016432c221169a476c">wolfSSL_lib_version_hex</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(libV != EXPECTED_HEX){</div>
<div class="line">    <span class="comment">// How to handle an unexpected value</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The expected result for libV</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga19621cde181fbc016432c221169a476c"><div class="ttname"><a href="#ga19621cde181fbc016432c221169a476c">wolfSSL_lib_version_hex</a></div><div class="ttdeci">word32 wolfSSL_lib_version_hex(void)</div><div class="ttdoc">This function returns the current library version in hexadecimal notation.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa3b1592df3acdace68187bd21c92554e" title="This function returns the current library version.">wolfSSL_lib_version</a> </dd></dl>

</div>
</div>
<a id="ga1d2b0be768745cb1383ad126e7af2576" name="ga1d2b0be768745cb1383ad126e7af2576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2b0be768745cb1383ad126e7af2576">&#9670;&#160;</a></span>wolfSSL_memrestore_session_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_memrestore_session_cache </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>mem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function restores the persistent session cache from memory. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without an error. </dd>
<dd>
BUFFER_E returned if the memory buffer is too small. </dd>
<dd>
BAD_MUTEX_E returned if the session cache mutex lock failed. </dd>
<dd>
CACHE_MATCH_ERROR returned if the session cache header match failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a constant void pointer containing the source of the restoration. </td></tr>
    <tr><td class="paramname">sz</td><td>an integer representing the size of the memory buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* memoryFile;</div>
<div class="line"><span class="keywordtype">int</span> szMf;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ga1d2b0be768745cb1383ad126e7af2576">wolfSSL_memrestore_session_cache</a>(memoryFile, szMf) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case. SSL_SUCCESS was not returned.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga1d2b0be768745cb1383ad126e7af2576"><div class="ttname"><a href="#ga1d2b0be768745cb1383ad126e7af2576">wolfSSL_memrestore_session_cache</a></div><div class="ttdeci">int wolfSSL_memrestore_session_cache(const void *mem, int sz)</div><div class="ttdoc">This function restores the persistent session cache from memory.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga20fc275712951d213a148883ecdf285e" title="This function persists the session cache to file. It doesn’t use memsave because of additional memory...">wolfSSL_save_session_cache</a> </dd></dl>

</div>
</div>
<a id="ga184b8366465a5cf8d477d2a45e89eaf9" name="ga184b8366465a5cf8d477d2a45e89eaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184b8366465a5cf8d477d2a45e89eaf9">&#9670;&#160;</a></span>wolfSSL_memsave_session_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_memsave_session_cache </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>mem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function persists session cache to memory. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. The session cache has been successfully persisted to memory. </dd>
<dd>
BAD_MUTEX_E returned if there was a mutex lock error. </dd>
<dd>
BUFFER_E returned if the buffer size was too small.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>a void pointer representing the destination for the memory copy, XMEMCPY(). </td></tr>
    <tr><td class="paramname">sz</td><td>an int type representing the size of mem.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* mem;</div>
<div class="line"><span class="keywordtype">int</span> sz; <span class="comment">// Max size of the memory buffer.</span></div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga184b8366465a5cf8d477d2a45e89eaf9">wolfSSL_memsave_session_cache</a>(mem, sz) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case, you did not persist the session cache to memory</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga184b8366465a5cf8d477d2a45e89eaf9"><div class="ttname"><a href="#ga184b8366465a5cf8d477d2a45e89eaf9">wolfSSL_memsave_session_cache</a></div><div class="ttdeci">int wolfSSL_memsave_session_cache(void *mem, int sz)</div><div class="ttdoc">This function persists session cache to memory.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>XMEMCPY </dd>
<dd>
<a class="el" href="#ga788f4e18e0e6ed15480c857e90def619" title="This function returns how large the session cache save buffer should be.">wolfSSL_get_session_cache_memsize</a> </dd></dl>

</div>
</div>
<a id="gaf6780235ee9a7abe3f704a585eb77849" name="gaf6780235ee9a7abe3f704a585eb77849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6780235ee9a7abe3f704a585eb77849">&#9670;&#160;</a></span>wolfSSL_negotiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_negotiate </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the actual connect or accept based on the side of the SSL method. If called from the client side then an <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> is done while a <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> is performed if called from the server side. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS will be returned if successful. (Note, older versions will return 0.) </dd>
<dd>
SSL_FATAL_ERROR will be returned if the underlying call resulted in an error. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = SSL_FATAL_ERROR;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#gaf6780235ee9a7abe3f704a585eb77849">wolfSSL_negotiate</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret == SSL_FATAL_ERROR) {</div>
<div class="line">    <span class="comment">// SSL establishment failed</span></div>
<div class="line"><span class="keywordtype">int</span> error_code = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl);</div>
<div class="line">...</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="agroup__IO_html_gaf6780235ee9a7abe3f704a585eb77849"><div class="ttname"><a href="#gaf6780235ee9a7abe3f704a585eb77849">wolfSSL_negotiate</a></div><div class="ttdeci">int wolfSSL_negotiate(WOLFSSL *ssl)</div><div class="ttdoc">Performs the actual connect or accept based on the side of the SSL method. If called from the client ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>SSL_connect </dd>
<dd>
SSL_accept </dd></dl>

</div>
</div>
<a id="gaf7f748e1605c2d37119105d61a592290" name="gaf7f748e1605c2d37119105d61a592290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7f748e1605c2d37119105d61a592290">&#9670;&#160;</a></span>wolfSSL_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_peek </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data. This function is identical to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that the data in the internal SSL session receive buffer is not removed or modified. If necessary, like <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>, <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> / <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_peek() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will trigger processing of the next record. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes read upon success. </dd>
<dd>
0 will be returned upon failure. This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer where <a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek()</a> will place data read. </td></tr>
    <tr><td class="paramname">sz</td><td>number of bytes to read into data.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> reply[1024];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">input = <a class="code hl_function" href="#gaf7f748e1605c2d37119105d61a592290">wolfSSL_peek</a>(ssl, reply, <span class="keyword">sizeof</span>(reply));</div>
<div class="line"><span class="keywordflow">if</span> (input &gt; 0) {</div>
<div class="line">    <span class="comment">// “input” number of bytes returned into buffer “reply”</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gaf7f748e1605c2d37119105d61a592290"><div class="ttname"><a href="#gaf7f748e1605c2d37119105d61a592290">wolfSSL_peek</a></div><div class="ttdeci">int wolfSSL_peek(WOLFSSL *ssl, void *data, int sz)</div><div class="ttdoc">This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd></dl>

</div>
</div>
<a id="ga423dba3e8ffd23f2a3eb38555368792b" name="ga423dba3e8ffd23f2a3eb38555368792b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423dba3e8ffd23f2a3eb38555368792b">&#9670;&#160;</a></span>wolfSSL_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_pending </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of bytes which are buffered and available in the SSL object to be read by <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>int This function returns the number of bytes pending.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> pending = 0;</div>
<div class="line">WOLFSSL* ssl = 0;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">pending = <a class="code hl_function" href="#ga423dba3e8ffd23f2a3eb38555368792b">wolfSSL_pending</a>(ssl);</div>
<div class="line">printf(“There are %d bytes buffered and available <span class="keywordflow">for</span> reading”, pending);</div>
<div class="ttc" id="agroup__IO_html_ga423dba3e8ffd23f2a3eb38555368792b"><div class="ttname"><a href="#ga423dba3e8ffd23f2a3eb38555368792b">wolfSSL_pending</a></div><div class="ttdeci">int wolfSSL_pending(WOLFSSL *)</div><div class="ttdoc">This function returns the number of bytes which are buffered and available in the SSL object to be re...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv</a> </dd>
<dd>
<a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd>
<dd>
<a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek</a> </dd></dl>

</div>
</div>
<a id="ga0085f8baa71150d0264766e4a2b6c784" name="ga0085f8baa71150d0264766e4a2b6c784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0085f8baa71150d0264766e4a2b6c784">&#9670;&#160;</a></span>wolfSSL_PrintSessionStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_PrintSessionStats </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the statistics from the session. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function and subroutines return without error. The session stats have been successfully retrieved and printed. </dd>
<dd>
BAD_FUNC_ARG returned if the subroutine <a class="el" href="#gaaaf142daad76403f27d7d5d2b6261420" title="This function gets the statistics for the session.">wolfSSL_get_session_stats()</a> was passed an unacceptable argument. </dd>
<dd>
BAD_MUTEX_E returned if there was a mutex error in the subroutine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>No parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="comment">// You will need to have a session object to retrieve stats from.</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga0085f8baa71150d0264766e4a2b6c784">wolfSSL_PrintSessionStats</a>(<span class="keywordtype">void</span>) != SSL_SUCCESS   ){</div>
<div class="line">    <span class="comment">// Did not print session stats</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaaf142daad76403f27d7d5d2b6261420" title="This function gets the statistics for the session.">wolfSSL_get_session_stats</a> </dd></dl>

</div>
</div>
<a id="ga80c3ccd3c0441c77307df3afe88a5c35" name="ga80c3ccd3c0441c77307df3afe88a5c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c3ccd3c0441c77307df3afe88a5c35">&#9670;&#160;</a></span>wolfSSL_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_read </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data. The bytes read are removed from the internal receive buffer. If necessary <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_read() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will trigger processing of the next record. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes read upon success. </dd>
<dd>
0 will be returned upon failure. This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer where <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> will place data read. </td></tr>
    <tr><td class="paramname">sz</td><td>number of bytes to read into data.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> reply[1024];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">input = <a class="code hl_function" href="#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a>(ssl, reply, <span class="keyword">sizeof</span>(reply));</div>
<div class="line"><span class="keywordflow">if</span> (input &gt; 0) {</div>
<div class="line">    <span class="comment">// “input” number of bytes returned into buffer “reply”</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">See wolfSSL examples (client, server, echoclient, echoserver) <span class="keywordflow">for</span> more</div>
<div class="line">complete examples of <a class="code hl_function" href="#ga80c3ccd3c0441c77307df3afe88a5c35">wolfSSL_read</a>().</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv</a> </dd>
<dd>
<a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd>
<dd>
<a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek</a> </dd>
<dd>
<a class="el" href="#ga423dba3e8ffd23f2a3eb38555368792b" title="This function returns the number of bytes which are buffered and available in the SSL object to be re...">wolfSSL_pending</a> </dd></dl>

</div>
</div>
<a id="ga218900890eae44f86614e3c54f0f02ab" name="ga218900890eae44f86614e3c54f0f02ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218900890eae44f86614e3c54f0f02ab">&#9670;&#160;</a></span>wolfSSL_read_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_read_early_data </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads any early data from a client on resumption. Call this function instead of <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a> or <a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13()</a> to accept a client and read any early data in the handshake. The function should be invoked until <a class="el" href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b" title="This function checks to see if the connection is established.">wolfSSL_is_init_finished()</a> returns true. Early data may be sent by the client in multiple messages. If there is no early data then the handshake will be processed as normal. This function is only used with servers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a buffer to hold the early data read from client. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the buffer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSz</td><td>number of bytes of early data read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG if a pointer parameter is NULL, sz is less than 0 or not using TLSv1.3. </dd>
<dd>
SIDE_ERROR if called with a client. </dd>
<dd>
WOLFSSL_FATAL_ERROR if accepting a connection fails. </dd>
<dd>
Number of early data bytes read (may be zero).</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">byte</span> earlyData[128];</div>
<div class="line"><span class="keywordtype">int</span> outSz;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">do {</div>
<div class="line">    ret = <a class="code hl_function" href="#ga218900890eae44f86614e3c54f0f02ab">wolfSSL_read_early_data</a>(ssl, earlyData, <span class="keyword">sizeof</span>(earlyData), &amp;outSz);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">        printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (outSz &gt; 0) {</div>
<div class="line">        <span class="comment">// early data available</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">while</span> (!<a class="code hl_function" href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b">wolfSSL_is_init_finished</a>(ssl));</div>
<div class="ttc" id="agroup__IO_html_ga218900890eae44f86614e3c54f0f02ab"><div class="ttname"><a href="#ga218900890eae44f86614e3c54f0f02ab">wolfSSL_read_early_data</a></div><div class="ttdeci">int wolfSSL_read_early_data(WOLFSSL *ssl, void *data, int sz, int *outSz)</div><div class="ttdoc">This function reads any early data from a client on resumption. Call this function instead of wolfSSL...</div></div>
<div class="ttc" id="agroup__TLS_html_gaa0bd0ae911e350d1e64b0cc9d3c8292b"><div class="ttname"><a href="group__TLS.html#gaa0bd0ae911e350d1e64b0cc9d3c8292b">wolfSSL_is_init_finished</a></div><div class="ttdeci">int wolfSSL_is_init_finished(WOLFSSL *ssl)</div><div class="ttdoc">This function checks to see if the connection is established.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gade058c507ad769c52e508e5ddf7c2a94" title="This function writes early data to the server on resumption. Call this function instead of wolfSSL_co...">wolfSSL_write_early_data</a> </dd>
<dd>
<a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept</a> </dd>
<dd>
<a class="el" href="#ga8344dc66a938e474d2f79bc4947d92cc" title="This function is called on the server side and waits for a SSL/TLS client to initiate the SSL/TLS han...">wolfSSL_accept_TLSv13</a> </dd></dl>

</div>
</div>
<a id="gaa47f91e3700231c0ac95d29663cb46d3" name="gaa47f91e3700231c0ac95d29663cb46d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47f91e3700231c0ac95d29663cb46d3">&#9670;&#160;</a></span>wolfSSL_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_recv </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data using the specified flags for the underlying recv operation. The bytes read are removed from the internal receive buffer. This function is identical to <a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read()</a> except that it allows the application to set the recv flags for the underlying read operation. If necessary <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. Because of this, a call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will only be able to return the maximum buffer size which has been decrypted at the time of calling. There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a>. If sz is larger than the number of bytes in the internal read buffer, SSL_recv() will return the bytes available in the internal read buffer. If no bytes are buffered in the internal read buffer yet, a call to <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will trigger processing of the next record. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes read upon success. </dd>
<dd>
0 will be returned upon failure. This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer where <a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv()</a> will place data read. </td></tr>
    <tr><td class="paramname">sz</td><td>number of bytes to read into data. </td></tr>
    <tr><td class="paramname">flags</td><td>the recv flags to use for the underlying recv operation.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> reply[1024];</div>
<div class="line"><span class="keywordtype">int</span> flags = ... ;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">input = <a class="code hl_function" href="#gaa47f91e3700231c0ac95d29663cb46d3">wolfSSL_recv</a>(ssl, reply, <span class="keyword">sizeof</span>(reply), flags);</div>
<div class="line"><span class="keywordflow">if</span> (input &gt; 0) {</div>
<div class="line">    <span class="comment">// “input” number of bytes returned into buffer “reply”</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gaa47f91e3700231c0ac95d29663cb46d3"><div class="ttname"><a href="#gaa47f91e3700231c0ac95d29663cb46d3">wolfSSL_recv</a></div><div class="ttdeci">int wolfSSL_recv(WOLFSSL *ssl, void *data, int sz, int flags)</div><div class="ttdoc">This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd>
<dd>
<a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd>
<dd>
<a class="el" href="#gaf7f748e1605c2d37119105d61a592290" title="This function copies sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_peek</a> </dd>
<dd>
<a class="el" href="#ga423dba3e8ffd23f2a3eb38555368792b" title="This function returns the number of bytes which are buffered and available in the SSL object to be re...">wolfSSL_pending</a> </dd></dl>

</div>
</div>
<a id="ga7ba02472014a68d0717ca9243d9dd646" name="ga7ba02472014a68d0717ca9243d9dd646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba02472014a68d0717ca9243d9dd646">&#9670;&#160;</a></span>wolfSSL_Rehandshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_Rehandshake </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function executes a secure renegotiation handshake; this is user forced as wolfSSL discourages this functionality. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure was NULL or otherwise if an unacceptable argument was passed in a subroutine. </dd>
<dd>
SECURE_RENEGOTIATION_E returned if there was an error with renegotiating the handshake. </dd>
<dd>
SSL_FATAL_ERROR returned if there was an error with the server or client configuration and the renegotiation could not be completed. See <a class="el" href="#gaf6780235ee9a7abe3f704a585eb77849" title="Performs the actual connect or accept based on the side of the SSL method. If called from the client ...">wolfSSL_negotiate()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ga7ba02472014a68d0717ca9243d9dd646">wolfSSL_Rehandshake</a>(ssl) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// There was an error and the rehandshake is not successful.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga7ba02472014a68d0717ca9243d9dd646"><div class="ttname"><a href="#ga7ba02472014a68d0717ca9243d9dd646">wolfSSL_Rehandshake</a></div><div class="ttdeci">int wolfSSL_Rehandshake(WOLFSSL *ssl)</div><div class="ttdoc">This function executes a secure renegotiation handshake; this is user forced as wolfSSL discourages t...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf6780235ee9a7abe3f704a585eb77849" title="Performs the actual connect or accept based on the side of the SSL method. If called from the client ...">wolfSSL_negotiate</a> </dd>
<dd>
<a class="el" href="group__SHA.html#ga7743789b491a860b2c7c745f8f759f55" title="This function initializes SHA512. This is automatically called by wc_Sha512Hash.">wc_InitSha512</a> </dd>
<dd>
<a class="el" href="group__SHA.html#ga0cab272b70b7d520382281e73f033d53" title="This function initializes SHA384. This is automatically called by wc_Sha384Hash.">wc_InitSha384</a> </dd>
<dd>
<a class="el" href="group__SHA.html#ga9bfb6a099a810c3b1e2137bf113fd7fe" title="This function initializes SHA256. This is automatically called by wc_Sha256Hash.">wc_InitSha256</a> </dd>
<dd>
<a class="el" href="group__SHA.html#ga4fb84a31d74cf14094b59bbd78f7cf89" title="This function initializes SHA. This is automatically called by wc_ShaHash.">wc_InitSha</a> </dd>
<dd>
<a class="el" href="group__MD5.html#gab7c2a1abde9ab76e8d2123b89deabcc4" title="This function initializes md5. This is automatically called by wc_Md5Hash.">wc_InitMd5</a> </dd></dl>

</div>
</div>
<a id="ga5bdfe1a09ee4d55d3e73f0bfec790d13" name="ga5bdfe1a09ee4d55d3e73f0bfec790d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bdfe1a09ee4d55d3e73f0bfec790d13">&#9670;&#160;</a></span>wolfSSL_request_certificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_request_certificate </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requests a client certificate from the TLS v1.3 client. This is useful when a web server is serving some pages that require client authentication and others that don't. A maximum of 256 requests can be sent on a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG if ssl is NULL or not using TLS v1.3. </dd>
<dd>
WANT_WRITE if the writing is not ready. </dd>
<dd>
SIDE_ERROR if called with a client. </dd>
<dd>
NOT_READY_ERROR if called when the handshake is not finished. </dd>
<dd>
POST_HAND_AUTH_ERROR if posthandshake authentication is disallowed. </dd>
<dd>
MEMORY_E if dynamic memory allocation fails. </dd>
<dd>
WOLFSSL_SUCCESS if successful.</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga5bdfe1a09ee4d55d3e73f0bfec790d13">wolfSSL_request_certificate</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret == WANT_WRITE) {</div>
<div class="line">    <span class="comment">// need to call again when I/O ready</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to request a client certificate</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga5bdfe1a09ee4d55d3e73f0bfec790d13"><div class="ttname"><a href="#ga5bdfe1a09ee4d55d3e73f0bfec790d13">wolfSSL_request_certificate</a></div><div class="ttdeci">int wolfSSL_request_certificate(WOLFSSL *ssl)</div><div class="ttdoc">This function requests a client certificate from the TLS v1.3 client. This is useful when a web serve...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Setup.html#ga84f52f3a3dc072414e05d725cc4e0654" title="This function is called on a TLS v1.3 client wolfSSL to allow a client certificate to be sent post ha...">wolfSSL_allow_post_handshake_auth</a> </dd>
<dd>
<a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd></dl>

</div>
</div>
<a id="ga12e7e6b57f8b1edb62a37e2ea63eb056" name="ga12e7e6b57f8b1edb62a37e2ea63eb056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e7e6b57f8b1edb62a37e2ea63eb056">&#9670;&#160;</a></span>wolfSSL_restore_session_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_restore_session_cache </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function restores the persistent session cache from file. It does not use memstore because of additional memory use. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. </dd>
<dd>
SSL_BAD_FILE returned if the file passed into the function was corrupted and could not be opened by XFOPEN. </dd>
<dd>
FREAD_ERROR returned if the file had a read error from XFREAD. </dd>
<dd>
CACHE_MATCH_ERROR returned if the session cache header match failed. </dd>
<dd>
BAD_MUTEX_E returned if there was a mutex lock failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>a constant char pointer file input that will be read.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *fname;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ga12e7e6b57f8b1edb62a37e2ea63eb056">wolfSSL_restore_session_cache</a>(fname) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Failure case. The function did not return SSL_SUCCESS.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga12e7e6b57f8b1edb62a37e2ea63eb056"><div class="ttname"><a href="#ga12e7e6b57f8b1edb62a37e2ea63eb056">wolfSSL_restore_session_cache</a></div><div class="ttdeci">int wolfSSL_restore_session_cache(const char *fname)</div><div class="ttdoc">This function restores the persistent session cache from file. It does not use memstore because of ad...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>XFREAD </dd>
<dd>
XFOPEN </dd></dl>

</div>
</div>
<a id="ga20fc275712951d213a148883ecdf285e" name="ga20fc275712951d213a148883ecdf285e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20fc275712951d213a148883ecdf285e">&#9670;&#160;</a></span>wolfSSL_save_session_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_save_session_cache </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function persists the session cache to file. It doesn’t use memsave because of additional memory use. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if the function executed without error. The session cache has been written to a file. </dd>
<dd>
SSL_BAD_FILE returned if fname cannot be opened or is otherwise corrupt. </dd>
<dd>
FWRITE_ERROR returned if XFWRITE failed to write to the file. </dd>
<dd>
BAD_MUTEX_E returned if there was a mutex lock failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>is a constant char pointer that points to a file for writing.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fname;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#ga20fc275712951d213a148883ecdf285e">wolfSSL_save_session_cache</a>(fname) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// Fail to write to file.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga20fc275712951d213a148883ecdf285e"><div class="ttname"><a href="#ga20fc275712951d213a148883ecdf285e">wolfSSL_save_session_cache</a></div><div class="ttdeci">int wolfSSL_save_session_cache(const char *fname)</div><div class="ttdoc">This function persists the session cache to file. It doesn’t use memsave because of additional memory...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>XFWRITE </dd>
<dd>
<a class="el" href="#ga12e7e6b57f8b1edb62a37e2ea63eb056" title="This function restores the persistent session cache from file. It does not use memstore because of ad...">wolfSSL_restore_session_cache</a> </dd>
<dd>
<a class="el" href="#ga1d2b0be768745cb1383ad126e7af2576" title="This function restores the persistent session cache from memory.">wolfSSL_memrestore_session_cache</a> </dd></dl>

</div>
</div>
<a id="ga1eea65c61599bf523a87f1d8f82a4cef" name="ga1eea65c61599bf523a87f1d8f82a4cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eea65c61599bf523a87f1d8f82a4cef">&#9670;&#160;</a></span>wolfSSL_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_send </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified flags for the underlying write operation. If necessary <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will return when the underlying I/O could not satisfy the needs of wolfSSL_send to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> will only return once the buffer data of size sz has been completely written or an error occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes written upon success. </dd>
<dd>
0 will be returned upon failure. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">data</td><td>data buffer to send to peer. </td></tr>
    <tr><td class="paramname">sz</td><td>size, in bytes, of data to be sent to peer. </td></tr>
    <tr><td class="paramname">flags</td><td>the send flags to use for the underlying send operation.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> msg[64] = “hello wolfssl!”;</div>
<div class="line"><span class="keywordtype">int</span> msgSz = (int)strlen(msg);</div>
<div class="line"><span class="keywordtype">int</span> flags = ... ;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">input = <a class="code hl_function" href="#ga1eea65c61599bf523a87f1d8f82a4cef">wolfSSL_send</a>(ssl, msg, msgSz, flags);</div>
<div class="line"><span class="keywordflow">if</span> (input != msgSz) {</div>
<div class="line">    <span class="comment">// wolfSSL_send() failed</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga1eea65c61599bf523a87f1d8f82a4cef"><div class="ttname"><a href="#ga1eea65c61599bf523a87f1d8f82a4cef">wolfSSL_send</a></div><div class="ttdeci">int wolfSSL_send(WOLFSSL *ssl, const void *data, int sz, int flags)</div><div class="ttdoc">This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd>
<dd>
<a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd>
<dd>
<a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv</a> </dd></dl>

</div>
</div>
<a id="ga0115589990495d8f79c18bda0363d84c" name="ga0115589990495d8f79c18bda0363d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0115589990495d8f79c18bda0363d84c">&#9670;&#160;</a></span>wolfSSL_SESSION_get_peer_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOLFSSL_X509_CHAIN * wolfSSL_SESSION_get_peer_chain </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL_SESSION *</td>          <td class="paramname"><span class="paramname"><em>session</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the peer certificate chain from the WOLFSSL_SESSION struct. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer A pointer to a WOLFSSL_X509_CHAIN structure that contains the peer certification chain.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a pointer to a WOLFSSL_SESSION structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_SESSION* session;</div>
<div class="line">WOLFSSL_X509_CHAIN* chain;</div>
<div class="line">...</div>
<div class="line">chain = <a class="code hl_function" href="#ga0115589990495d8f79c18bda0363d84c">wolfSSL_SESSION_get_peer_chain</a>(session);</div>
<div class="line"><span class="keywordflow">if</span>(!chain){</div>
<div class="line">    <span class="comment">// There was no chain. Failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga0115589990495d8f79c18bda0363d84c"><div class="ttname"><a href="#ga0115589990495d8f79c18bda0363d84c">wolfSSL_SESSION_get_peer_chain</a></div><div class="ttdeci">WOLFSSL_X509_CHAIN * wolfSSL_SESSION_get_peer_chain(WOLFSSL_SESSION *session)</div><div class="ttdoc">Returns the peer certificate chain from the WOLFSSL_SESSION struct.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab4a7dcdbfd357dced461795383b04bf2" title="This function gets the session at specified index of the session cache and copies it into memory....">wolfSSL_GetSessionAtIndex</a> </dd>
<dd>
<a class="el" href="#ga54930dd8cf9ac220eb44ad274d341795" title="This function gets the session index of the WOLFSSL structure.">wolfSSL_GetSessionIndex</a> </dd>
<dd>
AddSession </dd></dl>

</div>
</div>
<a id="gaa432304c3c7019ccbe6d98ee89d0c839" name="gaa432304c3c7019ccbe6d98ee89d0c839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa432304c3c7019ccbe6d98ee89d0c839">&#9670;&#160;</a></span>wolfSSL_session_reused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_session_reused </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the resuming member of the options struct. The flag indicates whether or not to reuse a session. If not, a new session must be established. </p>
<dl class="section return"><dt>Returns</dt><dd>This function returns an int type held in the Options structure representing the flag for session reuse.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(!<a class="code hl_function" href="#gaa432304c3c7019ccbe6d98ee89d0c839">wolfSSL_session_reused</a>(sslResume)){</div>
<div class="line">    <span class="comment">// No session reuse allowed.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gaa432304c3c7019ccbe6d98ee89d0c839"><div class="ttname"><a href="#gaa432304c3c7019ccbe6d98ee89d0c839">wolfSSL_session_reused</a></div><div class="ttdeci">int wolfSSL_session_reused(WOLFSSL *ssl)</div><div class="ttdoc">This function returns the resuming member of the options struct. The flag indicates whether or not to...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wolfSSL_SESSION_free </dd>
<dd>
<a class="el" href="#ga54930dd8cf9ac220eb44ad274d341795" title="This function gets the session index of the WOLFSSL structure.">wolfSSL_GetSessionIndex</a> </dd>
<dd>
<a class="el" href="#ga184b8366465a5cf8d477d2a45e89eaf9" title="This function persists session cache to memory.">wolfSSL_memsave_session_cache</a> </dd></dl>

</div>
</div>
<a id="gadea64abddfb32623d439ced576afb498" name="gadea64abddfb32623d439ced576afb498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea64abddfb32623d439ced576afb498">&#9670;&#160;</a></span>wolfSSL_set_jobject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_jobject </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>objPtr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the jObjectRef member of the WOLFSSL structure. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned if jObjectRef is properly set to objPtr. </dd>
<dd>
SSL_FAILURE returned if the function did not properly execute and jObjectRef is not set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">objPtr</td><td>a void pointer that will be set to jObjectRef.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = WOLFSSL_new();</div>
<div class="line"><span class="keywordtype">void</span>* objPtr = &amp;obj;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="#gadea64abddfb32623d439ced576afb498">wolfSSL_set_jobject</a>(ssl, objPtr)){</div>
<div class="line">    <span class="comment">// The success case</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gadea64abddfb32623d439ced576afb498"><div class="ttname"><a href="#gadea64abddfb32623d439ced576afb498">wolfSSL_set_jobject</a></div><div class="ttdeci">int wolfSSL_set_jobject(WOLFSSL *ssl, void *objPtr)</div><div class="ttdoc">This function sets the jObjectRef member of the WOLFSSL structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga89aed85f25618a8a012ae855d07e2023" title="This function returns the jObjectRef member of the WOLFSSL structure.">wolfSSL_get_jobject</a> </dd></dl>

</div>
</div>
<a id="ga49f87f9acd032dbbd43fa43113aa331c" name="ga49f87f9acd032dbbd43fa43113aa331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f87f9acd032dbbd43fa43113aa331c">&#9670;&#160;</a></span>wolfSSL_set_SessionTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_set_SessionTicket </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>bufSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the ticket member of the WOLFSSL_SESSION structure within the WOLFSSL struct. The buffer passed into the function is copied to memory. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS returned on successful execution of the function. The function returned without errors. </dd>
<dd>
BAD_FUNC_ARG returned if the WOLFSSL structure is NULL. This will also be thrown if the buf argument is NULL but the bufSz argument is not zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>a byte pointer that gets loaded into the ticket member of the session structure. </td></tr>
    <tr><td class="paramname">bufSz</td><td>a word32 type that represents the size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"><span class="keywordtype">byte</span>* buffer; <span class="comment">// File to load</span></div>
<div class="line">word32 bufSz;</div>
<div class="line">...</div>
<div class="line">if(<a class="code hl_function" href="group__CertsKeys.html#gad17318a1c890b18829a9a1e204dd6f04">wolfSSL_KeepArrays</a>(ssl, buffer, bufSz) != SSL_SUCCESS){</div>
<div class="line">    <span class="comment">// There was an error loading the buffer to memory.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="ssl_8h.html#a30b45a56db4091b9d9aec551ba659786" title="This function sets the session ticket callback. The type CallbackSessionTicket is a function pointer ...">wolfSSL_set_SessionTicket_cb</a> </dd></dl>

</div>
</div>
<a id="gaa877d2207c64ec05a6c7f5270f494fdd" name="gaa877d2207c64ec05a6c7f5270f494fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa877d2207c64ec05a6c7f5270f494fdd">&#9670;&#160;</a></span>wolfSSL_SetIO_NetX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wolfSSL_SetIO_NetX </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NX_TCP_SOCKET *</td>          <td class="paramname"><span class="paramname"><em>nxsocket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG</td>          <td class="paramname"><span class="paramname"><em>waitoption</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the nxSocket and nxWait members of the nxCtx struct within the WOLFSSL structure. </p>
<dl class="section return"><dt>Returns</dt><dd>none No returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">nxSocket</td><td>a pointer to type NX_TCP_SOCKET that is set to the nxSocket member of the nxCTX structure. </td></tr>
    <tr><td class="paramname">waitOption</td><td>a ULONG type that is set to the nxWait member of the nxCtx structure.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">NX_TCP_SOCKET* nxSocket;</div>
<div class="line">ULONG waitOption;</div>
<div class="line">…</div>
<div class="line"><span class="keywordflow">if</span>(ssl != NULL || nxSocket != NULL || waitOption &lt;= 0){</div>
<div class="line"><a class="code hl_function" href="#gaa877d2207c64ec05a6c7f5270f494fdd">wolfSSL_SetIO_NetX</a>(ssl, nxSocket, waitOption);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// You need to pass in good parameters.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gaa877d2207c64ec05a6c7f5270f494fdd"><div class="ttname"><a href="#gaa877d2207c64ec05a6c7f5270f494fdd">wolfSSL_SetIO_NetX</a></div><div class="ttdeci">void wolfSSL_SetIO_NetX(WOLFSSL *ssl, NX_TCP_SOCKET *nxsocket, ULONG waitoption)</div><div class="ttdoc">This function sets the nxSocket and nxWait members of the nxCtx struct within the WOLFSSL structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>set_fd </dd>
<dd>
NetX_Send </dd>
<dd>
NetX_Receive </dd></dl>

</div>
</div>
<a id="ga4455005c48c3bb24584984ea11dd54a0" name="ga4455005c48c3bb24584984ea11dd54a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4455005c48c3bb24584984ea11dd54a0">&#9670;&#160;</a></span>wolfSSL_SNI_Status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char wolfSSL_SNI_Status </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of an SNI object. </p>
<dl class="section return"><dt>Returns</dt><dd>value This function returns the byte value of the SNI struct’s status member if the SNI is not NULL. </dd>
<dd>
0 if the SNI object is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">type</td><td>the SNI type.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL_CTX* ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>( protocol method );</div>
<div class="line">WOLFSSL* ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line">…</div>
<div class="line"><span class="preprocessor">#define AssertIntEQ(x, y) AssertInt(x, y, ==, !=)</span></div>
<div class="line">…</div>
<div class="line">Byte type = WOLFSSL_SNI_HOST_NAME;</div>
<div class="line"><span class="keywordtype">char</span>* request = (<span class="keywordtype">char</span>*)&amp;type;</div>
<div class="line">AssertIntEQ(WOLFSSL_SNI_NO_MATCH, <a class="code hl_function" href="#ga4455005c48c3bb24584984ea11dd54a0">wolfSSL_SNI_Status</a>(ssl, type));</div>
<div class="line">…</div>
<div class="ttc" id="agroup__IO_html_ga4455005c48c3bb24584984ea11dd54a0"><div class="ttname"><a href="#ga4455005c48c3bb24584984ea11dd54a0">wolfSSL_SNI_Status</a></div><div class="ttdeci">unsigned char wolfSSL_SNI_Status(WOLFSSL *ssl, unsigned char type)</div><div class="ttdoc">This function gets the status of an SNI object.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_SNI_Status </dd>
<dd>
TLSX_SNI_find </dd>
<dd>
TLSX_Find </dd></dl>

</div>
</div>
<a id="ga38ef7eb0a15b65f3b68d2490dd0535a0" name="ga38ef7eb0a15b65f3b68d2490dd0535a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ef7eb0a15b65f3b68d2490dd0535a0">&#9670;&#160;</a></span>wolfSSL_update_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_update_keys </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys. A KeyUpdate message is sent to the peer and new keys are calculated for encryption. The peer will send back a KeyUpdate message and the new decryption keys will then be calculated. This function can only be called after a handshake has been completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG if ssl is NULL or not using TLS v1.3. </dd>
<dd>
WANT_WRITE if the writing is not ready. </dd>
<dd>
WOLFSSL_SUCCESS if successful.</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga38ef7eb0a15b65f3b68d2490dd0535a0">wolfSSL_update_keys</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret == WANT_WRITE) {</div>
<div class="line">    <span class="comment">// need to call again when I/O ready</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    <span class="comment">// failed to send key update</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga38ef7eb0a15b65f3b68d2490dd0535a0"><div class="ttname"><a href="#ga38ef7eb0a15b65f3b68d2490dd0535a0">wolfSSL_update_keys</a></div><div class="ttdeci">int wolfSSL_update_keys(WOLFSSL *ssl)</div><div class="ttdoc">This function is called on a TLS v1.3 client or server wolfSSL to force the rollover of keys....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd></dl>

</div>
</div>
<a id="ga8b482a054414e3411c8d4f45f3683f3c" name="ga8b482a054414e3411c8d4f45f3683f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b482a054414e3411c8d4f45f3683f3c">&#9670;&#160;</a></span>wolfSSL_UseSecureRenegotiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseSecureRenegotiation </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function forces secure renegotiation for the supplied WOLFSSL structure. This is not recommended. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS Successfully set secure renegotiation. </dd>
<dd>
BAD_FUNC_ARG Returns error if ssl is null. </dd>
<dd>
MEMORY_E Returns error if unable to allocate memory for secure renegotiation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a>();</div>
<div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">WOLFSSL_METHOD method = <span class="comment">// Some wolfSSL method</span></div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga8b482a054414e3411c8d4f45f3683f3c">wolfSSL_UseSecureRenegotiation</a>(ssl) != SSL_SUCCESS)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error setting secure renegotiation</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_ga8b482a054414e3411c8d4f45f3683f3c"><div class="ttname"><a href="#ga8b482a054414e3411c8d4f45f3683f3c">wolfSSL_UseSecureRenegotiation</a></div><div class="ttdeci">int wolfSSL_UseSecureRenegotiation(WOLFSSL *ssl)</div><div class="ttdoc">This function forces secure renegotiation for the supplied WOLFSSL structure. This is not recommended...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_Find </dd>
<dd>
TLSX_UseSecureRenegotiation </dd></dl>

</div>
</div>
<a id="gae22e32f06e5b1f22116c794b3dc28577" name="gae22e32f06e5b1f22116c794b3dc28577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae22e32f06e5b1f22116c794b3dc28577">&#9670;&#160;</a></span>wolfSSL_UseSessionTicket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_UseSessionTicket </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force provided WOLFSSL structure to use session ticket. The constant HAVE_SESSION_TICKET should be defined and the constant NO_WOLFSSL_CLIENT should not be defined to use this function. </p>
<dl class="section return"><dt>Returns</dt><dd>SSL_SUCCESS Successfully set use session ticket. </dd>
<dd>
BAD_FUNC_ARG Returned if ssl is null. </dd>
<dd>
MEMORY_E Error allocating memory for setting session ticket.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__TLS.html#ga789ef74e34df659a62f06da2ea709737">wolfSSL_Init</a>();</div>
<div class="line">WOLFSSL_CTX* ctx;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line">WOLFSSL_METHOD method = <span class="comment">// Some wolfSSL method</span></div>
<div class="line">ctx = <a class="code hl_function" href="group__Setup.html#ga2bcaa81e9fd11074c6e504891370dd45">wolfSSL_CTX_new</a>(method);</div>
<div class="line">ssl = <a class="code hl_function" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0">wolfSSL_new</a>(ctx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gae22e32f06e5b1f22116c794b3dc28577">wolfSSL_UseSessionTicket</a>(ssl) != SSL_SUCCESS)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error setting session ticket</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gae22e32f06e5b1f22116c794b3dc28577"><div class="ttname"><a href="#gae22e32f06e5b1f22116c794b3dc28577">wolfSSL_UseSessionTicket</a></div><div class="ttdeci">int wolfSSL_UseSessionTicket(WOLFSSL *ssl)</div><div class="ttdoc">Force provided WOLFSSL structure to use session ticket. The constant HAVE_SESSION_TICKET should be de...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>TLSX_UseSessionTicket </dd></dl>

</div>
</div>
<a id="gad6cbb3cb90e4d606e9507e4ec06197df" name="gad6cbb3cb90e4d606e9507e4ec06197df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6cbb3cb90e4d606e9507e4ec06197df">&#9670;&#160;</a></span>wolfSSL_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_write </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will negotiate an SSL/TLS session if the handshake has not already been performed yet by <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#gaf0cfc676947d7eabd67ec1a4661ed625" title="This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handsh...">wolfSSL_accept()</a>. When using (D)TLSv1.3 and early data feature is compiled in, this function progresses the handshake only up to the point when it is possible to send data. Next invocations of wolfSSL_Connect()/wolfSSL_Accept()/wolfSSL_read() will complete the handshake. <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> works with both blocking and non-blocking I/O. When the underlying I/O is non-blocking, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will return when the underlying I/O could not satisfy the needs of <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> to continue. In this case, a call to <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> will yield either SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE. The calling process must then repeat the call to <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> when the underlying I/O is ready. If the underlying I/O is blocking, <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> will only return once the buffer data of size sz has been completely written or an error occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes written upon success. </dd>
<dd>
0 will be returned upon failure. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">data</td><td>data buffer which will be sent to peer. </td></tr>
    <tr><td class="paramname">sz</td><td>size, in bytes, of data to send to the peer (data).</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> msg[64] = “hello wolfssl!”;</div>
<div class="line"><span class="keywordtype">int</span> msgSz = (int)strlen(msg);</div>
<div class="line"><span class="keywordtype">int</span> flags;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a>(ssl, msg, msgSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt;= 0) {</div>
<div class="line">    <span class="comment">// wolfSSL_write() failed, call wolfSSL_get_error()</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gad6cbb3cb90e4d606e9507e4ec06197df"><div class="ttname"><a href="#gad6cbb3cb90e4d606e9507e4ec06197df">wolfSSL_write</a></div><div class="ttdeci">int wolfSSL_write(WOLFSSL *ssl, const void *data, int sz)</div><div class="ttdoc">This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1eea65c61599bf523a87f1d8f82a4cef" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl, using the specified ...">wolfSSL_send</a> </dd>
<dd>
<a class="el" href="#ga80c3ccd3c0441c77307df3afe88a5c35" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data....">wolfSSL_read</a> </dd>
<dd>
<a class="el" href="#gaa47f91e3700231c0ac95d29663cb46d3" title="This function reads sz bytes from the SSL session (ssl) internal read buffer into the buffer data usi...">wolfSSL_recv</a> </dd></dl>

</div>
</div>
<a id="gade058c507ad769c52e508e5ddf7c2a94" name="gade058c507ad769c52e508e5ddf7c2a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade058c507ad769c52e508e5ddf7c2a94">&#9670;&#160;</a></span>wolfSSL_write_early_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_write_early_data </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes early data to the server on resumption. Call this function instead of <a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect()</a> or <a class="el" href="#ga2c85ff2299e5cb41d809dfdce9115d38" title="This function is called on the client side and initiates a TLS v1.3 handshake with a server....">wolfSSL_connect_TLSv13()</a> to connect to the server and send the data in the handshake. This function is only used with clients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ssl</td><td>a pointer to a WOLFSSL structure, created using <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the buffer holding the early data to write to server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>the amount of early data to write in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSz</td><td>the amount of early data written in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BAD_FUNC_ARG if a pointer parameter is NULL, sz is less than 0 or not using TLSv1.3. </dd>
<dd>
SIDE_ERROR if called with a server. </dd>
<dd>
WOLFSSL_FATAL_ERROR if the connection is not made. </dd>
<dd>
WOLFSSL_SUCCESS if successful.</dd></dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">int</span> err = 0;</div>
<div class="line">WOLFSSL* ssl;</div>
<div class="line"><span class="keywordtype">byte</span> earlyData[] = { early data };</div>
<div class="line"><span class="keywordtype">int</span> outSz;</div>
<div class="line"><span class="keywordtype">char</span> buffer[80];</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gade058c507ad769c52e508e5ddf7c2a94">wolfSSL_write_early_data</a>(ssl, earlyData, <span class="keyword">sizeof</span>(earlyData), &amp;outSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != WOLFSSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">    <span class="keywordflow">goto</span> err_label;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (outSz &lt; <span class="keyword">sizeof</span>(earlyData)) {</div>
<div class="line">    <span class="comment">// not all early data was sent</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#ga2c85ff2299e5cb41d809dfdce9115d38">wolfSSL_connect_TLSv13</a>(ssl);</div>
<div class="line"><span class="keywordflow">if</span> (ret != SSL_SUCCESS) {</div>
<div class="line">    err = <a class="code hl_function" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591">wolfSSL_get_error</a>(ssl, ret);</div>
<div class="line">    printf(“error = %d, %s\n”, err, <a class="code hl_function" href="group__Debug.html#ga1bf9410113a0a1808c2c970b5a972610">wolfSSL_ERR_error_string</a>(err, buffer));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__IO_html_gade058c507ad769c52e508e5ddf7c2a94"><div class="ttname"><a href="#gade058c507ad769c52e508e5ddf7c2a94">wolfSSL_write_early_data</a></div><div class="ttdeci">int wolfSSL_write_early_data(WOLFSSL *ssl, const void *data, int sz, int *outSz)</div><div class="ttdoc">This function writes early data to the server on resumption. Call this function instead of wolfSSL_co...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga218900890eae44f86614e3c54f0f02ab" title="This function reads any early data from a client on resumption. Call this function instead of wolfSSL...">wolfSSL_read_early_data</a> </dd>
<dd>
<a class="el" href="#ga5b8f41cca120758d1860c7bc959755dd" title="This function is called on the client side and initiates an SSL/TLS handshake with a server....">wolfSSL_connect</a> </dd>
<dd>
<a class="el" href="#ga2c85ff2299e5cb41d809dfdce9115d38" title="This function is called on the client side and initiates a TLS v1.3 handshake with a server....">wolfSSL_connect_TLSv13</a> </dd></dl>

</div>
</div>
<a id="ga0a34c427432d689f5d99f134b2865b90" name="ga0a34c427432d689f5d99f134b2865b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a34c427432d689f5d99f134b2865b90">&#9670;&#160;</a></span>wolfSSL_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wolfSSL_writev </td>
          <td>(</td>
          <td class="paramtype">WOLFSSL *</td>          <td class="paramname"><span class="paramname"><em>ssl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates writev semantics but doesn’t actually do block at a time because of SSL_write() behavior and because front adds may be small. Makes porting into software that uses writev easier. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 the number of bytes written upon success. </dd>
<dd>
0 will be returned upon failure. Call <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> for the specific error code. </dd>
<dd>
MEMORY_ERROR will be returned if a memory error was encountered. </dd>
<dd>
SSL_FATAL_ERROR will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call <a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write()</a> again. Use <a class="el" href="group__Debug.html#gaafd5671d443fa684913ba5955a4eb591" title="This function returns a unique error code describing why the previous API function call (wolfSSL_conn...">wolfSSL_get_error()</a> to get a specific error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>pointer to the SSL session, created with <a class="el" href="group__Setup.html#gab6d54b7485d74962e57bc636008aa9a0" title="This function creates a new SSL session, taking an already created SSL context as input.">wolfSSL_new()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>array of I/O vectors to write </td></tr>
    <tr><td class="paramname">iovcnt</td><td>number of vectors in iov array.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WOLFSSL* ssl = 0;</div>
<div class="line"><span class="keywordtype">char</span> *bufA = “hello\n”;</div>
<div class="line"><span class="keywordtype">char</span> *bufB = “hello world\n”;</div>
<div class="line"><span class="keywordtype">int</span> iovcnt;</div>
<div class="line"><span class="keyword">struct </span>iovec iov[2];</div>
<div class="line"> </div>
<div class="line">iov[0].iov_base = buffA;</div>
<div class="line">iov[0].iov_len = strlen(buffA);</div>
<div class="line">iov[1].iov_base = buffB;</div>
<div class="line">iov[1].iov_len = strlen(buffB);</div>
<div class="line">iovcnt = 2;</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga0a34c427432d689f5d99f134b2865b90">wolfSSL_writev</a>(ssl, iov, iovcnt);</div>
<div class="line"><span class="comment">// wrote “ret” bytes, or error if &lt;= 0.</span></div>
<div class="ttc" id="agroup__IO_html_ga0a34c427432d689f5d99f134b2865b90"><div class="ttname"><a href="#ga0a34c427432d689f5d99f134b2865b90">wolfSSL_writev</a></div><div class="ttdeci">int wolfSSL_writev(WOLFSSL *ssl, const struct iovec *iov, int iovcnt)</div><div class="ttdoc">Simulates writev semantics but doesn’t actually do block at a time because of SSL_write() behavior an...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad6cbb3cb90e4d606e9507e4ec06197df" title="This function writes sz bytes from the buffer, data, to the SSL connection, ssl. If necessary,...">wolfSSL_write</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
