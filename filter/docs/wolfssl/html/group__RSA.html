<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: Algorithms - RSA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Algorithms - RSA </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab7adfab8cbc5cb3c7b2069bee6a975a3" id="r_gab7adfab8cbc5cb3c7b2069bee6a975a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7adfab8cbc5cb3c7b2069bee6a975a3">wc_SetKeyUsage</a> (Cert *cert, const char *value)</td></tr>
<tr class="memdesc:gab7adfab8cbc5cb3c7b2069bee6a975a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows you to set the key usage using a comma delimited string of tokens. Accepted tokens are: digitalSignature, nonRepudiation, contentCommitment, keyCertSign, cRLSign, dataEncipherment, keyAgreement, keyEncipherment, encipherOnly, decipherOnly. Example: "digitalSignature,nonRepudiation" nonRepudiation and contentCommitment are for the same usage.  <br /></td></tr>
<tr class="memitem:ga02c9b34d405c5f1c24956ee84a843ef6" id="r_ga02c9b34d405c5f1c24956ee84a843ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a> (RsaKey *key, void *heap)</td></tr>
<tr class="memdesc:ga02c9b34d405c5f1c24956ee84a843ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC).  <br /></td></tr>
<tr class="memitem:gaba7b6eef17f80e711309f53f2c17dfc6" id="r_gaba7b6eef17f80e711309f53f2c17dfc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba7b6eef17f80e711309f53f2c17dfc6">wc_InitRsaKey_Id</a> (RsaKey *key, unsigned char *id, int len, void *heap, int devId)</td></tr>
<tr class="memdesc:gaba7b6eef17f80e711309f53f2c17dfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a provided RsaKey struct. The id and len are used to identify the key on the device while the devId identifies the device. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC).  <br /></td></tr>
<tr class="memitem:gade0e7ccd93ec8c9e5ba5ded3e11b1226" id="r_gade0e7ccd93ec8c9e5ba5ded3e11b1226"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a> (RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:gade0e7ccd93ec8c9e5ba5ded3e11b1226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga0e5ef34d84c264a1affa8d3a6478b4ce" id="r_ga0e5ef34d84c264a1affa8d3a6478b4ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a> (RsaKey *key)</td></tr>
<tr class="memdesc:ga0e5ef34d84c264a1affa8d3a6478b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees a provided RsaKey struct using mp_clear.  <br /></td></tr>
<tr class="memitem:gae935cf0597a24a636b730a4c290b442c" id="r_gae935cf0597a24a636b730a4c290b442c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae935cf0597a24a636b730a4c290b442c">wc_RsaDirect</a> (byte *in, word32 inLen, byte *out, word32 *outSz, RsaKey *key, int type, WC_RNG *rng)</td></tr>
<tr class="memdesc:gae935cf0597a24a636b730a4c290b442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that does the RSA operation directly with no padding. The input size must match key size. Typically this is used when padding is already done on the RSA input.  <br /></td></tr>
<tr class="memitem:ga72130d1043824f7e8a5df91fc6832539" id="r_ga72130d1043824f7e8a5df91fc6832539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga72130d1043824f7e8a5df91fc6832539">wc_RsaPublicEncrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga72130d1043824f7e8a5df91fc6832539"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts a message from in and stores the result in out. It requires an initialized public key and a random number generator. As a side effect, this function will return the bytes written to out in outLen.  <br /></td></tr>
<tr class="memitem:ga27ae50a0bc76cb4eea37fdbb565ae2a6" id="r_ga27ae50a0bc76cb4eea37fdbb565ae2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga27ae50a0bc76cb4eea37fdbb565ae2a6">wc_RsaPrivateDecryptInline</a> (byte *in, word32 inLen, byte **out, RsaKey *key)</td></tr>
<tr class="memdesc:ga27ae50a0bc76cb4eea37fdbb565ae2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting.  <br /></td></tr>
<tr class="memitem:ga674c968fd03a8b88931e412df8db7732" id="r_ga674c968fd03a8b88931e412df8db7732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga674c968fd03a8b88931e412df8db7732">wc_RsaPrivateDecrypt</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga674c968fd03a8b88931e412df8db7732"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions provides private RSA decryption.  <br /></td></tr>
<tr class="memitem:ga8299328ea8ddff961b79038bc97a4044" id="r_ga8299328ea8ddff961b79038bc97a4044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga8299328ea8ddff961b79038bc97a4044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signs the provided array with the private key.  <br /></td></tr>
<tr class="memitem:ga192d864bacce51770e774e304a343585" id="r_ga192d864bacce51770e774e304a343585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga192d864bacce51770e774e304a343585">wc_RsaSSL_VerifyInline</a> (byte *in, word32 inLen, byte **out, RsaKey *key)</td></tr>
<tr class="memdesc:ga192d864bacce51770e774e304a343585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by RSA key. The output uses the same byte array as the input.  <br /></td></tr>
<tr class="memitem:ga1e996b7382fa0951cd5000d11fc4c0ea" id="r_ga1e996b7382fa0951cd5000d11fc4c0ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e996b7382fa0951cd5000d11fc4c0ea">wc_RsaSSL_Verify</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga1e996b7382fa0951cd5000d11fc4c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to verify that the message was signed by key.  <br /></td></tr>
<tr class="memitem:gaaf1d180d5e8bcad38da35d34bef49e11" id="r_gaaf1d180d5e8bcad38da35d34bef49e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a> (const byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key, WC_RNG *rng)</td></tr>
<tr class="memdesc:gaaf1d180d5e8bcad38da35d34bef49e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signs the provided array with the private key.  <br /></td></tr>
<tr class="memitem:gac6e4d2ef764f65e53569508a0060818e" id="r_gac6e4d2ef764f65e53569508a0060818e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a> (byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gac6e4d2ef764f65e53569508a0060818e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt input signature to verify that the message was signed by key. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga3de78c85b8d5cf9d7b755292d6e75e3c" id="r_ga3de78c85b8d5cf9d7b755292d6e75e3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3de78c85b8d5cf9d7b755292d6e75e3c">wc_RsaPSS_VerifyInline</a> (byte *in, word32 inLen, byte **out, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:ga3de78c85b8d5cf9d7b755292d6e75e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt input signature to verify that the message was signed by RSA key. The output uses the same byte array as the input. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gabc0162af195b6a97d58deaec89d62d10" id="r_gabc0162af195b6a97d58deaec89d62d10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc0162af195b6a97d58deaec89d62d10">wc_RsaPSS_VerifyCheck</a> (byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gabc0162af195b6a97d58deaec89d62d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga4beef229be508f04004789e1e51ac859" id="r_ga4beef229be508f04004789e1e51ac859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4beef229be508f04004789e1e51ac859">wc_RsaPSS_VerifyCheck_ex</a> (byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</td></tr>
<tr class="memdesc:ga4beef229be508f04004789e1e51ac859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gaf11e0726a51dd4278346902c10d6f6b5" id="r_gaf11e0726a51dd4278346902c10d6f6b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5">wc_RsaPSS_VerifyCheckInline</a> (byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, RsaKey *key)</td></tr>
<tr class="memdesc:gaf11e0726a51dd4278346902c10d6f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. Salt length is equal to hash length.  <br /></td></tr>
<tr class="memitem:gac6f0820cdf3b0189b01993814635fda3" id="r_gac6f0820cdf3b0189b01993814635fda3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6f0820cdf3b0189b01993814635fda3">wc_RsaPSS_VerifyCheckInline_ex</a> (byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</td></tr>
<tr class="memdesc:gac6f0820cdf3b0189b01993814635fda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:gac32f035dce2d7765faf2bfc0289deeba" id="r_gac32f035dce2d7765faf2bfc0289deeba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba">wc_RsaPSS_CheckPadding</a> (const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType)</td></tr>
<tr class="memdesc:gac32f035dce2d7765faf2bfc0289deeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.  <br /></td></tr>
<tr class="memitem:ga8149b3fea0859eb26d1dbcadba46cb4b" id="r_ga8149b3fea0859eb26d1dbcadba46cb4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b">wc_RsaPSS_CheckPadding_ex</a> (const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType, int saltLen, int bits)</td></tr>
<tr class="memdesc:ga8149b3fea0859eb26d1dbcadba46cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.  <br /></td></tr>
<tr class="memitem:gaa4149b9e60fcc1eba1e7a263bb10a558" id="r_gaa4149b9e60fcc1eba1e7a263bb10a558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa4149b9e60fcc1eba1e7a263bb10a558">wc_RsaEncryptSize</a> (RsaKey *key)</td></tr>
<tr class="memdesc:gaa4149b9e60fcc1eba1e7a263bb10a558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the encryption size for the provided key structure.  <br /></td></tr>
<tr class="memitem:gac52250c3b5c69ff052dfa6605cf49837" id="r_gac52250c3b5c69ff052dfa6605cf49837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac52250c3b5c69ff052dfa6605cf49837">wc_RsaPrivateKeyDecode</a> (const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</td></tr>
<tr class="memdesc:gac52250c3b5c69ff052dfa6605cf49837"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA private key, extracts the private key and stores it in the given RsaKey structure. It also sets the distance parsed in idx.  <br /></td></tr>
<tr class="memitem:ga2610326206b322f33f59e31a845e24b9" id="r_ga2610326206b322f33f59e31a845e24b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2610326206b322f33f59e31a845e24b9">wc_RsaPublicKeyDecode</a> (const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</td></tr>
<tr class="memdesc:ga2610326206b322f33f59e31a845e24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a DER-formatted RSA public key, extracts the public key and stores it in the given RsaKey structure. It also sets the distance parsed in idx.  <br /></td></tr>
<tr class="memitem:ga437b3432338f18022e9b62d109ce0518" id="r_ga437b3432338f18022e9b62d109ce0518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga437b3432338f18022e9b62d109ce0518">wc_RsaPublicKeyDecodeRaw</a> (const byte *n, word32 nSz, const byte *e, word32 eSz, RsaKey *key)</td></tr>
<tr class="memdesc:ga437b3432338f18022e9b62d109ce0518"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exponent (e). It stores these raw elements in the provided RsaKey structure, allowing one to use them in the encryption/decryption process.  <br /></td></tr>
<tr class="memitem:ga428f841fea0e37d3c855c31b32f39dbd" id="r_ga428f841fea0e37d3c855c31b32f39dbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga428f841fea0e37d3c855c31b32f39dbd">wc_RsaKeyToDer</a> (RsaKey *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga428f841fea0e37d3c855c31b32f39dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an RsaKey key to DER format. The result is written to output and it returns the number of bytes written.  <br /></td></tr>
<tr class="memitem:ga9c5787bc3306eb65bec0f018314d309c" id="r_ga9c5787bc3306eb65bec0f018314d309c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:ga9c5787bc3306eb65bec0f018314d309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs RSA encrypt while allowing the choice of which padding to use.  <br /></td></tr>
<tr class="memitem:gaa51e899f36d2429b30213b3374f76521" id="r_gaa51e899f36d2429b30213b3374f76521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa51e899f36d2429b30213b3374f76521">wc_RsaPrivateDecrypt_ex</a> (const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:gaa51e899f36d2429b30213b3374f76521"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message and gives the option of what padding type.  <br /></td></tr>
<tr class="memitem:ga66a1aded8d710cec00046029be411ecb" id="r_ga66a1aded8d710cec00046029be411ecb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66a1aded8d710cec00046029be411ecb">wc_RsaPrivateDecryptInline_ex</a> (byte *in, word32 inLen, byte **out, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</td></tr>
<tr class="memdesc:ga66a1aded8d710cec00046029be411ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses RSA to decrypt a message inline and gives the option of what padding type. The in buffer will contain the decrypted message after being called and the out byte pointer will point to the location in the “in” buffer where the plain text is.  <br /></td></tr>
<tr class="memitem:ga65277ef2482b2a2af05c613b33cbf02a" id="r_ga65277ef2482b2a2af05c613b33cbf02a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65277ef2482b2a2af05c613b33cbf02a">wc_RsaFlattenPublicKey</a> (RsaKey *key, byte *e, word32 *eSz, byte *n, word32 *nSz)</td></tr>
<tr class="memdesc:ga65277ef2482b2a2af05c613b33cbf02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the RsaKey structure into individual elements (e, n) used for the RSA algorithm.  <br /></td></tr>
<tr class="memitem:ga4a7ac764a306106a2d805de0ce03f78a" id="r_ga4a7ac764a306106a2d805de0ce03f78a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4a7ac764a306106a2d805de0ce03f78a">wc_RsaKeyToPublicDer</a> (RsaKey *key, byte *output, word32 inLen)</td></tr>
<tr class="memdesc:ga4a7ac764a306106a2d805de0ce03f78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.  <br /></td></tr>
<tr class="memitem:ga754534e6ddb9db7c55de5793d442f904" id="r_ga754534e6ddb9db7c55de5793d442f904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga754534e6ddb9db7c55de5793d442f904">wc_RsaKeyToPublicDer_ex</a> (RsaKey *key, byte *output, word32 inLen, int with_header)</td></tr>
<tr class="memdesc:ga754534e6ddb9db7c55de5793d442f904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert RSA Public key to DER format. Writes to output, and returns count of bytes written. If with_header is 0 then only the ( seq + n + e) is returned in ASN.1 DER format and will exclude the header.  <br /></td></tr>
<tr class="memitem:ga3f89eea8d56ae352730ffd49ec2fd68e" id="r_ga3f89eea8d56ae352730ffd49ec2fd68e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a> (RsaKey *key, int size, long e, WC_RNG *rng)</td></tr>
<tr class="memdesc:ga3f89eea8d56ae352730ffd49ec2fd68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a RSA private key of length size (in bits) and given exponent (e). It then stores this key in the provided RsaKey structure, so that it may be used for encryption/decryption. A secure number to use for e is 65537. size is required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE. For this function to be available, the option WOLFSSL_KEY_GEN must be enabled at compile time. This can be accomplished with &ndash;enable-keygen if using ./configure.  <br /></td></tr>
<tr class="memitem:gab62eca8ad6726c5db562947e5e165a61" id="r_gab62eca8ad6726c5db562947e5e165a61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab62eca8ad6726c5db562947e5e165a61">wc_RsaSetNonBlock</a> (RsaKey *key, RsaNb *nb)</td></tr>
<tr class="memdesc:gab62eca8ad6726c5db562947e5e165a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the non-blocking RSA context. When a RsaNb context is set it enables fast math based non-blocking exptmod, which splits the RSA function into many smaller operations. Enabled when WC_RSA_NONBLOCK is defined.  <br /></td></tr>
<tr class="memitem:ga623ecefb5f932cbdab21f9b777fa8ea9" id="r_ga623ecefb5f932cbdab21f9b777fa8ea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga623ecefb5f932cbdab21f9b777fa8ea9">wc_RsaSetNonBlockTime</a> (RsaKey *key, word32 maxBlockUs, word32 cpuMHz)</td></tr>
<tr class="memdesc:ga623ecefb5f932cbdab21f9b777fa8ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the maximum amount of blocking time in microseconds. It uses a pre-computed table (see tfm.c exptModNbInst) along with the CPU speed in megahertz to determine if the next operation can be completed within the maximum blocking time provided. Enabled when WC_RSA_NONBLOCK_TIME is defined.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga0e5ef34d84c264a1affa8d3a6478b4ce" name="ga0e5ef34d84c264a1affa8d3a6478b4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">&#9670;&#160;</a></span>wc_FreeRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_FreeRsaKey </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees a provided RsaKey struct using mp_clear. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully freeing the key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey enc;</div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line">... set key, <span class="keywordflow">do</span> encryption</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;enc);</div>
<div class="ttc" id="agroup__RSA_html_ga02c9b34d405c5f1c24956ee84a843ef6"><div class="ttname"><a href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a></div><div class="ttdeci">int wc_InitRsaKey(RsaKey *key, void *heap)</div><div class="ttdoc">This function initializes a provided RsaKey struct. It also takes in a heap identifier,...</div></div>
<div class="ttc" id="agroup__RSA_html_ga0e5ef34d84c264a1affa8d3a6478b4ce"><div class="ttname"><a href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a></div><div class="ttdeci">int wc_FreeRsaKey(RsaKey *key)</div><div class="ttdoc">This function frees a provided RsaKey struct using mp_clear.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga02c9b34d405c5f1c24956ee84a843ef6" name="ga02c9b34d405c5f1c24956ee84a843ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02c9b34d405c5f1c24956ee84a843ef6">&#9670;&#160;</a></span>wc_InitRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_InitRsaKey </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a provided RsaKey struct. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). </p>
<p>The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the RSA structure for use with encryption and decryption </dd>
<dd>
BAD_FUNC_ARGS Returned if the RSA key pointer evaluates to NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure to initialize </td></tr>
    <tr><td class="paramname">heap</td><td>pointer to a heap identifier, for use with memory overrides, allowing custom handling of memory allocation. This heap will be the default used when allocating memory for use with this RSA object</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey enc;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error initializing RSA key</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce" title="This function frees a provided RsaKey struct using mp_clear.">wc_FreeRsaKey</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="gaba7b6eef17f80e711309f53f2c17dfc6" name="gaba7b6eef17f80e711309f53f2c17dfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7b6eef17f80e711309f53f2c17dfc6">&#9670;&#160;</a></span>wc_InitRsaKey_Id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_InitRsaKey_Id </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>heap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>devId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes a provided RsaKey struct. The id and len are used to identify the key on the device while the devId identifies the device. It also takes in a heap identifier, for use with user defined memory overrides (see XMALLOC, XFREE, XREALLOC). </p>
<p>The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the RSA structure for use with encryption and decryption </dd>
<dd>
BAD_FUNC_ARGS Returned if the RSA key pointer evaluates to NULL </dd>
<dd>
BUFFER_E Returned if len is less than 0 or greater than RSA_MAX_ID_LEN.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure to initialize </td></tr>
    <tr><td class="paramname">id</td><td>identifier of key on device </td></tr>
    <tr><td class="paramname">len</td><td>length of identifier in bytes </td></tr>
    <tr><td class="paramname">heap</td><td>pointer to a heap identifier, for use with memory overrides, allowing custom handling of memory allocation. This heap will be the default used when allocating memory for use with this RSA object </td></tr>
    <tr><td class="paramname">devId</td><td>ID to use with crypto callbacks or async hardware. Set to INVALID_DEVID (-2) if not used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey enc;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <span class="keywordtype">id</span> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;RSA2048&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> len = 6;</div>
<div class="line"><span class="keywordtype">int</span> devId = 1;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ret = wc_CryptoDev_RegisterDevice(devId, wc_Pkcs11_CryptoDevCb,</div>
<div class="line">                                  &amp;token);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0) {</div>
<div class="line">    <span class="comment">// error associating callback and token with device id</span></div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#gaba7b6eef17f80e711309f53f2c17dfc6">wc_InitRsaKey_Id</a>(&amp;enc, <span class="keywordtype">id</span>, len, NULL, devId); <span class="comment">// not using heap hint</span></div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error initializing RSA key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_gaba7b6eef17f80e711309f53f2c17dfc6"><div class="ttname"><a href="#gaba7b6eef17f80e711309f53f2c17dfc6">wc_InitRsaKey_Id</a></div><div class="ttdeci">int wc_InitRsaKey_Id(RsaKey *key, unsigned char *id, int len, void *heap, int devId)</div><div class="ttdoc">This function initializes a provided RsaKey struct. The id and len are used to identify the key on th...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd>
<dd>
<a class="el" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce" title="This function frees a provided RsaKey struct using mp_clear.">wc_FreeRsaKey</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga3f89eea8d56ae352730ffd49ec2fd68e" name="ga3f89eea8d56ae352730ffd49ec2fd68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f89eea8d56ae352730ffd49ec2fd68e">&#9670;&#160;</a></span>wc_MakeRsaKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_MakeRsaKey </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a RSA private key of length size (in bits) and given exponent (e). It then stores this key in the provided RsaKey structure, so that it may be used for encryption/decryption. A secure number to use for e is 65537. size is required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE. For this function to be available, the option WOLFSSL_KEY_GEN must be enabled at compile time. This can be accomplished with &ndash;enable-keygen if using ./configure. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a RSA private key </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input arguments are NULL, the size parameter falls outside of the necessary bounds, or e is incorrectly chosen </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a random block using the provided RNG structure </dd>
<dd>
MP_INIT_E </dd>
<dd>
MP_READ_E May be May be returned if there is an error in the math library used while generating the RSA key returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_CMP_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_INVMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_EXPTMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MUL_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_ADD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MULMOD_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_TO_E May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_MEM May be returned if there is an error in the math library used while generating the RSA key </dd>
<dd>
MP_ZERO_E May be returned if there is an error in the math library used while generating the RSA key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure in which to store the generated private key </td></tr>
    <tr><td class="paramname">size</td><td>desired key length, in bits. Required to be greater than RSA_MIN_SIZE and less than RSA_MAX_SIZE </td></tr>
    <tr><td class="paramname">e</td><td>exponent parameter to use for generating the key. A secure choice is 65537 </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to an RNG structure to use for random number generation while making the ke</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey priv;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;priv, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><span class="comment">// generate 2048 bit long private key</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;priv, 2048, e, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error generating private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga3f89eea8d56ae352730ffd49ec2fd68e"><div class="ttname"><a href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a></div><div class="ttdeci">int wc_MakeRsaKey(RsaKey *key, int size, long e, WC_RNG *rng)</div><div class="ttdoc">This function generates a RSA private key of length size (in bits) and given exponent (e)....</div></div>
<div class="ttc" id="agroup__Random_html_ga1a87307fac65d3c2a47ffb743020f83c"><div class="ttname"><a href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a></div><div class="ttdeci">int wc_InitRng(WC_RNG *)</div><div class="ttdoc">Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="gae935cf0597a24a636b730a4c290b442c" name="gae935cf0597a24a636b730a4c290b442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae935cf0597a24a636b730a4c290b442c">&#9670;&#160;</a></span>wc_RsaDirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaDirect </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that does the RSA operation directly with no padding. The input size must match key size. Typically this is used when padding is already done on the RSA input. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successfully encryption the size of the encrypted buffer is returned </dd>
<dd>
RSA_BUFFER_E RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>buffer to do operation on </td></tr>
    <tr><td class="paramname">inLen</td><td>length of input buffer </td></tr>
    <tr><td class="paramname">out</td><td>buffer to hold results </td></tr>
    <tr><td class="paramname">outSz</td><td>gets set to size of result buffer. Should be passed in as length of out buffer. If the pointer "out" is null then outSz gets set to the expected buffer size needed and LENGTH_ONLY_E gets returned. </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key to use for encrypt/decrypt </td></tr>
    <tr><td class="paramname">type</td><td>if using private or public key (RSA_PUBLIC_ENCRYPT, RSA_PUBLIC_DECRYPT, RSA_PRIVATE_ENCRYPT, RSA_PRIVATE_DECRYPT) </td></tr>
    <tr><td class="paramname">rng</td><td>initialized WC_RNG struct</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">WC_RNG rng;</div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="keywordtype">byte</span>  in[256];</div>
<div class="line"><span class="keywordtype">byte</span> out[256];</div>
<div class="line">word32 outSz = (word32)<span class="keyword">sizeof</span>(out);</div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gae935cf0597a24a636b730a4c290b442c">wc_RsaDirect</a>(in, (word32)<span class="keyword">sizeof</span>(in), out, &amp;outSz, &amp;key,</div>
<div class="line">    RSA_PRIVATE_ENCRYPT, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_gae935cf0597a24a636b730a4c290b442c"><div class="ttname"><a href="#gae935cf0597a24a636b730a4c290b442c">wc_RsaDirect</a></div><div class="ttdeci">int wc_RsaDirect(byte *in, word32 inLen, byte *out, word32 *outSz, RsaKey *key, int type, WC_RNG *rng)</div><div class="ttdoc">Function that does the RSA operation directly with no padding. The input size must match key size....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga72130d1043824f7e8a5df91fc6832539" title="This function encrypts a message from in and stores the result in out. It requires an initialized pub...">wc_RsaPublicEncrypt</a> </dd>
<dd>
<a class="el" href="#ga674c968fd03a8b88931e412df8db7732" title="This functions provides private RSA decryption.">wc_RsaPrivateDecrypt</a> </dd></dl>

</div>
</div>
<a id="gaa4149b9e60fcc1eba1e7a263bb10a558" name="gaa4149b9e60fcc1eba1e7a263bb10a558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4149b9e60fcc1eba1e7a263bb10a558">&#9670;&#160;</a></span>wc_RsaEncryptSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaEncryptSize </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the encryption size for the provided key structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Encryption size for the provided key structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sz = <a class="code hl_function" href="#gaa4149b9e60fcc1eba1e7a263bb10a558">wc_RsaEncryptSize</a>(&amp;key);</div>
<div class="ttc" id="agroup__RSA_html_gaa4149b9e60fcc1eba1e7a263bb10a558"><div class="ttname"><a href="#gaa4149b9e60fcc1eba1e7a263bb10a558">wc_RsaEncryptSize</a></div><div class="ttdeci">int wc_RsaEncryptSize(RsaKey *key)</div><div class="ttdoc">Returns the encryption size for the provided key structure.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd>
<dd>
wc_InitRsaKey_ex </dd>
<dd>
<a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e" title="This function generates a RSA private key of length size (in bits) and given exponent (e)....">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga65277ef2482b2a2af05c613b33cbf02a" name="ga65277ef2482b2a2af05c613b33cbf02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65277ef2482b2a2af05c613b33cbf02a">&#9670;&#160;</a></span>wc_RsaFlattenPublicKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaFlattenPublicKey </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>eSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>nSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the RsaKey structure into individual elements (e, n) used for the RSA algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned if the function executed normally, without error. </dd>
<dd>
BAD_FUNC_ARG: Returned if any of the parameters are passed in with a null value. </dd>
<dd>
RSA_BUFFER_E: Returned if the e or n buffers passed in are not the correct size. </dd>
<dd>
MP_MEM: Returned if an internal function has memory errors. </dd>
<dd>
MP_VAL: Returned if an internal function argument is not valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to use for verification. </td></tr>
    <tr><td class="paramname">e</td><td>a buffer for the value of e. e is a large positive integer in the RSA modular arithmetic operation. </td></tr>
    <tr><td class="paramname">eSz</td><td>the size of the e buffer. </td></tr>
    <tr><td class="paramname">n</td><td>a buffer for the value of n. n is a large positive integer in the RSA modular arithmetic operation. </td></tr>
    <tr><td class="paramname">nSz</td><td>the size of the n buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Rsa key; <span class="comment">// A valid RSA key.</span></div>
<div class="line"><span class="keywordtype">byte</span> e[ buffer sz E.g. 256 ];</div>
<div class="line"><span class="keywordtype">byte</span> n[256];</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">word32 eSz = <span class="keyword">sizeof</span>(e);</div>
<div class="line">word32 nSz = <span class="keyword">sizeof</span>(n);</div>
<div class="line">...</div>
<div class="line">ret = <a class="code hl_function" href="#ga65277ef2482b2a2af05c613b33cbf02a">wc_RsaFlattenPublicKey</a>(&amp;key, e, &amp;eSz, n, &amp;nSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// Failure case.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga65277ef2482b2a2af05c613b33cbf02a"><div class="ttname"><a href="#ga65277ef2482b2a2af05c613b33cbf02a">wc_RsaFlattenPublicKey</a></div><div class="ttdeci">int wc_RsaFlattenPublicKey(RsaKey *key, byte *e, word32 *eSz, byte *n, word32 *nSz)</div><div class="ttdoc">Flattens the RsaKey structure into individual elements (e, n) used for the RSA algorithm.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd>
<dd>
wc_InitRsaKey_ex </dd>
<dd>
<a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e" title="This function generates a RSA private key of length size (in bits) and given exponent (e)....">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga428f841fea0e37d3c855c31b32f39dbd" name="ga428f841fea0e37d3c855c31b32f39dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga428f841fea0e37d3c855c31b32f39dbd">&#9670;&#160;</a></span>wc_RsaKeyToDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaKeyToDer </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts an RsaKey key to DER format. The result is written to output and it returns the number of bytes written. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, number of bytes written. </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null, or if key-&gt;type is not RSA_PRIVATE, or if inLen isn't large enough for output buffer. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Initialized RsaKey structure. </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to output buffer. </td></tr>
    <tr><td class="paramname">inLen</td><td>Size of output buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">byte</span>* der;</div>
<div class="line"><span class="comment">// Allocate memory for der</span></div>
<div class="line"><span class="keywordtype">int</span> derSz = <span class="comment">// Amount of memory allocated for der;</span></div>
<div class="line">RsaKey key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, e, &amp;rng); <span class="comment">// generate 2048 bit long</span></div>
<div class="line"><span class="keyword">private</span> key</div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga428f841fea0e37d3c855c31b32f39dbd">wc_RsaKeyToDer</a>(&amp;key, der, derSz) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle the error thrown</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga428f841fea0e37d3c855c31b32f39dbd"><div class="ttname"><a href="#ga428f841fea0e37d3c855c31b32f39dbd">wc_RsaKeyToDer</a></div><div class="ttdeci">int wc_RsaKeyToDer(RsaKey *key, byte *output, word32 inLen)</div><div class="ttdoc">This function converts an RsaKey key to DER format. The result is written to output and it returns th...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga4a7ac764a306106a2d805de0ce03f78a" title="Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.">wc_RsaKeyToPublicDer</a> </dd>
<dd>
<a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd>
<dd>
<a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e" title="This function generates a RSA private key of length size (in bits) and given exponent (e)....">wc_MakeRsaKey</a> </dd>
<dd>
<a class="el" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c" title="Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...">wc_InitRng</a> </dd></dl>

</div>
</div>
<a id="ga4a7ac764a306106a2d805de0ce03f78a" name="ga4a7ac764a306106a2d805de0ce03f78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7ac764a306106a2d805de0ce03f78a">&#9670;&#160;</a></span>wc_RsaKeyToPublicDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaKeyToPublicDer </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, number of bytes written. </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null. </dd>
<dd>
MEMORY_E Returned when an error allocating memory occurs. </dd>
<dd>
&lt;0 Error</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The RSA key structure to convert. </td></tr>
    <tr><td class="paramname">output</td><td>Output buffer to hold DER. (if NULL will return length only) </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey key;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="comment">// Use key</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUFFER_SIZE = 1024; <span class="comment">// Some adequate size for the buffer</span></div>
<div class="line"><span class="keywordtype">byte</span> output[BUFFER_SIZE];</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga4a7ac764a306106a2d805de0ce03f78a">wc_RsaKeyToPublicDer</a>(&amp;key, output, <span class="keyword">sizeof</span>(output)) != 0) {</div>
<div class="line">    <span class="comment">// Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga4a7ac764a306106a2d805de0ce03f78a"><div class="ttname"><a href="#ga4a7ac764a306106a2d805de0ce03f78a">wc_RsaKeyToPublicDer</a></div><div class="ttdeci">int wc_RsaKeyToPublicDer(RsaKey *key, byte *output, word32 inLen)</div><div class="ttdoc">Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RsaPublicKeyDerSize </dd>
<dd>
<a class="el" href="#ga754534e6ddb9db7c55de5793d442f904" title="Convert RSA Public key to DER format. Writes to output, and returns count of bytes written....">wc_RsaKeyToPublicDer_ex</a> </dd>
<dd>
<a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga754534e6ddb9db7c55de5793d442f904" name="ga754534e6ddb9db7c55de5793d442f904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga754534e6ddb9db7c55de5793d442f904">&#9670;&#160;</a></span>wc_RsaKeyToPublicDer_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaKeyToPublicDer_ex </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>with_header</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert RSA Public key to DER format. Writes to output, and returns count of bytes written. If with_header is 0 then only the ( seq + n + e) is returned in ASN.1 DER format and will exclude the header. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Success, number of bytes written. </dd>
<dd>
BAD_FUNC_ARG Returned if key or output is null. </dd>
<dd>
MEMORY_E Returned when an error allocating memory occurs. </dd>
<dd>
&lt;0 Error</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The RSA key structure to convert. </td></tr>
    <tr><td class="paramname">output</td><td>Output buffer to hold DER. (if NULL will return length only) </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey key;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="comment">// Use key</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> BUFFER_SIZE = 1024; <span class="comment">// Some adequate size for the buffer</span></div>
<div class="line"><span class="keywordtype">byte</span> output[BUFFER_SIZE];</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga754534e6ddb9db7c55de5793d442f904">wc_RsaKeyToPublicDer_ex</a>(&amp;key, output, <span class="keyword">sizeof</span>(output), 0) != 0) {</div>
<div class="line">    <span class="comment">// Handle Error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga754534e6ddb9db7c55de5793d442f904"><div class="ttname"><a href="#ga754534e6ddb9db7c55de5793d442f904">wc_RsaKeyToPublicDer_ex</a></div><div class="ttdeci">int wc_RsaKeyToPublicDer_ex(RsaKey *key, byte *output, word32 inLen, int with_header)</div><div class="ttdoc">Convert RSA Public key to DER format. Writes to output, and returns count of bytes written....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RsaPublicKeyDerSize </dd>
<dd>
<a class="el" href="#ga4a7ac764a306106a2d805de0ce03f78a" title="Convert Rsa Public key to DER format. Writes to output, and returns count of bytes written.">wc_RsaKeyToPublicDer</a> </dd>
<dd>
<a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd></dl>

</div>
</div>
<a id="ga674c968fd03a8b88931e412df8db7732" name="ga674c968fd03a8b88931e412df8db7732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674c968fd03a8b88931e412df8db7732">&#9670;&#160;</a></span>wc_RsaPrivateDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPrivateDecrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions provides private RSA decryption. </p>
<dl class="section return"><dt>Returns</dt><dd>Success length of decrypted data. </dd>
<dd>
MEMORY_E -125, out of memory error </dd>
<dd>
BAD_FUNC_ARG -173, Bad function argument provided</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for decryption.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga72130d1043824f7e8a5df91fc6832539">wc_RsaPublicEncrypt</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">ret = <a class="code hl_function" href="#ga674c968fd03a8b88931e412df8db7732">wc_RsaPrivateDecrypt</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga674c968fd03a8b88931e412df8db7732"><div class="ttname"><a href="#ga674c968fd03a8b88931e412df8db7732">wc_RsaPrivateDecrypt</a></div><div class="ttdeci">int wc_RsaPrivateDecrypt(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</div><div class="ttdoc">This functions provides private RSA decryption.</div></div>
<div class="ttc" id="agroup__RSA_html_ga72130d1043824f7e8a5df91fc6832539"><div class="ttname"><a href="#ga72130d1043824f7e8a5df91fc6832539">wc_RsaPublicEncrypt</a></div><div class="ttdeci">int wc_RsaPublicEncrypt(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</div><div class="ttdoc">This function encrypts a message from in and stores the result in out. It requires an initialized pub...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>RsaUnPad </dd>
<dd>
wc_RsaFunction </dd>
<dd>
<a class="el" href="#ga27ae50a0bc76cb4eea37fdbb565ae2a6" title="This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting.">wc_RsaPrivateDecryptInline</a> </dd></dl>

</div>
</div>
<a id="gaa51e899f36d2429b30213b3374f76521" name="gaa51e899f36d2429b30213b3374f76521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa51e899f36d2429b30213b3374f76521">&#9670;&#160;</a></span>wc_RsaPrivateDecrypt_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPrivateDecrypt_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>labelSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses RSA to decrypt a message and gives the option of what padding type. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successful decryption, the size of the decrypted message is returned. </dd>
<dd>
MEMORY_E Returned if not enough memory on system to malloc a needed array. </dd>
<dd>
BAD_FUNC_ARG Returned if a bad argument was passed into the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for decryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>decrypted msg created </td></tr>
    <tr><td class="paramname">outLen</td><td>length of buffer available to hold decrypted msg </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WC_RNG rng;</div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="keywordtype">byte</span> in[] = “I use Turing Machines to ask questions”</div>
<div class="line"><span class="keywordtype">byte</span> out[256];</div>
<div class="line"><span class="keywordtype">byte</span> plain[256];</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key,</div>
<div class="line">&amp;rng, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#gaa51e899f36d2429b30213b3374f76521">wc_RsaPrivateDecrypt_ex</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key,</div>
<div class="line">WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga9c5787bc3306eb65bec0f018314d309c"><div class="ttname"><a href="#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a></div><div class="ttdeci">int wc_RsaPublicEncrypt_ex(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</div><div class="ttdoc">This function performs RSA encrypt while allowing the choice of which padding to use.</div></div>
<div class="ttc" id="agroup__RSA_html_gaa51e899f36d2429b30213b3374f76521"><div class="ttname"><a href="#gaa51e899f36d2429b30213b3374f76521">wc_RsaPrivateDecrypt_ex</a></div><div class="ttdeci">int wc_RsaPrivateDecrypt_ex(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</div><div class="ttdoc">This function uses RSA to decrypt a message and gives the option of what padding type.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga27ae50a0bc76cb4eea37fdbb565ae2a6" name="ga27ae50a0bc76cb4eea37fdbb565ae2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ae50a0bc76cb4eea37fdbb565ae2a6">&#9670;&#160;</a></span>wc_RsaPrivateDecryptInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPrivateDecryptInline </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions is utilized by the wc_RsaPrivateDecrypt function for decrypting. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Length of decrypted data. </dd>
<dd>
RSA_PAD_E RsaUnPad error, bad formatting</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for decryption.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">none</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga674c968fd03a8b88931e412df8db7732" title="This functions provides private RSA decryption.">wc_RsaPrivateDecrypt</a> </dd></dl>

</div>
</div>
<a id="ga66a1aded8d710cec00046029be411ecb" name="ga66a1aded8d710cec00046029be411ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a1aded8d710cec00046029be411ecb">&#9670;&#160;</a></span>wc_RsaPrivateDecryptInline_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPrivateDecryptInline_ex </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>labelSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses RSA to decrypt a message inline and gives the option of what padding type. The in buffer will contain the decrypted message after being called and the out byte pointer will point to the location in the “in” buffer where the plain text is. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successful decryption, the size of the decrypted message is returned. </dd>
<dd>
MEMORY_E: Returned if not enough memory on system to malloc a needed array. </dd>
<dd>
RSA_PAD_E: Returned if an error in the padding was encountered. </dd>
<dd>
BAD_PADDING_E: Returned if an error happened during parsing past padding. </dd>
<dd>
BAD_FUNC_ARG: Returned if a bad argument was passed into the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for decryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to decrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to location of decrypted message in “in” buffer </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WC_RNG rng;</div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="keywordtype">byte</span> in[] = “I use Turing Machines to ask questions”</div>
<div class="line"><span class="keywordtype">byte</span> out[256];</div>
<div class="line"><span class="keywordtype">byte</span>* plain;</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key,</div>
<div class="line">&amp;rng, WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
<div class="line">…</div>
<div class="line">ret = <a class="code hl_function" href="#ga66a1aded8d710cec00046029be411ecb">wc_RsaPrivateDecryptInline_ex</a>(out, ret, &amp;plain, &amp;key,</div>
<div class="line">WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga66a1aded8d710cec00046029be411ecb"><div class="ttname"><a href="#ga66a1aded8d710cec00046029be411ecb">wc_RsaPrivateDecryptInline_ex</a></div><div class="ttdeci">int wc_RsaPrivateDecryptInline_ex(byte *in, word32 inLen, byte **out, RsaKey *key, int type, enum wc_HashType hash, int mgf, byte *label, word32 labelSz)</div><div class="ttdoc">This function uses RSA to decrypt a message inline and gives the option of what padding type....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>none </dd></dl>

</div>
</div>
<a id="gac52250c3b5c69ff052dfa6605cf49837" name="gac52250c3b5c69ff052dfa6605cf49837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52250c3b5c69ff052dfa6605cf49837">&#9670;&#160;</a></span>wc_RsaPrivateKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPrivateKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a DER-formatted RSA private key, extracts the private key and stores it in the given RsaKey structure. It also sets the distance parsed in idx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully parsing the private key from the DER encoded input </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the private key from the input buffer. This may happen if the input private key is not properly formatted according to ASN.1 standards </dd>
<dd>
ASN_RSA_KEY_E Returned if there is an error reading the private key elements of the RSA key input</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the buffer containing the DER formatted private key to decode </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>pointer to the index in the buffer at which the key begins (usually 0). As a side effect of this function, inOutIdx will store the distance parsed through the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure in which to store the decoded private key </td></tr>
    <tr><td class="paramname">inSz</td><td>size of the input buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey enc;</div>
<div class="line">word32 idx = 0;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">byte</span> der[] = { <span class="comment">// initialize with DER-encoded RSA private key };</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;enc, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line">ret = <a class="code hl_function" href="#gac52250c3b5c69ff052dfa6605cf49837">wc_RsaPrivateKeyDecode</a>(der, &amp;idx, &amp;enc, <span class="keyword">sizeof</span>(der));</div>
<div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error parsing private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_gac52250c3b5c69ff052dfa6605cf49837"><div class="ttname"><a href="#gac52250c3b5c69ff052dfa6605cf49837">wc_RsaPrivateKeyDecode</a></div><div class="ttdeci">int wc_RsaPrivateKeyDecode(const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</div><div class="ttdoc">This function parses a DER-formatted RSA private key, extracts the private key and stores it in the g...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2610326206b322f33f59e31a845e24b9" title="This function parses a DER-formatted RSA public key, extracts the public key and stores it in the giv...">wc_RsaPublicKeyDecode</a> </dd>
<dd>
<a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e" title="This function generates a RSA private key of length size (in bits) and given exponent (e)....">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
<a id="gac32f035dce2d7765faf2bfc0289deeba" name="gac32f035dce2d7765faf2bfc0289deeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32f035dce2d7765faf2bfc0289deeba">&#9670;&#160;</a></span>wc_RsaPSS_CheckPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_CheckPadding </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sigSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hashType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>BAD_PADDING_E when the PSS data is invalid, BAD_FUNC_ARG when NULL is passed in to in or sig or inSz is not the same as the hash algorithm length and 0 on success. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">inSz</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">sig</td><td>Buffer holding PSS data. </td></tr>
    <tr><td class="paramname">sigSz</td><td>Size of PSS data. </td></tr>
    <tr><td class="paramname">hashType</td><td>Hash algorithm.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, <span class="keyword">sizeof</span>(pSignature),</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">    sz = ret;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">verify = <a class="code hl_function" href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a>(pSignature, sz, out, outLen,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (verify &lt;= 0)<span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gac32f035dce2d7765faf2bfc0289deeba">wc_RsaPSS_CheckPadding</a>(digest, digestSz, out, verify, hash);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_gaaf1d180d5e8bcad38da35d34bef49e11"><div class="ttname"><a href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a></div><div class="ttdeci">int wc_RsaPSS_Sign(const byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key, WC_RNG *rng)</div><div class="ttdoc">Signs the provided array with the private key.</div></div>
<div class="ttc" id="agroup__RSA_html_gac32f035dce2d7765faf2bfc0289deeba"><div class="ttname"><a href="#gac32f035dce2d7765faf2bfc0289deeba">wc_RsaPSS_CheckPadding</a></div><div class="ttdeci">int wc_RsaPSS_CheckPadding(const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType)</div><div class="ttdoc">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....</div></div>
<div class="ttc" id="agroup__RSA_html_gac6e4d2ef764f65e53569508a0060818e"><div class="ttname"><a href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a></div><div class="ttdeci">int wc_RsaPSS_Verify(byte *in, word32 inLen, byte *out, word32 outLen, enum wc_HashType hash, int mgf, RsaKey *key)</div><div class="ttdoc">Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...</div></div>
<div class="ttc" id="agroup__RSA_html_gade0e7ccd93ec8c9e5ba5ded3e11b1226"><div class="ttname"><a href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a></div><div class="ttdeci">int wc_RsaSetRNG(RsaKey *key, WC_RNG *rng)</div><div class="ttdoc">This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.</div></div>
<div class="ttc" id="agroup__Random_html_ga72ffd8b507b3a895af8a6e9996caba86"><div class="ttname"><a href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a></div><div class="ttdeci">int wc_FreeRng(WC_RNG *)</div><div class="ttdoc">Should be called when RNG no longer needed in order to securely free drgb. Zeros and XFREEs rng-drbg.</div></div>
<div class="ttc" id="agroup__wolfCrypt_html_ga0a2c6803a9ba6e8ff9cca961cff340a8"><div class="ttname"><a href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a></div><div class="ttdeci">int wc_Hash(enum wc_HashType hash_type, const byte *data, word32 data_len, byte *hash, word32 hash_len)</div><div class="ttdoc">This function performs a hash on the provided data buffer and returns it in the hash buffer provided.</div></div>
<div class="ttc" id="agroup__wolfCrypt_html_ga1126e1ba7ad303f3fde1cdea53615752"><div class="ttname"><a href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a></div><div class="ttdeci">int wc_HashGetDigestSize(enum wc_HashType hash_type)</div><div class="ttdoc">This function returns the size of the digest (output) for a hash_type. The returns size is used to ma...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#ga3de78c85b8d5cf9d7b755292d6e75e3c" title="Decrypt input signature to verify that the message was signed by RSA key. The output uses the same by...">wc_RsaPSS_VerifyInline</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga8149b3fea0859eb26d1dbcadba46cb4b" name="ga8149b3fea0859eb26d1dbcadba46cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8149b3fea0859eb26d1dbcadba46cb4b">&#9670;&#160;</a></span>wc_RsaPSS_CheckPadding_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_CheckPadding_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>sigSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hashType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>saltLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length. </p>
<dl class="section return"><dt>Returns</dt><dd>BAD_PADDING_E when the PSS data is invalid, BAD_FUNC_ARG when NULL is passed in to in or sig or inSz is not the same as the hash algorithm length and 0 on success. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">inSz</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">sig</td><td>Buffer holding PSS data. </td></tr>
    <tr><td class="paramname">sigSz</td><td>Size of PSS data. </td></tr>
    <tr><td class="paramname">hashType</td><td>Hash algorithm. </td></tr>
    <tr><td class="paramname">saltLen</td><td>Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER indicates salt length is determined from the data. </td></tr>
    <tr><td class="paramname">bits</td><td>Can be used to calculate salt size in FIPS case</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, <span class="keyword">sizeof</span>(pSignature),</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">    sz = ret;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">verify = <a class="code hl_function" href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a>(pSignature, sz, out, outLen,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (verify &lt;= 0)<span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga8149b3fea0859eb26d1dbcadba46cb4b">wc_RsaPSS_CheckPadding_ex</a>(digest, digestSz, out, verify, hash, saltLen, 0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_ga8149b3fea0859eb26d1dbcadba46cb4b"><div class="ttname"><a href="#ga8149b3fea0859eb26d1dbcadba46cb4b">wc_RsaPSS_CheckPadding_ex</a></div><div class="ttdeci">int wc_RsaPSS_CheckPadding_ex(const byte *in, word32 inLen, byte *sig, word32 sigSz, enum wc_HashType hashType, int saltLen, int bits)</div><div class="ttdoc">Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#ga3de78c85b8d5cf9d7b755292d6e75e3c" title="Decrypt input signature to verify that the message was signed by RSA key. The output uses the same by...">wc_RsaPSS_VerifyInline</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd></dl>

</div>
</div>
<a id="gaaf1d180d5e8bcad38da35d34bef49e11" name="gaaf1d180d5e8bcad38da35d34bef49e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1d180d5e8bcad38da35d34bef49e11">&#9670;&#160;</a></span>wc_RsaPSS_Sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_Sign </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signs the provided array with the private key. </p>
<dl class="section return"><dt>Returns</dt><dd>RSA_BUFFER_E: -131, RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be encrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the encrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">hash</td><td>The hash type to be in message </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask Generation Function Identifiers </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>((<span class="keywordtype">byte</span>*)szMessage, (word32)XSTRLEN(szMessage)+1,</div>
<div class="line">        pSignature, <span class="keyword">sizeof</span>(pSignature),</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">    sz = ret;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a>(pSignature, sz, pt, outLen,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt;= 0)<span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="gac6e4d2ef764f65e53569508a0060818e" name="gac6e4d2ef764f65e53569508a0060818e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e4d2ef764f65e53569508a0060818e">&#9670;&#160;</a></span>wc_RsaPSS_Verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_Verify </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt input signature to verify that the message was signed by key. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Length of text on no error. </dd>
<dd>
MEMORY_E memory exception. </dd>
<dd>
MP_EXPTMOD_E - When using fastmath and FP_MAX_BITS not set to at least 2 times the keySize (Example when using 4096-bit key set FP_MAX_BITS to 8192 or greater value)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">hash</td><td>The hash type to be in message </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask Generation Function Identifiers </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>((<span class="keywordtype">byte</span>*)szMessage, (word32)XSTRLEN(szMessage)+1,</div>
<div class="line">        pSignature, <span class="keyword">sizeof</span>(pSignature),</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">    sz = ret;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gac6e4d2ef764f65e53569508a0060818e">wc_RsaPSS_Verify</a>(pSignature, sz, pt, outLen,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt;= 0)<span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#ga3de78c85b8d5cf9d7b755292d6e75e3c" title="Decrypt input signature to verify that the message was signed by RSA key. The output uses the same by...">wc_RsaPSS_VerifyInline</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="gabc0162af195b6a97d58deaec89d62d10" name="gabc0162af195b6a97d58deaec89d62d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0162af195b6a97d58deaec89d62d10">&#9670;&#160;</a></span>wc_RsaPSS_VerifyCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_VerifyCheck </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>digest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>digestLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the PSS data on success and negative indicates failure. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to address containing the PSS data. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">digest</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">digestLen</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash algorithm. </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask generation function. </td></tr>
    <tr><td class="paramname">key</td><td>Public RSA key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, pSignatureSz,</div>
<div class="line">            WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">        sz = ret;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gabc0162af195b6a97d58deaec89d62d10">wc_RsaPSS_VerifyCheck</a>(pSignature, sz, pt, outLen,</div>
<div class="line">            digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt;= 0) <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_gabc0162af195b6a97d58deaec89d62d10"><div class="ttname"><a href="#gabc0162af195b6a97d58deaec89d62d10">wc_RsaPSS_VerifyCheck</a></div><div class="ttdeci">int wc_RsaPSS_VerifyCheck(byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, RsaKey *key)</div><div class="ttdoc">Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga4beef229be508f04004789e1e51ac859" name="ga4beef229be508f04004789e1e51ac859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4beef229be508f04004789e1e51ac859">&#9670;&#160;</a></span>wc_RsaPSS_VerifyCheck_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_VerifyCheck_ex </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>digest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>digestLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>saltLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the PSS data on success and negative indicates failure. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to address containing the PSS data. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">digest</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">digestLen</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash algorithm. </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask generation function. </td></tr>
    <tr><td class="paramname">saltLen</td><td>Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER indicates salt length is determined from the data.</td></tr>
    <tr><td class="paramname">key</td><td>Public RSA key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, pSignatureSz,</div>
<div class="line">            WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">        sz = ret;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#ga4beef229be508f04004789e1e51ac859">wc_RsaPSS_VerifyCheck_ex</a>(pSignature, sz, pt, outLen,</div>
<div class="line">            digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, saltLen, &amp;key);</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt;= 0) <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_ga4beef229be508f04004789e1e51ac859"><div class="ttname"><a href="#ga4beef229be508f04004789e1e51ac859">wc_RsaPSS_VerifyCheck_ex</a></div><div class="ttdeci">int wc_RsaPSS_VerifyCheck_ex(byte *in, word32 inLen, byte *out, word32 outLen, const byte *digest, word32 digestLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</div><div class="ttdoc">Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="gaf11e0726a51dd4278346902c10d6f6b5" name="gaf11e0726a51dd4278346902c10d6f6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11e0726a51dd4278346902c10d6f6b5">&#9670;&#160;</a></span>wc_RsaPSS_VerifyCheckInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_VerifyCheckInline </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>digest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>digentLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. Salt length is equal to hash length. </p>
<p>The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the PSS data on success and negative indicates failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">digest</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">digestLen</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">hash</td><td>The hash type to be in message </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask Generation Function Identifiers </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, pSignatureSz,</div>
<div class="line">            WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">        sz = ret;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaf11e0726a51dd4278346902c10d6f6b5">wc_RsaPSS_VerifyCheckInline</a>(pSignature, sz, pt,</div>
<div class="line">            digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt;= 0) <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_gaf11e0726a51dd4278346902c10d6f6b5"><div class="ttname"><a href="#gaf11e0726a51dd4278346902c10d6f6b5">wc_RsaPSS_VerifyCheckInline</a></div><div class="ttdeci">int wc_RsaPSS_VerifyCheckInline(byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, RsaKey *key)</div><div class="ttdoc">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="gac6f0820cdf3b0189b01993814635fda3" name="gac6f0820cdf3b0189b01993814635fda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f0820cdf3b0189b01993814635fda3">&#9670;&#160;</a></span>wc_RsaPSS_VerifyCheckInline_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_VerifyCheckInline_ex </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>digest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>digentLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>saltLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the PSS data on success and negative indicates failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">digest</td><td>Hash of the data that is being verified. </td></tr>
    <tr><td class="paramname">digestLen</td><td>Length of hash. </td></tr>
    <tr><td class="paramname">hash</td><td>The hash type to be in message </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask Generation Function Identifiers </td></tr>
    <tr><td class="paramname">saltLen</td><td>Length of salt used. RSA_PSS_SALT_LEN_DEFAULT (-1) indicates salt length is the same as the hash length. RSA_PSS_SALT_LEN_DISCOVER indicates salt length is determined from the data. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    digestSz = <a class="code hl_function" href="group__wolfCrypt.html#ga1126e1ba7ad303f3fde1cdea53615752">wc_HashGetDigestSize</a>(WC_HASH_TYPE_SHA256);</div>
<div class="line">    ret = <a class="code hl_function" href="group__wolfCrypt.html#ga0a2c6803a9ba6e8ff9cca961cff340a8">wc_Hash</a>(WC_HASH_TYPE_SHA256, message, sz, digest, digestSz);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, pSignatureSz,</div>
<div class="line">            WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">        sz = ret;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gac6f0820cdf3b0189b01993814635fda3">wc_RsaPSS_VerifyCheckInline_ex</a>(pSignature, sz, pt,</div>
<div class="line">            digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, saltLen, &amp;key);</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt;= 0) <span class="keywordflow">return</span> -1;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_gac6f0820cdf3b0189b01993814635fda3"><div class="ttname"><a href="#gac6f0820cdf3b0189b01993814635fda3">wc_RsaPSS_VerifyCheckInline_ex</a></div><div class="ttdeci">int wc_RsaPSS_VerifyCheckInline_ex(byte *in, word32 inLen, byte **out, const byte *digest, word32 digentLen, enum wc_HashType hash, int mgf, int saltLen, RsaKey *key)</div><div class="ttdoc">Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga3de78c85b8d5cf9d7b755292d6e75e3c" name="ga3de78c85b8d5cf9d7b755292d6e75e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3de78c85b8d5cf9d7b755292d6e75e3c">&#9670;&#160;</a></span>wc_RsaPSS_VerifyInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPSS_VerifyInline </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt input signature to verify that the message was signed by RSA key. The output uses the same byte array as the input. The key has to be associated with RNG by wc_RsaSetRNG when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Length of text. </dd>
<dd>
&lt;0 An error occurred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of the buffer input. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to address containing the PSS data. </td></tr>
    <tr><td class="paramname">hash</td><td>The hash type to be in message </td></tr>
    <tr><td class="paramname">mgf</td><td>Mask Generation Function Identifiers </td></tr>
    <tr><td class="paramname">key</td><td>RsaKey to use.</td></tr>
  </table>
  </dd>
</dl>
<p>_Example_ </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">        ret = <a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, WC_RSA_EXPONENT, &amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line">ret = <a class="code hl_function" href="#gaaf1d180d5e8bcad38da35d34bef49e11">wc_RsaPSS_Sign</a>(digest, digestSz, pSignature, pSignatureSz,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &gt; 0 ){</div>
<div class="line">    sz = ret;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga3de78c85b8d5cf9d7b755292d6e75e3c">wc_RsaPSS_VerifyInline</a>(pSignature, sz, pt,</div>
<div class="line">        WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt;= 0)<span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga0e5ef34d84c264a1affa8d3a6478b4ce">wc_FreeRsaKey</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga72ffd8b507b3a895af8a6e9996caba86">wc_FreeRng</a>(&amp;rng);</div>
<div class="ttc" id="agroup__RSA_html_ga3de78c85b8d5cf9d7b755292d6e75e3c"><div class="ttname"><a href="#ga3de78c85b8d5cf9d7b755292d6e75e3c">wc_RsaPSS_VerifyInline</a></div><div class="ttdeci">int wc_RsaPSS_VerifyInline(byte *in, word32 inLen, byte **out, enum wc_HashType hash, int mgf, RsaKey *key)</div><div class="ttdoc">Decrypt input signature to verify that the message was signed by RSA key. The output uses the same by...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac6e4d2ef764f65e53569508a0060818e" title="Decrypt input signature to verify that the message was signed by key. The key has to be associated wi...">wc_RsaPSS_Verify</a> </dd>
<dd>
<a class="el" href="#gaaf1d180d5e8bcad38da35d34bef49e11" title="Signs the provided array with the private key.">wc_RsaPSS_Sign</a> </dd>
<dd>
<a class="el" href="#gabc0162af195b6a97d58deaec89d62d10" title="Verify the message signed with RSA-PSS. Salt length is equal to hash length. The key has to be associ...">wc_RsaPSS_VerifyCheck</a> </dd>
<dd>
<a class="el" href="#ga4beef229be508f04004789e1e51ac859" title="Verify the message signed with RSA-PSS. The key has to be associated with RNG by wc_RsaSetRNG when WC...">wc_RsaPSS_VerifyCheck_ex</a> </dd>
<dd>
<a class="el" href="#gaf11e0726a51dd4278346902c10d6f6b5" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline</a> </dd>
<dd>
<a class="el" href="#gac6f0820cdf3b0189b01993814635fda3" title="Verify the message signed with RSA-PSS. The input buffer is reused for the output buffer....">wc_RsaPSS_VerifyCheckInline_ex</a> </dd>
<dd>
<a class="el" href="#gac32f035dce2d7765faf2bfc0289deeba" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length....">wc_RsaPSS_CheckPadding</a> </dd>
<dd>
<a class="el" href="#ga8149b3fea0859eb26d1dbcadba46cb4b" title="Checks the PSS data to ensure that the signature matches. Salt length is equal to hash length.">wc_RsaPSS_CheckPadding_ex</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga72130d1043824f7e8a5df91fc6832539" name="ga72130d1043824f7e8a5df91fc6832539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72130d1043824f7e8a5df91fc6832539">&#9670;&#160;</a></span>wc_RsaPublicEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPublicEncrypt </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts a message from in and stores the result in out. It requires an initialized public key and a random number generator. As a side effect, this function will return the bytes written to out in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Upon successfully encrypting the input message, returns 0 for success and less than zero for failure. Also returns the number bytes written to out by storing the value in outLen </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters are invalid </dd>
<dd>
RSA_BUFFER_E Returned if the output buffer is too small to store the ciphertext </dd>
<dd>
RNG_FAILURE_E Returned if there is an error generating a random block using the provided RNG structure </dd>
<dd>
MP_INIT_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_READ_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_CMP_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_INVMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_EXPTMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MUL_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_ADD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MULMOD_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_TO_E May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_MEM May be returned if there is an error in the math library used while encrypting the message </dd>
<dd>
MP_ZERO_E May be returned if there is an error in the math library used while encrypting the message</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to a buffer containing the input message to encrypt </td></tr>
    <tr><td class="paramname">inLen</td><td>the length of the message to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>pointer to the buffer in which to store the output ciphertext </td></tr>
    <tr><td class="paramname">outLen</td><td>the length of the output buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure containing the public key to use for encryption </td></tr>
    <tr><td class="paramname">rng</td><td>The RNG structure with which to generate random block padding</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey pub;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">byte</span> n[] = { <span class="comment">// initialize with received n component of public key };</span></div>
<div class="line"><span class="keywordtype">byte</span> e[] = { <span class="comment">// initialize with received e component of public key };</span></div>
<div class="line"><span class="keywordtype">byte</span> msg[] = { <span class="comment">// initialize with plaintext of message to encrypt };</span></div>
<div class="line"><span class="keywordtype">byte</span> cipher[256]; <span class="comment">// 256 bytes is large enough to store 2048 bit RSA</span></div>
<div class="line">ciphertext</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line"><a class="code hl_function" href="#ga437b3432338f18022e9b62d109ce0518">wc_RsaPublicKeyDecodeRaw</a>(n, <span class="keyword">sizeof</span>(n), e, <span class="keyword">sizeof</span>(e), &amp;pub);</div>
<div class="line"><span class="comment">// initialize with received public key parameters</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga72130d1043824f7e8a5df91fc6832539">wc_RsaPublicEncrypt</a>(msg, <span class="keyword">sizeof</span>(msg), out, <span class="keyword">sizeof</span>(out), &amp;pub, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> ( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error encrypting message</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga437b3432338f18022e9b62d109ce0518"><div class="ttname"><a href="#ga437b3432338f18022e9b62d109ce0518">wc_RsaPublicKeyDecodeRaw</a></div><div class="ttdeci">int wc_RsaPublicKeyDecodeRaw(const byte *n, word32 nSz, const byte *e, word32 eSz, RsaKey *key)</div><div class="ttdoc">This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exp...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga674c968fd03a8b88931e412df8db7732" title="This functions provides private RSA decryption.">wc_RsaPrivateDecrypt</a> </dd></dl>

</div>
</div>
<a id="ga9c5787bc3306eb65bec0f018314d309c" name="ga9c5787bc3306eb65bec0f018314d309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c5787bc3306eb65bec0f018314d309c">&#9670;&#160;</a></span>wc_RsaPublicEncrypt_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPublicEncrypt_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum wc_HashType</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mgf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>labelSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs RSA encrypt while allowing the choice of which padding to use. </p>
<dl class="section return"><dt>Returns</dt><dd>size On successfully encryption the size of the encrypted buffer is returned </dd>
<dd>
RSA_BUFFER_E RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the buffer for encryption </td></tr>
    <tr><td class="paramname">inLen</td><td>length of the buffer to encrypt </td></tr>
    <tr><td class="paramname">out</td><td>encrypted msg created </td></tr>
    <tr><td class="paramname">outLen</td><td>length of buffer available to hold encrypted msg </td></tr>
    <tr><td class="paramname">key</td><td>initialized RSA key struct </td></tr>
    <tr><td class="paramname">rng</td><td>initialized WC_RNG struct </td></tr>
    <tr><td class="paramname">type</td><td>type of padding to use (WC_RSA_OAEP_PAD or WC_RSA_PKCSV15_PAD) </td></tr>
    <tr><td class="paramname">hash</td><td>type of hash to use (choices can be found in <a class="el" href="hash_8h.html">hash.h</a>) </td></tr>
    <tr><td class="paramname">mgf</td><td>type of mask generation function to use </td></tr>
    <tr><td class="paramname">label</td><td>an optional label to associate with encrypted message </td></tr>
    <tr><td class="paramname">labelSz</td><td>size of the optional label used</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">WC_RNG rng;</div>
<div class="line">RsaKey key;</div>
<div class="line"><span class="keywordtype">byte</span> in[] = “I use Turing Machines to ask questions”</div>
<div class="line"><span class="keywordtype">byte</span> out[256];</div>
<div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga9c5787bc3306eb65bec0f018314d309c">wc_RsaPublicEncrypt_ex</a>(in, <span class="keyword">sizeof</span>(in), out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng,</div>
<div class="line">WC_RSA_OAEP_PAD, WC_HASH_TYPE_SHA, WC_MGF1SHA1, NULL, 0);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">//handle error</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga72130d1043824f7e8a5df91fc6832539" title="This function encrypts a message from in and stores the result in out. It requires an initialized pub...">wc_RsaPublicEncrypt</a> </dd>
<dd>
<a class="el" href="#gaa51e899f36d2429b30213b3374f76521" title="This function uses RSA to decrypt a message and gives the option of what padding type.">wc_RsaPrivateDecrypt_ex</a> </dd></dl>

</div>
</div>
<a id="ga2610326206b322f33f59e31a845e24b9" name="ga2610326206b322f33f59e31a845e24b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2610326206b322f33f59e31a845e24b9">&#9670;&#160;</a></span>wc_RsaPublicKeyDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPublicKeyDecode </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>inOutIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a DER-formatted RSA public key, extracts the public key and stores it in the given RsaKey structure. It also sets the distance parsed in idx. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully parsing the public key from the DER encoded input </dd>
<dd>
ASN_PARSE_E Returned if there is an error parsing the public key from the input buffer. This may happen if the input public key is not properly formatted according to ASN.1 standards </dd>
<dd>
ASN_OBJECT_ID_E Returned if the ASN.1 Object ID does not match that of a RSA public key </dd>
<dd>
ASN_EXPECT_0_E Returned if the input key is not correctly formatted according to ASN.1 standards </dd>
<dd>
ASN_BITSTR_E Returned if the input key is not correctly formatted according to ASN.1 standards </dd>
<dd>
ASN_RSA_KEY_E Returned if there is an error reading the public key elements of the RSA key input</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>pointer to the buffer containing the input DER-encoded RSA public key to decode </td></tr>
    <tr><td class="paramname">inOutIdx</td><td>pointer to the index in the buffer at which the key begins (usually 0). As a side effect of this function, inOutIdx will store the distance parsed through the input buffer </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure in which to store the decoded public key </td></tr>
    <tr><td class="paramname">inSz</td><td>size of the input buffer</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey pub;</div>
<div class="line">word32 idx = 0;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">byte</span> der[] = { <span class="comment">// initialize with DER-encoded RSA public key };</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga2610326206b322f33f59e31a845e24b9">wc_RsaPublicKeyDecode</a>(der, &amp;idx, &amp;pub, <span class="keyword">sizeof</span>(der));</div>
<div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error parsing public key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga2610326206b322f33f59e31a845e24b9"><div class="ttname"><a href="#ga2610326206b322f33f59e31a845e24b9">wc_RsaPublicKeyDecode</a></div><div class="ttdeci">int wc_RsaPublicKeyDecode(const byte *input, word32 *inOutIdx, RsaKey *key, word32 inSz)</div><div class="ttdoc">This function parses a DER-formatted RSA public key, extracts the public key and stores it in the giv...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga437b3432338f18022e9b62d109ce0518" title="This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exp...">wc_RsaPublicKeyDecodeRaw</a> </dd></dl>

</div>
</div>
<a id="ga437b3432338f18022e9b62d109ce0518" name="ga437b3432338f18022e9b62d109ce0518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437b3432338f18022e9b62d109ce0518">&#9670;&#160;</a></span>wc_RsaPublicKeyDecodeRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaPublicKeyDecodeRaw </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>nSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>eSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decodes the raw elements of an RSA public key, taking in the public modulus (n) and exponent (e). It stores these raw elements in the provided RsaKey structure, allowing one to use them in the encryption/decryption process. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully decoding the raw elements of the public key into the RsaKey structure </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input arguments evaluates to NULL </dd>
<dd>
MP_INIT_E Returned if there is an error initializing an integer for use with the multiple precision integer (mp_int) library </dd>
<dd>
ASN_GETINT_E Returned if there is an error reading one of the provided RSA key elements, n or e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>pointer to a buffer containing the raw modulus parameter of the public RSA key </td></tr>
    <tr><td class="paramname">nSz</td><td>size of the buffer containing n </td></tr>
    <tr><td class="paramname">e</td><td>pointer to a buffer containing the raw exponent parameter of the public RSA key </td></tr>
    <tr><td class="paramname">eSz</td><td>size of the buffer containing e </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the RsaKey struct to initialize with the provided public key elements</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey pub;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">byte</span> n[] = { <span class="comment">// initialize with received n component of public key };</span></div>
<div class="line"><span class="keywordtype">byte</span> e[] = { <span class="comment">// initialize with received e component of public key };</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;pub, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga437b3432338f18022e9b62d109ce0518">wc_RsaPublicKeyDecodeRaw</a>(n, <span class="keyword">sizeof</span>(n), e, <span class="keyword">sizeof</span>(e), &amp;pub);</div>
<div class="line"><span class="keywordflow">if</span>( ret != 0 ) {</div>
<div class="line">    <span class="comment">// error parsing public key elements</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2610326206b322f33f59e31a845e24b9" title="This function parses a DER-formatted RSA public key, extracts the public key and stores it in the giv...">wc_RsaPublicKeyDecode</a> </dd></dl>

</div>
</div>
<a id="gab62eca8ad6726c5db562947e5e165a61" name="gab62eca8ad6726c5db562947e5e165a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab62eca8ad6726c5db562947e5e165a61">&#9670;&#160;</a></span>wc_RsaSetNonBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSetNonBlock </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaNb *</td>          <td class="paramname"><span class="paramname"><em>nb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the non-blocking RSA context. When a RsaNb context is set it enables fast math based non-blocking exptmod, which splits the RSA function into many smaller operations. Enabled when WC_RSA_NONBLOCK is defined. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned if key or nb is null.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The RSA key structure </td></tr>
    <tr><td class="paramname">nb</td><td>The RSA non-blocking structure for this RSA key to use.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret, count = 0;</div>
<div class="line">RsaKey key;</div>
<div class="line">RsaNb  nb;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable non-blocking RSA mode - provide context</span></div>
<div class="line">ret = <a class="code hl_function" href="#gab62eca8ad6726c5db562947e5e165a61">wc_RsaSetNonBlock</a>(key, &amp;nb);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">    ret = <a class="code hl_function" href="#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a>(in, inLen, out, outSz, key, rng);</div>
<div class="line">    count++; <span class="comment">// track number of would blocks</span></div>
<div class="line">    <span class="keywordflow">if</span> (ret == FP_WOULDBLOCK) {</div>
<div class="line">        <span class="comment">// do &quot;other&quot; work here</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">while</span> (ret == FP_WOULDBLOCK);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;RSA non-block sign: size %d, %d times\n&quot;</span>, ret, count);</div>
<div class="ttc" id="agroup__RSA_html_ga8299328ea8ddff961b79038bc97a4044"><div class="ttname"><a href="#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a></div><div class="ttdeci">int wc_RsaSSL_Sign(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key, WC_RNG *rng)</div><div class="ttdoc">Signs the provided array with the private key.</div></div>
<div class="ttc" id="agroup__RSA_html_gab62eca8ad6726c5db562947e5e165a61"><div class="ttname"><a href="#gab62eca8ad6726c5db562947e5e165a61">wc_RsaSetNonBlock</a></div><div class="ttdeci">int wc_RsaSetNonBlock(RsaKey *key, RsaNb *nb)</div><div class="ttdoc">This function sets the non-blocking RSA context. When a RsaNb context is set it enables fast math bas...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga623ecefb5f932cbdab21f9b777fa8ea9" title="This function configures the maximum amount of blocking time in microseconds. It uses a pre-computed ...">wc_RsaSetNonBlockTime</a> </dd></dl>

</div>
</div>
<a id="ga623ecefb5f932cbdab21f9b777fa8ea9" name="ga623ecefb5f932cbdab21f9b777fa8ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623ecefb5f932cbdab21f9b777fa8ea9">&#9670;&#160;</a></span>wc_RsaSetNonBlockTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSetNonBlockTime </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>maxBlockUs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>cpuMHz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the maximum amount of blocking time in microseconds. It uses a pre-computed table (see tfm.c exptModNbInst) along with the CPU speed in megahertz to determine if the next operation can be completed within the maximum blocking time provided. Enabled when WC_RSA_NONBLOCK_TIME is defined. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned if key is null or wc_RsaSetNonBlock was not previously called and key-&gt;nb is null.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The RSA key structure. </td></tr>
    <tr><td class="paramname">maxBlockUs</td><td>Maximum time to block microseconds. </td></tr>
    <tr><td class="paramname">cpuMHz</td><td>CPU speed in megahertz.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey key;</div>
<div class="line">RsaNb  nb;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><a class="code hl_function" href="#gab62eca8ad6726c5db562947e5e165a61">wc_RsaSetNonBlock</a>(key, &amp;nb);</div>
<div class="line"><a class="code hl_function" href="#ga623ecefb5f932cbdab21f9b777fa8ea9">wc_RsaSetNonBlockTime</a>(&amp;key, 4000, 160); <span class="comment">// Block Max = 4 ms, CPU = 160MHz</span></div>
<div class="ttc" id="agroup__RSA_html_ga623ecefb5f932cbdab21f9b777fa8ea9"><div class="ttname"><a href="#ga623ecefb5f932cbdab21f9b777fa8ea9">wc_RsaSetNonBlockTime</a></div><div class="ttdeci">int wc_RsaSetNonBlockTime(RsaKey *key, word32 maxBlockUs, word32 cpuMHz)</div><div class="ttdoc">This function configures the maximum amount of blocking time in microseconds. It uses a pre-computed ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab62eca8ad6726c5db562947e5e165a61" title="This function sets the non-blocking RSA context. When a RsaNb context is set it enables fast math bas...">wc_RsaSetNonBlock</a> </dd></dl>

</div>
</div>
<a id="gade0e7ccd93ec8c9e5ba5ded3e11b1226" name="gade0e7ccd93ec8c9e5ba5ded3e11b1226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">&#9670;&#160;</a></span>wc_RsaSetRNG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSetRNG </td>
          <td>(</td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon success </dd>
<dd>
BAD_FUNC_ARGS Returned if the RSA key, rng pointer evaluates to NULL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>pointer to the RsaKey structure to be associated </td></tr>
    <tr><td class="paramname">rng</td><td>pointer to the WC_RNG structure to associate with</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0) {</div>
<div class="line">    ret = <a class="code hl_function" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226">wc_RsaSetRNG</a>(&amp;key, &amp;rng);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga02c9b34d405c5f1c24956ee84a843ef6" title="This function initializes a provided RsaKey struct. It also takes in a heap identifier,...">wc_InitRsaKey</a> </dd>
<dd>
<a class="el" href="#gade0e7ccd93ec8c9e5ba5ded3e11b1226" title="This function associates RNG with Key. It is needed when WC_RSA_BLINDING is enabled.">wc_RsaSetRNG</a> </dd></dl>

</div>
</div>
<a id="ga8299328ea8ddff961b79038bc97a4044" name="ga8299328ea8ddff961b79038bc97a4044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8299328ea8ddff961b79038bc97a4044">&#9670;&#160;</a></span>wc_RsaSSL_Sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSSL_Sign </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signs the provided array with the private key. </p>
<dl class="section return"><dt>Returns</dt><dd>RSA_BUFFER_E: -131, RSA buffer error, output too small or input too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be encrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the encrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for encryption. </td></tr>
    <tr><td class="paramname">RNG</td><td>The RNG struct to use for random number purposes.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">memset(plain, 0, <span class="keyword">sizeof</span>(plain));</div>
<div class="line">ret = <a class="code hl_function" href="#ga1e996b7382fa0951cd5000d11fc4c0ea">wc_RsaSSL_Verify</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (ret != inLen) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (XMEMCMP(in, plain, ret) != 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga1e996b7382fa0951cd5000d11fc4c0ea"><div class="ttname"><a href="#ga1e996b7382fa0951cd5000d11fc4c0ea">wc_RsaSSL_Verify</a></div><div class="ttdeci">int wc_RsaSSL_Verify(const byte *in, word32 inLen, byte *out, word32 outLen, RsaKey *key)</div><div class="ttdoc">Used to verify that the message was signed by key.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_RsaPad </dd></dl>

</div>
</div>
<a id="ga1e996b7382fa0951cd5000d11fc4c0ea" name="ga1e996b7382fa0951cd5000d11fc4c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e996b7382fa0951cd5000d11fc4c0ea">&#9670;&#160;</a></span>wc_RsaSSL_Verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSSL_Verify </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to verify that the message was signed by key. </p>
<dl class="section return"><dt>Returns</dt><dd>Success Length of text on no error. </dd>
<dd>
MEMORY_E memory exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>The length of in. </td></tr>
    <tr><td class="paramname">out</td><td>The byte array for the decrypted data to be stored. </td></tr>
    <tr><td class="paramname">outLen</td><td>The length of out. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for verification.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ret = <a class="code hl_function" href="#ga8299328ea8ddff961b79038bc97a4044">wc_RsaSSL_Sign</a>(in, inLen, out, <span class="keyword">sizeof</span>(out), &amp;key, &amp;rng);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line">memset(plain, 0, <span class="keyword">sizeof</span>(plain));</div>
<div class="line">ret = <a class="code hl_function" href="#ga1e996b7382fa0951cd5000d11fc4c0ea">wc_RsaSSL_Verify</a>(out, ret, plain, <span class="keyword">sizeof</span>(plain), &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (ret != inLen) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (XMEMCMP(in, plain, ret) != 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8299328ea8ddff961b79038bc97a4044" title="Signs the provided array with the private key.">wc_RsaSSL_Sign</a> </dd></dl>

</div>
</div>
<a id="ga192d864bacce51770e774e304a343585" name="ga192d864bacce51770e774e304a343585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192d864bacce51770e774e304a343585">&#9670;&#160;</a></span>wc_RsaSSL_VerifyInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_RsaSSL_VerifyInline </td>
          <td>(</td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RsaKey *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to verify that the message was signed by RSA key. The output uses the same byte array as the input. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 Length of text. </dd>
<dd>
&lt;0 An error occurred.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Byte array to be decrypted. </td></tr>
    <tr><td class="paramname">inLen</td><td>Length of the buffer input. </td></tr>
    <tr><td class="paramname">out</td><td>Pointer to a pointer for decrypted information. </td></tr>
    <tr><td class="paramname">key</td><td>RsaKey to use.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">RsaKey key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret = 0;</div>
<div class="line"><span class="keywordtype">long</span> e = 65537; <span class="comment">// standard value to use for exponent</span></div>
<div class="line"><a class="code hl_function" href="#ga02c9b34d405c5f1c24956ee84a843ef6">wc_InitRsaKey</a>(&amp;key, NULL); <span class="comment">// not using heap hint. No custom memory</span></div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="#ga3f89eea8d56ae352730ffd49ec2fd68e">wc_MakeRsaKey</a>(&amp;key, 2048, e, &amp;rng);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> in[] = { <span class="comment">// Initialize with some RSA encrypted information }</span></div>
<div class="line"><span class="keywordtype">byte</span>* out;</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#ga192d864bacce51770e774e304a343585">wc_RsaSSL_VerifyInline</a>(in, <span class="keyword">sizeof</span>(in), &amp;out, &amp;key) &lt; 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__RSA_html_ga192d864bacce51770e774e304a343585"><div class="ttname"><a href="#ga192d864bacce51770e774e304a343585">wc_RsaSSL_VerifyInline</a></div><div class="ttdeci">int wc_RsaSSL_VerifyInline(byte *in, word32 inLen, byte **out, RsaKey *key)</div><div class="ttdoc">Used to verify that the message was signed by RSA key. The output uses the same byte array as the inp...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga1e996b7382fa0951cd5000d11fc4c0ea" title="Used to verify that the message was signed by key.">wc_RsaSSL_Verify</a> </dd>
<dd>
<a class="el" href="#ga8299328ea8ddff961b79038bc97a4044" title="Signs the provided array with the private key.">wc_RsaSSL_Sign</a> </dd></dl>

</div>
</div>
<a id="gab7adfab8cbc5cb3c7b2069bee6a975a3" name="gab7adfab8cbc5cb3c7b2069bee6a975a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7adfab8cbc5cb3c7b2069bee6a975a3">&#9670;&#160;</a></span>wc_SetKeyUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_SetKeyUsage </td>
          <td>(</td>
          <td class="paramtype">Cert *</td>          <td class="paramname"><span class="paramname"><em>cert</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows you to set the key usage using a comma delimited string of tokens. Accepted tokens are: digitalSignature, nonRepudiation, contentCommitment, keyCertSign, cRLSign, dataEncipherment, keyAgreement, keyEncipherment, encipherOnly, decipherOnly. Example: "digitalSignature,nonRepudiation" nonRepudiation and contentCommitment are for the same usage. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Success </dd>
<dd>
BAD_FUNC_ARG Returned when either arg is null. </dd>
<dd>
MEMORY_E Returned when there is an error allocating memory. </dd>
<dd>
KEYUSAGE_E Returned if an unrecognized token is entered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>Pointer to initialized Cert structure. </td></tr>
    <tr><td class="paramname">value</td><td>Comma delimited string of tokens to set usage.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">Cert cert;</div>
<div class="line"><a class="code hl_function" href="group__ASN.html#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a>(&amp;cert);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_function" href="#gab7adfab8cbc5cb3c7b2069bee6a975a3">wc_SetKeyUsage</a>(&amp;cert, <span class="stringliteral">&quot;cRLSign,keyCertSign&quot;</span>) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ASN_html_gacd9209218503a6aa6750307200d3de76"><div class="ttname"><a href="group__ASN.html#gacd9209218503a6aa6750307200d3de76">wc_InitCert</a></div><div class="ttdeci">int wc_InitCert(Cert *)</div><div class="ttdoc">This function initializes a default cert, with the default options: version = 3 (0x2),...</div></div>
<div class="ttc" id="agroup__RSA_html_gab7adfab8cbc5cb3c7b2069bee6a975a3"><div class="ttname"><a href="#gab7adfab8cbc5cb3c7b2069bee6a975a3">wc_SetKeyUsage</a></div><div class="ttdeci">int wc_SetKeyUsage(Cert *cert, const char *value)</div><div class="ttdoc">This function allows you to set the key usage using a comma delimited string of tokens....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ASN.html#gacd9209218503a6aa6750307200d3de76" title="This function initializes a default cert, with the default options: version = 3 (0x2),...">wc_InitCert</a> </dd>
<dd>
<a class="el" href="#ga3f89eea8d56ae352730ffd49ec2fd68e" title="This function generates a RSA private key of length size (in bits) and given exponent (e)....">wc_MakeRsaKey</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
