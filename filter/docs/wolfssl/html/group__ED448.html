<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>My Project: Algorithms - ED448</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="wolfssl_logo" style="width: 150px; height: 100px; display: inline-block;"><img alt="Logo" src="../images/wolfssl_logo.png" style="width: 150px; height: 100px;"/></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Algorithms - ED448 </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f6d0337ebe40382e584a4244df3dc4e" id="r_ga2f6d0337ebe40382e584a4244df3dc4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f6d0337ebe40382e584a4244df3dc4e">wc_ed448_make_public</a> (ed448_key *key, unsigned char *pubKey, word32 pubKeySz)</td></tr>
<tr class="memdesc:ga2f6d0337ebe40382e584a4244df3dc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates the Ed448 public key from the private key. It stores the public key in the buffer pubKey, and sets the bytes written to this buffer in pubKeySz.  <br /></td></tr>
<tr class="memitem:ga2c1c2f9106f86b26a6bce368971243c5" id="r_ga2c1c2f9106f86b26a6bce368971243c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a> (WC_RNG *rng, int keysize, ed448_key *key)</td></tr>
<tr class="memdesc:ga2c1c2f9106f86b26a6bce368971243c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a new Ed448 key and stores it in key.  <br /></td></tr>
<tr class="memitem:gafcc33d6e03d6fbd310521fbce27a97a2" id="r_gafcc33d6e03d6fbd310521fbce27a97a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafcc33d6e03d6fbd310521fbce27a97a2">wc_ed448_sign_msg</a> (const byte *in, word32 inlen, byte *out, word32 *outlen, ed448_key *key)</td></tr>
<tr class="memdesc:gafcc33d6e03d6fbd310521fbce27a97a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message using an ed448_key object to guarantee authenticity.  <br /></td></tr>
<tr class="memitem:gafb41ac8534081b76e3ac910d415e35f0" id="r_gafb41ac8534081b76e3ac910d415e35f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafb41ac8534081b76e3ac910d415e35f0">wc_ed448ph_sign_hash</a> (const byte *hash, word32 hashLen, byte *out, word32 *outLen, ed448_key *key, const byte *context, byte contextLen)</td></tr>
<tr class="memdesc:gafb41ac8534081b76e3ac910d415e35f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message digest using an ed448_key object to guarantee authenticity. The context is included as part of the data signed. The hash is the pre-hashed message before signature calculation.  <br /></td></tr>
<tr class="memitem:ga6fbfc3883a2c9d61afe1877be31aba99" id="r_ga6fbfc3883a2c9d61afe1877be31aba99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fbfc3883a2c9d61afe1877be31aba99">wc_ed448ph_sign_msg</a> (const byte *in, word32 inLen, byte *out, word32 *outLen, ed448_key *key, const byte *context, byte contextLen)</td></tr>
<tr class="memdesc:ga6fbfc3883a2c9d61afe1877be31aba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function signs a message using an ed448_key object to guarantee authenticity. The context is included as part of the data signed. The message is pre-hashed before signature calculation.  <br /></td></tr>
<tr class="memitem:gae2074aef588b6c8ce5ffb6fbc50dd17c" id="r_gae2074aef588b6c8ce5ffb6fbc50dd17c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2074aef588b6c8ce5ffb6fbc50dd17c">wc_ed448_verify_msg</a> (const byte *sig, word32 siglen, const byte *msg, word32 msgLen, int *res, ed448_key *key, const byte *context, byte contextLen)</td></tr>
<tr class="memdesc:gae2074aef588b6c8ce5ffb6fbc50dd17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the Ed448 signature of a message to ensure authenticity. The context is included as part of the data verified. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <br /></td></tr>
<tr class="memitem:gab430498dfd1b3431fc5ffc8a28306ea6" id="r_gab430498dfd1b3431fc5ffc8a28306ea6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab430498dfd1b3431fc5ffc8a28306ea6">wc_ed448ph_verify_hash</a> (const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *res, ed448_key *key, const byte *context, byte contextLen)</td></tr>
<tr class="memdesc:gab430498dfd1b3431fc5ffc8a28306ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the Ed448 signature of the digest of a message to ensure authenticity. The context is included as part of the data verified. The hash is the pre-hashed message before signature calculation. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <br /></td></tr>
<tr class="memitem:ga7b27adf9b70ee3e9a4bd6070a70a0f34" id="r_ga7b27adf9b70ee3e9a4bd6070a70a0f34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34">wc_ed448ph_verify_msg</a> (const byte *sig, word32 siglen, const byte *msg, word32 msgLen, int *res, ed448_key *key, const byte *context, byte contextLen)</td></tr>
<tr class="memdesc:ga7b27adf9b70ee3e9a4bd6070a70a0f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies the Ed448 signature of a message to ensure authenticity. The context is included as part of the data verified. The message is pre-hashed before verification. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature.  <br /></td></tr>
<tr class="memitem:ga913a5bc2a48b4dab46ec633bd5b4f51e" id="r_ga913a5bc2a48b4dab46ec633bd5b4f51e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a> (ed448_key *key)</td></tr>
<tr class="memdesc:ga913a5bc2a48b4dab46ec633bd5b4f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an ed448_key object for future use with message verification.  <br /></td></tr>
<tr class="memitem:ga9f98063a184323b113b818fa15b72427" id="r_ga9f98063a184323b113b818fa15b72427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f98063a184323b113b818fa15b72427">wc_ed448_free</a> (ed448_key *key)</td></tr>
<tr class="memdesc:ga9f98063a184323b113b818fa15b72427"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function frees an Ed448 object after it has been used.  <br /></td></tr>
<tr class="memitem:ga3d34e8461e4757ac01d6f2f94771dab2" id="r_ga3d34e8461e4757ac01d6f2f94771dab2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2">wc_ed448_import_public</a> (const byte *in, word32 inLen, ed448_key *key)</td></tr>
<tr class="memdesc:ga3d34e8461e4757ac01d6f2f94771dab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public ed448_key pair from a buffer containing the public key. This function will handle both compressed and uncompressed keys. The public key is checked that it matches the private key when one is present.  <br /></td></tr>
<tr class="memitem:ga6abc9eac0257b5b6d237d889e966a46a" id="r_ga6abc9eac0257b5b6d237d889e966a46a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a">wc_ed448_import_public_ex</a> (const byte *in, word32 inLen, ed448_key *key, int trusted)</td></tr>
<tr class="memdesc:ga6abc9eac0257b5b6d237d889e966a46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public ed448_key pair from a buffer containing the public key. This function will handle both compressed and uncompressed keys. Check public key matches private key, when present, when not trusted.  <br /></td></tr>
<tr class="memitem:ga5eef4174f40433eb710b3d349feb9260" id="r_ga5eef4174f40433eb710b3d349feb9260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5eef4174f40433eb710b3d349feb9260">wc_ed448_import_private_only</a> (const byte *priv, word32 privSz, ed448_key *key)</td></tr>
<tr class="memdesc:ga5eef4174f40433eb710b3d349feb9260"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports an Ed448 private key only from a buffer.  <br /></td></tr>
<tr class="memitem:ga51c4b2810825be0aab1d2680e1a8e2ed" id="r_ga51c4b2810825be0aab1d2680e1a8e2ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed">wc_ed448_import_private_key</a> (const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ed448_key *key)</td></tr>
<tr class="memdesc:ga51c4b2810825be0aab1d2680e1a8e2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public/private Ed448 key pair from a pair of buffers. This function will handle both compressed and uncompressed keys.  <br /></td></tr>
<tr class="memitem:ga5bbd08077b070e400c579d208e826d09" id="r_ga5bbd08077b070e400c579d208e826d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5bbd08077b070e400c579d208e826d09">wc_ed448_import_private_key_ex</a> (const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ed448_key *key, int trusted)</td></tr>
<tr class="memdesc:ga5bbd08077b070e400c579d208e826d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function imports a public/private Ed448 key pair from a pair of buffers. This function will handle both compressed and uncompressed keys. The public is checked against private key if not trusted.  <br /></td></tr>
<tr class="memitem:ga0752317068719b744014ef037942e5d7" id="r_ga0752317068719b744014ef037942e5d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0752317068719b744014ef037942e5d7">wc_ed448_export_public</a> (ed448_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:ga0752317068719b744014ef037942e5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the private key from an ed448_key structure. It stores the public key in the buffer out, and sets the bytes written to this buffer in outLen.  <br /></td></tr>
<tr class="memitem:ga7177e1daed42bd5941a674c02cd40b46" id="r_ga7177e1daed42bd5941a674c02cd40b46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7177e1daed42bd5941a674c02cd40b46">wc_ed448_export_private_only</a> (ed448_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:ga7177e1daed42bd5941a674c02cd40b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports only the private key from an ed448_key structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen.  <br /></td></tr>
<tr class="memitem:gad8f5f29b97e429e417b7172f97f39d8b" id="r_gad8f5f29b97e429e417b7172f97f39d8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8f5f29b97e429e417b7172f97f39d8b">wc_ed448_export_private</a> (ed448_key *key, byte *out, word32 *outLen)</td></tr>
<tr class="memdesc:gad8f5f29b97e429e417b7172f97f39d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer out, and sets the bytes written to this buffer in outLen.  <br /></td></tr>
<tr class="memitem:gafbd936e5a6b16f1d4efa1aee71e75589" id="r_gafbd936e5a6b16f1d4efa1aee71e75589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbd936e5a6b16f1d4efa1aee71e75589">wc_ed448_export_key</a> (ed448_key *key, byte *priv, word32 *privSz, byte *pub, word32 *pubSz)</td></tr>
<tr class="memdesc:gafbd936e5a6b16f1d4efa1aee71e75589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exports the private and public key separately from an ed448_key structure. It stores the private key in the buffer priv, and sets the bytes written to this buffer in privSz. It stores the public key in the buffer pub, and sets the bytes written to this buffer in pubSz.  <br /></td></tr>
<tr class="memitem:ga1f7829dbee3135351d27a2c9a81d2e24" id="r_ga1f7829dbee3135351d27a2c9a81d2e24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f7829dbee3135351d27a2c9a81d2e24">wc_ed448_check_key</a> (ed448_key *key)</td></tr>
<tr class="memdesc:ga1f7829dbee3135351d27a2c9a81d2e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the public key in ed448_key structure matches the private key.  <br /></td></tr>
<tr class="memitem:ga5029a0482b6f77e34893d19b3c077018" id="r_ga5029a0482b6f77e34893d19b3c077018"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5029a0482b6f77e34893d19b3c077018">wc_ed448_size</a> (ed448_key *key)</td></tr>
<tr class="memdesc:ga5029a0482b6f77e34893d19b3c077018"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the size of an Ed448 private key - 57 bytes.  <br /></td></tr>
<tr class="memitem:gad643b21a00b1c6e02b5a55d48f7896e6" id="r_gad643b21a00b1c6e02b5a55d48f7896e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad643b21a00b1c6e02b5a55d48f7896e6">wc_ed448_priv_size</a> (ed448_key *key)</td></tr>
<tr class="memdesc:gad643b21a00b1c6e02b5a55d48f7896e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the private key size (secret + public) in bytes.  <br /></td></tr>
<tr class="memitem:gafc4b0528fcae4f2bf37a955cf6e9443c" id="r_gafc4b0528fcae4f2bf37a955cf6e9443c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc4b0528fcae4f2bf37a955cf6e9443c">wc_ed448_pub_size</a> (ed448_key *key)</td></tr>
<tr class="memdesc:gafc4b0528fcae4f2bf37a955cf6e9443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the compressed key size in bytes (public key).  <br /></td></tr>
<tr class="memitem:ga10b1c6f80fd27720a28cd1433cacfb6a" id="r_ga10b1c6f80fd27720a28cd1433cacfb6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10b1c6f80fd27720a28cd1433cacfb6a">wc_ed448_sig_size</a> (ed448_key *key)</td></tr>
<tr class="memdesc:ga10b1c6f80fd27720a28cd1433cacfb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the size of an Ed448 signature (114 in bytes).  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga1f7829dbee3135351d27a2c9a81d2e24" name="ga1f7829dbee3135351d27a2c9a81d2e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7829dbee3135351d27a2c9a81d2e24">&#9670;&#160;</a></span>wc_ed448_check_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_check_key </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks the public key in ed448_key structure matches the private key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned if the private and public key matched. </dd>
<dd>
BAD_FUNC_ARGS Returned if the given key is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure holding a private and public key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with 57 <span class="keywordtype">byte</span> <span class="keyword">private</span> key };</div>
<div class="line"><span class="keywordtype">byte</span> pub[]  = { initialize with the corresponding <span class="keyword">public</span> key };</div>
<div class="line"> </div>
<div class="line">ed448_key key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line"><a class="code hl_function" href="#ga5bbd08077b070e400c579d208e826d09">wc_ed448_import_private_key_ex</a>(priv, <span class="keyword">sizeof</span>(priv), pub, <span class="keyword">sizeof</span>(pub), &amp;key,</div>
<div class="line">    1);</div>
<div class="line">ret = <a class="code hl_function" href="#ga1f7829dbee3135351d27a2c9a81d2e24">wc_ed448_check_key</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error checking key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga1f7829dbee3135351d27a2c9a81d2e24"><div class="ttname"><a href="#ga1f7829dbee3135351d27a2c9a81d2e24">wc_ed448_check_key</a></div><div class="ttdeci">int wc_ed448_check_key(ed448_key *key)</div><div class="ttdoc">This function checks the public key in ed448_key structure matches the private key.</div></div>
<div class="ttc" id="agroup__ED448_html_ga5bbd08077b070e400c579d208e826d09"><div class="ttname"><a href="#ga5bbd08077b070e400c579d208e826d09">wc_ed448_import_private_key_ex</a></div><div class="ttdeci">int wc_ed448_import_private_key_ex(const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ed448_key *key, int trusted)</div><div class="ttdoc">This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd></dl>

</div>
</div>
<a id="gafbd936e5a6b16f1d4efa1aee71e75589" name="gafbd936e5a6b16f1d4efa1aee71e75589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd936e5a6b16f1d4efa1aee71e75589">&#9670;&#160;</a></span>wc_ed448_export_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_export_key </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>privSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>pubSz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the private and public key separately from an ed448_key structure. It stores the private key in the buffer priv, and sets the bytes written to this buffer in privSz. It stores the public key in the buffer pub, and sets the bytes written to this buffer in pubSz. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the key pair. </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL. </dd>
<dd>
BUFFER_E Returned if the buffer provided is not large enough to store the key pair.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure from which to export the key pair. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priv</td><td>Pointer to the buffer in which to store the private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">privSz</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pub</td><td>Pointer to the buffer in which to store the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pubSz</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the public key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> pub[57];</div>
<div class="line">word32 pubSz = <span class="keyword">sizeof</span>(pub);</div>
<div class="line"><span class="keywordtype">char</span> priv[57];</div>
<div class="line">word32 privSz = <span class="keyword">sizeof</span>(priv);</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#gafbd936e5a6b16f1d4efa1aee71e75589">wc_ed448_export_key</a>(&amp;key, priv, &amp;pubSz, pub, &amp;pubSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting private and public key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_gafbd936e5a6b16f1d4efa1aee71e75589"><div class="ttname"><a href="#gafbd936e5a6b16f1d4efa1aee71e75589">wc_ed448_export_key</a></div><div class="ttdeci">int wc_ed448_export_key(ed448_key *key, byte *priv, word32 *privSz, byte *pub, word32 *pubSz)</div><div class="ttdoc">This function exports the private and public key separately from an ed448_key structure....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad8f5f29b97e429e417b7172f97f39d8b" title="This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer ...">wc_ed448_export_private</a> </dd>
<dd>
<a class="el" href="#ga0752317068719b744014ef037942e5d7" title="This function exports the private key from an ed448_key structure. It stores the public key in the bu...">wc_ed448_export_public</a> </dd></dl>

</div>
</div>
<a id="gad8f5f29b97e429e417b7172f97f39d8b" name="gad8f5f29b97e429e417b7172f97f39d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f5f29b97e429e417b7172f97f39d8b">&#9670;&#160;</a></span>wc_ed448_export_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_export_private </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer out, and sets the bytes written to this buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the key pair. </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL. </dd>
<dd>
BUFFER_E Returned if the buffer provided is not large enough to store the key pair.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure from which to export the key pair. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to the buffer in which to store the key pair. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outLen</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the key pair.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
<div class="line"> </div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// initialize 57 byte Ed448 key</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> out[114]; <span class="comment">// out needs to be a sufficient buffer size</span></div>
<div class="line">word32 outLen = <span class="keyword">sizeof</span>(out);</div>
<div class="line"><span class="keywordtype">int</span> key_size = <a class="code hl_function" href="#gad8f5f29b97e429e417b7172f97f39d8b">wc_ed448_export_private</a>(&amp;key, out, &amp;outLen);</div>
<div class="line"><span class="keywordflow">if</span> (key_size == BUFFER_E) {</div>
<div class="line">    <span class="comment">// Check size of out compared to outLen to see if function reset outLen</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga2c1c2f9106f86b26a6bce368971243c5"><div class="ttname"><a href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a></div><div class="ttdeci">int wc_ed448_make_key(WC_RNG *rng, int keysize, ed448_key *key)</div><div class="ttdoc">This function generates a new Ed448 key and stores it in key.</div></div>
<div class="ttc" id="agroup__ED448_html_ga913a5bc2a48b4dab46ec633bd5b4f51e"><div class="ttname"><a href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a></div><div class="ttdeci">int wc_ed448_init(ed448_key *key)</div><div class="ttdoc">This function initializes an ed448_key object for future use with message verification.</div></div>
<div class="ttc" id="agroup__ED448_html_gad8f5f29b97e429e417b7172f97f39d8b"><div class="ttname"><a href="#gad8f5f29b97e429e417b7172f97f39d8b">wc_ed448_export_private</a></div><div class="ttdeci">int wc_ed448_export_private(ed448_key *key, byte *out, word32 *outLen)</div><div class="ttdoc">This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer ...</div></div>
<div class="ttc" id="agroup__Random_html_ga1a87307fac65d3c2a47ffb743020f83c"><div class="ttname"><a href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a></div><div class="ttdeci">int wc_InitRng(WC_RNG *)</div><div class="ttdoc">Gets the seed (from OS) and key cipher for rng. rng-&gt;drbg (deterministic random bit generator) alloca...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>wc_ed448_import_private </dd>
<dd>
<a class="el" href="#ga7177e1daed42bd5941a674c02cd40b46" title="This function exports only the private key from an ed448_key structure. It stores the private key in ...">wc_ed448_export_private_only</a> </dd></dl>

</div>
</div>
<a id="ga7177e1daed42bd5941a674c02cd40b46" name="ga7177e1daed42bd5941a674c02cd40b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7177e1daed42bd5941a674c02cd40b46">&#9670;&#160;</a></span>wc_ed448_export_private_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_export_private_only </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports only the private key from an ed448_key structure. It stores the private key in the buffer out, and sets the bytes written to this buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the private key. </dd>
<dd>
ECC_BAD_ARG_E Returned if any of the input values evaluate to NULL. </dd>
<dd>
BUFFER_E Returned if the buffer provided is not large enough to store the private key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure from which to export the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to the buffer in which to store the private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outLen</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the private key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> priv[57]; <span class="comment">// 57 bytes because only private key</span></div>
<div class="line">word32 privSz = <span class="keyword">sizeof</span>(priv);</div>
<div class="line">ret = <a class="code hl_function" href="#ga7177e1daed42bd5941a674c02cd40b46">wc_ed448_export_private_only</a>(&amp;key, priv, &amp;privSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga7177e1daed42bd5941a674c02cd40b46"><div class="ttname"><a href="#ga7177e1daed42bd5941a674c02cd40b46">wc_ed448_export_private_only</a></div><div class="ttdeci">int wc_ed448_export_private_only(ed448_key *key, byte *out, word32 *outLen)</div><div class="ttdoc">This function exports only the private key from an ed448_key structure. It stores the private key in ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga0752317068719b744014ef037942e5d7" title="This function exports the private key from an ed448_key structure. It stores the public key in the bu...">wc_ed448_export_public</a> </dd>
<dd>
<a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd></dl>

</div>
</div>
<a id="ga0752317068719b744014ef037942e5d7" name="ga0752317068719b744014ef037942e5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0752317068719b744014ef037942e5d7">&#9670;&#160;</a></span>wc_ed448_export_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_export_public </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exports the private key from an ed448_key structure. It stores the public key in the buffer out, and sets the bytes written to this buffer in outLen. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully exporting the public key. </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input values evaluate to NULL. </dd>
<dd>
BUFFER_E Returned if the buffer provided is not large enough to store the private key. Upon returning this error, the function sets the size required in outLen.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure from which to export the public key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to the buffer in which to store the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outLen</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the public key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> pub[57];</div>
<div class="line">word32 pubSz = <span class="keyword">sizeof</span>(pub);</div>
<div class="line"> </div>
<div class="line">ret = <a class="code hl_function" href="#ga0752317068719b744014ef037942e5d7">wc_ed448_export_public</a>(&amp;key, pub, &amp;pubSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error exporting public key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga0752317068719b744014ef037942e5d7"><div class="ttname"><a href="#ga0752317068719b744014ef037942e5d7">wc_ed448_export_public</a></div><div class="ttdeci">int wc_ed448_export_public(ed448_key *key, byte *out, word32 *outLen)</div><div class="ttdoc">This function exports the private key from an ed448_key structure. It stores the public key in the bu...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public</a> </dd>
<dd>
<a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public_ex</a> </dd>
<dd>
<a class="el" href="#ga7177e1daed42bd5941a674c02cd40b46" title="This function exports only the private key from an ed448_key structure. It stores the private key in ...">wc_ed448_export_private_only</a> </dd></dl>

</div>
</div>
<a id="ga9f98063a184323b113b818fa15b72427" name="ga9f98063a184323b113b818fa15b72427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f98063a184323b113b818fa15b72427">&#9670;&#160;</a></span>wc_ed448_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wc_ed448_free </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function frees an Ed448 object after it has been used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object to free</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key and perform secure exchanges</span></div>
<div class="line">...</div>
<div class="line">wc_ed448_free(&amp;key);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e" title="This function initializes an ed448_key object for future use with message verification.">wc_ed448_init</a> </dd></dl>

</div>
</div>
<a id="ga51c4b2810825be0aab1d2680e1a8e2ed" name="ga51c4b2810825be0aab1d2680e1a8e2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c4b2810825be0aab1d2680e1a8e2ed">&#9670;&#160;</a></span>wc_ed448_import_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_import_private_key </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>privSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>pubSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public/private Ed448 key pair from a pair of buffers. This function will handle both compressed and uncompressed keys. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the Ed448 key. </dd>
<dd>
BAD_FUNC_ARG Returned if in or key evaluate to NULL, or if either privSz is less than ED448_KEY_SIZE or pubSz is less than ED448_PUB_KEY_SIZE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">priv</td><td>Pointer to the buffer containing the private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">privSz</td><td>Length of the private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pub</td><td>Pointer to the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pubSz</td><td>Length of the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object in which to store the imported private/public key pair.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with 57 <span class="keywordtype">byte</span> <span class="keyword">private</span> key };</div>
<div class="line"><span class="keywordtype">byte</span> pub[]  = { initialize with the corresponding <span class="keyword">public</span> key };</div>
<div class="line"> </div>
<div class="line">ed448_key key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga51c4b2810825be0aab1d2680e1a8e2ed">wc_ed448_import_private_key</a>(priv, <span class="keyword">sizeof</span>(priv), pub, <span class="keyword">sizeof</span>(pub),</div>
<div class="line">        &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga51c4b2810825be0aab1d2680e1a8e2ed"><div class="ttname"><a href="#ga51c4b2810825be0aab1d2680e1a8e2ed">wc_ed448_import_private_key</a></div><div class="ttdeci">int wc_ed448_import_private_key(const byte *priv, word32 privSz, const byte *pub, word32 pubSz, ed448_key *key)</div><div class="ttdoc">This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public</a> </dd>
<dd>
<a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public_ex</a> </dd>
<dd>
<a class="el" href="#ga5eef4174f40433eb710b3d349feb9260" title="This function imports an Ed448 private key only from a buffer.">wc_ed448_import_private_only</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd>
<dd>
<a class="el" href="#gad8f5f29b97e429e417b7172f97f39d8b" title="This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer ...">wc_ed448_export_private</a> </dd></dl>

</div>
</div>
<a id="ga5bbd08077b070e400c579d208e826d09" name="ga5bbd08077b070e400c579d208e826d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bbd08077b070e400c579d208e826d09">&#9670;&#160;</a></span>wc_ed448_import_private_key_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_import_private_key_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>privSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>pub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>pubSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>trusted</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public/private Ed448 key pair from a pair of buffers. This function will handle both compressed and uncompressed keys. The public is checked against private key if not trusted. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the Ed448 key. </dd>
<dd>
BAD_FUNC_ARG Returned if in or key evaluate to NULL, or if either privSz is less than ED448_KEY_SIZE or pubSz is less than ED448_PUB_KEY_SIZE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">priv</td><td>Pointer to the buffer containing the private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">privSz</td><td>Length of the private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pub</td><td>Pointer to the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pubSz</td><td>Length of the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object in which to store the imported private/public key pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trusted</td><td>Public key data is trusted or not.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with 57 <span class="keywordtype">byte</span> <span class="keyword">private</span> key };</div>
<div class="line"><span class="keywordtype">byte</span> pub[]  = { initialize with the corresponding <span class="keyword">public</span> key };</div>
<div class="line"> </div>
<div class="line">ed448_key key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga5bbd08077b070e400c579d208e826d09">wc_ed448_import_private_key_ex</a>(priv, <span class="keyword">sizeof</span>(priv), pub, <span class="keyword">sizeof</span>(pub),</div>
<div class="line">        &amp;key, 1);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public</a> </dd>
<dd>
<a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public_ex</a> </dd>
<dd>
<a class="el" href="#ga5eef4174f40433eb710b3d349feb9260" title="This function imports an Ed448 private key only from a buffer.">wc_ed448_import_private_only</a> </dd>
<dd>
<a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#gad8f5f29b97e429e417b7172f97f39d8b" title="This function exports the key pair from an ed448_key structure. It stores the key pair in the buffer ...">wc_ed448_export_private</a> </dd></dl>

</div>
</div>
<a id="ga5eef4174f40433eb710b3d349feb9260" name="ga5eef4174f40433eb710b3d349feb9260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eef4174f40433eb710b3d349feb9260">&#9670;&#160;</a></span>wc_ed448_import_private_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_import_private_only </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>priv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>privSz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports an Ed448 private key only from a buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the Ed448 private key. </dd>
<dd>
BAD_FUNC_ARG Returned if in or key evaluate to NULL, or if privSz is less than ED448_KEY_SIZE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">priv</td><td>Pointer to the buffer containing the private key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">privSz</td><td>Length of the private key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object in which to store the imported private key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with 57 <span class="keywordtype">byte</span> <span class="keyword">private</span> key };</div>
<div class="line"> </div>
<div class="line">ed448_key key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga5eef4174f40433eb710b3d349feb9260">wc_ed448_import_private_only</a>(priv, <span class="keyword">sizeof</span>(priv), &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error importing private key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga5eef4174f40433eb710b3d349feb9260"><div class="ttname"><a href="#ga5eef4174f40433eb710b3d349feb9260">wc_ed448_import_private_only</a></div><div class="ttdeci">int wc_ed448_import_private_only(const byte *priv, word32 privSz, ed448_key *key)</div><div class="ttdoc">This function imports an Ed448 private key only from a buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public</a> </dd>
<dd>
<a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public_ex</a> </dd>
<dd>
<a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd>
<dd>
<a class="el" href="#ga7177e1daed42bd5941a674c02cd40b46" title="This function exports only the private key from an ed448_key structure. It stores the private key in ...">wc_ed448_export_private_only</a> </dd></dl>

</div>
</div>
<a id="ga3d34e8461e4757ac01d6f2f94771dab2" name="ga3d34e8461e4757ac01d6f2f94771dab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d34e8461e4757ac01d6f2f94771dab2">&#9670;&#160;</a></span>wc_ed448_import_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_import_public </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public ed448_key pair from a buffer containing the public key. This function will handle both compressed and uncompressed keys. The public key is checked that it matches the private key when one is present. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the ed448_key. </dd>
<dd>
BAD_FUNC_ARG Returned if in or key evaluate to NULL, or inLen is less than the size of an Ed448 key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Pointer to the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inLen</td><td>Length of the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object in which to store the public key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> pub[] = { initialize Ed448 <span class="keyword">public</span> key };</div>
<div class="line"> </div>
<div class="line">ed_448 key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga3d34e8461e4757ac01d6f2f94771dab2">wc_ed448_import_public</a>(pub, <span class="keyword">sizeof</span>(pub), &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga3d34e8461e4757ac01d6f2f94771dab2"><div class="ttname"><a href="#ga3d34e8461e4757ac01d6f2f94771dab2">wc_ed448_import_public</a></div><div class="ttdeci">int wc_ed448_import_public(const byte *in, word32 inLen, ed448_key *key)</div><div class="ttdoc">This function imports a public ed448_key pair from a buffer containing the public key....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6abc9eac0257b5b6d237d889e966a46a" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public_ex</a> </dd>
<dd>
<a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd>
<dd>
<a class="el" href="#ga0752317068719b744014ef037942e5d7" title="This function exports the private key from an ed448_key structure. It stores the public key in the bu...">wc_ed448_export_public</a> </dd></dl>

</div>
</div>
<a id="ga6abc9eac0257b5b6d237d889e966a46a" name="ga6abc9eac0257b5b6d237d889e966a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6abc9eac0257b5b6d237d889e966a46a">&#9670;&#160;</a></span>wc_ed448_import_public_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_import_public_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>trusted</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function imports a public ed448_key pair from a buffer containing the public key. This function will handle both compressed and uncompressed keys. Check public key matches private key, when present, when not trusted. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned on successfully importing the ed448_key. </dd>
<dd>
BAD_FUNC_ARG Returned if in or key evaluate to NULL, or inLen is less than the size of an Ed448 key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Pointer to the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inLen</td><td>Length of the buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object in which to store the public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trusted</td><td>Public key data is trusted or not.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"><span class="keywordtype">byte</span> pub[] = { initialize Ed448 <span class="keyword">public</span> key };</div>
<div class="line"> </div>
<div class="line">ed_448 key;</div>
<div class="line">wc_ed448_init_key(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga6abc9eac0257b5b6d237d889e966a46a">wc_ed448_import_public_ex</a>(pub, <span class="keyword">sizeof</span>(pub), &amp;key, 1);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error importing key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga6abc9eac0257b5b6d237d889e966a46a"><div class="ttname"><a href="#ga6abc9eac0257b5b6d237d889e966a46a">wc_ed448_import_public_ex</a></div><div class="ttdeci">int wc_ed448_import_public_ex(const byte *in, word32 inLen, ed448_key *key, int trusted)</div><div class="ttdoc">This function imports a public ed448_key pair from a buffer containing the public key....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3d34e8461e4757ac01d6f2f94771dab2" title="This function imports a public ed448_key pair from a buffer containing the public key....">wc_ed448_import_public</a> </dd>
<dd>
<a class="el" href="#ga51c4b2810825be0aab1d2680e1a8e2ed" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key</a> </dd>
<dd>
<a class="el" href="#ga5bbd08077b070e400c579d208e826d09" title="This function imports a public/private Ed448 key pair from a pair of buffers. This function will hand...">wc_ed448_import_private_key_ex</a> </dd>
<dd>
<a class="el" href="#ga0752317068719b744014ef037942e5d7" title="This function exports the private key from an ed448_key structure. It stores the public key in the bu...">wc_ed448_export_public</a> </dd></dl>

</div>
</div>
<a id="ga913a5bc2a48b4dab46ec633bd5b4f51e" name="ga913a5bc2a48b4dab46ec633bd5b4f51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">&#9670;&#160;</a></span>wc_ed448_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_init </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an ed448_key object for future use with message verification. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully initializing the ed448_key object. </dd>
<dd>
BAD_FUNC_ARG Returned if key is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key object to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2c1c2f9106f86b26a6bce368971243c5" title="This function generates a new Ed448 key and stores it in key.">wc_ed448_make_key</a> </dd>
<dd>
<a class="el" href="#ga9f98063a184323b113b818fa15b72427" title="This function frees an Ed448 object after it has been used.">wc_ed448_free</a> </dd></dl>

</div>
</div>
<a id="ga2c1c2f9106f86b26a6bce368971243c5" name="ga2c1c2f9106f86b26a6bce368971243c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c1c2f9106f86b26a6bce368971243c5">&#9670;&#160;</a></span>wc_ed448_make_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_make_key </td>
          <td>(</td>
          <td class="paramtype">WC_RNG *</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>keysize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a new Ed448 key and stores it in key. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully making an ed448_key. </dd>
<dd>
BAD_FUNC_ARG Returned if rng or key evaluate to NULL, or if the specified key size is not 57 bytes (Ed448 has 57 byte keys). </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory during function execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rng</td><td>Pointer to an initialized RNG object with which to generate the key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysize</td><td>Length of key to generate. Should always be 57 for Ed448. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td>Pointer to the ed448_key for which to generate a key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line">WC_RNG rng;</div>
<div class="line">ed448_key key;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error making key</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e" title="This function initializes an ed448_key object for future use with message verification.">wc_ed448_init</a> </dd></dl>

</div>
</div>
<a id="ga2f6d0337ebe40382e584a4244df3dc4e" name="ga2f6d0337ebe40382e584a4244df3dc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6d0337ebe40382e584a4244df3dc4e">&#9670;&#160;</a></span>wc_ed448_make_public()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_make_public </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>pubKey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>pubKeySz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates the Ed448 public key from the private key. It stores the public key in the buffer pubKey, and sets the bytes written to this buffer in pubKeySz. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully making the public key. </dd>
<dd>
BAD_FUNC_ARG Returned ifi key or pubKey evaluate to NULL, or if the specified key size is not 57 bytes (Ed448 has 57 byte keys). </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory during function execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to the ed448_key for which to generate a key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to the buffer in which to store the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outLen</td><td>Pointer to a word32 object with the size available in out. Set with the number of bytes written to out after successfully exporting the public key.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret;</div>
<div class="line"> </div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="keywordtype">byte</span> priv[] = { initialize with 57 <span class="keywordtype">byte</span> <span class="keyword">private</span> key };</div>
<div class="line"><span class="keywordtype">byte</span> pub[57];</div>
<div class="line">word32 pubSz = <span class="keyword">sizeof</span>(pub);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
<div class="line"><a class="code hl_function" href="#ga5eef4174f40433eb710b3d349feb9260">wc_ed448_import_private_only</a>(priv, <span class="keyword">sizeof</span>(priv), &amp;key);</div>
<div class="line">ret = <a class="code hl_function" href="#ga2f6d0337ebe40382e584a4244df3dc4e">wc_ed448_make_public</a>(&amp;key, pub, &amp;pubSz);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error making public key</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga2f6d0337ebe40382e584a4244df3dc4e"><div class="ttname"><a href="#ga2f6d0337ebe40382e584a4244df3dc4e">wc_ed448_make_public</a></div><div class="ttdeci">int wc_ed448_make_public(ed448_key *key, unsigned char *pubKey, word32 pubKeySz)</div><div class="ttdoc">This function generates the Ed448 public key from the private key. It stores the public key in the bu...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e" title="This function initializes an ed448_key object for future use with message verification.">wc_ed448_init</a> </dd>
<dd>
<a class="el" href="#ga5eef4174f40433eb710b3d349feb9260" title="This function imports an Ed448 private key only from a buffer.">wc_ed448_import_private_only</a> </dd>
<dd>
<a class="el" href="#ga2c1c2f9106f86b26a6bce368971243c5" title="This function generates a new Ed448 key and stores it in key.">wc_ed448_make_key</a> </dd></dl>

</div>
</div>
<a id="gad643b21a00b1c6e02b5a55d48f7896e6" name="gad643b21a00b1c6e02b5a55d48f7896e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad643b21a00b1c6e02b5a55d48f7896e6">&#9670;&#160;</a></span>wc_ed448_priv_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_priv_size </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the private key size (secret + public) in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>ED448_PRV_KEY_SIZE The size of the private key (114 bytes). </dd>
<dd>
BAD_FUNC_ARG Returns if key argument is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure for which to get the key size.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
<div class="line"> </div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// initialize 57 byte Ed448 key</span></div>
<div class="line"><span class="keywordtype">int</span> key_size = <a class="code hl_function" href="#gad643b21a00b1c6e02b5a55d48f7896e6">wc_ed448_priv_size</a>(&amp;key);</div>
<div class="ttc" id="agroup__ED448_html_gad643b21a00b1c6e02b5a55d48f7896e6"><div class="ttname"><a href="#gad643b21a00b1c6e02b5a55d48f7896e6">wc_ed448_priv_size</a></div><div class="ttdeci">int wc_ed448_priv_size(ed448_key *key)</div><div class="ttdoc">This function returns the private key size (secret + public) in bytes.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafc4b0528fcae4f2bf37a955cf6e9443c" title="This function returns the compressed key size in bytes (public key).">wc_ed448_pub_size</a> </dd></dl>

</div>
</div>
<a id="gafc4b0528fcae4f2bf37a955cf6e9443c" name="gafc4b0528fcae4f2bf37a955cf6e9443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc4b0528fcae4f2bf37a955cf6e9443c">&#9670;&#160;</a></span>wc_ed448_pub_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_pub_size </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the compressed key size in bytes (public key). </p>
<dl class="section return"><dt>Returns</dt><dd>ED448_PUB_KEY_SIZE The size of the compressed public key (57 bytes). </dd>
<dd>
BAD_FUNC_ARG Returns if key argument is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure for which to get the key size.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key);</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// initialize 57 byte Ed448 key</span></div>
<div class="line"><span class="keywordtype">int</span> key_size = <a class="code hl_function" href="#gafc4b0528fcae4f2bf37a955cf6e9443c">wc_ed448_pub_size</a>(&amp;key);</div>
<div class="ttc" id="agroup__ED448_html_gafc4b0528fcae4f2bf37a955cf6e9443c"><div class="ttname"><a href="#gafc4b0528fcae4f2bf37a955cf6e9443c">wc_ed448_pub_size</a></div><div class="ttdeci">int wc_ed448_pub_size(ed448_key *key)</div><div class="ttdoc">This function returns the compressed key size in bytes (public key).</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad643b21a00b1c6e02b5a55d48f7896e6" title="This function returns the private key size (secret + public) in bytes.">wc_ed448_priv_size</a> </dd></dl>

</div>
</div>
<a id="ga10b1c6f80fd27720a28cd1433cacfb6a" name="ga10b1c6f80fd27720a28cd1433cacfb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b1c6f80fd27720a28cd1433cacfb6a">&#9670;&#160;</a></span>wc_ed448_sig_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_sig_size </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the size of an Ed448 signature (114 in bytes). </p>
<dl class="section return"><dt>Returns</dt><dd>ED448_SIG_SIZE The size of an Ed448 signature (114 bytes). </dd>
<dd>
BAD_FUNC_ARG Returns if key argument is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure for which to get the signature size.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sigSz;</div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line"> </div>
<div class="line">sigSz = <a class="code hl_function" href="#ga10b1c6f80fd27720a28cd1433cacfb6a">wc_ed448_sig_size</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (sigSz == 0) {</div>
<div class="line">    <span class="comment">// error determining sig size</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga10b1c6f80fd27720a28cd1433cacfb6a"><div class="ttname"><a href="#ga10b1c6f80fd27720a28cd1433cacfb6a">wc_ed448_sig_size</a></div><div class="ttdeci">int wc_ed448_sig_size(ed448_key *key)</div><div class="ttdoc">This function returns the size of an Ed448 signature (114 in bytes).</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafcc33d6e03d6fbd310521fbce27a97a2" title="This function signs a message using an ed448_key object to guarantee authenticity.">wc_ed448_sign_msg</a> </dd></dl>

</div>
</div>
<a id="gafcc33d6e03d6fbd310521fbce27a97a2" name="gafcc33d6e03d6fbd310521fbce27a97a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcc33d6e03d6fbd310521fbce27a97a2">&#9670;&#160;</a></span>wc_ed448_sign_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_sign_msg </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs a message using an ed448_key object to guarantee authenticity. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a signature for the message. </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory during function execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Pointer to the buffer containing the message to sign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inlen</td><td>Length of the message to sign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Buffer in which to store the generated signature. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outlen</td><td>Maximum length of the output buffer. Will store the bytes written to out upon successfully generating a message signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a private ed448_key with which to generate the signature.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret, sigSz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[114]; <span class="comment">// will hold generated signature</span></div>
<div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line"><span class="keywordtype">byte</span> message[] = { initialize with message };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// make public/private key pair</span></div>
<div class="line">ret = <a class="code hl_function" href="#gafcc33d6e03d6fbd310521fbce27a97a2">wc_ed448_sign_msg</a>(message, <span class="keyword">sizeof</span>(message), sig, &amp;sigSz, &amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0 ) {</div>
<div class="line">    <span class="comment">// error generating message signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_gafcc33d6e03d6fbd310521fbce27a97a2"><div class="ttname"><a href="#gafcc33d6e03d6fbd310521fbce27a97a2">wc_ed448_sign_msg</a></div><div class="ttdeci">int wc_ed448_sign_msg(const byte *in, word32 inlen, byte *out, word32 *outlen, ed448_key *key)</div><div class="ttdoc">This function signs a message using an ed448_key object to guarantee authenticity.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafb41ac8534081b76e3ac910d415e35f0" title="This function signs a message digest using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_hash</a> </dd>
<dd>
<a class="el" href="#ga6fbfc3883a2c9d61afe1877be31aba99" title="This function signs a message using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_msg</a> </dd>
<dd>
<a class="el" href="#gae2074aef588b6c8ce5ffb6fbc50dd17c" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448_verify_msg</a> </dd></dl>

</div>
</div>
<a id="ga5029a0482b6f77e34893d19b3c077018" name="ga5029a0482b6f77e34893d19b3c077018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5029a0482b6f77e34893d19b3c077018">&#9670;&#160;</a></span>wc_ed448_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_size </td>
          <td>(</td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the size of an Ed448 private key - 57 bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>ED448_KEY_SIZE The size of a valid private key (57 bytes). </dd>
<dd>
BAD_FUNC_ARGS Returned if the given key is NULL.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to an ed448_key structure for which to get the key size.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> keySz;</div>
<div class="line">ed448_key key;</div>
<div class="line"><span class="comment">// initialize key, make key</span></div>
<div class="line">keySz = <a class="code hl_function" href="#ga5029a0482b6f77e34893d19b3c077018">wc_ed448_size</a>(&amp;key);</div>
<div class="line"><span class="keywordflow">if</span> (keySz == 0) {</div>
<div class="line">    <span class="comment">// error determining key size</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga5029a0482b6f77e34893d19b3c077018"><div class="ttname"><a href="#ga5029a0482b6f77e34893d19b3c077018">wc_ed448_size</a></div><div class="ttdeci">int wc_ed448_size(ed448_key *key)</div><div class="ttdoc">This function returns the size of an Ed448 private key - 57 bytes.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2c1c2f9106f86b26a6bce368971243c5" title="This function generates a new Ed448 key and stores it in key.">wc_ed448_make_key</a> </dd></dl>

</div>
</div>
<a id="gae2074aef588b6c8ce5ffb6fbc50dd17c" name="gae2074aef588b6c8ce5ffb6fbc50dd17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2074aef588b6c8ce5ffb6fbc50dd17c">&#9670;&#160;</a></span>wc_ed448_verify_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448_verify_msg </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>msgLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>contextLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the Ed448 signature of a message to ensure authenticity. The context is included as part of the data verified. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully performing the signature verification and authentication. </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the siglen does not match the actual length of a signature. </dd>
<dd>
SIG_VERIFY_E Returned if verification completes, but the signature generated does not match the signature provided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Pointer to the buffer containing the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">siglen</td><td>Length of the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the buffer containing the message to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Length of the message to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a public Ed448 key with which to verify the signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the buffer containing the context for which the message was signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextLen</td><td>Length of the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><span class="keywordtype">int</span> ret, verified = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[] { initialize with received signature };</div>
<div class="line"><span class="keywordtype">byte</span> msg[] = { initialize with message };</div>
<div class="line"><span class="keywordtype">byte</span> context[] = { initialize with context of signature };</div>
<div class="line"><span class="comment">// initialize key with received public key</span></div>
<div class="line">ret = <a class="code hl_function" href="#gae2074aef588b6c8ce5ffb6fbc50dd17c">wc_ed448_verify_msg</a>(sig, <span class="keyword">sizeof</span>(sig), msg, <span class="keyword">sizeof</span>(msg), &amp;verified,</div>
<div class="line">        &amp;key, context, <span class="keyword">sizeof</span>(context));</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// error performing verification</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (verified == 0)</div>
<div class="line">    <span class="comment">// the signature is invalid</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_gae2074aef588b6c8ce5ffb6fbc50dd17c"><div class="ttname"><a href="#gae2074aef588b6c8ce5ffb6fbc50dd17c">wc_ed448_verify_msg</a></div><div class="ttdeci">int wc_ed448_verify_msg(const byte *sig, word32 siglen, const byte *msg, word32 msgLen, int *res, ed448_key *key, const byte *context, byte contextLen)</div><div class="ttdoc">This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gab430498dfd1b3431fc5ffc8a28306ea6" title="This function verifies the Ed448 signature of the digest of a message to ensure authenticity....">wc_ed448ph_verify_hash</a> </dd>
<dd>
<a class="el" href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448ph_verify_msg</a> </dd>
<dd>
<a class="el" href="#gafcc33d6e03d6fbd310521fbce27a97a2" title="This function signs a message using an ed448_key object to guarantee authenticity.">wc_ed448_sign_msg</a> </dd></dl>

</div>
</div>
<a id="gafb41ac8534081b76e3ac910d415e35f0" name="gafb41ac8534081b76e3ac910d415e35f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb41ac8534081b76e3ac910d415e35f0">&#9670;&#160;</a></span>wc_ed448ph_sign_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448ph_sign_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>contextLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs a message digest using an ed448_key object to guarantee authenticity. The context is included as part of the data signed. The hash is the pre-hashed message before signature calculation. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a signature for the message digest. </dd>
<dd>
BAD_FUNC_ARG Returned any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory during function execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Pointer to the buffer containing the hash of the message to sign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashLen</td><td>Length of the hash of the message to sign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Buffer in which to store the generated signature. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outlen</td><td>Maximum length of the output buffer. Will store the bytes written to out upon successfully generating a message signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a private ed448_key with which to generate the signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the buffer containing the context for which message is being signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextLen</td><td>Length of the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret, sigSz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[114]; <span class="comment">// will hold generated signature</span></div>
<div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line"><span class="keywordtype">byte</span> hash[] = { initialize hash of message };</div>
<div class="line"><span class="keywordtype">byte</span> context[] = { initialize with context of signing };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// make public/private key pair</span></div>
<div class="line">ret = <a class="code hl_function" href="#gafb41ac8534081b76e3ac910d415e35f0">wc_ed448ph_sign_hash</a>(hash, <span class="keyword">sizeof</span>(hash), sig, &amp;sigSz, &amp;key,</div>
<div class="line">        context, <span class="keyword">sizeof</span>(context));</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error generating message signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_gafb41ac8534081b76e3ac910d415e35f0"><div class="ttname"><a href="#gafb41ac8534081b76e3ac910d415e35f0">wc_ed448ph_sign_hash</a></div><div class="ttdeci">int wc_ed448ph_sign_hash(const byte *hash, word32 hashLen, byte *out, word32 *outLen, ed448_key *key, const byte *context, byte contextLen)</div><div class="ttdoc">This function signs a message digest using an ed448_key object to guarantee authenticity....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafcc33d6e03d6fbd310521fbce27a97a2" title="This function signs a message using an ed448_key object to guarantee authenticity.">wc_ed448_sign_msg</a> </dd>
<dd>
<a class="el" href="#ga6fbfc3883a2c9d61afe1877be31aba99" title="This function signs a message using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_msg</a> </dd>
<dd>
<a class="el" href="#gab430498dfd1b3431fc5ffc8a28306ea6" title="This function verifies the Ed448 signature of the digest of a message to ensure authenticity....">wc_ed448ph_verify_hash</a> </dd></dl>

</div>
</div>
<a id="ga6fbfc3883a2c9d61afe1877be31aba99" name="ga6fbfc3883a2c9d61afe1877be31aba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbfc3883a2c9d61afe1877be31aba99">&#9670;&#160;</a></span>wc_ed448ph_sign_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448ph_sign_msg </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>inLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32 *</td>          <td class="paramname"><span class="paramname"><em>outLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>contextLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function signs a message using an ed448_key object to guarantee authenticity. The context is included as part of the data signed. The message is pre-hashed before signature calculation. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully generating a signature for the message. </dd>
<dd>
BAD_FUNC_ARG Returned any of the input parameters evaluate to NULL, or if the output buffer is too small to store the generated signature. </dd>
<dd>
MEMORY_E Returned if there is an error allocating memory during function execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Pointer to the buffer containing the message to sign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inlen</td><td>Length of the message to sign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Buffer in which to store the generated signature. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">outlen</td><td>Maximum length of the output buffer. Will store the bytes written to out upon successfully generating a message signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a private ed448_key with which to generate the signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the buffer containing the context for which message is being signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextLen</td><td>Length of the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line">WC_RNG rng;</div>
<div class="line"><span class="keywordtype">int</span> ret, sigSz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[114]; <span class="comment">// will hold generated signature</span></div>
<div class="line">sigSz = <span class="keyword">sizeof</span>(sig);</div>
<div class="line"><span class="keywordtype">byte</span> message[] = { initialize with message };</div>
<div class="line"><span class="keywordtype">byte</span> context[] = { initialize with context of signing };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__Random.html#ga1a87307fac65d3c2a47ffb743020f83c">wc_InitRng</a>(&amp;rng); <span class="comment">// initialize rng</span></div>
<div class="line"><a class="code hl_function" href="#ga913a5bc2a48b4dab46ec633bd5b4f51e">wc_ed448_init</a>(&amp;key); <span class="comment">// initialize key</span></div>
<div class="line"><a class="code hl_function" href="#ga2c1c2f9106f86b26a6bce368971243c5">wc_ed448_make_key</a>(&amp;rng, 57, &amp;key); <span class="comment">// make public/private key pair</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga6fbfc3883a2c9d61afe1877be31aba99">wc_ed448ph_sign_msg</a>(message, <span class="keyword">sizeof</span>(message), sig, &amp;sigSz, &amp;key,</div>
<div class="line">        context, <span class="keyword">sizeof</span>(context));</div>
<div class="line"><span class="keywordflow">if</span> (ret != 0) {</div>
<div class="line">    <span class="comment">// error generating message signature</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga6fbfc3883a2c9d61afe1877be31aba99"><div class="ttname"><a href="#ga6fbfc3883a2c9d61afe1877be31aba99">wc_ed448ph_sign_msg</a></div><div class="ttdeci">int wc_ed448ph_sign_msg(const byte *in, word32 inLen, byte *out, word32 *outLen, ed448_key *key, const byte *context, byte contextLen)</div><div class="ttdoc">This function signs a message using an ed448_key object to guarantee authenticity....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gafcc33d6e03d6fbd310521fbce27a97a2" title="This function signs a message using an ed448_key object to guarantee authenticity.">wc_ed448_sign_msg</a> </dd>
<dd>
<a class="el" href="#gafb41ac8534081b76e3ac910d415e35f0" title="This function signs a message digest using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_hash</a> </dd>
<dd>
<a class="el" href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448ph_verify_msg</a> </dd></dl>

</div>
</div>
<a id="gab430498dfd1b3431fc5ffc8a28306ea6" name="gab430498dfd1b3431fc5ffc8a28306ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab430498dfd1b3431fc5ffc8a28306ea6">&#9670;&#160;</a></span>wc_ed448ph_verify_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448ph_verify_hash </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>hashlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>contextLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the Ed448 signature of the digest of a message to ensure authenticity. The context is included as part of the data verified. The hash is the pre-hashed message before signature calculation. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully performing the signature verification and authentication. </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the siglen does not match the actual length of a signature. </dd>
<dd>
SIG_VERIFY_E Returned if verification completes, but the signature generated does not match the signature provided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Pointer to the buffer containing the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">siglen</td><td>Length of the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Pointer to the buffer containing the hash of the message to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashLen</td><td>Length of the hash to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a public Ed448 key with which to verify the signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the buffer containing the context for which the message was signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextLen</td><td>Length of the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><span class="keywordtype">int</span> ret, verified = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[] { initialize with received signature };</div>
<div class="line"><span class="keywordtype">byte</span> hash[] = { initialize hash of message };</div>
<div class="line"><span class="keywordtype">byte</span> context[] = { initialize with context of signature };</div>
<div class="line"><span class="comment">// initialize key with received public key</span></div>
<div class="line">ret = <a class="code hl_function" href="#gab430498dfd1b3431fc5ffc8a28306ea6">wc_ed448ph_verify_hash</a>(sig, <span class="keyword">sizeof</span>(sig), hash, <span class="keyword">sizeof</span>(hash),</div>
<div class="line">        &amp;verified, &amp;key, context, <span class="keyword">sizeof</span>(context));</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// error performing verification</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (verified == 0)</div>
<div class="line">    <span class="comment">// the signature is invalid</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_gab430498dfd1b3431fc5ffc8a28306ea6"><div class="ttname"><a href="#gab430498dfd1b3431fc5ffc8a28306ea6">wc_ed448ph_verify_hash</a></div><div class="ttdeci">int wc_ed448ph_verify_hash(const byte *sig, word32 siglen, const byte *hash, word32 hashlen, int *res, ed448_key *key, const byte *context, byte contextLen)</div><div class="ttdoc">This function verifies the Ed448 signature of the digest of a message to ensure authenticity....</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae2074aef588b6c8ce5ffb6fbc50dd17c" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448_verify_msg</a> </dd>
<dd>
<a class="el" href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448ph_verify_msg</a> </dd>
<dd>
<a class="el" href="#gafb41ac8534081b76e3ac910d415e35f0" title="This function signs a message digest using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_hash</a> </dd></dl>

</div>
</div>
<a id="ga7b27adf9b70ee3e9a4bd6070a70a0f34" name="ga7b27adf9b70ee3e9a4bd6070a70a0f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34">&#9670;&#160;</a></span>wc_ed448ph_verify_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wc_ed448ph_verify_msg </td>
          <td>(</td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>siglen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word32</td>          <td class="paramname"><span class="paramname"><em>msgLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ed448_key *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>contextLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies the Ed448 signature of a message to ensure authenticity. The context is included as part of the data verified. The message is pre-hashed before verification. The answer is returned through res, with 1 corresponding to a valid signature, and 0 corresponding to an invalid signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0 Returned upon successfully performing the signature verification and authentication. </dd>
<dd>
BAD_FUNC_ARG Returned if any of the input parameters evaluate to NULL, or if the siglen does not match the actual length of a signature. </dd>
<dd>
SIG_VERIFY_E Returned if verification completes, but the signature generated does not match the signature provided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Pointer to the buffer containing the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">siglen</td><td>Length of the signature to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the buffer containing the message to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Length of the message to verify. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a public Ed448 key with which to verify the signature. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the buffer containing the context for which the message was signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextLen</td><td>Length of the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><em>Example</em> </p><div class="fragment"><div class="line">ed448_key key;</div>
<div class="line"><span class="keywordtype">int</span> ret, verified = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">byte</span> sig[] { initialize with received signature };</div>
<div class="line"><span class="keywordtype">byte</span> msg[] = { initialize with message };</div>
<div class="line"><span class="keywordtype">byte</span> context[] = { initialize with context of signature };</div>
<div class="line"><span class="comment">// initialize key with received public key</span></div>
<div class="line">ret = <a class="code hl_function" href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34">wc_ed448ph_verify_msg</a>(sig, <span class="keyword">sizeof</span>(sig), msg, <span class="keyword">sizeof</span>(msg), &amp;verified,</div>
<div class="line">        &amp;key, context, <span class="keyword">sizeof</span>(context));</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">    <span class="comment">// error performing verification</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (verified == 0)</div>
<div class="line">    <span class="comment">// the signature is invalid</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ED448_html_ga7b27adf9b70ee3e9a4bd6070a70a0f34"><div class="ttname"><a href="#ga7b27adf9b70ee3e9a4bd6070a70a0f34">wc_ed448ph_verify_msg</a></div><div class="ttdeci">int wc_ed448ph_verify_msg(const byte *sig, word32 siglen, const byte *msg, word32 msgLen, int *res, ed448_key *key, const byte *context, byte contextLen)</div><div class="ttdoc">This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae2074aef588b6c8ce5ffb6fbc50dd17c" title="This function verifies the Ed448 signature of a message to ensure authenticity. The context is includ...">wc_ed448_verify_msg</a> </dd>
<dd>
<a class="el" href="#gab430498dfd1b3431fc5ffc8a28306ea6" title="This function verifies the Ed448 signature of the digest of a message to ensure authenticity....">wc_ed448ph_verify_hash</a> </dd>
<dd>
<a class="el" href="#ga6fbfc3883a2c9d61afe1877be31aba99" title="This function signs a message using an ed448_key object to guarantee authenticity....">wc_ed448ph_sign_msg</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
